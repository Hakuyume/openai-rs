impl<'de> serde::Deserialize<'de> for AddUploadPartRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<u8>,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(AddUploadPartRequest { data })
    }
}
impl serde::Serialize for AddUploadPartRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "data")]
            data: &'a Vec<u8>,
        }
        let AddUploadPartRequest { data } = self;
        _S { data }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AddUploadPartRequest {
    #[doc = "The chunk of bytes for this Part.\n"]
    pub data: Vec<u8>,
}
impl<'de> serde::Deserialize<'de> for AdminApiKeyOwner {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<String>,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: Option<u64>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let _D {
            type_,
            object,
            id,
            name,
            created_at,
            role,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AdminApiKeyOwner {
            type_,
            object,
            id,
            name,
            created_at,
            role,
        })
    }
}
impl serde::Serialize for AdminApiKeyOwner {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<String>,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "created_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_at: &'a Option<u64>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let AdminApiKeyOwner {
            type_,
            object,
            id,
            name,
            created_at,
            role,
        } = self;
        _S {
            type_,
            object,
            id,
            name,
            created_at,
            role,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AdminApiKeyOwner {
    #[doc = "Always `user`"]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "The object type, which is always organization.user"]
    #[builder(default)]
    pub object: Option<String>,
    #[doc = "The identifier, which can be referenced in API endpoints"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the user"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The Unix timestamp (in seconds) of when the user was created"]
    #[builder(default)]
    pub created_at: Option<u64>,
    #[doc = "Always `owner`"]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AdminApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.admin_api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AdminApiKeyObject {
            #[default]
            #[serde(rename = "organization.admin_api_key")]
            OrganizationAdminApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: AdminApiKeyObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "redacted_value")]
            #[allow(dead_code)]
            redacted_value: String,
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: Option<String>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "last_used_at")]
            #[allow(dead_code)]
            last_used_at: Option<u64>,
            #[serde(rename = "owner")]
            #[allow(dead_code)]
            owner: AdminApiKeyOwner,
        }
        let _D {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AdminApiKey {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        })
    }
}
impl serde::Serialize for AdminApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.admin_api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AdminApiKeyObject {
            #[default]
            #[serde(rename = "organization.admin_api_key")]
            OrganizationAdminApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a AdminApiKeyObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "redacted_value")]
            redacted_value: &'a String,
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            value: &'a Option<String>,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "last_used_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_used_at: &'a Option<u64>,
            #[serde(rename = "owner")]
            owner: &'a AdminApiKeyOwner,
        }
        let AdminApiKey {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        } = self;
        _S {
            object: &Default::default(),
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual Admin API key in an org."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AdminApiKey {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the API key"]
    pub name: String,
    #[doc = "The redacted value of the API key"]
    pub redacted_value: String,
    #[doc = "The value of the API key. Only shown on create."]
    #[builder(default)]
    pub value: Option<String>,
    #[doc = "The Unix timestamp (in seconds) of when the API key was created"]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the API key was last used"]
    #[builder(default)]
    pub last_used_at: Option<u64>,
    #[builder(default)]
    pub owner: AdminApiKeyOwner,
}
impl<'de> serde::Deserialize<'de> for ApiKeyList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<Vec<AdminApiKey>>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: Option<bool>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
        }
        let _D {
            object,
            data,
            has_more,
            first_id,
            last_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ApiKeyList {
            object,
            data,
            has_more,
            first_id,
            last_id,
        })
    }
}
impl serde::Serialize for ApiKeyList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<Vec<AdminApiKey>>,
            #[serde(rename = "has_more")]
            #[serde(skip_serializing_if = "Option::is_none")]
            has_more: &'a Option<bool>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
        }
        let ApiKeyList {
            object,
            data,
            has_more,
            first_id,
            last_id,
        } = self;
        _S {
            object,
            data,
            has_more,
            first_id,
            last_id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ApiKeyList {
    #[builder(default)]
    pub object: Option<String>,
    #[builder(default)]
    pub data: Option<Vec<AdminApiKey>>,
    #[builder(default)]
    pub has_more: Option<bool>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AssistantObjectTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearch),
            Function(#[allow(dead_code)] AssistantToolsFunction),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for AssistantObjectTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearch),
            Function(#[allow(dead_code)] &'a AssistantToolsFunction),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantObjectTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearch),
    Function(AssistantToolsFunction),
}
impl<'de> serde::Deserialize<'de> for AssistantObjectToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let _D { file_ids, .. } = _D::deserialize(deserializer)?;
        Ok(AssistantObjectToolResourcesCodeInterpreter { file_ids })
    }
}
impl serde::Serialize for AssistantObjectToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let AssistantObjectToolResourcesCodeInterpreter { file_ids } = self;
        _S { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AssistantObjectToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for AssistantObjectToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let _D {
            vector_store_ids, ..
        } = _D::deserialize(deserializer)?;
        Ok(AssistantObjectToolResourcesFileSearch { vector_store_ids })
    }
}
impl serde::Serialize for AssistantObjectToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let AssistantObjectToolResourcesFileSearch { vector_store_ids } = self;
        _S { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AssistantObjectToolResourcesFileSearch {
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for AssistantObjectToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<AssistantObjectToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<AssistantObjectToolResourcesFileSearch>,
        }
        let _D {
            code_interpreter,
            file_search,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AssistantObjectToolResources {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for AssistantObjectToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<AssistantObjectToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<AssistantObjectToolResourcesFileSearch>,
        }
        let AssistantObjectToolResources {
            code_interpreter,
            file_search,
        } = self;
        _S {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AssistantObjectToolResources {
    #[builder(default)]
    pub code_interpreter: Option<AssistantObjectToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<AssistantObjectToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for AssistantObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `assistant`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantObjectObject {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: AssistantObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Vec<AssistantObjectTool>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<AssistantObjectToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Metadata,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let _D {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AssistantObject {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        })
    }
}
impl serde::Serialize for AssistantObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `assistant`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantObjectObject {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a AssistantObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "tools")]
            tools: &'a Vec<AssistantObjectTool>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<AssistantObjectToolResources>,
            #[serde(rename = "metadata")]
            metadata: &'a Metadata,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let AssistantObject {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        } = self;
        _S {
            id,
            object: &Default::default(),
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an `assistant` that can call the model and use tools."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the assistant was created."]
    pub created_at: u64,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    pub tools: Vec<AssistantObjectTool>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<AssistantObjectToolResources>,
    pub metadata: Metadata,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for AssistantStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ThreadStreamEvent(#[allow(dead_code)] ThreadStreamEvent),
            RunStreamEvent(#[allow(dead_code)] RunStreamEvent),
            RunStepStreamEvent(#[allow(dead_code)] RunStepStreamEvent),
            MessageStreamEvent(#[allow(dead_code)] MessageStreamEvent),
            ErrorEvent(#[allow(dead_code)] ErrorEvent),
            DoneEvent(#[allow(dead_code)] DoneEvent),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ThreadStreamEvent(_v) => Self::ThreadStreamEvent(_v),
            _D::RunStreamEvent(_v) => Self::RunStreamEvent(_v),
            _D::RunStepStreamEvent(_v) => Self::RunStepStreamEvent(_v),
            _D::MessageStreamEvent(_v) => Self::MessageStreamEvent(_v),
            _D::ErrorEvent(_v) => Self::ErrorEvent(_v),
            _D::DoneEvent(_v) => Self::DoneEvent(_v),
        })
    }
}
impl serde::Serialize for AssistantStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ThreadStreamEvent(#[allow(dead_code)] &'a ThreadStreamEvent),
            RunStreamEvent(#[allow(dead_code)] &'a RunStreamEvent),
            RunStepStreamEvent(#[allow(dead_code)] &'a RunStepStreamEvent),
            MessageStreamEvent(#[allow(dead_code)] &'a MessageStreamEvent),
            ErrorEvent(#[allow(dead_code)] &'a ErrorEvent),
            DoneEvent(#[allow(dead_code)] &'a DoneEvent),
        }
        match self {
            Self::ThreadStreamEvent(_v) => _S::ThreadStreamEvent(_v).serialize(serializer),
            Self::RunStreamEvent(_v) => _S::RunStreamEvent(_v).serialize(serializer),
            Self::RunStepStreamEvent(_v) => _S::RunStepStreamEvent(_v).serialize(serializer),
            Self::MessageStreamEvent(_v) => _S::MessageStreamEvent(_v).serialize(serializer),
            Self::ErrorEvent(_v) => _S::ErrorEvent(_v).serialize(serializer),
            Self::DoneEvent(_v) => _S::DoneEvent(_v).serialize(serializer),
        }
    }
}
#[doc = "Represents an event emitted when streaming a Run.\n\nEach event in a server-sent events stream has an `event` and `data` property:\n\n```\nevent: thread.created\ndata: {\"id\": \"thread_123\", \"object\": \"thread\", ...}\n```\n\nWe emit events whenever a new object is created, transitions to a new state, or is being\nstreamed in parts (deltas). For example, we emit `thread.run.created` when a new run\nis created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses\nto create a message during a run, we emit a `thread.message.created event`, a\n`thread.message.in_progress` event, many `thread.message.delta` events, and finally a\n`thread.message.completed` event.\n\nWe may add additional events over time, so we recommend handling unknown events gracefully\nin your code. See the [Assistants API quickstart](/docs/assistants/overview) to learn how to\nintegrate the Assistants API with streaming.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantStreamEvent {
    ThreadStreamEvent(ThreadStreamEvent),
    RunStreamEvent(RunStreamEvent),
    RunStepStreamEvent(RunStepStreamEvent),
    MessageStreamEvent(MessageStreamEvent),
    ErrorEvent(ErrorEvent),
    DoneEvent(DoneEvent),
}
impl<'de> serde::Deserialize<'de> for AssistantSupportedModels {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1 {
            #[default]
            #[serde(rename = "gpt-4.1")]
            Gpt4_1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Mini {
            #[default]
            #[serde(rename = "gpt-4.1-mini")]
            Gpt4_1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Nano {
            #[default]
            #[serde(rename = "gpt-4.1-nano")]
            Gpt4_1Nano,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1_2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-2025-04-14")]
            Gpt4_1_2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Mini2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-mini-2025-04-14")]
            Gpt4_1Mini2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Nano2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-nano-2025-04-14")]
            Gpt4_1Nano2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO3Mini {
            #[default]
            #[serde(rename = "o3-mini")]
            O3Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO3Mini2025_01_31 {
            #[default]
            #[serde(rename = "o3-mini-2025-01-31")]
            O3Mini2025_01_31,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO1 {
            #[default]
            #[serde(rename = "o1")]
            O1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO1_2024_12_17 {
            #[default]
            #[serde(rename = "o1-2024-12-17")]
            O1_2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o {
            #[default]
            #[serde(rename = "gpt-4o")]
            Gpt4o,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_11_20 {
            #[default]
            #[serde(rename = "gpt-4o-2024-11-20")]
            Gpt4o2024_11_20,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_08_06 {
            #[default]
            #[serde(rename = "gpt-4o-2024-08-06")]
            Gpt4o2024_08_06,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_05_13 {
            #[default]
            #[serde(rename = "gpt-4o-2024-05-13")]
            Gpt4o2024_05_13,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4oMini {
            #[default]
            #[serde(rename = "gpt-4o-mini")]
            Gpt4oMini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4oMini2024_07_18 {
            #[default]
            #[serde(rename = "gpt-4o-mini-2024-07-18")]
            Gpt4oMini2024_07_18,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_5Preview {
            #[default]
            #[serde(rename = "gpt-4.5-preview")]
            Gpt4_5Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_5Preview2025_02_27 {
            #[default]
            #[serde(rename = "gpt-4.5-preview-2025-02-27")]
            Gpt4_5Preview2025_02_27,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4Turbo {
            #[default]
            #[serde(rename = "gpt-4-turbo")]
            Gpt4Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4Turbo2024_04_09 {
            #[default]
            #[serde(rename = "gpt-4-turbo-2024-04-09")]
            Gpt4Turbo2024_04_09,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0125Preview {
            #[default]
            #[serde(rename = "gpt-4-0125-preview")]
            Gpt4_0125Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4TurboPreview {
            #[default]
            #[serde(rename = "gpt-4-turbo-preview")]
            Gpt4TurboPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1106Preview {
            #[default]
            #[serde(rename = "gpt-4-1106-preview")]
            Gpt4_1106Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4VisionPreview {
            #[default]
            #[serde(rename = "gpt-4-vision-preview")]
            Gpt4VisionPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4 {
            #[default]
            #[serde(rename = "gpt-4")]
            Gpt4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0314 {
            #[default]
            #[serde(rename = "gpt-4-0314")]
            Gpt4_0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0613 {
            #[default]
            #[serde(rename = "gpt-4-0613")]
            Gpt4_0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k {
            #[default]
            #[serde(rename = "gpt-4-32k")]
            Gpt4_32k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k0314 {
            #[default]
            #[serde(rename = "gpt-4-32k-0314")]
            Gpt4_32k0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k0613 {
            #[default]
            #[serde(rename = "gpt-4-32k-0613")]
            Gpt4_32k0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo {
            #[default]
            #[serde(rename = "gpt-3.5-turbo")]
            Gpt3_5Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo16k {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k")]
            Gpt3_5Turbo16k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0613")]
            Gpt3_5Turbo0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo1106 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-1106")]
            Gpt3_5Turbo1106,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo0125 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0125")]
            Gpt3_5Turbo0125,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo16k0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k-0613")]
            Gpt3_5Turbo16k0613,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Gpt4_1(#[allow(dead_code)] AssistantSupportedModelsGpt4_1),
            Gpt4_1Mini(#[allow(dead_code)] AssistantSupportedModelsGpt4_1Mini),
            Gpt4_1Nano(#[allow(dead_code)] AssistantSupportedModelsGpt4_1Nano),
            Gpt4_1_2025_04_14(#[allow(dead_code)] AssistantSupportedModelsGpt4_1_2025_04_14),
            Gpt4_1Mini2025_04_14(#[allow(dead_code)] AssistantSupportedModelsGpt4_1Mini2025_04_14),
            Gpt4_1Nano2025_04_14(#[allow(dead_code)] AssistantSupportedModelsGpt4_1Nano2025_04_14),
            O3Mini(#[allow(dead_code)] AssistantSupportedModelsO3Mini),
            O3Mini2025_01_31(#[allow(dead_code)] AssistantSupportedModelsO3Mini2025_01_31),
            O1(#[allow(dead_code)] AssistantSupportedModelsO1),
            O1_2024_12_17(#[allow(dead_code)] AssistantSupportedModelsO1_2024_12_17),
            Gpt4o(#[allow(dead_code)] AssistantSupportedModelsGpt4o),
            Gpt4o2024_11_20(#[allow(dead_code)] AssistantSupportedModelsGpt4o2024_11_20),
            Gpt4o2024_08_06(#[allow(dead_code)] AssistantSupportedModelsGpt4o2024_08_06),
            Gpt4o2024_05_13(#[allow(dead_code)] AssistantSupportedModelsGpt4o2024_05_13),
            Gpt4oMini(#[allow(dead_code)] AssistantSupportedModelsGpt4oMini),
            Gpt4oMini2024_07_18(#[allow(dead_code)] AssistantSupportedModelsGpt4oMini2024_07_18),
            Gpt4_5Preview(#[allow(dead_code)] AssistantSupportedModelsGpt4_5Preview),
            Gpt4_5Preview2025_02_27(
                #[allow(dead_code)] AssistantSupportedModelsGpt4_5Preview2025_02_27,
            ),
            Gpt4Turbo(#[allow(dead_code)] AssistantSupportedModelsGpt4Turbo),
            Gpt4Turbo2024_04_09(#[allow(dead_code)] AssistantSupportedModelsGpt4Turbo2024_04_09),
            Gpt4_0125Preview(#[allow(dead_code)] AssistantSupportedModelsGpt4_0125Preview),
            Gpt4TurboPreview(#[allow(dead_code)] AssistantSupportedModelsGpt4TurboPreview),
            Gpt4_1106Preview(#[allow(dead_code)] AssistantSupportedModelsGpt4_1106Preview),
            Gpt4VisionPreview(#[allow(dead_code)] AssistantSupportedModelsGpt4VisionPreview),
            Gpt4(#[allow(dead_code)] AssistantSupportedModelsGpt4),
            Gpt4_0314(#[allow(dead_code)] AssistantSupportedModelsGpt4_0314),
            Gpt4_0613(#[allow(dead_code)] AssistantSupportedModelsGpt4_0613),
            Gpt4_32k(#[allow(dead_code)] AssistantSupportedModelsGpt4_32k),
            Gpt4_32k0314(#[allow(dead_code)] AssistantSupportedModelsGpt4_32k0314),
            Gpt4_32k0613(#[allow(dead_code)] AssistantSupportedModelsGpt4_32k0613),
            Gpt3_5Turbo(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo),
            Gpt3_5Turbo16k(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo16k),
            Gpt3_5Turbo0613(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo0613),
            Gpt3_5Turbo1106(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo1106),
            Gpt3_5Turbo0125(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo0125),
            Gpt3_5Turbo16k0613(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo16k0613),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Gpt4_1(_) => Self::Gpt4_1,
            _D::Gpt4_1Mini(_) => Self::Gpt4_1Mini,
            _D::Gpt4_1Nano(_) => Self::Gpt4_1Nano,
            _D::Gpt4_1_2025_04_14(_) => Self::Gpt4_1_2025_04_14,
            _D::Gpt4_1Mini2025_04_14(_) => Self::Gpt4_1Mini2025_04_14,
            _D::Gpt4_1Nano2025_04_14(_) => Self::Gpt4_1Nano2025_04_14,
            _D::O3Mini(_) => Self::O3Mini,
            _D::O3Mini2025_01_31(_) => Self::O3Mini2025_01_31,
            _D::O1(_) => Self::O1,
            _D::O1_2024_12_17(_) => Self::O1_2024_12_17,
            _D::Gpt4o(_) => Self::Gpt4o,
            _D::Gpt4o2024_11_20(_) => Self::Gpt4o2024_11_20,
            _D::Gpt4o2024_08_06(_) => Self::Gpt4o2024_08_06,
            _D::Gpt4o2024_05_13(_) => Self::Gpt4o2024_05_13,
            _D::Gpt4oMini(_) => Self::Gpt4oMini,
            _D::Gpt4oMini2024_07_18(_) => Self::Gpt4oMini2024_07_18,
            _D::Gpt4_5Preview(_) => Self::Gpt4_5Preview,
            _D::Gpt4_5Preview2025_02_27(_) => Self::Gpt4_5Preview2025_02_27,
            _D::Gpt4Turbo(_) => Self::Gpt4Turbo,
            _D::Gpt4Turbo2024_04_09(_) => Self::Gpt4Turbo2024_04_09,
            _D::Gpt4_0125Preview(_) => Self::Gpt4_0125Preview,
            _D::Gpt4TurboPreview(_) => Self::Gpt4TurboPreview,
            _D::Gpt4_1106Preview(_) => Self::Gpt4_1106Preview,
            _D::Gpt4VisionPreview(_) => Self::Gpt4VisionPreview,
            _D::Gpt4(_) => Self::Gpt4,
            _D::Gpt4_0314(_) => Self::Gpt4_0314,
            _D::Gpt4_0613(_) => Self::Gpt4_0613,
            _D::Gpt4_32k(_) => Self::Gpt4_32k,
            _D::Gpt4_32k0314(_) => Self::Gpt4_32k0314,
            _D::Gpt4_32k0613(_) => Self::Gpt4_32k0613,
            _D::Gpt3_5Turbo(_) => Self::Gpt3_5Turbo,
            _D::Gpt3_5Turbo16k(_) => Self::Gpt3_5Turbo16k,
            _D::Gpt3_5Turbo0613(_) => Self::Gpt3_5Turbo0613,
            _D::Gpt3_5Turbo1106(_) => Self::Gpt3_5Turbo1106,
            _D::Gpt3_5Turbo0125(_) => Self::Gpt3_5Turbo0125,
            _D::Gpt3_5Turbo16k0613(_) => Self::Gpt3_5Turbo16k0613,
        })
    }
}
impl serde::Serialize for AssistantSupportedModels {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1 {
            #[default]
            #[serde(rename = "gpt-4.1")]
            Gpt4_1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Mini {
            #[default]
            #[serde(rename = "gpt-4.1-mini")]
            Gpt4_1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Nano {
            #[default]
            #[serde(rename = "gpt-4.1-nano")]
            Gpt4_1Nano,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1_2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-2025-04-14")]
            Gpt4_1_2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Mini2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-mini-2025-04-14")]
            Gpt4_1Mini2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Nano2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-nano-2025-04-14")]
            Gpt4_1Nano2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO3Mini {
            #[default]
            #[serde(rename = "o3-mini")]
            O3Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO3Mini2025_01_31 {
            #[default]
            #[serde(rename = "o3-mini-2025-01-31")]
            O3Mini2025_01_31,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO1 {
            #[default]
            #[serde(rename = "o1")]
            O1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO1_2024_12_17 {
            #[default]
            #[serde(rename = "o1-2024-12-17")]
            O1_2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o {
            #[default]
            #[serde(rename = "gpt-4o")]
            Gpt4o,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_11_20 {
            #[default]
            #[serde(rename = "gpt-4o-2024-11-20")]
            Gpt4o2024_11_20,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_08_06 {
            #[default]
            #[serde(rename = "gpt-4o-2024-08-06")]
            Gpt4o2024_08_06,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_05_13 {
            #[default]
            #[serde(rename = "gpt-4o-2024-05-13")]
            Gpt4o2024_05_13,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4oMini {
            #[default]
            #[serde(rename = "gpt-4o-mini")]
            Gpt4oMini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4oMini2024_07_18 {
            #[default]
            #[serde(rename = "gpt-4o-mini-2024-07-18")]
            Gpt4oMini2024_07_18,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_5Preview {
            #[default]
            #[serde(rename = "gpt-4.5-preview")]
            Gpt4_5Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_5Preview2025_02_27 {
            #[default]
            #[serde(rename = "gpt-4.5-preview-2025-02-27")]
            Gpt4_5Preview2025_02_27,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4Turbo {
            #[default]
            #[serde(rename = "gpt-4-turbo")]
            Gpt4Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4Turbo2024_04_09 {
            #[default]
            #[serde(rename = "gpt-4-turbo-2024-04-09")]
            Gpt4Turbo2024_04_09,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0125Preview {
            #[default]
            #[serde(rename = "gpt-4-0125-preview")]
            Gpt4_0125Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4TurboPreview {
            #[default]
            #[serde(rename = "gpt-4-turbo-preview")]
            Gpt4TurboPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1106Preview {
            #[default]
            #[serde(rename = "gpt-4-1106-preview")]
            Gpt4_1106Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4VisionPreview {
            #[default]
            #[serde(rename = "gpt-4-vision-preview")]
            Gpt4VisionPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4 {
            #[default]
            #[serde(rename = "gpt-4")]
            Gpt4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0314 {
            #[default]
            #[serde(rename = "gpt-4-0314")]
            Gpt4_0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0613 {
            #[default]
            #[serde(rename = "gpt-4-0613")]
            Gpt4_0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k {
            #[default]
            #[serde(rename = "gpt-4-32k")]
            Gpt4_32k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k0314 {
            #[default]
            #[serde(rename = "gpt-4-32k-0314")]
            Gpt4_32k0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k0613 {
            #[default]
            #[serde(rename = "gpt-4-32k-0613")]
            Gpt4_32k0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo {
            #[default]
            #[serde(rename = "gpt-3.5-turbo")]
            Gpt3_5Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo16k {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k")]
            Gpt3_5Turbo16k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0613")]
            Gpt3_5Turbo0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo1106 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-1106")]
            Gpt3_5Turbo1106,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo0125 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0125")]
            Gpt3_5Turbo0125,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo16k0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k-0613")]
            Gpt3_5Turbo16k0613,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Gpt4_1(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1),
            Gpt4_1Mini(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1Mini),
            Gpt4_1Nano(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1Nano),
            Gpt4_1_2025_04_14(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1_2025_04_14),
            Gpt4_1Mini2025_04_14(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1Mini2025_04_14,
            ),
            Gpt4_1Nano2025_04_14(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1Nano2025_04_14,
            ),
            O3Mini(#[allow(dead_code)] &'a AssistantSupportedModelsO3Mini),
            O3Mini2025_01_31(#[allow(dead_code)] &'a AssistantSupportedModelsO3Mini2025_01_31),
            O1(#[allow(dead_code)] &'a AssistantSupportedModelsO1),
            O1_2024_12_17(#[allow(dead_code)] &'a AssistantSupportedModelsO1_2024_12_17),
            Gpt4o(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4o),
            Gpt4o2024_11_20(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4o2024_11_20),
            Gpt4o2024_08_06(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4o2024_08_06),
            Gpt4o2024_05_13(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4o2024_05_13),
            Gpt4oMini(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4oMini),
            Gpt4oMini2024_07_18(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4oMini2024_07_18,
            ),
            Gpt4_5Preview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_5Preview),
            Gpt4_5Preview2025_02_27(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4_5Preview2025_02_27,
            ),
            Gpt4Turbo(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4Turbo),
            Gpt4Turbo2024_04_09(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4Turbo2024_04_09,
            ),
            Gpt4_0125Preview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_0125Preview),
            Gpt4TurboPreview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4TurboPreview),
            Gpt4_1106Preview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1106Preview),
            Gpt4VisionPreview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4VisionPreview),
            Gpt4(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4),
            Gpt4_0314(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_0314),
            Gpt4_0613(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_0613),
            Gpt4_32k(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_32k),
            Gpt4_32k0314(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_32k0314),
            Gpt4_32k0613(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_32k0613),
            Gpt3_5Turbo(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo),
            Gpt3_5Turbo16k(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo16k),
            Gpt3_5Turbo0613(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo0613),
            Gpt3_5Turbo1106(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo1106),
            Gpt3_5Turbo0125(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo0125),
            Gpt3_5Turbo16k0613(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo16k0613),
        }
        match self {
            Self::Gpt4_1 => _S::Gpt4_1(&Default::default()).serialize(serializer),
            Self::Gpt4_1Mini => _S::Gpt4_1Mini(&Default::default()).serialize(serializer),
            Self::Gpt4_1Nano => _S::Gpt4_1Nano(&Default::default()).serialize(serializer),
            Self::Gpt4_1_2025_04_14 => {
                _S::Gpt4_1_2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1Mini2025_04_14 => {
                _S::Gpt4_1Mini2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1Nano2025_04_14 => {
                _S::Gpt4_1Nano2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::O3Mini => _S::O3Mini(&Default::default()).serialize(serializer),
            Self::O3Mini2025_01_31 => {
                _S::O3Mini2025_01_31(&Default::default()).serialize(serializer)
            }
            Self::O1 => _S::O1(&Default::default()).serialize(serializer),
            Self::O1_2024_12_17 => _S::O1_2024_12_17(&Default::default()).serialize(serializer),
            Self::Gpt4o => _S::Gpt4o(&Default::default()).serialize(serializer),
            Self::Gpt4o2024_11_20 => _S::Gpt4o2024_11_20(&Default::default()).serialize(serializer),
            Self::Gpt4o2024_08_06 => _S::Gpt4o2024_08_06(&Default::default()).serialize(serializer),
            Self::Gpt4o2024_05_13 => _S::Gpt4o2024_05_13(&Default::default()).serialize(serializer),
            Self::Gpt4oMini => _S::Gpt4oMini(&Default::default()).serialize(serializer),
            Self::Gpt4oMini2024_07_18 => {
                _S::Gpt4oMini2024_07_18(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_5Preview => _S::Gpt4_5Preview(&Default::default()).serialize(serializer),
            Self::Gpt4_5Preview2025_02_27 => {
                _S::Gpt4_5Preview2025_02_27(&Default::default()).serialize(serializer)
            }
            Self::Gpt4Turbo => _S::Gpt4Turbo(&Default::default()).serialize(serializer),
            Self::Gpt4Turbo2024_04_09 => {
                _S::Gpt4Turbo2024_04_09(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_0125Preview => {
                _S::Gpt4_0125Preview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4TurboPreview => {
                _S::Gpt4TurboPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1106Preview => {
                _S::Gpt4_1106Preview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4VisionPreview => {
                _S::Gpt4VisionPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4 => _S::Gpt4(&Default::default()).serialize(serializer),
            Self::Gpt4_0314 => _S::Gpt4_0314(&Default::default()).serialize(serializer),
            Self::Gpt4_0613 => _S::Gpt4_0613(&Default::default()).serialize(serializer),
            Self::Gpt4_32k => _S::Gpt4_32k(&Default::default()).serialize(serializer),
            Self::Gpt4_32k0314 => _S::Gpt4_32k0314(&Default::default()).serialize(serializer),
            Self::Gpt4_32k0613 => _S::Gpt4_32k0613(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo => _S::Gpt3_5Turbo(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo16k => _S::Gpt3_5Turbo16k(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo0613 => _S::Gpt3_5Turbo0613(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo1106 => _S::Gpt3_5Turbo1106(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo0125 => _S::Gpt3_5Turbo0125(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo16k0613 => {
                _S::Gpt3_5Turbo16k0613(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantSupportedModels {
    #[doc = "gpt-4.1"]
    Gpt4_1,
    #[doc = "gpt-4.1-mini"]
    Gpt4_1Mini,
    #[doc = "gpt-4.1-nano"]
    Gpt4_1Nano,
    #[doc = "gpt-4.1-2025-04-14"]
    Gpt4_1_2025_04_14,
    #[doc = "gpt-4.1-mini-2025-04-14"]
    Gpt4_1Mini2025_04_14,
    #[doc = "gpt-4.1-nano-2025-04-14"]
    Gpt4_1Nano2025_04_14,
    #[doc = "o3-mini"]
    O3Mini,
    #[doc = "o3-mini-2025-01-31"]
    O3Mini2025_01_31,
    #[doc = "o1"]
    O1,
    #[doc = "o1-2024-12-17"]
    O1_2024_12_17,
    #[doc = "gpt-4o"]
    Gpt4o,
    #[doc = "gpt-4o-2024-11-20"]
    Gpt4o2024_11_20,
    #[doc = "gpt-4o-2024-08-06"]
    Gpt4o2024_08_06,
    #[doc = "gpt-4o-2024-05-13"]
    Gpt4o2024_05_13,
    #[doc = "gpt-4o-mini"]
    Gpt4oMini,
    #[doc = "gpt-4o-mini-2024-07-18"]
    Gpt4oMini2024_07_18,
    #[doc = "gpt-4.5-preview"]
    Gpt4_5Preview,
    #[doc = "gpt-4.5-preview-2025-02-27"]
    Gpt4_5Preview2025_02_27,
    #[doc = "gpt-4-turbo"]
    Gpt4Turbo,
    #[doc = "gpt-4-turbo-2024-04-09"]
    Gpt4Turbo2024_04_09,
    #[doc = "gpt-4-0125-preview"]
    Gpt4_0125Preview,
    #[doc = "gpt-4-turbo-preview"]
    Gpt4TurboPreview,
    #[doc = "gpt-4-1106-preview"]
    Gpt4_1106Preview,
    #[doc = "gpt-4-vision-preview"]
    Gpt4VisionPreview,
    #[doc = "gpt-4"]
    Gpt4,
    #[doc = "gpt-4-0314"]
    Gpt4_0314,
    #[doc = "gpt-4-0613"]
    Gpt4_0613,
    #[doc = "gpt-4-32k"]
    Gpt4_32k,
    #[doc = "gpt-4-32k-0314"]
    Gpt4_32k0314,
    #[doc = "gpt-4-32k-0613"]
    Gpt4_32k0613,
    #[doc = "gpt-3.5-turbo"]
    Gpt3_5Turbo,
    #[doc = "gpt-3.5-turbo-16k"]
    Gpt3_5Turbo16k,
    #[doc = "gpt-3.5-turbo-0613"]
    Gpt3_5Turbo0613,
    #[doc = "gpt-3.5-turbo-1106"]
    Gpt3_5Turbo1106,
    #[doc = "gpt-3.5-turbo-0125"]
    Gpt3_5Turbo0125,
    #[doc = "gpt-3.5-turbo-16k-0613"]
    Gpt3_5Turbo16k0613,
}
impl<'de> serde::Deserialize<'de> for AssistantToolsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool being defined: `code_interpreter`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsCodeType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantToolsCodeType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(AssistantToolsCode {})
    }
}
impl serde::Serialize for AssistantToolsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool being defined: `code_interpreter`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsCodeType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantToolsCodeType,
        }
        let AssistantToolsCode {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AssistantToolsCode {}
impl<'de> serde::Deserialize<'de> for AssistantToolsFileSearchFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "max_num_results")]
            #[allow(dead_code)]
            max_num_results: Option<u64>,
            #[serde(rename = "ranking_options")]
            #[allow(dead_code)]
            ranking_options: Option<FileSearchRankingOptions>,
        }
        let _D {
            max_num_results,
            ranking_options,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AssistantToolsFileSearchFileSearch {
            max_num_results,
            ranking_options,
        })
    }
}
impl serde::Serialize for AssistantToolsFileSearchFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "max_num_results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_num_results: &'a Option<u64>,
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<FileSearchRankingOptions>,
        }
        let AssistantToolsFileSearchFileSearch {
            max_num_results,
            ranking_options,
        } = self;
        _S {
            max_num_results,
            ranking_options,
        }
        .serialize(serializer)
    }
}
#[doc = "Overrides for the file search tool."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFileSearchFileSearch {
    #[doc = "The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive.\n\nNote that the file search tool may output fewer than `max_num_results` results. See the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
    #[builder(default)]
    pub max_num_results: Option<u64>,
    #[builder(default)]
    pub ranking_options: Option<FileSearchRankingOptions>,
}
impl<'de> serde::Deserialize<'de> for AssistantToolsFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool being defined: `file_search`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFileSearchType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantToolsFileSearchType,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<AssistantToolsFileSearchFileSearch>,
        }
        let _D { file_search, .. } = _D::deserialize(deserializer)?;
        Ok(AssistantToolsFileSearch { file_search })
    }
}
impl serde::Serialize for AssistantToolsFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool being defined: `file_search`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFileSearchType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantToolsFileSearchType,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<AssistantToolsFileSearchFileSearch>,
        }
        let AssistantToolsFileSearch { file_search } = self;
        _S {
            type_: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFileSearch {
    #[doc = "Overrides for the file search tool."]
    #[builder(default)]
    pub file_search: Option<AssistantToolsFileSearchFileSearch>,
}
impl<'de> serde::Deserialize<'de> for AssistantToolsFileSearchTypeOnly {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool being defined: `file_search`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFileSearchTypeOnlyType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantToolsFileSearchTypeOnlyType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(AssistantToolsFileSearchTypeOnly {})
    }
}
impl serde::Serialize for AssistantToolsFileSearchTypeOnly {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool being defined: `file_search`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFileSearchTypeOnlyType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantToolsFileSearchTypeOnlyType,
        }
        let AssistantToolsFileSearchTypeOnly {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFileSearchTypeOnly {}
impl<'de> serde::Deserialize<'de> for AssistantToolsFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool being defined: `function`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFunctionType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantToolsFunctionType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: FunctionObject,
        }
        let _D { function, .. } = _D::deserialize(deserializer)?;
        Ok(AssistantToolsFunction { function })
    }
}
impl serde::Serialize for AssistantToolsFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool being defined: `function`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFunctionType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantToolsFunctionType,
            #[serde(rename = "function")]
            function: &'a FunctionObject,
        }
        let AssistantToolsFunction { function } = self;
        _S {
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFunction {
    pub function: FunctionObject,
}
impl<'de> serde::Deserialize<'de> for AssistantsApiResponseFormatOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "`auto` is the default value\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiResponseFormatOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] AssistantsApiResponseFormatOptionAuto),
            Text(#[allow(dead_code)] ResponseFormatText),
            JsonObject(#[allow(dead_code)] ResponseFormatJsonObject),
            JsonSchema(#[allow(dead_code)] ResponseFormatJsonSchema),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Text(_v) => Self::Text(_v),
            _D::JsonObject(_v) => Self::JsonObject(_v),
            _D::JsonSchema(_v) => Self::JsonSchema(_v),
        })
    }
}
impl serde::Serialize for AssistantsApiResponseFormatOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "`auto` is the default value\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiResponseFormatOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a AssistantsApiResponseFormatOptionAuto),
            Text(#[allow(dead_code)] &'a ResponseFormatText),
            JsonObject(#[allow(dead_code)] &'a ResponseFormatJsonObject),
            JsonSchema(#[allow(dead_code)] &'a ResponseFormatJsonSchema),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
            Self::JsonObject(_v) => _S::JsonObject(_v).serialize(serializer),
            Self::JsonSchema(_v) => _S::JsonSchema(_v).serialize(serializer),
        }
    }
}
#[doc = "Specifies the format that the model must output. Compatible with [GPT-4o](/docs/models#gpt-4o), [GPT-4 Turbo](/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.\n\n**Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantsApiResponseFormatOption {
    #[doc = "auto"]
    Auto,
    Text(ResponseFormatText),
    JsonObject(ResponseFormatJsonObject),
    JsonSchema(ResponseFormatJsonSchema),
}
impl<'de> serde::Deserialize<'de> for AssistantsApiToolChoiceOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            None(#[allow(dead_code)] AssistantsApiToolChoiceOptionNone),
            Auto(#[allow(dead_code)] AssistantsApiToolChoiceOptionAuto),
            Required(#[allow(dead_code)] AssistantsApiToolChoiceOptionRequired),
            AssistantsNamedToolChoice(#[allow(dead_code)] AssistantsNamedToolChoice),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::None(_) => Self::None,
            _D::Auto(_) => Self::Auto,
            _D::Required(_) => Self::Required,
            _D::AssistantsNamedToolChoice(_v) => Self::AssistantsNamedToolChoice(_v),
        })
    }
}
impl serde::Serialize for AssistantsApiToolChoiceOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            None(#[allow(dead_code)] &'a AssistantsApiToolChoiceOptionNone),
            Auto(#[allow(dead_code)] &'a AssistantsApiToolChoiceOptionAuto),
            Required(#[allow(dead_code)] &'a AssistantsApiToolChoiceOptionRequired),
            AssistantsNamedToolChoice(#[allow(dead_code)] &'a AssistantsNamedToolChoice),
        }
        match self {
            Self::None => _S::None(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Required => _S::Required(&Default::default()).serialize(serializer),
            Self::AssistantsNamedToolChoice(_v) => {
                _S::AssistantsNamedToolChoice(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tools and instead generates a message.\n`auto` is the default value and means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools before responding to the user.\nSpecifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantsApiToolChoiceOption {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    #[doc = "required"]
    Required,
    AssistantsNamedToolChoice(AssistantsNamedToolChoice),
}
impl<'de> serde::Deserialize<'de> for AssistantsNamedToolChoiceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeFunction {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeCodeInterpreter {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeFileSearch {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Function(#[allow(dead_code)] AssistantsNamedToolChoiceTypeFunction),
            CodeInterpreter(#[allow(dead_code)] AssistantsNamedToolChoiceTypeCodeInterpreter),
            FileSearch(#[allow(dead_code)] AssistantsNamedToolChoiceTypeFileSearch),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Function(_) => Self::Function,
            _D::CodeInterpreter(_) => Self::CodeInterpreter,
            _D::FileSearch(_) => Self::FileSearch,
        })
    }
}
impl serde::Serialize for AssistantsNamedToolChoiceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeFunction {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeCodeInterpreter {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeFileSearch {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Function(#[allow(dead_code)] &'a AssistantsNamedToolChoiceTypeFunction),
            CodeInterpreter(#[allow(dead_code)] &'a AssistantsNamedToolChoiceTypeCodeInterpreter),
            FileSearch(#[allow(dead_code)] &'a AssistantsNamedToolChoiceTypeFileSearch),
        }
        match self {
            Self::Function => _S::Function(&Default::default()).serialize(serializer),
            Self::CodeInterpreter => _S::CodeInterpreter(&Default::default()).serialize(serializer),
            Self::FileSearch => _S::FileSearch(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of the tool. If type is `function`, the function name must be set"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantsNamedToolChoiceType {
    #[doc = "function"]
    Function,
    #[doc = "code_interpreter"]
    CodeInterpreter,
    #[doc = "file_search"]
    FileSearch,
}
impl<'de> serde::Deserialize<'de> for AssistantsNamedToolChoiceFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { name, .. } = _D::deserialize(deserializer)?;
        Ok(AssistantsNamedToolChoiceFunction { name })
    }
}
impl serde::Serialize for AssistantsNamedToolChoiceFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let AssistantsNamedToolChoiceFunction { name } = self;
        _S { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantsNamedToolChoiceFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for AssistantsNamedToolChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantsNamedToolChoiceType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: Option<AssistantsNamedToolChoiceFunction>,
        }
        let _D {
            type_, function, ..
        } = _D::deserialize(deserializer)?;
        Ok(AssistantsNamedToolChoice { type_, function })
    }
}
impl serde::Serialize for AssistantsNamedToolChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantsNamedToolChoiceType,
            #[serde(rename = "function")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function: &'a Option<AssistantsNamedToolChoiceFunction>,
        }
        let AssistantsNamedToolChoice { type_, function } = self;
        _S { type_, function }.serialize(serializer)
    }
}
#[doc = "Specifies a tool the model should use. Use to force the model to call a specific tool."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantsNamedToolChoice {
    #[doc = "The type of the tool. If type is `function`, the function name must be set"]
    pub type_: AssistantsNamedToolChoiceType,
    #[builder(default)]
    pub function: Option<AssistantsNamedToolChoiceFunction>,
}
impl<'de> serde::Deserialize<'de> for AudioResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatJson {
            #[default]
            #[serde(rename = "json")]
            Json,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatSrt {
            #[default]
            #[serde(rename = "srt")]
            Srt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatVerboseJson {
            #[default]
            #[serde(rename = "verbose_json")]
            VerboseJson,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatVtt {
            #[default]
            #[serde(rename = "vtt")]
            Vtt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Json(#[allow(dead_code)] AudioResponseFormatJson),
            Text(#[allow(dead_code)] AudioResponseFormatText),
            Srt(#[allow(dead_code)] AudioResponseFormatSrt),
            VerboseJson(#[allow(dead_code)] AudioResponseFormatVerboseJson),
            Vtt(#[allow(dead_code)] AudioResponseFormatVtt),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Json(_) => Self::Json,
            _D::Text(_) => Self::Text,
            _D::Srt(_) => Self::Srt,
            _D::VerboseJson(_) => Self::VerboseJson,
            _D::Vtt(_) => Self::Vtt,
        })
    }
}
impl serde::Serialize for AudioResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatJson {
            #[default]
            #[serde(rename = "json")]
            Json,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatSrt {
            #[default]
            #[serde(rename = "srt")]
            Srt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatVerboseJson {
            #[default]
            #[serde(rename = "verbose_json")]
            VerboseJson,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatVtt {
            #[default]
            #[serde(rename = "vtt")]
            Vtt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Json(#[allow(dead_code)] &'a AudioResponseFormatJson),
            Text(#[allow(dead_code)] &'a AudioResponseFormatText),
            Srt(#[allow(dead_code)] &'a AudioResponseFormatSrt),
            VerboseJson(#[allow(dead_code)] &'a AudioResponseFormatVerboseJson),
            Vtt(#[allow(dead_code)] &'a AudioResponseFormatVtt),
        }
        match self {
            Self::Json => _S::Json(&Default::default()).serialize(serializer),
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Srt => _S::Srt(&Default::default()).serialize(serializer),
            Self::VerboseJson => _S::VerboseJson(&Default::default()).serialize(serializer),
            Self::Vtt => _S::Vtt(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`. For `gpt-4o-transcribe` and `gpt-4o-mini-transcribe`, the only supported format is `json`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum AudioResponseFormat {
    #[doc = "json"]
    #[default]
    Json,
    #[doc = "text"]
    Text,
    #[doc = "srt"]
    Srt,
    #[doc = "verbose_json"]
    VerboseJson,
    #[doc = "vtt"]
    Vtt,
}
impl<'de> serde::Deserialize<'de> for AuditLogProject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D { id, name, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogProject { id, name })
    }
}
impl serde::Serialize for AuditLogProject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let AuditLogProject { id, name } = self;
        _S { id, name }.serialize(serializer)
    }
}
#[doc = "The project that the action was scoped to. Absent for actions not scoped to projects."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProject {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The project title."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyCreatedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "scopes")]
            #[allow(dead_code)]
            scopes: Option<Vec<String>>,
        }
        let _D { scopes, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogApiKeyCreatedData { scopes })
    }
}
impl serde::Serialize for AuditLogApiKeyCreatedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "scopes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            scopes: &'a Option<Vec<String>>,
        }
        let AuditLogApiKeyCreatedData { scopes } = self;
        _S { scopes }.serialize(serializer)
    }
}
#[doc = "The payload used to create the API key."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyCreatedData {
    #[doc = "A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`"]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogApiKeyCreatedData>,
        }
        let _D { id, data, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogApiKeyCreated { id, data })
    }
}
impl serde::Serialize for AuditLogApiKeyCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogApiKeyCreatedData>,
        }
        let AuditLogApiKeyCreated { id, data } = self;
        _S { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyCreated {
    #[doc = "The tracking ID of the API key."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the API key."]
    #[builder(default)]
    pub data: Option<AuditLogApiKeyCreatedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "scopes")]
            #[allow(dead_code)]
            scopes: Option<Vec<String>>,
        }
        let _D { scopes, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogApiKeyUpdatedChangesRequested { scopes })
    }
}
impl serde::Serialize for AuditLogApiKeyUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "scopes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            scopes: &'a Option<Vec<String>>,
        }
        let AuditLogApiKeyUpdatedChangesRequested { scopes } = self;
        _S { scopes }.serialize(serializer)
    }
}
#[doc = "The payload used to update the API key."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyUpdatedChangesRequested {
    #[doc = "A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`"]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogApiKeyUpdatedChangesRequested>,
        }
        let _D {
            id,
            changes_requested,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogApiKeyUpdated {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogApiKeyUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogApiKeyUpdatedChangesRequested>,
        }
        let AuditLogApiKeyUpdated {
            id,
            changes_requested,
        } = self;
        _S {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyUpdated {
    #[doc = "The tracking ID of the API key."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the API key."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogApiKeyUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogApiKeyDeleted { id })
    }
}
impl serde::Serialize for AuditLogApiKeyDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogApiKeyDeleted { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyDeleted {
    #[doc = "The tracking ID of the API key."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCheckpointPermissionCreatedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            #[allow(dead_code)]
            fine_tuned_model_checkpoint: Option<String>,
        }
        let _D {
            project_id,
            fine_tuned_model_checkpoint,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogCheckpointPermissionCreatedData {
            project_id,
            fine_tuned_model_checkpoint,
        })
    }
}
impl serde::Serialize for AuditLogCheckpointPermissionCreatedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            fine_tuned_model_checkpoint: &'a Option<String>,
        }
        let AuditLogCheckpointPermissionCreatedData {
            project_id,
            fine_tuned_model_checkpoint,
        } = self;
        _S {
            project_id,
            fine_tuned_model_checkpoint,
        }
        .serialize(serializer)
    }
}
#[doc = "The payload used to create the checkpoint permission."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCheckpointPermissionCreatedData {
    #[doc = "The ID of the project that the checkpoint permission was created for."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "The ID of the fine-tuned model checkpoint."]
    #[builder(default)]
    pub fine_tuned_model_checkpoint: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCheckpointPermissionCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogCheckpointPermissionCreatedData>,
        }
        let _D { id, data, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogCheckpointPermissionCreated { id, data })
    }
}
impl serde::Serialize for AuditLogCheckpointPermissionCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogCheckpointPermissionCreatedData>,
        }
        let AuditLogCheckpointPermissionCreated { id, data } = self;
        _S { id, data }.serialize(serializer)
    }
}
#[doc = "The project and fine-tuned model checkpoint that the checkpoint permission was created for."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCheckpointPermissionCreated {
    #[doc = "The ID of the checkpoint permission."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the checkpoint permission."]
    #[builder(default)]
    pub data: Option<AuditLogCheckpointPermissionCreatedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCheckpointPermissionDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogCheckpointPermissionDeleted { id })
    }
}
impl serde::Serialize for AuditLogCheckpointPermissionDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogCheckpointPermissionDeleted { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCheckpointPermissionDeleted {
    #[doc = "The ID of the checkpoint permission."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogInviteSentData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: Option<String>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let _D { email, role, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogInviteSentData { email, role })
    }
}
impl serde::Serialize for AuditLogInviteSentData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "email")]
            #[serde(skip_serializing_if = "Option::is_none")]
            email: &'a Option<String>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let AuditLogInviteSentData { email, role } = self;
        _S { email, role }.serialize(serializer)
    }
}
#[doc = "The payload used to create the invite."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogInviteSentData {
    #[doc = "The email invited to the organization."]
    #[builder(default)]
    pub email: Option<String>,
    #[doc = "The role the email was invited to be. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogInviteSent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogInviteSentData>,
        }
        let _D { id, data, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogInviteSent { id, data })
    }
}
impl serde::Serialize for AuditLogInviteSent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogInviteSentData>,
        }
        let AuditLogInviteSent { id, data } = self;
        _S { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogInviteSent {
    #[doc = "The ID of the invite."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the invite."]
    #[builder(default)]
    pub data: Option<AuditLogInviteSentData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogInviteAccepted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogInviteAccepted { id })
    }
}
impl serde::Serialize for AuditLogInviteAccepted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogInviteAccepted { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogInviteAccepted {
    #[doc = "The ID of the invite."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogInviteDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogInviteDeleted { id })
    }
}
impl serde::Serialize for AuditLogInviteDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogInviteDeleted { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogInviteDeleted {
    #[doc = "The ID of the invite."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogLoginFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "error_code")]
            #[allow(dead_code)]
            error_code: Option<String>,
            #[serde(rename = "error_message")]
            #[allow(dead_code)]
            error_message: Option<String>,
        }
        let _D {
            error_code,
            error_message,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogLoginFailed {
            error_code,
            error_message,
        })
    }
}
impl serde::Serialize for AuditLogLoginFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "error_code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_code: &'a Option<String>,
            #[serde(rename = "error_message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_message: &'a Option<String>,
        }
        let AuditLogLoginFailed {
            error_code,
            error_message,
        } = self;
        _S {
            error_code,
            error_message,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogLoginFailed {
    #[doc = "The error code of the failure."]
    #[builder(default)]
    pub error_code: Option<String>,
    #[doc = "The error message of the failure."]
    #[builder(default)]
    pub error_message: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogLogoutFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "error_code")]
            #[allow(dead_code)]
            error_code: Option<String>,
            #[serde(rename = "error_message")]
            #[allow(dead_code)]
            error_message: Option<String>,
        }
        let _D {
            error_code,
            error_message,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogLogoutFailed {
            error_code,
            error_message,
        })
    }
}
impl serde::Serialize for AuditLogLogoutFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "error_code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_code: &'a Option<String>,
            #[serde(rename = "error_message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_message: &'a Option<String>,
        }
        let AuditLogLogoutFailed {
            error_code,
            error_message,
        } = self;
        _S {
            error_code,
            error_message,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogLogoutFailed {
    #[doc = "The error code of the failure."]
    #[builder(default)]
    pub error_code: Option<String>,
    #[doc = "The error message of the failure."]
    #[builder(default)]
    pub error_message: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogOrganizationUpdatedChangesRequestedSettings {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "threads_ui_visibility")]
            #[allow(dead_code)]
            threads_ui_visibility: Option<String>,
            #[serde(rename = "usage_dashboard_visibility")]
            #[allow(dead_code)]
            usage_dashboard_visibility: Option<String>,
        }
        let _D {
            threads_ui_visibility,
            usage_dashboard_visibility,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogOrganizationUpdatedChangesRequestedSettings {
            threads_ui_visibility,
            usage_dashboard_visibility,
        })
    }
}
impl serde::Serialize for AuditLogOrganizationUpdatedChangesRequestedSettings {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "threads_ui_visibility")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threads_ui_visibility: &'a Option<String>,
            #[serde(rename = "usage_dashboard_visibility")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage_dashboard_visibility: &'a Option<String>,
        }
        let AuditLogOrganizationUpdatedChangesRequestedSettings {
            threads_ui_visibility,
            usage_dashboard_visibility,
        } = self;
        _S {
            threads_ui_visibility,
            usage_dashboard_visibility,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogOrganizationUpdatedChangesRequestedSettings {
    #[doc = "Visibility of the threads page which shows messages created with the Assistants API and Playground. One of `ANY_ROLE`, `OWNERS`, or `NONE`."]
    #[builder(default)]
    pub threads_ui_visibility: Option<String>,
    #[doc = "Visibility of the usage dashboard which shows activity and costs for your organization. One of `ANY_ROLE` or `OWNERS`."]
    #[builder(default)]
    pub usage_dashboard_visibility: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogOrganizationUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "settings")]
            #[allow(dead_code)]
            settings: Option<AuditLogOrganizationUpdatedChangesRequestedSettings>,
        }
        let _D {
            title,
            description,
            name,
            settings,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogOrganizationUpdatedChangesRequested {
            title,
            description,
            name,
            settings,
        })
    }
}
impl serde::Serialize for AuditLogOrganizationUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            title: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "settings")]
            #[serde(skip_serializing_if = "Option::is_none")]
            settings: &'a Option<AuditLogOrganizationUpdatedChangesRequestedSettings>,
        }
        let AuditLogOrganizationUpdatedChangesRequested {
            title,
            description,
            name,
            settings,
        } = self;
        _S {
            title,
            description,
            name,
            settings,
        }
        .serialize(serializer)
    }
}
#[doc = "The payload used to update the organization settings."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogOrganizationUpdatedChangesRequested {
    #[doc = "The organization title."]
    #[builder(default)]
    pub title: Option<String>,
    #[doc = "The organization description."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The organization name."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub settings: Option<AuditLogOrganizationUpdatedChangesRequestedSettings>,
}
impl<'de> serde::Deserialize<'de> for AuditLogOrganizationUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogOrganizationUpdatedChangesRequested>,
        }
        let _D {
            id,
            changes_requested,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogOrganizationUpdated {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogOrganizationUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogOrganizationUpdatedChangesRequested>,
        }
        let AuditLogOrganizationUpdated {
            id,
            changes_requested,
        } = self;
        _S {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogOrganizationUpdated {
    #[doc = "The organization ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the organization settings."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogOrganizationUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectCreatedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: Option<String>,
        }
        let _D { name, title, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogProjectCreatedData { name, title })
    }
}
impl serde::Serialize for AuditLogProjectCreatedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            title: &'a Option<String>,
        }
        let AuditLogProjectCreatedData { name, title } = self;
        _S { name, title }.serialize(serializer)
    }
}
#[doc = "The payload used to create the project."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectCreatedData {
    #[doc = "The project name."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The title of the project as seen on the dashboard."]
    #[builder(default)]
    pub title: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogProjectCreatedData>,
        }
        let _D { id, data, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogProjectCreated { id, data })
    }
}
impl serde::Serialize for AuditLogProjectCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogProjectCreatedData>,
        }
        let AuditLogProjectCreated { id, data } = self;
        _S { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectCreated {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the project."]
    #[builder(default)]
    pub data: Option<AuditLogProjectCreatedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: Option<String>,
        }
        let _D { title, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogProjectUpdatedChangesRequested { title })
    }
}
impl serde::Serialize for AuditLogProjectUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            title: &'a Option<String>,
        }
        let AuditLogProjectUpdatedChangesRequested { title } = self;
        _S { title }.serialize(serializer)
    }
}
#[doc = "The payload used to update the project."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectUpdatedChangesRequested {
    #[doc = "The title of the project as seen on the dashboard."]
    #[builder(default)]
    pub title: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogProjectUpdatedChangesRequested>,
        }
        let _D {
            id,
            changes_requested,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogProjectUpdated {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogProjectUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogProjectUpdatedChangesRequested>,
        }
        let AuditLogProjectUpdated {
            id,
            changes_requested,
        } = self;
        _S {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectUpdated {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the project."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogProjectUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectArchived {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogProjectArchived { id })
    }
}
impl serde::Serialize for AuditLogProjectArchived {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogProjectArchived { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectArchived {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogRateLimitUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "max_requests_per_1_minute")]
            #[allow(dead_code)]
            max_requests_per_1_minute: Option<u64>,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[allow(dead_code)]
            max_tokens_per_1_minute: Option<u64>,
            #[serde(rename = "max_images_per_1_minute")]
            #[allow(dead_code)]
            max_images_per_1_minute: Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[allow(dead_code)]
            max_audio_megabytes_per_1_minute: Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[allow(dead_code)]
            max_requests_per_1_day: Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[allow(dead_code)]
            batch_1_day_max_input_tokens: Option<u64>,
        }
        let _D {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogRateLimitUpdatedChangesRequested {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        })
    }
}
impl serde::Serialize for AuditLogRateLimitUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "max_requests_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tokens_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_images_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_images_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_audio_megabytes_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_day: &'a Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_1_day_max_input_tokens: &'a Option<u64>,
        }
        let AuditLogRateLimitUpdatedChangesRequested {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        } = self;
        _S {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "The payload used to update the rate limits."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogRateLimitUpdatedChangesRequested {
    #[doc = "The maximum requests per minute."]
    #[builder(default)]
    pub max_requests_per_1_minute: Option<u64>,
    #[doc = "The maximum tokens per minute."]
    #[builder(default)]
    pub max_tokens_per_1_minute: Option<u64>,
    #[doc = "The maximum images per minute. Only relevant for certain models."]
    #[builder(default)]
    pub max_images_per_1_minute: Option<u64>,
    #[doc = "The maximum audio megabytes per minute. Only relevant for certain models."]
    #[builder(default)]
    pub max_audio_megabytes_per_1_minute: Option<u64>,
    #[doc = "The maximum requests per day. Only relevant for certain models."]
    #[builder(default)]
    pub max_requests_per_1_day: Option<u64>,
    #[doc = "The maximum batch input tokens per day. Only relevant for certain models."]
    #[builder(default)]
    pub batch_1_day_max_input_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for AuditLogRateLimitUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogRateLimitUpdatedChangesRequested>,
        }
        let _D {
            id,
            changes_requested,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogRateLimitUpdated {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogRateLimitUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogRateLimitUpdatedChangesRequested>,
        }
        let AuditLogRateLimitUpdated {
            id,
            changes_requested,
        } = self;
        _S {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogRateLimitUpdated {
    #[doc = "The rate limit ID"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the rate limits."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogRateLimitUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogRateLimitDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogRateLimitDeleted { id })
    }
}
impl serde::Serialize for AuditLogRateLimitDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogRateLimitDeleted { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogRateLimitDeleted {
    #[doc = "The rate limit ID"]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountCreatedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let _D { role, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogServiceAccountCreatedData { role })
    }
}
impl serde::Serialize for AuditLogServiceAccountCreatedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let AuditLogServiceAccountCreatedData { role } = self;
        _S { role }.serialize(serializer)
    }
}
#[doc = "The payload used to create the service account."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountCreatedData {
    #[doc = "The role of the service account. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogServiceAccountCreatedData>,
        }
        let _D { id, data, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogServiceAccountCreated { id, data })
    }
}
impl serde::Serialize for AuditLogServiceAccountCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogServiceAccountCreatedData>,
        }
        let AuditLogServiceAccountCreated { id, data } = self;
        _S { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountCreated {
    #[doc = "The service account ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the service account."]
    #[builder(default)]
    pub data: Option<AuditLogServiceAccountCreatedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let _D { role, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogServiceAccountUpdatedChangesRequested { role })
    }
}
impl serde::Serialize for AuditLogServiceAccountUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let AuditLogServiceAccountUpdatedChangesRequested { role } = self;
        _S { role }.serialize(serializer)
    }
}
#[doc = "The payload used to updated the service account."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountUpdatedChangesRequested {
    #[doc = "The role of the service account. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogServiceAccountUpdatedChangesRequested>,
        }
        let _D {
            id,
            changes_requested,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogServiceAccountUpdated {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogServiceAccountUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogServiceAccountUpdatedChangesRequested>,
        }
        let AuditLogServiceAccountUpdated {
            id,
            changes_requested,
        } = self;
        _S {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountUpdated {
    #[doc = "The service account ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to updated the service account."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogServiceAccountUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogServiceAccountDeleted { id })
    }
}
impl serde::Serialize for AuditLogServiceAccountDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogServiceAccountDeleted { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountDeleted {
    #[doc = "The service account ID."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserAddedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let _D { role, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogUserAddedData { role })
    }
}
impl serde::Serialize for AuditLogUserAddedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let AuditLogUserAddedData { role } = self;
        _S { role }.serialize(serializer)
    }
}
#[doc = "The payload used to add the user to the project."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserAddedData {
    #[doc = "The role of the user. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserAdded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogUserAddedData>,
        }
        let _D { id, data, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogUserAdded { id, data })
    }
}
impl serde::Serialize for AuditLogUserAdded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogUserAddedData>,
        }
        let AuditLogUserAdded { id, data } = self;
        _S { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserAdded {
    #[doc = "The user ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to add the user to the project."]
    #[builder(default)]
    pub data: Option<AuditLogUserAddedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let _D { role, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogUserUpdatedChangesRequested { role })
    }
}
impl serde::Serialize for AuditLogUserUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let AuditLogUserUpdatedChangesRequested { role } = self;
        _S { role }.serialize(serializer)
    }
}
#[doc = "The payload used to update the user."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserUpdatedChangesRequested {
    #[doc = "The role of the user. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogUserUpdatedChangesRequested>,
        }
        let _D {
            id,
            changes_requested,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogUserUpdated {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogUserUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogUserUpdatedChangesRequested>,
        }
        let AuditLogUserUpdated {
            id,
            changes_requested,
        } = self;
        _S {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserUpdated {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the user."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogUserUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogUserDeleted { id })
    }
}
impl serde::Serialize for AuditLogUserDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogUserDeleted { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserDeleted {
    #[doc = "The user ID."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificateCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D { id, name, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogCertificateCreated { id, name })
    }
}
impl serde::Serialize for AuditLogCertificateCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let AuditLogCertificateCreated { id, name } = self;
        _S { id, name }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificateCreated {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificateUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D { id, name, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogCertificateUpdated { id, name })
    }
}
impl serde::Serialize for AuditLogCertificateUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let AuditLogCertificateUpdated { id, name } = self;
        _S { id, name }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificateUpdated {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificateDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "certificate")]
            #[allow(dead_code)]
            certificate: Option<String>,
        }
        let _D {
            id,
            name,
            certificate,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogCertificateDeleted {
            id,
            name,
            certificate,
        })
    }
}
impl serde::Serialize for AuditLogCertificateDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "certificate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificate: &'a Option<String>,
        }
        let AuditLogCertificateDeleted {
            id,
            name,
            certificate,
        } = self;
        _S {
            id,
            name,
            certificate,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificateDeleted {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The certificate content in PEM format."]
    #[builder(default)]
    pub certificate: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificatesActivatedCertificate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D { id, name, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogCertificatesActivatedCertificate { id, name })
    }
}
impl serde::Serialize for AuditLogCertificatesActivatedCertificate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let AuditLogCertificatesActivatedCertificate { id, name } = self;
        _S { id, name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificatesActivatedCertificate {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificatesActivated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "certificates")]
            #[allow(dead_code)]
            certificates: Option<Vec<AuditLogCertificatesActivatedCertificate>>,
        }
        let _D { certificates, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogCertificatesActivated { certificates })
    }
}
impl serde::Serialize for AuditLogCertificatesActivated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "certificates")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificates: &'a Option<Vec<AuditLogCertificatesActivatedCertificate>>,
        }
        let AuditLogCertificatesActivated { certificates } = self;
        _S { certificates }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificatesActivated {
    #[builder(default)]
    pub certificates: Option<Vec<AuditLogCertificatesActivatedCertificate>>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificatesDeactivatedCertificate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D { id, name, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogCertificatesDeactivatedCertificate { id, name })
    }
}
impl serde::Serialize for AuditLogCertificatesDeactivatedCertificate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let AuditLogCertificatesDeactivatedCertificate { id, name } = self;
        _S { id, name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificatesDeactivatedCertificate {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificatesDeactivated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "certificates")]
            #[allow(dead_code)]
            certificates: Option<Vec<AuditLogCertificatesDeactivatedCertificate>>,
        }
        let _D { certificates, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogCertificatesDeactivated { certificates })
    }
}
impl serde::Serialize for AuditLogCertificatesDeactivated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "certificates")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificates: &'a Option<Vec<AuditLogCertificatesDeactivatedCertificate>>,
        }
        let AuditLogCertificatesDeactivated { certificates } = self;
        _S { certificates }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificatesDeactivated {
    #[builder(default)]
    pub certificates: Option<Vec<AuditLogCertificatesDeactivatedCertificate>>,
}
impl<'de> serde::Deserialize<'de> for AuditLog {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AuditLogEventType,
            #[serde(rename = "effective_at")]
            #[allow(dead_code)]
            effective_at: u64,
            #[serde(rename = "project")]
            #[allow(dead_code)]
            project: Option<AuditLogProject>,
            #[serde(rename = "actor")]
            #[allow(dead_code)]
            actor: AuditLogActor,
            #[serde(rename = "api_key.created")]
            #[allow(dead_code)]
            api_key_created: Option<AuditLogApiKeyCreated>,
            #[serde(rename = "api_key.updated")]
            #[allow(dead_code)]
            api_key_updated: Option<AuditLogApiKeyUpdated>,
            #[serde(rename = "api_key.deleted")]
            #[allow(dead_code)]
            api_key_deleted: Option<AuditLogApiKeyDeleted>,
            #[serde(rename = "checkpoint_permission.created")]
            #[allow(dead_code)]
            checkpoint_permission_created: Option<AuditLogCheckpointPermissionCreated>,
            #[serde(rename = "checkpoint_permission.deleted")]
            #[allow(dead_code)]
            checkpoint_permission_deleted: Option<AuditLogCheckpointPermissionDeleted>,
            #[serde(rename = "invite.sent")]
            #[allow(dead_code)]
            invite_sent: Option<AuditLogInviteSent>,
            #[serde(rename = "invite.accepted")]
            #[allow(dead_code)]
            invite_accepted: Option<AuditLogInviteAccepted>,
            #[serde(rename = "invite.deleted")]
            #[allow(dead_code)]
            invite_deleted: Option<AuditLogInviteDeleted>,
            #[serde(rename = "login.failed")]
            #[allow(dead_code)]
            login_failed: Option<AuditLogLoginFailed>,
            #[serde(rename = "logout.failed")]
            #[allow(dead_code)]
            logout_failed: Option<AuditLogLogoutFailed>,
            #[serde(rename = "organization.updated")]
            #[allow(dead_code)]
            organization_updated: Option<AuditLogOrganizationUpdated>,
            #[serde(rename = "project.created")]
            #[allow(dead_code)]
            project_created: Option<AuditLogProjectCreated>,
            #[serde(rename = "project.updated")]
            #[allow(dead_code)]
            project_updated: Option<AuditLogProjectUpdated>,
            #[serde(rename = "project.archived")]
            #[allow(dead_code)]
            project_archived: Option<AuditLogProjectArchived>,
            #[serde(rename = "rate_limit.updated")]
            #[allow(dead_code)]
            rate_limit_updated: Option<AuditLogRateLimitUpdated>,
            #[serde(rename = "rate_limit.deleted")]
            #[allow(dead_code)]
            rate_limit_deleted: Option<AuditLogRateLimitDeleted>,
            #[serde(rename = "service_account.created")]
            #[allow(dead_code)]
            service_account_created: Option<AuditLogServiceAccountCreated>,
            #[serde(rename = "service_account.updated")]
            #[allow(dead_code)]
            service_account_updated: Option<AuditLogServiceAccountUpdated>,
            #[serde(rename = "service_account.deleted")]
            #[allow(dead_code)]
            service_account_deleted: Option<AuditLogServiceAccountDeleted>,
            #[serde(rename = "user.added")]
            #[allow(dead_code)]
            user_added: Option<AuditLogUserAdded>,
            #[serde(rename = "user.updated")]
            #[allow(dead_code)]
            user_updated: Option<AuditLogUserUpdated>,
            #[serde(rename = "user.deleted")]
            #[allow(dead_code)]
            user_deleted: Option<AuditLogUserDeleted>,
            #[serde(rename = "certificate.created")]
            #[allow(dead_code)]
            certificate_created: Option<AuditLogCertificateCreated>,
            #[serde(rename = "certificate.updated")]
            #[allow(dead_code)]
            certificate_updated: Option<AuditLogCertificateUpdated>,
            #[serde(rename = "certificate.deleted")]
            #[allow(dead_code)]
            certificate_deleted: Option<AuditLogCertificateDeleted>,
            #[serde(rename = "certificates.activated")]
            #[allow(dead_code)]
            certificates_activated: Option<AuditLogCertificatesActivated>,
            #[serde(rename = "certificates.deactivated")]
            #[allow(dead_code)]
            certificates_deactivated: Option<AuditLogCertificatesDeactivated>,
        }
        let _D {
            id,
            type_,
            effective_at,
            project,
            actor,
            api_key_created,
            api_key_updated,
            api_key_deleted,
            checkpoint_permission_created,
            checkpoint_permission_deleted,
            invite_sent,
            invite_accepted,
            invite_deleted,
            login_failed,
            logout_failed,
            organization_updated,
            project_created,
            project_updated,
            project_archived,
            rate_limit_updated,
            rate_limit_deleted,
            service_account_created,
            service_account_updated,
            service_account_deleted,
            user_added,
            user_updated,
            user_deleted,
            certificate_created,
            certificate_updated,
            certificate_deleted,
            certificates_activated,
            certificates_deactivated,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLog {
            id,
            type_,
            effective_at,
            project,
            actor,
            api_key_created,
            api_key_updated,
            api_key_deleted,
            checkpoint_permission_created,
            checkpoint_permission_deleted,
            invite_sent,
            invite_accepted,
            invite_deleted,
            login_failed,
            logout_failed,
            organization_updated,
            project_created,
            project_updated,
            project_archived,
            rate_limit_updated,
            rate_limit_deleted,
            service_account_created,
            service_account_updated,
            service_account_deleted,
            user_added,
            user_updated,
            user_deleted,
            certificate_created,
            certificate_updated,
            certificate_deleted,
            certificates_activated,
            certificates_deactivated,
        })
    }
}
impl serde::Serialize for AuditLog {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a AuditLogEventType,
            #[serde(rename = "effective_at")]
            effective_at: &'a u64,
            #[serde(rename = "project")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project: &'a Option<AuditLogProject>,
            #[serde(rename = "actor")]
            actor: &'a AuditLogActor,
            #[serde(rename = "api_key.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_created: &'a Option<AuditLogApiKeyCreated>,
            #[serde(rename = "api_key.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_updated: &'a Option<AuditLogApiKeyUpdated>,
            #[serde(rename = "api_key.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_deleted: &'a Option<AuditLogApiKeyDeleted>,
            #[serde(rename = "checkpoint_permission.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            checkpoint_permission_created: &'a Option<AuditLogCheckpointPermissionCreated>,
            #[serde(rename = "checkpoint_permission.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            checkpoint_permission_deleted: &'a Option<AuditLogCheckpointPermissionDeleted>,
            #[serde(rename = "invite.sent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            invite_sent: &'a Option<AuditLogInviteSent>,
            #[serde(rename = "invite.accepted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            invite_accepted: &'a Option<AuditLogInviteAccepted>,
            #[serde(rename = "invite.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            invite_deleted: &'a Option<AuditLogInviteDeleted>,
            #[serde(rename = "login.failed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            login_failed: &'a Option<AuditLogLoginFailed>,
            #[serde(rename = "logout.failed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logout_failed: &'a Option<AuditLogLogoutFailed>,
            #[serde(rename = "organization.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            organization_updated: &'a Option<AuditLogOrganizationUpdated>,
            #[serde(rename = "project.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_created: &'a Option<AuditLogProjectCreated>,
            #[serde(rename = "project.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_updated: &'a Option<AuditLogProjectUpdated>,
            #[serde(rename = "project.archived")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_archived: &'a Option<AuditLogProjectArchived>,
            #[serde(rename = "rate_limit.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            rate_limit_updated: &'a Option<AuditLogRateLimitUpdated>,
            #[serde(rename = "rate_limit.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            rate_limit_deleted: &'a Option<AuditLogRateLimitDeleted>,
            #[serde(rename = "service_account.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account_created: &'a Option<AuditLogServiceAccountCreated>,
            #[serde(rename = "service_account.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account_updated: &'a Option<AuditLogServiceAccountUpdated>,
            #[serde(rename = "service_account.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account_deleted: &'a Option<AuditLogServiceAccountDeleted>,
            #[serde(rename = "user.added")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_added: &'a Option<AuditLogUserAdded>,
            #[serde(rename = "user.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_updated: &'a Option<AuditLogUserUpdated>,
            #[serde(rename = "user.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_deleted: &'a Option<AuditLogUserDeleted>,
            #[serde(rename = "certificate.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificate_created: &'a Option<AuditLogCertificateCreated>,
            #[serde(rename = "certificate.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificate_updated: &'a Option<AuditLogCertificateUpdated>,
            #[serde(rename = "certificate.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificate_deleted: &'a Option<AuditLogCertificateDeleted>,
            #[serde(rename = "certificates.activated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificates_activated: &'a Option<AuditLogCertificatesActivated>,
            #[serde(rename = "certificates.deactivated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificates_deactivated: &'a Option<AuditLogCertificatesDeactivated>,
        }
        let AuditLog {
            id,
            type_,
            effective_at,
            project,
            actor,
            api_key_created,
            api_key_updated,
            api_key_deleted,
            checkpoint_permission_created,
            checkpoint_permission_deleted,
            invite_sent,
            invite_accepted,
            invite_deleted,
            login_failed,
            logout_failed,
            organization_updated,
            project_created,
            project_updated,
            project_archived,
            rate_limit_updated,
            rate_limit_deleted,
            service_account_created,
            service_account_updated,
            service_account_deleted,
            user_added,
            user_updated,
            user_deleted,
            certificate_created,
            certificate_updated,
            certificate_deleted,
            certificates_activated,
            certificates_deactivated,
        } = self;
        _S {
            id,
            type_,
            effective_at,
            project,
            actor,
            api_key_created,
            api_key_updated,
            api_key_deleted,
            checkpoint_permission_created,
            checkpoint_permission_deleted,
            invite_sent,
            invite_accepted,
            invite_deleted,
            login_failed,
            logout_failed,
            organization_updated,
            project_created,
            project_updated,
            project_archived,
            rate_limit_updated,
            rate_limit_deleted,
            service_account_created,
            service_account_updated,
            service_account_deleted,
            user_added,
            user_updated,
            user_deleted,
            certificate_created,
            certificate_updated,
            certificate_deleted,
            certificates_activated,
            certificates_deactivated,
        }
        .serialize(serializer)
    }
}
#[doc = "A log of a user action or configuration change within this organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AuditLog {
    #[doc = "The ID of this log."]
    pub id: String,
    pub type_: AuditLogEventType,
    #[doc = "The Unix timestamp (in seconds) of the event."]
    pub effective_at: u64,
    #[doc = "The project that the action was scoped to. Absent for actions not scoped to projects."]
    #[builder(default)]
    pub project: Option<AuditLogProject>,
    #[builder(default)]
    pub actor: AuditLogActor,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub api_key_created: Option<AuditLogApiKeyCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub api_key_updated: Option<AuditLogApiKeyUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub api_key_deleted: Option<AuditLogApiKeyDeleted>,
    #[doc = "The project and fine-tuned model checkpoint that the checkpoint permission was created for."]
    #[builder(default)]
    pub checkpoint_permission_created: Option<AuditLogCheckpointPermissionCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub checkpoint_permission_deleted: Option<AuditLogCheckpointPermissionDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub invite_sent: Option<AuditLogInviteSent>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub invite_accepted: Option<AuditLogInviteAccepted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub invite_deleted: Option<AuditLogInviteDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub login_failed: Option<AuditLogLoginFailed>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub logout_failed: Option<AuditLogLogoutFailed>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub organization_updated: Option<AuditLogOrganizationUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub project_created: Option<AuditLogProjectCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub project_updated: Option<AuditLogProjectUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub project_archived: Option<AuditLogProjectArchived>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub rate_limit_updated: Option<AuditLogRateLimitUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub rate_limit_deleted: Option<AuditLogRateLimitDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub service_account_created: Option<AuditLogServiceAccountCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub service_account_updated: Option<AuditLogServiceAccountUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub service_account_deleted: Option<AuditLogServiceAccountDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub user_added: Option<AuditLogUserAdded>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub user_updated: Option<AuditLogUserUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub user_deleted: Option<AuditLogUserDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificate_created: Option<AuditLogCertificateCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificate_updated: Option<AuditLogCertificateUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificate_deleted: Option<AuditLogCertificateDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificates_activated: Option<AuditLogCertificatesActivated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificates_deactivated: Option<AuditLogCertificatesDeactivated>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorTypeSession {
            #[default]
            #[serde(rename = "session")]
            Session,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorTypeApiKey {
            #[default]
            #[serde(rename = "api_key")]
            ApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Session(#[allow(dead_code)] AuditLogActorTypeSession),
            ApiKey(#[allow(dead_code)] AuditLogActorTypeApiKey),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Session(_) => Self::Session,
            _D::ApiKey(_) => Self::ApiKey,
        })
    }
}
impl serde::Serialize for AuditLogActorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorTypeSession {
            #[default]
            #[serde(rename = "session")]
            Session,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorTypeApiKey {
            #[default]
            #[serde(rename = "api_key")]
            ApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Session(#[allow(dead_code)] &'a AuditLogActorTypeSession),
            ApiKey(#[allow(dead_code)] &'a AuditLogActorTypeApiKey),
        }
        match self {
            Self::Session => _S::Session(&Default::default()).serialize(serializer),
            Self::ApiKey => _S::ApiKey(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of actor. Is either `session` or `api_key`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AuditLogActorType {
    #[doc = "session"]
    Session,
    #[doc = "api_key"]
    ApiKey,
}
impl<'de> serde::Deserialize<'de> for AuditLogActor {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<AuditLogActorType>,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: Option<AuditLogActorSession>,
            #[serde(rename = "api_key")]
            #[allow(dead_code)]
            api_key: Option<AuditLogActorApiKey>,
        }
        let _D {
            type_,
            session,
            api_key,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogActor {
            type_,
            session,
            api_key,
        })
    }
}
impl serde::Serialize for AuditLogActor {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<AuditLogActorType>,
            #[serde(rename = "session")]
            #[serde(skip_serializing_if = "Option::is_none")]
            session: &'a Option<AuditLogActorSession>,
            #[serde(rename = "api_key")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key: &'a Option<AuditLogActorApiKey>,
        }
        let AuditLogActor {
            type_,
            session,
            api_key,
        } = self;
        _S {
            type_,
            session,
            api_key,
        }
        .serialize(serializer)
    }
}
#[doc = "The actor who performed the audit logged action."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActor {
    #[doc = "The type of actor. Is either `session` or `api_key`."]
    #[builder(default)]
    pub type_: Option<AuditLogActorType>,
    #[builder(default)]
    pub session: Option<AuditLogActorSession>,
    #[builder(default)]
    pub api_key: Option<AuditLogActorApiKey>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorApiKeyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorApiKeyTypeUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorApiKeyTypeServiceAccount {
            #[default]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] AuditLogActorApiKeyTypeUser),
            ServiceAccount(#[allow(dead_code)] AuditLogActorApiKeyTypeServiceAccount),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::ServiceAccount(_) => Self::ServiceAccount,
        })
    }
}
impl serde::Serialize for AuditLogActorApiKeyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorApiKeyTypeUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorApiKeyTypeServiceAccount {
            #[default]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a AuditLogActorApiKeyTypeUser),
            ServiceAccount(#[allow(dead_code)] &'a AuditLogActorApiKeyTypeServiceAccount),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::ServiceAccount => _S::ServiceAccount(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of API key. Can be either `user` or `service_account`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AuditLogActorApiKeyType {
    #[doc = "user"]
    User,
    #[doc = "service_account"]
    ServiceAccount,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<AuditLogActorApiKeyType>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<AuditLogActorUser>,
            #[serde(rename = "service_account")]
            #[allow(dead_code)]
            service_account: Option<AuditLogActorServiceAccount>,
        }
        let _D {
            id,
            type_,
            user,
            service_account,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogActorApiKey {
            id,
            type_,
            user,
            service_account,
        })
    }
}
impl serde::Serialize for AuditLogActorApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<AuditLogActorApiKeyType>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<AuditLogActorUser>,
            #[serde(rename = "service_account")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account: &'a Option<AuditLogActorServiceAccount>,
        }
        let AuditLogActorApiKey {
            id,
            type_,
            user,
            service_account,
        } = self;
        _S {
            id,
            type_,
            user,
            service_account,
        }
        .serialize(serializer)
    }
}
#[doc = "The API Key used to perform the audit logged action."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActorApiKey {
    #[doc = "The tracking id of the API key."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of API key. Can be either `user` or `service_account`."]
    #[builder(default)]
    pub type_: Option<AuditLogActorApiKeyType>,
    #[builder(default)]
    pub user: Option<AuditLogActorUser>,
    #[builder(default)]
    pub service_account: Option<AuditLogActorServiceAccount>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorServiceAccount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogActorServiceAccount { id })
    }
}
impl serde::Serialize for AuditLogActorServiceAccount {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let AuditLogActorServiceAccount { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "The service account that performed the audit logged action."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActorServiceAccount {
    #[doc = "The service account id."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorSession {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<AuditLogActorUser>,
            #[serde(rename = "ip_address")]
            #[allow(dead_code)]
            ip_address: Option<String>,
        }
        let _D {
            user, ip_address, ..
        } = _D::deserialize(deserializer)?;
        Ok(AuditLogActorSession { user, ip_address })
    }
}
impl serde::Serialize for AuditLogActorSession {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<AuditLogActorUser>,
            #[serde(rename = "ip_address")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ip_address: &'a Option<String>,
        }
        let AuditLogActorSession { user, ip_address } = self;
        _S { user, ip_address }.serialize(serializer)
    }
}
#[doc = "The session in which the audit logged action was performed."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActorSession {
    #[builder(default)]
    pub user: Option<AuditLogActorUser>,
    #[doc = "The IP address from which the action was performed."]
    #[builder(default)]
    pub ip_address: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorUser {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: Option<String>,
        }
        let _D { id, email, .. } = _D::deserialize(deserializer)?;
        Ok(AuditLogActorUser { id, email })
    }
}
impl serde::Serialize for AuditLogActorUser {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "email")]
            #[serde(skip_serializing_if = "Option::is_none")]
            email: &'a Option<String>,
        }
        let AuditLogActorUser { id, email } = self;
        _S { id, email }.serialize(serializer)
    }
}
#[doc = "The user who performed the audit logged action."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActorUser {
    #[doc = "The user id."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The user email."]
    #[builder(default)]
    pub email: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogEventType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyCreated {
            #[default]
            #[serde(rename = "api_key.created")]
            ApiKeyCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyUpdated {
            #[default]
            #[serde(rename = "api_key.updated")]
            ApiKeyUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyDeleted {
            #[default]
            #[serde(rename = "api_key.deleted")]
            ApiKeyDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeCheckpointPermissionCreated {
            #[default]
            #[serde(rename = "checkpoint_permission.created")]
            CheckpointPermissionCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeCheckpointPermissionDeleted {
            #[default]
            #[serde(rename = "checkpoint_permission.deleted")]
            CheckpointPermissionDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteSent {
            #[default]
            #[serde(rename = "invite.sent")]
            InviteSent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteAccepted {
            #[default]
            #[serde(rename = "invite.accepted")]
            InviteAccepted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteDeleted {
            #[default]
            #[serde(rename = "invite.deleted")]
            InviteDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLoginSucceeded {
            #[default]
            #[serde(rename = "login.succeeded")]
            LoginSucceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLoginFailed {
            #[default]
            #[serde(rename = "login.failed")]
            LoginFailed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLogoutSucceeded {
            #[default]
            #[serde(rename = "logout.succeeded")]
            LogoutSucceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLogoutFailed {
            #[default]
            #[serde(rename = "logout.failed")]
            LogoutFailed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeOrganizationUpdated {
            #[default]
            #[serde(rename = "organization.updated")]
            OrganizationUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectCreated {
            #[default]
            #[serde(rename = "project.created")]
            ProjectCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectUpdated {
            #[default]
            #[serde(rename = "project.updated")]
            ProjectUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectArchived {
            #[default]
            #[serde(rename = "project.archived")]
            ProjectArchived,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountCreated {
            #[default]
            #[serde(rename = "service_account.created")]
            ServiceAccountCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountUpdated {
            #[default]
            #[serde(rename = "service_account.updated")]
            ServiceAccountUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountDeleted {
            #[default]
            #[serde(rename = "service_account.deleted")]
            ServiceAccountDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeRateLimitUpdated {
            #[default]
            #[serde(rename = "rate_limit.updated")]
            RateLimitUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeRateLimitDeleted {
            #[default]
            #[serde(rename = "rate_limit.deleted")]
            RateLimitDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserAdded {
            #[default]
            #[serde(rename = "user.added")]
            UserAdded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserUpdated {
            #[default]
            #[serde(rename = "user.updated")]
            UserUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserDeleted {
            #[default]
            #[serde(rename = "user.deleted")]
            UserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ApiKeyCreated(#[allow(dead_code)] AuditLogEventTypeApiKeyCreated),
            ApiKeyUpdated(#[allow(dead_code)] AuditLogEventTypeApiKeyUpdated),
            ApiKeyDeleted(#[allow(dead_code)] AuditLogEventTypeApiKeyDeleted),
            CheckpointPermissionCreated(
                #[allow(dead_code)] AuditLogEventTypeCheckpointPermissionCreated,
            ),
            CheckpointPermissionDeleted(
                #[allow(dead_code)] AuditLogEventTypeCheckpointPermissionDeleted,
            ),
            InviteSent(#[allow(dead_code)] AuditLogEventTypeInviteSent),
            InviteAccepted(#[allow(dead_code)] AuditLogEventTypeInviteAccepted),
            InviteDeleted(#[allow(dead_code)] AuditLogEventTypeInviteDeleted),
            LoginSucceeded(#[allow(dead_code)] AuditLogEventTypeLoginSucceeded),
            LoginFailed(#[allow(dead_code)] AuditLogEventTypeLoginFailed),
            LogoutSucceeded(#[allow(dead_code)] AuditLogEventTypeLogoutSucceeded),
            LogoutFailed(#[allow(dead_code)] AuditLogEventTypeLogoutFailed),
            OrganizationUpdated(#[allow(dead_code)] AuditLogEventTypeOrganizationUpdated),
            ProjectCreated(#[allow(dead_code)] AuditLogEventTypeProjectCreated),
            ProjectUpdated(#[allow(dead_code)] AuditLogEventTypeProjectUpdated),
            ProjectArchived(#[allow(dead_code)] AuditLogEventTypeProjectArchived),
            ServiceAccountCreated(#[allow(dead_code)] AuditLogEventTypeServiceAccountCreated),
            ServiceAccountUpdated(#[allow(dead_code)] AuditLogEventTypeServiceAccountUpdated),
            ServiceAccountDeleted(#[allow(dead_code)] AuditLogEventTypeServiceAccountDeleted),
            RateLimitUpdated(#[allow(dead_code)] AuditLogEventTypeRateLimitUpdated),
            RateLimitDeleted(#[allow(dead_code)] AuditLogEventTypeRateLimitDeleted),
            UserAdded(#[allow(dead_code)] AuditLogEventTypeUserAdded),
            UserUpdated(#[allow(dead_code)] AuditLogEventTypeUserUpdated),
            UserDeleted(#[allow(dead_code)] AuditLogEventTypeUserDeleted),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ApiKeyCreated(_) => Self::ApiKeyCreated,
            _D::ApiKeyUpdated(_) => Self::ApiKeyUpdated,
            _D::ApiKeyDeleted(_) => Self::ApiKeyDeleted,
            _D::CheckpointPermissionCreated(_) => Self::CheckpointPermissionCreated,
            _D::CheckpointPermissionDeleted(_) => Self::CheckpointPermissionDeleted,
            _D::InviteSent(_) => Self::InviteSent,
            _D::InviteAccepted(_) => Self::InviteAccepted,
            _D::InviteDeleted(_) => Self::InviteDeleted,
            _D::LoginSucceeded(_) => Self::LoginSucceeded,
            _D::LoginFailed(_) => Self::LoginFailed,
            _D::LogoutSucceeded(_) => Self::LogoutSucceeded,
            _D::LogoutFailed(_) => Self::LogoutFailed,
            _D::OrganizationUpdated(_) => Self::OrganizationUpdated,
            _D::ProjectCreated(_) => Self::ProjectCreated,
            _D::ProjectUpdated(_) => Self::ProjectUpdated,
            _D::ProjectArchived(_) => Self::ProjectArchived,
            _D::ServiceAccountCreated(_) => Self::ServiceAccountCreated,
            _D::ServiceAccountUpdated(_) => Self::ServiceAccountUpdated,
            _D::ServiceAccountDeleted(_) => Self::ServiceAccountDeleted,
            _D::RateLimitUpdated(_) => Self::RateLimitUpdated,
            _D::RateLimitDeleted(_) => Self::RateLimitDeleted,
            _D::UserAdded(_) => Self::UserAdded,
            _D::UserUpdated(_) => Self::UserUpdated,
            _D::UserDeleted(_) => Self::UserDeleted,
        })
    }
}
impl serde::Serialize for AuditLogEventType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyCreated {
            #[default]
            #[serde(rename = "api_key.created")]
            ApiKeyCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyUpdated {
            #[default]
            #[serde(rename = "api_key.updated")]
            ApiKeyUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyDeleted {
            #[default]
            #[serde(rename = "api_key.deleted")]
            ApiKeyDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeCheckpointPermissionCreated {
            #[default]
            #[serde(rename = "checkpoint_permission.created")]
            CheckpointPermissionCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeCheckpointPermissionDeleted {
            #[default]
            #[serde(rename = "checkpoint_permission.deleted")]
            CheckpointPermissionDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteSent {
            #[default]
            #[serde(rename = "invite.sent")]
            InviteSent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteAccepted {
            #[default]
            #[serde(rename = "invite.accepted")]
            InviteAccepted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteDeleted {
            #[default]
            #[serde(rename = "invite.deleted")]
            InviteDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLoginSucceeded {
            #[default]
            #[serde(rename = "login.succeeded")]
            LoginSucceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLoginFailed {
            #[default]
            #[serde(rename = "login.failed")]
            LoginFailed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLogoutSucceeded {
            #[default]
            #[serde(rename = "logout.succeeded")]
            LogoutSucceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLogoutFailed {
            #[default]
            #[serde(rename = "logout.failed")]
            LogoutFailed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeOrganizationUpdated {
            #[default]
            #[serde(rename = "organization.updated")]
            OrganizationUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectCreated {
            #[default]
            #[serde(rename = "project.created")]
            ProjectCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectUpdated {
            #[default]
            #[serde(rename = "project.updated")]
            ProjectUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectArchived {
            #[default]
            #[serde(rename = "project.archived")]
            ProjectArchived,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountCreated {
            #[default]
            #[serde(rename = "service_account.created")]
            ServiceAccountCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountUpdated {
            #[default]
            #[serde(rename = "service_account.updated")]
            ServiceAccountUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountDeleted {
            #[default]
            #[serde(rename = "service_account.deleted")]
            ServiceAccountDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeRateLimitUpdated {
            #[default]
            #[serde(rename = "rate_limit.updated")]
            RateLimitUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeRateLimitDeleted {
            #[default]
            #[serde(rename = "rate_limit.deleted")]
            RateLimitDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserAdded {
            #[default]
            #[serde(rename = "user.added")]
            UserAdded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserUpdated {
            #[default]
            #[serde(rename = "user.updated")]
            UserUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserDeleted {
            #[default]
            #[serde(rename = "user.deleted")]
            UserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ApiKeyCreated(#[allow(dead_code)] &'a AuditLogEventTypeApiKeyCreated),
            ApiKeyUpdated(#[allow(dead_code)] &'a AuditLogEventTypeApiKeyUpdated),
            ApiKeyDeleted(#[allow(dead_code)] &'a AuditLogEventTypeApiKeyDeleted),
            CheckpointPermissionCreated(
                #[allow(dead_code)] &'a AuditLogEventTypeCheckpointPermissionCreated,
            ),
            CheckpointPermissionDeleted(
                #[allow(dead_code)] &'a AuditLogEventTypeCheckpointPermissionDeleted,
            ),
            InviteSent(#[allow(dead_code)] &'a AuditLogEventTypeInviteSent),
            InviteAccepted(#[allow(dead_code)] &'a AuditLogEventTypeInviteAccepted),
            InviteDeleted(#[allow(dead_code)] &'a AuditLogEventTypeInviteDeleted),
            LoginSucceeded(#[allow(dead_code)] &'a AuditLogEventTypeLoginSucceeded),
            LoginFailed(#[allow(dead_code)] &'a AuditLogEventTypeLoginFailed),
            LogoutSucceeded(#[allow(dead_code)] &'a AuditLogEventTypeLogoutSucceeded),
            LogoutFailed(#[allow(dead_code)] &'a AuditLogEventTypeLogoutFailed),
            OrganizationUpdated(#[allow(dead_code)] &'a AuditLogEventTypeOrganizationUpdated),
            ProjectCreated(#[allow(dead_code)] &'a AuditLogEventTypeProjectCreated),
            ProjectUpdated(#[allow(dead_code)] &'a AuditLogEventTypeProjectUpdated),
            ProjectArchived(#[allow(dead_code)] &'a AuditLogEventTypeProjectArchived),
            ServiceAccountCreated(#[allow(dead_code)] &'a AuditLogEventTypeServiceAccountCreated),
            ServiceAccountUpdated(#[allow(dead_code)] &'a AuditLogEventTypeServiceAccountUpdated),
            ServiceAccountDeleted(#[allow(dead_code)] &'a AuditLogEventTypeServiceAccountDeleted),
            RateLimitUpdated(#[allow(dead_code)] &'a AuditLogEventTypeRateLimitUpdated),
            RateLimitDeleted(#[allow(dead_code)] &'a AuditLogEventTypeRateLimitDeleted),
            UserAdded(#[allow(dead_code)] &'a AuditLogEventTypeUserAdded),
            UserUpdated(#[allow(dead_code)] &'a AuditLogEventTypeUserUpdated),
            UserDeleted(#[allow(dead_code)] &'a AuditLogEventTypeUserDeleted),
        }
        match self {
            Self::ApiKeyCreated => _S::ApiKeyCreated(&Default::default()).serialize(serializer),
            Self::ApiKeyUpdated => _S::ApiKeyUpdated(&Default::default()).serialize(serializer),
            Self::ApiKeyDeleted => _S::ApiKeyDeleted(&Default::default()).serialize(serializer),
            Self::CheckpointPermissionCreated => {
                _S::CheckpointPermissionCreated(&Default::default()).serialize(serializer)
            }
            Self::CheckpointPermissionDeleted => {
                _S::CheckpointPermissionDeleted(&Default::default()).serialize(serializer)
            }
            Self::InviteSent => _S::InviteSent(&Default::default()).serialize(serializer),
            Self::InviteAccepted => _S::InviteAccepted(&Default::default()).serialize(serializer),
            Self::InviteDeleted => _S::InviteDeleted(&Default::default()).serialize(serializer),
            Self::LoginSucceeded => _S::LoginSucceeded(&Default::default()).serialize(serializer),
            Self::LoginFailed => _S::LoginFailed(&Default::default()).serialize(serializer),
            Self::LogoutSucceeded => _S::LogoutSucceeded(&Default::default()).serialize(serializer),
            Self::LogoutFailed => _S::LogoutFailed(&Default::default()).serialize(serializer),
            Self::OrganizationUpdated => {
                _S::OrganizationUpdated(&Default::default()).serialize(serializer)
            }
            Self::ProjectCreated => _S::ProjectCreated(&Default::default()).serialize(serializer),
            Self::ProjectUpdated => _S::ProjectUpdated(&Default::default()).serialize(serializer),
            Self::ProjectArchived => _S::ProjectArchived(&Default::default()).serialize(serializer),
            Self::ServiceAccountCreated => {
                _S::ServiceAccountCreated(&Default::default()).serialize(serializer)
            }
            Self::ServiceAccountUpdated => {
                _S::ServiceAccountUpdated(&Default::default()).serialize(serializer)
            }
            Self::ServiceAccountDeleted => {
                _S::ServiceAccountDeleted(&Default::default()).serialize(serializer)
            }
            Self::RateLimitUpdated => {
                _S::RateLimitUpdated(&Default::default()).serialize(serializer)
            }
            Self::RateLimitDeleted => {
                _S::RateLimitDeleted(&Default::default()).serialize(serializer)
            }
            Self::UserAdded => _S::UserAdded(&Default::default()).serialize(serializer),
            Self::UserUpdated => _S::UserUpdated(&Default::default()).serialize(serializer),
            Self::UserDeleted => _S::UserDeleted(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The event type."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AuditLogEventType {
    #[doc = "api_key.created"]
    ApiKeyCreated,
    #[doc = "api_key.updated"]
    ApiKeyUpdated,
    #[doc = "api_key.deleted"]
    ApiKeyDeleted,
    #[doc = "checkpoint_permission.created"]
    CheckpointPermissionCreated,
    #[doc = "checkpoint_permission.deleted"]
    CheckpointPermissionDeleted,
    #[doc = "invite.sent"]
    InviteSent,
    #[doc = "invite.accepted"]
    InviteAccepted,
    #[doc = "invite.deleted"]
    InviteDeleted,
    #[doc = "login.succeeded"]
    LoginSucceeded,
    #[doc = "login.failed"]
    LoginFailed,
    #[doc = "logout.succeeded"]
    LogoutSucceeded,
    #[doc = "logout.failed"]
    LogoutFailed,
    #[doc = "organization.updated"]
    OrganizationUpdated,
    #[doc = "project.created"]
    ProjectCreated,
    #[doc = "project.updated"]
    ProjectUpdated,
    #[doc = "project.archived"]
    ProjectArchived,
    #[doc = "service_account.created"]
    ServiceAccountCreated,
    #[doc = "service_account.updated"]
    ServiceAccountUpdated,
    #[doc = "service_account.deleted"]
    ServiceAccountDeleted,
    #[doc = "rate_limit.updated"]
    RateLimitUpdated,
    #[doc = "rate_limit.deleted"]
    RateLimitDeleted,
    #[doc = "user.added"]
    UserAdded,
    #[doc = "user.updated"]
    UserUpdated,
    #[doc = "user.deleted"]
    UserDeleted,
}
impl<'de> serde::Deserialize<'de> for AutoChunkingStrategyRequestParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AutoChunkingStrategyRequestParamType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AutoChunkingStrategyRequestParamType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(AutoChunkingStrategyRequestParam {})
    }
}
impl serde::Serialize for AutoChunkingStrategyRequestParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AutoChunkingStrategyRequestParamType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a AutoChunkingStrategyRequestParamType,
        }
        let AutoChunkingStrategyRequestParam {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AutoChunkingStrategyRequestParam {}
impl<'de> serde::Deserialize<'de> for BatchErrorsDatum {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: Option<String>,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
            #[serde(rename = "line")]
            #[allow(dead_code)]
            line: Option<u64>,
        }
        let _D {
            code,
            message,
            param,
            line,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(BatchErrorsDatum {
            code,
            message,
            param,
            line,
        })
    }
}
impl serde::Serialize for BatchErrorsDatum {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message: &'a Option<String>,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
            #[serde(rename = "line")]
            #[serde(skip_serializing_if = "Option::is_none")]
            line: &'a Option<u64>,
        }
        let BatchErrorsDatum {
            code,
            message,
            param,
            line,
        } = self;
        _S {
            code,
            message,
            param,
            line,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchErrorsDatum {
    #[doc = "An error code identifying the error type."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable message providing more details about the error."]
    #[builder(default)]
    pub message: Option<String>,
    #[doc = "The name of the parameter that caused the error, if applicable."]
    #[builder(default)]
    pub param: Option<String>,
    #[doc = "The line number of the input file where the error occurred, if applicable."]
    #[builder(default)]
    pub line: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for BatchErrors {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<Vec<BatchErrorsDatum>>,
        }
        let _D { object, data, .. } = _D::deserialize(deserializer)?;
        Ok(BatchErrors { object, data })
    }
}
impl serde::Serialize for BatchErrors {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<Vec<BatchErrorsDatum>>,
        }
        let BatchErrors { object, data } = self;
        _S { object, data }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchErrors {
    #[doc = "The object type, which is always `list`."]
    #[builder(default)]
    pub object: Option<String>,
    #[builder(default)]
    pub data: Option<Vec<BatchErrorsDatum>>,
}
impl<'de> serde::Deserialize<'de> for BatchStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusValidating {
            #[default]
            #[serde(rename = "validating")]
            Validating,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusFinalizing {
            #[default]
            #[serde(rename = "finalizing")]
            Finalizing,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCancelling {
            #[default]
            #[serde(rename = "cancelling")]
            Cancelling,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Validating(#[allow(dead_code)] BatchStatusValidating),
            Failed(#[allow(dead_code)] BatchStatusFailed),
            InProgress(#[allow(dead_code)] BatchStatusInProgress),
            Finalizing(#[allow(dead_code)] BatchStatusFinalizing),
            Completed(#[allow(dead_code)] BatchStatusCompleted),
            Expired(#[allow(dead_code)] BatchStatusExpired),
            Cancelling(#[allow(dead_code)] BatchStatusCancelling),
            Cancelled(#[allow(dead_code)] BatchStatusCancelled),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Validating(_) => Self::Validating,
            _D::Failed(_) => Self::Failed,
            _D::InProgress(_) => Self::InProgress,
            _D::Finalizing(_) => Self::Finalizing,
            _D::Completed(_) => Self::Completed,
            _D::Expired(_) => Self::Expired,
            _D::Cancelling(_) => Self::Cancelling,
            _D::Cancelled(_) => Self::Cancelled,
        })
    }
}
impl serde::Serialize for BatchStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusValidating {
            #[default]
            #[serde(rename = "validating")]
            Validating,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusFinalizing {
            #[default]
            #[serde(rename = "finalizing")]
            Finalizing,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCancelling {
            #[default]
            #[serde(rename = "cancelling")]
            Cancelling,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Validating(#[allow(dead_code)] &'a BatchStatusValidating),
            Failed(#[allow(dead_code)] &'a BatchStatusFailed),
            InProgress(#[allow(dead_code)] &'a BatchStatusInProgress),
            Finalizing(#[allow(dead_code)] &'a BatchStatusFinalizing),
            Completed(#[allow(dead_code)] &'a BatchStatusCompleted),
            Expired(#[allow(dead_code)] &'a BatchStatusExpired),
            Cancelling(#[allow(dead_code)] &'a BatchStatusCancelling),
            Cancelled(#[allow(dead_code)] &'a BatchStatusCancelled),
        }
        match self {
            Self::Validating => _S::Validating(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Finalizing => _S::Finalizing(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Expired => _S::Expired(&Default::default()).serialize(serializer),
            Self::Cancelling => _S::Cancelling(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The current status of the batch."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum BatchStatus {
    #[doc = "validating"]
    Validating,
    #[doc = "failed"]
    Failed,
    #[doc = "in_progress"]
    InProgress,
    #[doc = "finalizing"]
    Finalizing,
    #[doc = "completed"]
    Completed,
    #[doc = "expired"]
    Expired,
    #[doc = "cancelling"]
    Cancelling,
    #[doc = "cancelled"]
    Cancelled,
}
impl<'de> serde::Deserialize<'de> for BatchRequestCounts {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "total")]
            #[allow(dead_code)]
            total: u64,
            #[serde(rename = "completed")]
            #[allow(dead_code)]
            completed: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
        }
        let _D {
            total,
            completed,
            failed,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(BatchRequestCounts {
            total,
            completed,
            failed,
        })
    }
}
impl serde::Serialize for BatchRequestCounts {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "total")]
            total: &'a u64,
            #[serde(rename = "completed")]
            completed: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
        }
        let BatchRequestCounts {
            total,
            completed,
            failed,
        } = self;
        _S {
            total,
            completed,
            failed,
        }
        .serialize(serializer)
    }
}
#[doc = "The request counts for different statuses within the batch."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct BatchRequestCounts {
    #[doc = "Total number of requests in the batch."]
    pub total: u64,
    #[doc = "Number of requests that have been completed successfully."]
    pub completed: u64,
    #[doc = "Number of requests that have failed."]
    pub failed: u64,
}
impl<'de> serde::Deserialize<'de> for Batch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `batch`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchObject {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: BatchObject,
            #[serde(rename = "endpoint")]
            #[allow(dead_code)]
            endpoint: String,
            #[serde(rename = "errors")]
            #[allow(dead_code)]
            errors: Option<BatchErrors>,
            #[serde(rename = "input_file_id")]
            #[allow(dead_code)]
            input_file_id: String,
            #[serde(rename = "completion_window")]
            #[allow(dead_code)]
            completion_window: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: BatchStatus,
            #[serde(rename = "output_file_id")]
            #[allow(dead_code)]
            output_file_id: Option<String>,
            #[serde(rename = "error_file_id")]
            #[allow(dead_code)]
            error_file_id: Option<String>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "in_progress_at")]
            #[allow(dead_code)]
            in_progress_at: Option<u64>,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "finalizing_at")]
            #[allow(dead_code)]
            finalizing_at: Option<u64>,
            #[serde(rename = "completed_at")]
            #[allow(dead_code)]
            completed_at: Option<u64>,
            #[serde(rename = "failed_at")]
            #[allow(dead_code)]
            failed_at: Option<u64>,
            #[serde(rename = "expired_at")]
            #[allow(dead_code)]
            expired_at: Option<u64>,
            #[serde(rename = "cancelling_at")]
            #[allow(dead_code)]
            cancelling_at: Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[allow(dead_code)]
            cancelled_at: Option<u64>,
            #[serde(rename = "request_counts")]
            #[allow(dead_code)]
            request_counts: Option<BatchRequestCounts>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Batch {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        })
    }
}
impl serde::Serialize for Batch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `batch`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchObject {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a BatchObject,
            #[serde(rename = "endpoint")]
            endpoint: &'a String,
            #[serde(rename = "errors")]
            #[serde(skip_serializing_if = "Option::is_none")]
            errors: &'a Option<BatchErrors>,
            #[serde(rename = "input_file_id")]
            input_file_id: &'a String,
            #[serde(rename = "completion_window")]
            completion_window: &'a String,
            #[serde(rename = "status")]
            status: &'a BatchStatus,
            #[serde(rename = "output_file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_file_id: &'a Option<String>,
            #[serde(rename = "error_file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_file_id: &'a Option<String>,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "in_progress_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            in_progress_at: &'a Option<u64>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "finalizing_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            finalizing_at: &'a Option<u64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<u64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<u64>,
            #[serde(rename = "expired_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expired_at: &'a Option<u64>,
            #[serde(rename = "cancelling_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelling_at: &'a Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<u64>,
            #[serde(rename = "request_counts")]
            #[serde(skip_serializing_if = "Option::is_none")]
            request_counts: &'a Option<BatchRequestCounts>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Batch {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        } = self;
        _S {
            id,
            object: &Default::default(),
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Batch {
    pub id: String,
    #[doc = "The OpenAI API endpoint used by the batch."]
    pub endpoint: String,
    #[builder(default)]
    pub errors: Option<BatchErrors>,
    #[doc = "The ID of the input file for the batch."]
    pub input_file_id: String,
    #[doc = "The time frame within which the batch should be processed."]
    pub completion_window: String,
    #[doc = "The current status of the batch."]
    pub status: BatchStatus,
    #[doc = "The ID of the file containing the outputs of successfully executed requests."]
    #[builder(default)]
    pub output_file_id: Option<String>,
    #[doc = "The ID of the file containing the outputs of requests with errors."]
    #[builder(default)]
    pub error_file_id: Option<String>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was created."]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) for when the batch started processing."]
    #[builder(default)]
    pub in_progress_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch will expire."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch started finalizing."]
    #[builder(default)]
    pub finalizing_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was completed."]
    #[builder(default)]
    pub completed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch failed."]
    #[builder(default)]
    pub failed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch expired."]
    #[builder(default)]
    pub expired_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch started cancelling."]
    #[builder(default)]
    pub cancelling_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<u64>,
    #[doc = "The request counts for different statuses within the batch."]
    #[builder(default)]
    pub request_counts: Option<BatchRequestCounts>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
#[doc = "The HTTP method to be used for the request. Currently only `POST` is supported."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum BatchRequestInputMethod {
    #[default]
    #[serde(rename = "POST")]
    Post,
}
impl<'de> serde::Deserialize<'de> for BatchRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "custom_id")]
            #[allow(dead_code)]
            custom_id: Option<String>,
            #[serde(rename = "method")]
            #[allow(dead_code)]
            method: Option<BatchRequestInputMethod>,
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: Option<String>,
        }
        let _D {
            custom_id,
            method,
            url,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(BatchRequestInput {
            custom_id,
            method,
            url,
        })
    }
}
impl serde::Serialize for BatchRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "custom_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            custom_id: &'a Option<String>,
            #[serde(rename = "method")]
            #[serde(skip_serializing_if = "Option::is_none")]
            method: &'a Option<BatchRequestInputMethod>,
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            url: &'a Option<String>,
        }
        let BatchRequestInput {
            custom_id,
            method,
            url,
        } = self;
        _S {
            custom_id,
            method,
            url,
        }
        .serialize(serializer)
    }
}
#[doc = "The per-line object of the batch input file"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchRequestInput {
    #[doc = "A developer-provided per-request id that will be used to match outputs to inputs. Must be unique for each request in a batch."]
    #[builder(default)]
    pub custom_id: Option<String>,
    #[doc = "The HTTP method to be used for the request. Currently only `POST` is supported."]
    #[builder(default)]
    pub method: Option<BatchRequestInputMethod>,
    #[doc = "The OpenAI API relative URL to be used for the request. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported."]
    #[builder(default)]
    pub url: Option<String>,
}
impl<'de> serde::Deserialize<'de> for BatchRequestOutputResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "status_code")]
            #[allow(dead_code)]
            status_code: Option<u64>,
            #[serde(rename = "request_id")]
            #[allow(dead_code)]
            request_id: Option<String>,
            #[serde(rename = "body")]
            #[allow(dead_code)]
            body: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let _D {
            status_code,
            request_id,
            body,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(BatchRequestOutputResponse {
            status_code,
            request_id,
            body,
        })
    }
}
impl serde::Serialize for BatchRequestOutputResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "status_code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status_code: &'a Option<u64>,
            #[serde(rename = "request_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            request_id: &'a Option<String>,
            #[serde(rename = "body")]
            #[serde(skip_serializing_if = "Option::is_none")]
            body: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let BatchRequestOutputResponse {
            status_code,
            request_id,
            body,
        } = self;
        _S {
            status_code,
            request_id,
            body,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchRequestOutputResponse {
    #[doc = "The HTTP status code of the response"]
    #[builder(default)]
    pub status_code: Option<u64>,
    #[doc = "An unique identifier for the OpenAI API request. Please include this request ID when contacting support."]
    #[builder(default)]
    pub request_id: Option<String>,
    #[doc = "The JSON body of the response"]
    #[builder(default)]
    pub body: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for BatchRequestOutputError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: Option<String>,
        }
        let _D { code, message, .. } = _D::deserialize(deserializer)?;
        Ok(BatchRequestOutputError { code, message })
    }
}
impl serde::Serialize for BatchRequestOutputError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message: &'a Option<String>,
        }
        let BatchRequestOutputError { code, message } = self;
        _S { code, message }.serialize(serializer)
    }
}
#[doc = "For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchRequestOutputError {
    #[doc = "A machine-readable error code."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable error message."]
    #[builder(default)]
    pub message: Option<String>,
}
impl<'de> serde::Deserialize<'de> for BatchRequestOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "custom_id")]
            #[allow(dead_code)]
            custom_id: Option<String>,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Option<BatchRequestOutputResponse>,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<BatchRequestOutputError>,
        }
        let _D {
            id,
            custom_id,
            response,
            error,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(BatchRequestOutput {
            id,
            custom_id,
            response,
            error,
        })
    }
}
impl serde::Serialize for BatchRequestOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "custom_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            custom_id: &'a Option<String>,
            #[serde(rename = "response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response: &'a Option<BatchRequestOutputResponse>,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<BatchRequestOutputError>,
        }
        let BatchRequestOutput {
            id,
            custom_id,
            response,
            error,
        } = self;
        _S {
            id,
            custom_id,
            response,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "The per-line object of the batch output and error files"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchRequestOutput {
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "A developer-provided per-request id that will be used to match outputs to inputs."]
    #[builder(default)]
    pub custom_id: Option<String>,
    #[builder(default)]
    pub response: Option<BatchRequestOutputResponse>,
    #[doc = "For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure."]
    #[builder(default)]
    pub error: Option<BatchRequestOutputError>,
}
impl<'de> serde::Deserialize<'de> for CertificateObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectCertificate {
            #[default]
            #[serde(rename = "certificate")]
            Certificate,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectOrganizationCertificate {
            #[default]
            #[serde(rename = "organization.certificate")]
            OrganizationCertificate,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectOrganizationProjectCertificate {
            #[default]
            #[serde(rename = "organization.project.certificate")]
            OrganizationProjectCertificate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Certificate(#[allow(dead_code)] CertificateObjectCertificate),
            OrganizationCertificate(#[allow(dead_code)] CertificateObjectOrganizationCertificate),
            OrganizationProjectCertificate(
                #[allow(dead_code)] CertificateObjectOrganizationProjectCertificate,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Certificate(_) => Self::Certificate,
            _D::OrganizationCertificate(_) => Self::OrganizationCertificate,
            _D::OrganizationProjectCertificate(_) => Self::OrganizationProjectCertificate,
        })
    }
}
impl serde::Serialize for CertificateObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectCertificate {
            #[default]
            #[serde(rename = "certificate")]
            Certificate,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectOrganizationCertificate {
            #[default]
            #[serde(rename = "organization.certificate")]
            OrganizationCertificate,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectOrganizationProjectCertificate {
            #[default]
            #[serde(rename = "organization.project.certificate")]
            OrganizationProjectCertificate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Certificate(#[allow(dead_code)] &'a CertificateObjectCertificate),
            OrganizationCertificate(
                #[allow(dead_code)] &'a CertificateObjectOrganizationCertificate,
            ),
            OrganizationProjectCertificate(
                #[allow(dead_code)] &'a CertificateObjectOrganizationProjectCertificate,
            ),
        }
        match self {
            Self::Certificate => _S::Certificate(&Default::default()).serialize(serializer),
            Self::OrganizationCertificate => {
                _S::OrganizationCertificate(&Default::default()).serialize(serializer)
            }
            Self::OrganizationProjectCertificate => {
                _S::OrganizationProjectCertificate(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The object type.\n\n- If creating, updating, or getting a specific certificate, the object type is `certificate`.\n- If listing, activating, or deactivating certificates for the organization, the object type is `organization.certificate`.\n- If listing, activating, or deactivating certificates for a project, the object type is `organization.project.certificate`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CertificateObject {
    #[doc = "certificate"]
    Certificate,
    #[doc = "organization.certificate"]
    OrganizationCertificate,
    #[doc = "organization.project.certificate"]
    OrganizationProjectCertificate,
}
impl<'de> serde::Deserialize<'de> for CertificateCertificateDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "valid_at")]
            #[allow(dead_code)]
            valid_at: Option<u64>,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
        }
        let _D {
            valid_at,
            expires_at,
            content,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CertificateCertificateDetails {
            valid_at,
            expires_at,
            content,
        })
    }
}
impl serde::Serialize for CertificateCertificateDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "valid_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            valid_at: &'a Option<u64>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
        }
        let CertificateCertificateDetails {
            valid_at,
            expires_at,
            content,
        } = self;
        _S {
            valid_at,
            expires_at,
            content,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CertificateCertificateDetails {
    #[doc = "The Unix timestamp (in seconds) of when the certificate becomes valid."]
    #[builder(default)]
    pub valid_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) of when the certificate expires."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The content of the certificate in PEM format."]
    #[builder(default)]
    pub content: Option<String>,
}
impl<'de> serde::Deserialize<'de> for Certificate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CertificateObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "certificate_details")]
            #[allow(dead_code)]
            certificate_details: CertificateCertificateDetails,
            #[serde(rename = "active")]
            #[allow(dead_code)]
            active: Option<bool>,
        }
        let _D {
            object,
            id,
            name,
            created_at,
            certificate_details,
            active,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Certificate {
            object,
            id,
            name,
            created_at,
            certificate_details,
            active,
        })
    }
}
impl serde::Serialize for Certificate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a CertificateObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "certificate_details")]
            certificate_details: &'a CertificateCertificateDetails,
            #[serde(rename = "active")]
            #[serde(skip_serializing_if = "Option::is_none")]
            active: &'a Option<bool>,
        }
        let Certificate {
            object,
            id,
            name,
            created_at,
            certificate_details,
            active,
        } = self;
        _S {
            object,
            id,
            name,
            created_at,
            certificate_details,
            active,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual `certificate` uploaded to the organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Certificate {
    #[doc = "The object type.\n\n- If creating, updating, or getting a specific certificate, the object type is `certificate`.\n- If listing, activating, or deactivating certificates for the organization, the object type is `organization.certificate`.\n- If listing, activating, or deactivating certificates for a project, the object type is `organization.project.certificate`.\n"]
    pub object: CertificateObject,
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the certificate."]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the certificate was uploaded."]
    pub created_at: u64,
    #[builder(default)]
    pub certificate_details: CertificateCertificateDetails,
    #[doc = "Whether the certificate is currently active at the specified scope. Not returned when getting details for a specific certificate."]
    #[builder(default)]
    pub active: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of object being deleted."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionDeletedObject {
            #[default]
            #[serde(rename = "chat.completion.deleted")]
            ChatCompletionDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ChatCompletionDeletedObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionDeleted { id, deleted })
    }
}
impl serde::Serialize for ChatCompletionDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of object being deleted."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionDeletedObject {
            #[default]
            #[serde(rename = "chat.completion.deleted")]
            ChatCompletionDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ChatCompletionDeletedObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let ChatCompletionDeleted { id, deleted } = self;
        _S {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionDeleted {
    #[doc = "The ID of the chat completion that was deleted."]
    pub id: String,
    #[doc = "Whether the chat completion was deleted."]
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionFunctionCallOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { name, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionFunctionCallOption { name })
    }
}
impl serde::Serialize for ChatCompletionFunctionCallOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ChatCompletionFunctionCallOption { name } = self;
        _S { name }.serialize(serializer)
    }
}
#[doc = "Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionFunctionCallOption {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionFunctions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<FunctionParameters>,
        }
        let _D {
            description,
            name,
            parameters,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionFunctions {
            description,
            name,
            parameters,
        })
    }
}
impl serde::Serialize for ChatCompletionFunctions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<FunctionParameters>,
        }
        let ChatCompletionFunctions {
            description,
            name,
            parameters,
        } = self;
        _S {
            description,
            name,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionFunctions {
    #[doc = "A description of what the function does, used by the model to choose when and how to call the function."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."]
    pub name: String,
    #[builder(default)]
    pub parameters: Option<FunctionParameters>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ChatCompletionListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<CreateChatCompletionResponse>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionList {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ChatCompletionList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ChatCompletionListObject,
            #[serde(rename = "data")]
            data: &'a Vec<CreateChatCompletionResponse>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ChatCompletionList {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of Chat Completions.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionList {
    #[doc = "An array of chat completion objects.\n"]
    pub data: Vec<CreateChatCompletionResponse>,
    #[doc = "The identifier of the first chat completion in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last chat completion in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more Chat Completions available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageListDatum {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(flatten)]
            #[allow(dead_code)]
            chat_completion_response_message: ChatCompletionResponseMessage,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D {
            chat_completion_response_message,
            id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionMessageListDatum {
            chat_completion_response_message,
            id,
        })
    }
}
impl serde::Serialize for ChatCompletionMessageListDatum {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(flatten)]
            chat_completion_response_message: &'a ChatCompletionResponseMessage,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let ChatCompletionMessageListDatum {
            chat_completion_response_message,
            id,
        } = self;
        _S {
            chat_completion_response_message,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageListDatum {
    #[builder(default)]
    pub chat_completion_response_message: ChatCompletionResponseMessage,
    #[doc = "The identifier of the chat message."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionMessageListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ChatCompletionMessageListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ChatCompletionMessageListDatum>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionMessageList {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ChatCompletionMessageList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionMessageListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ChatCompletionMessageListObject,
            #[serde(rename = "data")]
            data: &'a Vec<ChatCompletionMessageListDatum>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ChatCompletionMessageList {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of chat completion messages.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageList {
    #[doc = "An array of chat completion message objects.\n"]
    pub data: Vec<ChatCompletionMessageListDatum>,
    #[doc = "The identifier of the first chat message in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last chat message in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more chat messages available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCallFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let _D {
            name, arguments, ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionMessageToolCallFunction { name, arguments })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCallFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let ChatCompletionMessageToolCallFunction { name, arguments } = self;
        _S { name, arguments }.serialize(serializer)
    }
}
#[doc = "The function that the model called."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCallFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionMessageToolCallType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionMessageToolCallType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: ChatCompletionMessageToolCallFunction,
        }
        let _D { id, function, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionMessageToolCall { id, function })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionMessageToolCallType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a ChatCompletionMessageToolCallType,
            #[serde(rename = "function")]
            function: &'a ChatCompletionMessageToolCallFunction,
        }
        let ChatCompletionMessageToolCall { id, function } = self;
        _S {
            id,
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCall {
    #[doc = "The ID of the tool call."]
    pub id: String,
    #[doc = "The function that the model called."]
    pub function: ChatCompletionMessageToolCallFunction,
}
#[doc = "The type of the tool. Currently, only `function` is supported."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum ChatCompletionMessageToolCallChunkType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCallChunkFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
        }
        let _D {
            name, arguments, ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionMessageToolCallChunkFunction { name, arguments })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCallChunkFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
        }
        let ChatCompletionMessageToolCallChunkFunction { name, arguments } = self;
        _S { name, arguments }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCallChunkFunction {
    #[doc = "The name of the function to call."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    #[builder(default)]
    pub arguments: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCallChunk {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<ChatCompletionMessageToolCallChunkType>,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: Option<ChatCompletionMessageToolCallChunkFunction>,
        }
        let _D {
            index,
            id,
            type_,
            function,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionMessageToolCallChunk {
            index,
            id,
            type_,
            function,
        })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCallChunk {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<ChatCompletionMessageToolCallChunkType>,
            #[serde(rename = "function")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function: &'a Option<ChatCompletionMessageToolCallChunkFunction>,
        }
        let ChatCompletionMessageToolCallChunk {
            index,
            id,
            type_,
            function,
        } = self;
        _S {
            index,
            id,
            type_,
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCallChunk {
    pub index: u64,
    #[doc = "The ID of the tool call."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the tool. Currently, only `function` is supported."]
    #[builder(default)]
    pub type_: Option<ChatCompletionMessageToolCallChunkType>,
    #[builder(default)]
    pub function: Option<ChatCompletionMessageToolCallChunkFunction>,
}
#[doc = "The tool calls generated by the model, such as function calls."]
pub type ChatCompletionMessageToolCalls = Vec<ChatCompletionMessageToolCall>;
impl<'de> serde::Deserialize<'de> for ChatCompletionModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] ChatCompletionModalityText),
            Audio(#[allow(dead_code)] ChatCompletionModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for ChatCompletionModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a ChatCompletionModalityText),
            Audio(#[allow(dead_code)] &'a ChatCompletionModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
#[doc = "Output types that you would like the model to generate for this request.\nMost models are capable of generating text, which is the default:\n\n`[\"text\"]`\n\nThe `gpt-4o-audio-preview` model can also be used to [generate audio](/docs/guides/audio). To\nrequest that this model generate both text and audio responses, you can\nuse:\n\n`[\"text\", \"audio\"]`\n"]
pub type ChatCompletionModalities = Vec<ChatCompletionModality>;
impl<'de> serde::Deserialize<'de> for ChatCompletionNamedToolChoiceFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { name, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionNamedToolChoiceFunction { name })
    }
}
impl serde::Serialize for ChatCompletionNamedToolChoiceFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ChatCompletionNamedToolChoiceFunction { name } = self;
        _S { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionNamedToolChoiceFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionNamedToolChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionNamedToolChoiceType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionNamedToolChoiceType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: ChatCompletionNamedToolChoiceFunction,
        }
        let _D { function, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionNamedToolChoice { function })
    }
}
impl serde::Serialize for ChatCompletionNamedToolChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionNamedToolChoiceType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionNamedToolChoiceType,
            #[serde(rename = "function")]
            function: &'a ChatCompletionNamedToolChoiceFunction,
        }
        let ChatCompletionNamedToolChoice { function } = self;
        _S {
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[doc = "Specifies a tool the model should use. Use to force the model to call a specific function."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionNamedToolChoice {
    pub function: ChatCompletionNamedToolChoiceFunction,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestAssistantMessageContentPart>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestAssistantMessageContentPart>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestAssistantMessageContent {
    #[doc = "The contents of the assistant message."]
    String(String),
    #[doc = "An array of content parts with a defined type. Can be one or more of type `text`, or exactly one of type `refusal`."]
    Array(Vec<ChatCompletionRequestAssistantMessageContentPart>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessageAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestAssistantMessageAudio { id })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessageAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
        }
        let ChatCompletionRequestAssistantMessageAudio { id } = self;
        _S { id }.serialize(serializer)
    }
}
#[doc = "Data about a previous audio response from the model. \n[Learn more](/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestAssistantMessageAudio {
    #[doc = "Unique identifier for a previous audio response from the model.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessageFunctionCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D {
            arguments, name, ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestAssistantMessageFunctionCall { arguments, name })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessageFunctionCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ChatCompletionRequestAssistantMessageFunctionCall { arguments, name } = self;
        _S { arguments, name }.serialize(serializer)
    }
}
#[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestAssistantMessageFunctionCall {
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    pub arguments: String,
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `assistant`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestAssistantMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<ChatCompletionRequestAssistantMessageContent>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<String>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestAssistantMessageRole,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<ChatCompletionRequestAssistantMessageAudio>,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Option<ChatCompletionMessageToolCalls>,
            #[serde(rename = "function_call")]
            #[allow(dead_code)]
            function_call: Option<ChatCompletionRequestAssistantMessageFunctionCall>,
        }
        let _D {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestAssistantMessage {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `assistant`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestAssistantMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<ChatCompletionRequestAssistantMessageContent>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestAssistantMessageRole,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<ChatCompletionRequestAssistantMessageAudio>,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<ChatCompletionMessageToolCalls>,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<ChatCompletionRequestAssistantMessageFunctionCall>,
        }
        let ChatCompletionRequestAssistantMessage {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
        } = self;
        _S {
            content,
            refusal,
            role: &Default::default(),
            name,
            audio,
            tool_calls,
            function_call,
        }
        .serialize(serializer)
    }
}
#[doc = "Messages sent by the model in response to user messages.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestAssistantMessage {
    #[doc = "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"]
    #[builder(default)]
    pub content: Option<ChatCompletionRequestAssistantMessageContent>,
    #[doc = "The refusal message by the assistant."]
    #[builder(default)]
    pub refusal: Option<String>,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "Data about a previous audio response from the model. \n[Learn more](/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<ChatCompletionRequestAssistantMessageAudio>,
    #[builder(default)]
    pub tool_calls: Option<ChatCompletionMessageToolCalls>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call: Option<ChatCompletionRequestAssistantMessageFunctionCall>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessageContentPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] ChatCompletionRequestMessageContentPartText),
            Refusal(#[allow(dead_code)] ChatCompletionRequestMessageContentPartRefusal),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_v) => Self::Text(_v),
            _D::Refusal(_v) => Self::Refusal(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessageContentPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartText),
            Refusal(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartRefusal),
        }
        match self {
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
            Self::Refusal(_v) => _S::Refusal(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestAssistantMessageContentPart {
    Text(ChatCompletionRequestMessageContentPartText),
    Refusal(ChatCompletionRequestMessageContentPartRefusal),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestDeveloperMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestMessageContentPartText>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionRequestDeveloperMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestMessageContentPartText>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The contents of the developer message."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestDeveloperMessageContent {
    #[doc = "The contents of the developer message."]
    String(String),
    #[doc = "An array of content parts with a defined type. For developer messages, only type `text` is supported."]
    Array(Vec<ChatCompletionRequestMessageContentPartText>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestDeveloperMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `developer`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestDeveloperMessageRole {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: ChatCompletionRequestDeveloperMessageContent,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestDeveloperMessageRole,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D { content, name, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestDeveloperMessage { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestDeveloperMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `developer`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestDeveloperMessageRole {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "content")]
            content: &'a ChatCompletionRequestDeveloperMessageContent,
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestDeveloperMessageRole,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let ChatCompletionRequestDeveloperMessage { content, name } = self;
        _S {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Developer-provided instructions that the model should follow, regardless of\nmessages sent by the user. With o1 models and newer, `developer` messages\nreplace the previous `system` messages.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestDeveloperMessage {
    #[doc = "The contents of the developer message."]
    pub content: ChatCompletionRequestDeveloperMessageContent,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestFunctionMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestFunctionMessageRole {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestFunctionMessageRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { content, name, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestFunctionMessage { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestFunctionMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestFunctionMessageRole {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestFunctionMessageRole,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ChatCompletionRequestFunctionMessage { content, name } = self;
        _S {
            role: &Default::default(),
            content,
            name,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestFunctionMessage {
    #[doc = "The contents of the function message."]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Developer(#[allow(dead_code)] ChatCompletionRequestDeveloperMessage),
            System(#[allow(dead_code)] ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] ChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] ChatCompletionRequestFunctionMessage),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Developer(_v) => Self::Developer(_v),
            _D::System(_v) => Self::System(_v),
            _D::User(_v) => Self::User(_v),
            _D::Assistant(_v) => Self::Assistant(_v),
            _D::Tool(_v) => Self::Tool(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionRequestMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Developer(#[allow(dead_code)] &'a ChatCompletionRequestDeveloperMessage),
            System(#[allow(dead_code)] &'a ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] &'a ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] &'a ChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] &'a ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] &'a ChatCompletionRequestFunctionMessage),
        }
        match self {
            Self::Developer(_v) => _S::Developer(_v).serialize(serializer),
            Self::System(_v) => _S::System(_v).serialize(serializer),
            Self::User(_v) => _S::User(_v).serialize(serializer),
            Self::Assistant(_v) => _S::Assistant(_v).serialize(serializer),
            Self::Tool(_v) => _S::Tool(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestMessage {
    Developer(ChatCompletionRequestDeveloperMessage),
    System(ChatCompletionRequestSystemMessage),
    User(ChatCompletionRequestUserMessage),
    Assistant(ChatCompletionRequestAssistantMessage),
    Tool(ChatCompletionRequestToolMessage),
    Function(ChatCompletionRequestFunctionMessage),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartAudioInputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Wav(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav,
            ),
            Mp3(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Wav(_) => Self::Wav,
            _D::Mp3(_) => Self::Mp3,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartAudioInputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Wav(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav,
            ),
            Mp3(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3,
            ),
        }
        match self {
            Self::Wav => _S::Wav(&Default::default()).serialize(serializer),
            Self::Mp3 => _S::Mp3(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of the encoded audio data. Currently supports \"wav\" and \"mp3\".\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestMessageContentPartAudioInputAudioFormat {
    #[doc = "wav"]
    Wav,
    #[doc = "mp3"]
    Mp3,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartAudioInputAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: String,
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: ChatCompletionRequestMessageContentPartAudioInputAudioFormat,
        }
        let _D { data, format, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestMessageContentPartAudioInputAudio { data, format })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartAudioInputAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "format")]
            format: &'a ChatCompletionRequestMessageContentPartAudioInputAudioFormat,
        }
        let ChatCompletionRequestMessageContentPartAudioInputAudio { data, format } = self;
        _S { data, format }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartAudioInputAudio {
    #[doc = "Base64 encoded audio data."]
    pub data: String,
    #[doc = "The format of the encoded audio data. Currently supports \"wav\" and \"mp3\".\n"]
    pub format: ChatCompletionRequestMessageContentPartAudioInputAudioFormat,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part. Always `input_audio`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioType {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartAudioType,
            #[serde(rename = "input_audio")]
            #[allow(dead_code)]
            input_audio: ChatCompletionRequestMessageContentPartAudioInputAudio,
        }
        let _D { input_audio, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestMessageContentPartAudio { input_audio })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part. Always `input_audio`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioType {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartAudioType,
            #[serde(rename = "input_audio")]
            input_audio: &'a ChatCompletionRequestMessageContentPartAudioInputAudio,
        }
        let ChatCompletionRequestMessageContentPartAudio { input_audio } = self;
        _S {
            type_: &Default::default(),
            input_audio,
        }
        .serialize(serializer)
    }
}
#[doc = "Learn about [audio inputs](/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartAudio {
    pub input_audio: ChatCompletionRequestMessageContentPartAudioInputAudio,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartFileFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: Option<String>,
            #[serde(rename = "file_data")]
            #[allow(dead_code)]
            file_data: Option<String>,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let _D {
            filename,
            file_data,
            file_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestMessageContentPartFileFile {
            filename,
            file_data,
            file_id,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartFileFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "filename")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filename: &'a Option<String>,
            #[serde(rename = "file_data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_data: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let ChatCompletionRequestMessageContentPartFileFile {
            filename,
            file_data,
            file_id,
        } = self;
        _S {
            filename,
            file_data,
            file_id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartFileFile {
    #[doc = "The name of the file, used when passing the file to the model as a \nstring.\n"]
    #[builder(default)]
    pub filename: Option<String>,
    #[doc = "The base64 encoded file data, used when passing the file to the model \nas a string.\n"]
    #[builder(default)]
    pub file_data: Option<String>,
    #[doc = "The ID of an uploaded file to use as input.\n"]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part. Always `file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartFileType {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartFileType,
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: ChatCompletionRequestMessageContentPartFileFile,
        }
        let _D { file, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestMessageContentPartFile { file })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part. Always `file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartFileType {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartFileType,
            #[serde(rename = "file")]
            file: &'a ChatCompletionRequestMessageContentPartFileFile,
        }
        let ChatCompletionRequestMessageContentPartFile { file } = self;
        _S {
            type_: &Default::default(),
            file,
        }
        .serialize(serializer)
    }
}
#[doc = "Learn about [file inputs](/docs/guides/text) for text generation.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartFile {
    #[builder(default)]
    pub file: ChatCompletionRequestMessageContentPartFileFile,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartImageImageUrlDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto,
            ),
            Low(#[allow(dead_code)] ChatCompletionRequestMessageContentPartImageImageUrlDetailLow),
            High(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Low(_) => Self::Low,
            _D::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartImageImageUrlDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto,
            ),
            Low(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartImageImageUrlDetailLow,
            ),
            High(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh,
            ),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding)."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestMessageContentPartImageImageUrlDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartImageImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<ChatCompletionRequestMessageContentPartImageImageUrlDetail>,
        }
        let _D { url, detail, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestMessageContentPartImageImageUrl { url, detail })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartImageImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<ChatCompletionRequestMessageContentPartImageImageUrlDetail>,
        }
        let ChatCompletionRequestMessageContentPartImageImageUrl { url, detail } = self;
        _S { url, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartImageImageUrl {
    #[doc = "Either a URL of the image or the base64 encoded image data."]
    pub url: String,
    #[doc = "Specifies the detail level of the image. Learn more in the [Vision guide](/docs/guides/vision#low-or-high-fidelity-image-understanding)."]
    #[builder(default)]
    pub detail: Option<ChatCompletionRequestMessageContentPartImageImageUrlDetail>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartImageType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: ChatCompletionRequestMessageContentPartImageImageUrl,
        }
        let _D { image_url, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestMessageContentPartImage { image_url })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartImageType,
            #[serde(rename = "image_url")]
            image_url: &'a ChatCompletionRequestMessageContentPartImageImageUrl,
        }
        let ChatCompletionRequestMessageContentPartImage { image_url } = self;
        _S {
            type_: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[doc = "Learn about [image inputs](/docs/guides/vision).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartImage {
    pub image_url: ChatCompletionRequestMessageContentPartImageImageUrl,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartRefusal {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartRefusalType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartRefusalType,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: String,
        }
        let _D { refusal, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestMessageContentPartRefusal { refusal })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartRefusal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartRefusalType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartRefusalType,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let ChatCompletionRequestMessageContentPartRefusal { refusal } = self;
        _S {
            type_: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartRefusal {
    #[doc = "The refusal message generated by the model."]
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartTextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartTextType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestMessageContentPartText { text })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartTextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartTextType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let ChatCompletionRequestMessageContentPartText { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "Learn about [text inputs](/docs/guides/text-generation).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartText {
    #[doc = "The text content."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestSystemMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestSystemMessageContentPart>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionRequestSystemMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestSystemMessageContentPart>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The contents of the system message."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestSystemMessageContent {
    #[doc = "The contents of the system message."]
    String(String),
    #[doc = "An array of content parts with a defined type. For system messages, only type `text` is supported."]
    Array(Vec<ChatCompletionRequestSystemMessageContentPart>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestSystemMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `system`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestSystemMessageRole {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: ChatCompletionRequestSystemMessageContent,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestSystemMessageRole,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D { content, name, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestSystemMessage { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestSystemMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `system`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestSystemMessageRole {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "content")]
            content: &'a ChatCompletionRequestSystemMessageContent,
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestSystemMessageRole,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let ChatCompletionRequestSystemMessage { content, name } = self;
        _S {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Developer-provided instructions that the model should follow, regardless of\nmessages sent by the user. With o1 models and newer, use `developer` messages\nfor this purpose instead.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestSystemMessage {
    #[doc = "The contents of the system message."]
    pub content: ChatCompletionRequestSystemMessageContent,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestSystemMessageContentPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ChatCompletionRequestMessageContentPartText(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartText,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ChatCompletionRequestMessageContentPartText(_v) => {
                Self::ChatCompletionRequestMessageContentPartText(_v)
            }
        })
    }
}
impl serde::Serialize for ChatCompletionRequestSystemMessageContentPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ChatCompletionRequestMessageContentPartText(
                #[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartText,
            ),
        }
        match self {
            Self::ChatCompletionRequestMessageContentPartText(_v) => {
                _S::ChatCompletionRequestMessageContentPartText(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestSystemMessageContentPart {
    ChatCompletionRequestMessageContentPartText(ChatCompletionRequestMessageContentPartText),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestToolMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestToolMessageContentPart>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionRequestToolMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestToolMessageContentPart>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The contents of the tool message."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestToolMessageContent {
    #[doc = "The contents of the tool message."]
    String(String),
    #[doc = "An array of content parts with a defined type. For tool messages, only type `text` is supported."]
    Array(Vec<ChatCompletionRequestToolMessageContentPart>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestToolMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `tool`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestToolMessageRole {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestToolMessageRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: ChatCompletionRequestToolMessageContent,
            #[serde(rename = "tool_call_id")]
            #[allow(dead_code)]
            tool_call_id: String,
        }
        let _D {
            content,
            tool_call_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestToolMessage {
            content,
            tool_call_id,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestToolMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `tool`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestToolMessageRole {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestToolMessageRole,
            #[serde(rename = "content")]
            content: &'a ChatCompletionRequestToolMessageContent,
            #[serde(rename = "tool_call_id")]
            tool_call_id: &'a String,
        }
        let ChatCompletionRequestToolMessage {
            content,
            tool_call_id,
        } = self;
        _S {
            role: &Default::default(),
            content,
            tool_call_id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestToolMessage {
    #[doc = "The contents of the tool message."]
    pub content: ChatCompletionRequestToolMessageContent,
    #[doc = "Tool call that this message is responding to."]
    pub tool_call_id: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestToolMessageContentPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ChatCompletionRequestMessageContentPartText(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartText,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ChatCompletionRequestMessageContentPartText(_v) => {
                Self::ChatCompletionRequestMessageContentPartText(_v)
            }
        })
    }
}
impl serde::Serialize for ChatCompletionRequestToolMessageContentPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ChatCompletionRequestMessageContentPartText(
                #[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartText,
            ),
        }
        match self {
            Self::ChatCompletionRequestMessageContentPartText(_v) => {
                _S::ChatCompletionRequestMessageContentPartText(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestToolMessageContentPart {
    ChatCompletionRequestMessageContentPartText(ChatCompletionRequestMessageContentPartText),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestUserMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestUserMessageContentPart>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionRequestUserMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestUserMessageContentPart>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The contents of the user message.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestUserMessageContent {
    #[doc = "The text contents of the message."]
    String(String),
    #[doc = "An array of content parts with a defined type. Supported options differ based on the [model](/docs/models) being used to generate the response. Can contain text, image, or audio inputs."]
    Array(Vec<ChatCompletionRequestUserMessageContentPart>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestUserMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `user`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestUserMessageRole {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: ChatCompletionRequestUserMessageContent,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestUserMessageRole,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D { content, name, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionRequestUserMessage { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestUserMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `user`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestUserMessageRole {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "content")]
            content: &'a ChatCompletionRequestUserMessageContent,
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestUserMessageRole,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let ChatCompletionRequestUserMessage { content, name } = self;
        _S {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Messages sent by an end user, containing prompts or additional context\ninformation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestUserMessage {
    #[doc = "The contents of the user message.\n"]
    pub content: ChatCompletionRequestUserMessageContent,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestUserMessageContentPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] ChatCompletionRequestMessageContentPartText),
            ImageUrl(#[allow(dead_code)] ChatCompletionRequestMessageContentPartImage),
            InputAudio(#[allow(dead_code)] ChatCompletionRequestMessageContentPartAudio),
            File(#[allow(dead_code)] ChatCompletionRequestMessageContentPartFile),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_v) => Self::Text(_v),
            _D::ImageUrl(_v) => Self::ImageUrl(_v),
            _D::InputAudio(_v) => Self::InputAudio(_v),
            _D::File(_v) => Self::File(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionRequestUserMessageContentPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartText),
            ImageUrl(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartImage),
            InputAudio(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartAudio),
            File(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartFile),
        }
        match self {
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
            Self::ImageUrl(_v) => _S::ImageUrl(_v).serialize(serializer),
            Self::InputAudio(_v) => _S::InputAudio(_v).serialize(serializer),
            Self::File(_v) => _S::File(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestUserMessageContentPart {
    Text(ChatCompletionRequestMessageContentPartText),
    ImageUrl(ChatCompletionRequestMessageContentPartImage),
    InputAudio(ChatCompletionRequestMessageContentPartAudio),
    File(ChatCompletionRequestMessageContentPartFile),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessageAnnotationUrlCitation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: String,
        }
        let _D {
            end_index,
            start_index,
            url,
            title,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionResponseMessageAnnotationUrlCitation {
            end_index,
            start_index,
            url,
            title,
        })
    }
}
impl serde::Serialize for ChatCompletionResponseMessageAnnotationUrlCitation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "end_index")]
            end_index: &'a u64,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "title")]
            title: &'a String,
        }
        let ChatCompletionResponseMessageAnnotationUrlCitation {
            end_index,
            start_index,
            url,
            title,
        } = self;
        _S {
            end_index,
            start_index,
            url,
            title,
        }
        .serialize(serializer)
    }
}
#[doc = "A URL citation when using web search."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessageAnnotationUrlCitation {
    #[doc = "The index of the last character of the URL citation in the message."]
    pub end_index: u64,
    #[doc = "The index of the first character of the URL citation in the message."]
    pub start_index: u64,
    #[doc = "The URL of the web resource."]
    pub url: String,
    #[doc = "The title of the web resource."]
    pub title: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessageAnnotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the URL citation. Always `url_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionResponseMessageAnnotationType {
            #[default]
            #[serde(rename = "url_citation")]
            UrlCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionResponseMessageAnnotationType,
            #[serde(rename = "url_citation")]
            #[allow(dead_code)]
            url_citation: ChatCompletionResponseMessageAnnotationUrlCitation,
        }
        let _D { url_citation, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionResponseMessageAnnotation { url_citation })
    }
}
impl serde::Serialize for ChatCompletionResponseMessageAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the URL citation. Always `url_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionResponseMessageAnnotationType {
            #[default]
            #[serde(rename = "url_citation")]
            UrlCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionResponseMessageAnnotationType,
            #[serde(rename = "url_citation")]
            url_citation: &'a ChatCompletionResponseMessageAnnotationUrlCitation,
        }
        let ChatCompletionResponseMessageAnnotation { url_citation } = self;
        _S {
            type_: &Default::default(),
            url_citation,
        }
        .serialize(serializer)
    }
}
#[doc = "A URL citation when using web search.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessageAnnotation {
    #[doc = "A URL citation when using web search."]
    pub url_citation: ChatCompletionResponseMessageAnnotationUrlCitation,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessageFunctionCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D {
            arguments, name, ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionResponseMessageFunctionCall { arguments, name })
    }
}
impl serde::Serialize for ChatCompletionResponseMessageFunctionCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ChatCompletionResponseMessageFunctionCall { arguments, name } = self;
        _S { arguments, name }.serialize(serializer)
    }
}
#[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessageFunctionCall {
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    pub arguments: String,
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessageAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: String,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: String,
        }
        let _D {
            id,
            expires_at,
            data,
            transcript,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionResponseMessageAudio {
            id,
            expires_at,
            data,
            transcript,
        })
    }
}
impl serde::Serialize for ChatCompletionResponseMessageAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "transcript")]
            transcript: &'a String,
        }
        let ChatCompletionResponseMessageAudio {
            id,
            expires_at,
            data,
            transcript,
        } = self;
        _S {
            id,
            expires_at,
            data,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessageAudio {
    #[doc = "Unique identifier for this audio response."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when this audio response will\nno longer be accessible on the server for use in multi-turn\nconversations.\n"]
    pub expires_at: u64,
    #[doc = "Base64 encoded audio bytes generated by the model, in the format\nspecified in the request.\n"]
    pub data: String,
    #[doc = "Transcript of the audio generated by the model."]
    pub transcript: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the author of this message."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionResponseMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<String>,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Option<ChatCompletionMessageToolCalls>,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Option<Vec<ChatCompletionResponseMessageAnnotation>>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionResponseMessageRole,
            #[serde(rename = "function_call")]
            #[allow(dead_code)]
            function_call: Option<ChatCompletionResponseMessageFunctionCall>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<ChatCompletionResponseMessageAudio>,
        }
        let _D {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionResponseMessage {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
        })
    }
}
impl serde::Serialize for ChatCompletionResponseMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the author of this message."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionResponseMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<ChatCompletionMessageToolCalls>,
            #[serde(rename = "annotations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            annotations: &'a Option<Vec<ChatCompletionResponseMessageAnnotation>>,
            #[serde(rename = "role")]
            role: &'a ChatCompletionResponseMessageRole,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<ChatCompletionResponseMessageFunctionCall>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<ChatCompletionResponseMessageAudio>,
        }
        let ChatCompletionResponseMessage {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
        } = self;
        _S {
            content,
            refusal,
            tool_calls,
            annotations,
            role: &Default::default(),
            function_call,
            audio,
        }
        .serialize(serializer)
    }
}
#[doc = "A chat completion message generated by the model."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessage {
    #[doc = "The contents of the message."]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "The refusal message generated by the model."]
    #[builder(default)]
    pub refusal: Option<String>,
    #[builder(default)]
    pub tool_calls: Option<ChatCompletionMessageToolCalls>,
    #[doc = "Annotations for the message, when applicable, as when using the\n[web search tool](/docs/guides/tools-web-search?api-mode=chat).\n"]
    #[builder(default)]
    pub annotations: Option<Vec<ChatCompletionResponseMessageAnnotation>>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call: Option<ChatCompletionResponseMessageFunctionCall>,
    #[doc = "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<ChatCompletionResponseMessageAudio>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleTool {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleFunction {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Developer(#[allow(dead_code)] ChatCompletionRoleDeveloper),
            System(#[allow(dead_code)] ChatCompletionRoleSystem),
            User(#[allow(dead_code)] ChatCompletionRoleUser),
            Assistant(#[allow(dead_code)] ChatCompletionRoleAssistant),
            Tool(#[allow(dead_code)] ChatCompletionRoleTool),
            Function(#[allow(dead_code)] ChatCompletionRoleFunction),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Developer(_) => Self::Developer,
            _D::System(_) => Self::System,
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
            _D::Tool(_) => Self::Tool,
            _D::Function(_) => Self::Function,
        })
    }
}
impl serde::Serialize for ChatCompletionRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleTool {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleFunction {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Developer(#[allow(dead_code)] &'a ChatCompletionRoleDeveloper),
            System(#[allow(dead_code)] &'a ChatCompletionRoleSystem),
            User(#[allow(dead_code)] &'a ChatCompletionRoleUser),
            Assistant(#[allow(dead_code)] &'a ChatCompletionRoleAssistant),
            Tool(#[allow(dead_code)] &'a ChatCompletionRoleTool),
            Function(#[allow(dead_code)] &'a ChatCompletionRoleFunction),
        }
        match self {
            Self::Developer => _S::Developer(&Default::default()).serialize(serializer),
            Self::System => _S::System(&Default::default()).serialize(serializer),
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
            Self::Tool => _S::Tool(&Default::default()).serialize(serializer),
            Self::Function => _S::Function(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the author of a message"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRole {
    #[doc = "developer"]
    Developer,
    #[doc = "system"]
    System,
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "tool"]
    Tool,
    #[doc = "function"]
    Function,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionStreamOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "include_usage")]
            #[allow(dead_code)]
            include_usage: Option<bool>,
        }
        let _D { include_usage, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionStreamOptions { include_usage })
    }
}
impl serde::Serialize for ChatCompletionStreamOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "include_usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_usage: &'a Option<bool>,
        }
        let ChatCompletionStreamOptions { include_usage } = self;
        _S { include_usage }.serialize(serializer)
    }
}
#[doc = "Options for streaming response. Only set this when you set `stream: true`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionStreamOptions {
    #[doc = "If set, an additional chunk will be streamed before the `data: [DONE]`\nmessage. The `usage` field on this chunk shows the token usage statistics\nfor the entire request, and the `choices` field will always be an empty\narray. \n\nAll other chunks will also include a `usage` field, but with a null\nvalue. **NOTE:** If the stream is interrupted, you may not receive the\nfinal usage chunk which contains the total token usage for the request.\n"]
    #[builder(default)]
    pub include_usage: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionStreamResponseDeltaFunctionCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let _D {
            arguments, name, ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionStreamResponseDeltaFunctionCall { arguments, name })
    }
}
impl serde::Serialize for ChatCompletionStreamResponseDeltaFunctionCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let ChatCompletionStreamResponseDeltaFunctionCall { arguments, name } = self;
        _S { arguments, name }.serialize(serializer)
    }
}
#[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionStreamResponseDeltaFunctionCall {
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The name of the function to call."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionStreamResponseDeltaRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleTool {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Developer(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleDeveloper),
            System(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleSystem),
            User(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleUser),
            Assistant(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleAssistant),
            Tool(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleTool),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Developer(_) => Self::Developer,
            _D::System(_) => Self::System,
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
            _D::Tool(_) => Self::Tool,
        })
    }
}
impl serde::Serialize for ChatCompletionStreamResponseDeltaRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleTool {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Developer(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleDeveloper),
            System(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleSystem),
            User(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleUser),
            Assistant(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleAssistant),
            Tool(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleTool),
        }
        match self {
            Self::Developer => _S::Developer(&Default::default()).serialize(serializer),
            Self::System => _S::System(&Default::default()).serialize(serializer),
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
            Self::Tool => _S::Tool(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the author of this message."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionStreamResponseDeltaRole {
    #[doc = "developer"]
    Developer,
    #[doc = "system"]
    System,
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "tool"]
    Tool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionStreamResponseDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
            #[serde(rename = "function_call")]
            #[allow(dead_code)]
            function_call: Option<ChatCompletionStreamResponseDeltaFunctionCall>,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Option<Vec<ChatCompletionMessageToolCallChunk>>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<ChatCompletionStreamResponseDeltaRole>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<String>,
        }
        let _D {
            content,
            function_call,
            tool_calls,
            role,
            refusal,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionStreamResponseDelta {
            content,
            function_call,
            tool_calls,
            role,
            refusal,
        })
    }
}
impl serde::Serialize for ChatCompletionStreamResponseDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<ChatCompletionStreamResponseDeltaFunctionCall>,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<Vec<ChatCompletionMessageToolCallChunk>>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<ChatCompletionStreamResponseDeltaRole>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
        }
        let ChatCompletionStreamResponseDelta {
            content,
            function_call,
            tool_calls,
            role,
            refusal,
        } = self;
        _S {
            content,
            function_call,
            tool_calls,
            role,
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "A chat completion delta generated by streamed model responses."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionStreamResponseDelta {
    #[doc = "The contents of the chunk message."]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call: Option<ChatCompletionStreamResponseDeltaFunctionCall>,
    #[builder(default)]
    pub tool_calls: Option<Vec<ChatCompletionMessageToolCallChunk>>,
    #[doc = "The role of the author of this message."]
    #[builder(default)]
    pub role: Option<ChatCompletionStreamResponseDeltaRole>,
    #[doc = "The refusal message generated by the model."]
    #[builder(default)]
    pub refusal: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionTokenLogprobTopLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: String,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: f64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<u64>>,
        }
        let _D {
            token,
            logprob,
            bytes,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionTokenLogprobTopLogprob {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for ChatCompletionTokenLogprobTopLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "token")]
            token: &'a String,
            #[serde(rename = "logprob")]
            logprob: &'a f64,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<u64>>,
        }
        let ChatCompletionTokenLogprobTopLogprob {
            token,
            logprob,
            bytes,
        } = self;
        _S {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionTokenLogprobTopLogprob {
    #[doc = "The token."]
    pub token: String,
    #[doc = "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely."]
    pub logprob: f64,
    #[doc = "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token."]
    #[builder(default)]
    pub bytes: Option<Vec<u64>>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionTokenLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: String,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: f64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<u64>>,
            #[serde(rename = "top_logprobs")]
            #[allow(dead_code)]
            top_logprobs: Vec<ChatCompletionTokenLogprobTopLogprob>,
        }
        let _D {
            token,
            logprob,
            bytes,
            top_logprobs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionTokenLogprob {
            token,
            logprob,
            bytes,
            top_logprobs,
        })
    }
}
impl serde::Serialize for ChatCompletionTokenLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "token")]
            token: &'a String,
            #[serde(rename = "logprob")]
            logprob: &'a f64,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<u64>>,
            #[serde(rename = "top_logprobs")]
            top_logprobs: &'a Vec<ChatCompletionTokenLogprobTopLogprob>,
        }
        let ChatCompletionTokenLogprob {
            token,
            logprob,
            bytes,
            top_logprobs,
        } = self;
        _S {
            token,
            logprob,
            bytes,
            top_logprobs,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionTokenLogprob {
    #[doc = "The token."]
    pub token: String,
    #[doc = "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely."]
    pub logprob: f64,
    #[doc = "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token."]
    #[builder(default)]
    pub bytes: Option<Vec<u64>>,
    #[doc = "List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned."]
    pub top_logprobs: Vec<ChatCompletionTokenLogprobTopLogprob>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionToolType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: FunctionObject,
        }
        let _D { function, .. } = _D::deserialize(deserializer)?;
        Ok(ChatCompletionTool { function })
    }
}
impl serde::Serialize for ChatCompletionTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionToolType,
            #[serde(rename = "function")]
            function: &'a FunctionObject,
        }
        let ChatCompletionTool { function } = self;
        _S {
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionTool {
    pub function: FunctionObject,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionToolChoiceOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            None(#[allow(dead_code)] ChatCompletionToolChoiceOptionNone),
            Auto(#[allow(dead_code)] ChatCompletionToolChoiceOptionAuto),
            Required(#[allow(dead_code)] ChatCompletionToolChoiceOptionRequired),
            ChatCompletionNamedToolChoice(#[allow(dead_code)] ChatCompletionNamedToolChoice),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::None(_) => Self::None,
            _D::Auto(_) => Self::Auto,
            _D::Required(_) => Self::Required,
            _D::ChatCompletionNamedToolChoice(_v) => Self::ChatCompletionNamedToolChoice(_v),
        })
    }
}
impl serde::Serialize for ChatCompletionToolChoiceOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            None(#[allow(dead_code)] &'a ChatCompletionToolChoiceOptionNone),
            Auto(#[allow(dead_code)] &'a ChatCompletionToolChoiceOptionAuto),
            Required(#[allow(dead_code)] &'a ChatCompletionToolChoiceOptionRequired),
            ChatCompletionNamedToolChoice(#[allow(dead_code)] &'a ChatCompletionNamedToolChoice),
        }
        match self {
            Self::None => _S::None(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Required => _S::Required(&Default::default()).serialize(serializer),
            Self::ChatCompletionNamedToolChoice(_v) => {
                _S::ChatCompletionNamedToolChoice(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tool and instead generates a message.\n`auto` means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools.\nSpecifying a particular tool via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n\n`none` is the default when no tools are present. `auto` is the default if tools are present.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionToolChoiceOption {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    #[doc = "required"]
    Required,
    ChatCompletionNamedToolChoice(ChatCompletionNamedToolChoice),
}
impl<'de> serde::Deserialize<'de> for ChunkingStrategyRequestParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] AutoChunkingStrategyRequestParam),
            Static(#[allow(dead_code)] StaticChunkingStrategyRequestParam),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_v) => Self::Auto(_v),
            _D::Static(_v) => Self::Static(_v),
        })
    }
}
impl serde::Serialize for ChunkingStrategyRequestParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a AutoChunkingStrategyRequestParam),
            Static(#[allow(dead_code)] &'a StaticChunkingStrategyRequestParam),
        }
        match self {
            Self::Auto(_v) => _S::Auto(_v).serialize(serializer),
            Self::Static(_v) => _S::Static(_v).serialize(serializer),
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChunkingStrategyRequestParam {
    Auto(AutoChunkingStrategyRequestParam),
    Static(StaticChunkingStrategyRequestParam),
}
impl<'de> serde::Deserialize<'de> for ClickButton {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonLeft {
            #[default]
            #[serde(rename = "left")]
            Left,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonRight {
            #[default]
            #[serde(rename = "right")]
            Right,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonWheel {
            #[default]
            #[serde(rename = "wheel")]
            Wheel,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonBack {
            #[default]
            #[serde(rename = "back")]
            Back,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonForward {
            #[default]
            #[serde(rename = "forward")]
            Forward,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Left(#[allow(dead_code)] ClickButtonLeft),
            Right(#[allow(dead_code)] ClickButtonRight),
            Wheel(#[allow(dead_code)] ClickButtonWheel),
            Back(#[allow(dead_code)] ClickButtonBack),
            Forward(#[allow(dead_code)] ClickButtonForward),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Left(_) => Self::Left,
            _D::Right(_) => Self::Right,
            _D::Wheel(_) => Self::Wheel,
            _D::Back(_) => Self::Back,
            _D::Forward(_) => Self::Forward,
        })
    }
}
impl serde::Serialize for ClickButton {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonLeft {
            #[default]
            #[serde(rename = "left")]
            Left,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonRight {
            #[default]
            #[serde(rename = "right")]
            Right,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonWheel {
            #[default]
            #[serde(rename = "wheel")]
            Wheel,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonBack {
            #[default]
            #[serde(rename = "back")]
            Back,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonForward {
            #[default]
            #[serde(rename = "forward")]
            Forward,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Left(#[allow(dead_code)] &'a ClickButtonLeft),
            Right(#[allow(dead_code)] &'a ClickButtonRight),
            Wheel(#[allow(dead_code)] &'a ClickButtonWheel),
            Back(#[allow(dead_code)] &'a ClickButtonBack),
            Forward(#[allow(dead_code)] &'a ClickButtonForward),
        }
        match self {
            Self::Left => _S::Left(&Default::default()).serialize(serializer),
            Self::Right => _S::Right(&Default::default()).serialize(serializer),
            Self::Wheel => _S::Wheel(&Default::default()).serialize(serializer),
            Self::Back => _S::Back(&Default::default()).serialize(serializer),
            Self::Forward => _S::Forward(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Indicates which mouse button was pressed during the click. One of `left`, `right`, `wheel`, `back`, or `forward`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ClickButton {
    #[doc = "left"]
    Left,
    #[doc = "right"]
    Right,
    #[doc = "wheel"]
    Wheel,
    #[doc = "back"]
    Back,
    #[doc = "forward"]
    Forward,
}
impl<'de> serde::Deserialize<'de> for Click {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a click action, this property is \nalways set to `click`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickType {
            #[default]
            #[serde(rename = "click")]
            Click,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ClickType,
            #[serde(rename = "button")]
            #[allow(dead_code)]
            button: ClickButton,
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
        }
        let _D { button, x, y, .. } = _D::deserialize(deserializer)?;
        Ok(Click { button, x, y })
    }
}
impl serde::Serialize for Click {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a click action, this property is \nalways set to `click`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickType {
            #[default]
            #[serde(rename = "click")]
            Click,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ClickType,
            #[serde(rename = "button")]
            button: &'a ClickButton,
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
        }
        let Click { button, x, y } = self;
        _S {
            type_: &Default::default(),
            button,
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[doc = "A click action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct Click {
    #[doc = "Indicates which mouse button was pressed during the click. One of `left`, `right`, `wheel`, `back`, or `forward`.\n"]
    pub button: ClickButton,
    #[doc = "The x-coordinate where the click occurred.\n"]
    pub x: u64,
    #[doc = "The y-coordinate where the click occurred.\n"]
    pub y: u64,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterFileOutputFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "mime_type")]
            #[allow(dead_code)]
            mime_type: String,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
        }
        let _D {
            mime_type, file_id, ..
        } = _D::deserialize(deserializer)?;
        Ok(CodeInterpreterFileOutputFile { mime_type, file_id })
    }
}
impl serde::Serialize for CodeInterpreterFileOutputFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "mime_type")]
            mime_type: &'a String,
            #[serde(rename = "file_id")]
            file_id: &'a String,
        }
        let CodeInterpreterFileOutputFile { mime_type, file_id } = self;
        _S { mime_type, file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterFileOutputFile {
    #[doc = "The MIME type of the file.\n"]
    pub mime_type: String,
    #[doc = "The ID of the file.\n"]
    pub file_id: String,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterFileOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the code interpreter file output. Always `files`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterFileOutputType {
            #[default]
            #[serde(rename = "files")]
            Files,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CodeInterpreterFileOutputType,
            #[serde(rename = "files")]
            #[allow(dead_code)]
            files: Vec<CodeInterpreterFileOutputFile>,
        }
        let _D { files, .. } = _D::deserialize(deserializer)?;
        Ok(CodeInterpreterFileOutput { files })
    }
}
impl serde::Serialize for CodeInterpreterFileOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the code interpreter file output. Always `files`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterFileOutputType {
            #[default]
            #[serde(rename = "files")]
            Files,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CodeInterpreterFileOutputType,
            #[serde(rename = "files")]
            files: &'a Vec<CodeInterpreterFileOutputFile>,
        }
        let CodeInterpreterFileOutput { files } = self;
        _S {
            type_: &Default::default(),
            files,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a code interpreter tool call that is a file.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterFileOutput {
    pub files: Vec<CodeInterpreterFileOutputFile>,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterTextOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the code interpreter text output. Always `logs`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterTextOutputType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CodeInterpreterTextOutputType,
            #[serde(rename = "logs")]
            #[allow(dead_code)]
            logs: String,
        }
        let _D { logs, .. } = _D::deserialize(deserializer)?;
        Ok(CodeInterpreterTextOutput { logs })
    }
}
impl serde::Serialize for CodeInterpreterTextOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the code interpreter text output. Always `logs`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterTextOutputType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CodeInterpreterTextOutputType,
            #[serde(rename = "logs")]
            logs: &'a String,
        }
        let CodeInterpreterTextOutput { logs } = self;
        _S {
            type_: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a code interpreter tool call that is text.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterTextOutput {
    #[doc = "The logs of the code interpreter tool call.\n"]
    pub logs: String,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusInterpreting {
            #[default]
            #[serde(rename = "interpreting")]
            Interpreting,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] CodeInterpreterToolCallStatusInProgress),
            Interpreting(#[allow(dead_code)] CodeInterpreterToolCallStatusInterpreting),
            Completed(#[allow(dead_code)] CodeInterpreterToolCallStatusCompleted),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Interpreting(_) => Self::Interpreting,
            _D::Completed(_) => Self::Completed,
        })
    }
}
impl serde::Serialize for CodeInterpreterToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusInterpreting {
            #[default]
            #[serde(rename = "interpreting")]
            Interpreting,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a CodeInterpreterToolCallStatusInProgress),
            Interpreting(#[allow(dead_code)] &'a CodeInterpreterToolCallStatusInterpreting),
            Completed(#[allow(dead_code)] &'a CodeInterpreterToolCallStatusCompleted),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Interpreting => _S::Interpreting(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the code interpreter tool call.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CodeInterpreterToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "interpreting"]
    Interpreting,
    #[doc = "completed"]
    Completed,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the code interpreter tool call. Always `code_interpreter_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallType {
            #[default]
            #[serde(rename = "code_interpreter_call")]
            CodeInterpreterCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CodeInterpreterToolCallType,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: CodeInterpreterToolCallStatus,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Vec<CodeInterpreterToolOutput>,
        }
        let _D {
            id,
            code,
            status,
            results,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CodeInterpreterToolCall {
            id,
            code,
            status,
            results,
        })
    }
}
impl serde::Serialize for CodeInterpreterToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the code interpreter tool call. Always `code_interpreter_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallType {
            #[default]
            #[serde(rename = "code_interpreter_call")]
            CodeInterpreterCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a CodeInterpreterToolCallType,
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "status")]
            status: &'a CodeInterpreterToolCallStatus,
            #[serde(rename = "results")]
            results: &'a Vec<CodeInterpreterToolOutput>,
        }
        let CodeInterpreterToolCall {
            id,
            code,
            status,
            results,
        } = self;
        _S {
            id,
            type_: &Default::default(),
            code,
            status,
            results,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool call to run code.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterToolCall {
    #[doc = "The unique ID of the code interpreter tool call.\n"]
    pub id: String,
    #[doc = "The code to run.\n"]
    pub code: String,
    #[doc = "The status of the code interpreter tool call.\n"]
    pub status: CodeInterpreterToolCallStatus,
    #[doc = "The results of the code interpreter tool call.\n"]
    pub results: Vec<CodeInterpreterToolOutput>,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Logs(#[allow(dead_code)] CodeInterpreterTextOutput),
            Files(#[allow(dead_code)] CodeInterpreterFileOutput),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Logs(_v) => Self::Logs(_v),
            _D::Files(_v) => Self::Files(_v),
        })
    }
}
impl serde::Serialize for CodeInterpreterToolOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Logs(#[allow(dead_code)] &'a CodeInterpreterTextOutput),
            Files(#[allow(dead_code)] &'a CodeInterpreterFileOutput),
        }
        match self {
            Self::Logs(_v) => _S::Logs(_v).serialize(serializer),
            Self::Files(_v) => _S::Files(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CodeInterpreterToolOutput {
    Logs(CodeInterpreterTextOutput),
    Files(CodeInterpreterFileOutput),
}
impl<'de> serde::Deserialize<'de> for ComparisonFilterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeEq {
            #[default]
            #[serde(rename = "eq")]
            Eq,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeNe {
            #[default]
            #[serde(rename = "ne")]
            Ne,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeGt {
            #[default]
            #[serde(rename = "gt")]
            Gt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeGte {
            #[default]
            #[serde(rename = "gte")]
            Gte,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeLt {
            #[default]
            #[serde(rename = "lt")]
            Lt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeLte {
            #[default]
            #[serde(rename = "lte")]
            Lte,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Eq(#[allow(dead_code)] ComparisonFilterTypeEq),
            Ne(#[allow(dead_code)] ComparisonFilterTypeNe),
            Gt(#[allow(dead_code)] ComparisonFilterTypeGt),
            Gte(#[allow(dead_code)] ComparisonFilterTypeGte),
            Lt(#[allow(dead_code)] ComparisonFilterTypeLt),
            Lte(#[allow(dead_code)] ComparisonFilterTypeLte),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Eq(_) => Self::Eq,
            _D::Ne(_) => Self::Ne,
            _D::Gt(_) => Self::Gt,
            _D::Gte(_) => Self::Gte,
            _D::Lt(_) => Self::Lt,
            _D::Lte(_) => Self::Lte,
        })
    }
}
impl serde::Serialize for ComparisonFilterType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeEq {
            #[default]
            #[serde(rename = "eq")]
            Eq,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeNe {
            #[default]
            #[serde(rename = "ne")]
            Ne,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeGt {
            #[default]
            #[serde(rename = "gt")]
            Gt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeGte {
            #[default]
            #[serde(rename = "gte")]
            Gte,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeLt {
            #[default]
            #[serde(rename = "lt")]
            Lt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeLte {
            #[default]
            #[serde(rename = "lte")]
            Lte,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Eq(#[allow(dead_code)] &'a ComparisonFilterTypeEq),
            Ne(#[allow(dead_code)] &'a ComparisonFilterTypeNe),
            Gt(#[allow(dead_code)] &'a ComparisonFilterTypeGt),
            Gte(#[allow(dead_code)] &'a ComparisonFilterTypeGte),
            Lt(#[allow(dead_code)] &'a ComparisonFilterTypeLt),
            Lte(#[allow(dead_code)] &'a ComparisonFilterTypeLte),
        }
        match self {
            Self::Eq => _S::Eq(&Default::default()).serialize(serializer),
            Self::Ne => _S::Ne(&Default::default()).serialize(serializer),
            Self::Gt => _S::Gt(&Default::default()).serialize(serializer),
            Self::Gte => _S::Gte(&Default::default()).serialize(serializer),
            Self::Lt => _S::Lt(&Default::default()).serialize(serializer),
            Self::Lte => _S::Lte(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ComparisonFilterType {
    #[doc = "eq"]
    #[default]
    Eq,
    #[doc = "ne"]
    Ne,
    #[doc = "gt"]
    Gt,
    #[doc = "gte"]
    Gte,
    #[doc = "lt"]
    Lt,
    #[doc = "lte"]
    Lte,
}
impl<'de> serde::Deserialize<'de> for ComparisonFilterValue {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Float(#[allow(dead_code)] f64),
            Bool(#[allow(dead_code)] bool),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Float(_v) => Self::Float(_v),
            _D::Bool(_v) => Self::Bool(_v),
        })
    }
}
impl serde::Serialize for ComparisonFilterValue {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Float(#[allow(dead_code)] &'a f64),
            Bool(#[allow(dead_code)] &'a bool),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Float(_v) => _S::Float(_v).serialize(serializer),
            Self::Bool(_v) => _S::Bool(_v).serialize(serializer),
        }
    }
}
#[doc = "The value to compare against the attribute key; supports string, number, or boolean types."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ComparisonFilterValue {
    String(String),
    Float(f64),
    Bool(bool),
}
impl<'de> serde::Deserialize<'de> for ComparisonFilter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComparisonFilterType,
            #[serde(rename = "key")]
            #[allow(dead_code)]
            key: String,
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: ComparisonFilterValue,
        }
        let _D {
            type_, key, value, ..
        } = _D::deserialize(deserializer)?;
        Ok(ComparisonFilter { type_, key, value })
    }
}
impl serde::Serialize for ComparisonFilter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ComparisonFilterType,
            #[serde(rename = "key")]
            key: &'a String,
            #[serde(rename = "value")]
            value: &'a ComparisonFilterValue,
        }
        let ComparisonFilter { type_, key, value } = self;
        _S { type_, key, value }.serialize(serializer)
    }
}
#[doc = "A filter used to compare a specified attribute key to a given value using a defined comparison operation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComparisonFilter {
    #[doc = "Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n"]
    #[builder(default)]
    pub type_: ComparisonFilterType,
    #[doc = "The key to compare against the value."]
    pub key: String,
    #[doc = "The value to compare against the attribute key; supports string, number, or boolean types."]
    pub value: ComparisonFilterValue,
}
impl<'de> serde::Deserialize<'de> for CompleteUploadRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "part_ids")]
            #[allow(dead_code)]
            part_ids: Vec<String>,
            #[serde(rename = "md5")]
            #[allow(dead_code)]
            md5: Option<String>,
        }
        let _D { part_ids, md5, .. } = _D::deserialize(deserializer)?;
        Ok(CompleteUploadRequest { part_ids, md5 })
    }
}
impl serde::Serialize for CompleteUploadRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "part_ids")]
            part_ids: &'a Vec<String>,
            #[serde(rename = "md5")]
            #[serde(skip_serializing_if = "Option::is_none")]
            md5: &'a Option<String>,
        }
        let CompleteUploadRequest { part_ids, md5 } = self;
        _S { part_ids, md5 }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CompleteUploadRequest {
    #[doc = "The ordered list of Part IDs.\n"]
    pub part_ids: Vec<String>,
    #[doc = "The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect.\n"]
    #[builder(default)]
    pub md5: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CompletionUsageCompletionTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "accepted_prediction_tokens")]
            #[allow(dead_code)]
            accepted_prediction_tokens: Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[allow(dead_code)]
            audio_tokens: Option<u64>,
            #[serde(rename = "reasoning_tokens")]
            #[allow(dead_code)]
            reasoning_tokens: Option<u64>,
            #[serde(rename = "rejected_prediction_tokens")]
            #[allow(dead_code)]
            rejected_prediction_tokens: Option<u64>,
        }
        let _D {
            accepted_prediction_tokens,
            audio_tokens,
            reasoning_tokens,
            rejected_prediction_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CompletionUsageCompletionTokensDetails {
            accepted_prediction_tokens,
            audio_tokens,
            reasoning_tokens,
            rejected_prediction_tokens,
        })
    }
}
impl serde::Serialize for CompletionUsageCompletionTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "accepted_prediction_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            accepted_prediction_tokens: &'a Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio_tokens: &'a Option<u64>,
            #[serde(rename = "reasoning_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_tokens: &'a Option<u64>,
            #[serde(rename = "rejected_prediction_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            rejected_prediction_tokens: &'a Option<u64>,
        }
        let CompletionUsageCompletionTokensDetails {
            accepted_prediction_tokens,
            audio_tokens,
            reasoning_tokens,
            rejected_prediction_tokens,
        } = self;
        _S {
            accepted_prediction_tokens,
            audio_tokens,
            reasoning_tokens,
            rejected_prediction_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Breakdown of tokens used in a completion."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CompletionUsageCompletionTokensDetails {
    #[doc = "When using Predicted Outputs, the number of tokens in the\nprediction that appeared in the completion.\n"]
    #[builder(default)]
    pub accepted_prediction_tokens: Option<u64>,
    #[doc = "Audio input tokens generated by the model."]
    #[builder(default)]
    pub audio_tokens: Option<u64>,
    #[doc = "Tokens generated by the model for reasoning."]
    #[builder(default)]
    pub reasoning_tokens: Option<u64>,
    #[doc = "When using Predicted Outputs, the number of tokens in the\nprediction that did not appear in the completion. However, like\nreasoning tokens, these tokens are still counted in the total\ncompletion tokens for purposes of billing, output, and context window\nlimits.\n"]
    #[builder(default)]
    pub rejected_prediction_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for CompletionUsagePromptTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "audio_tokens")]
            #[allow(dead_code)]
            audio_tokens: Option<u64>,
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: Option<u64>,
        }
        let _D {
            audio_tokens,
            cached_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CompletionUsagePromptTokensDetails {
            audio_tokens,
            cached_tokens,
        })
    }
}
impl serde::Serialize for CompletionUsagePromptTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio_tokens: &'a Option<u64>,
            #[serde(rename = "cached_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cached_tokens: &'a Option<u64>,
        }
        let CompletionUsagePromptTokensDetails {
            audio_tokens,
            cached_tokens,
        } = self;
        _S {
            audio_tokens,
            cached_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Breakdown of tokens used in the prompt."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CompletionUsagePromptTokensDetails {
    #[doc = "Audio input tokens present in the prompt."]
    #[builder(default)]
    pub audio_tokens: Option<u64>,
    #[doc = "Cached tokens present in the prompt."]
    #[builder(default)]
    pub cached_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for CompletionUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
            #[serde(rename = "completion_tokens_details")]
            #[allow(dead_code)]
            completion_tokens_details: Option<CompletionUsageCompletionTokensDetails>,
            #[serde(rename = "prompt_tokens_details")]
            #[allow(dead_code)]
            prompt_tokens_details: Option<CompletionUsagePromptTokensDetails>,
        }
        let _D {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            completion_tokens_details,
            prompt_tokens_details,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            completion_tokens_details,
            prompt_tokens_details,
        })
    }
}
impl serde::Serialize for CompletionUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
            #[serde(rename = "completion_tokens_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completion_tokens_details: &'a Option<CompletionUsageCompletionTokensDetails>,
            #[serde(rename = "prompt_tokens_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt_tokens_details: &'a Option<CompletionUsagePromptTokensDetails>,
        }
        let CompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            completion_tokens_details,
            prompt_tokens_details,
        } = self;
        _S {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            completion_tokens_details,
            prompt_tokens_details,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics for the completion request."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CompletionUsage {
    #[doc = "Number of tokens in the generated completion."]
    pub completion_tokens: u64,
    #[doc = "Number of tokens in the prompt."]
    pub prompt_tokens: u64,
    #[doc = "Total number of tokens used in the request (prompt + completion)."]
    pub total_tokens: u64,
    #[doc = "Breakdown of tokens used in a completion."]
    #[builder(default)]
    pub completion_tokens_details: Option<CompletionUsageCompletionTokensDetails>,
    #[doc = "Breakdown of tokens used in the prompt."]
    #[builder(default)]
    pub prompt_tokens_details: Option<CompletionUsagePromptTokensDetails>,
}
impl<'de> serde::Deserialize<'de> for CompoundFilterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CompoundFilterTypeAnd {
            #[default]
            #[serde(rename = "and")]
            And,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CompoundFilterTypeOr {
            #[default]
            #[serde(rename = "or")]
            Or,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            And(#[allow(dead_code)] CompoundFilterTypeAnd),
            Or(#[allow(dead_code)] CompoundFilterTypeOr),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::And(_) => Self::And,
            _D::Or(_) => Self::Or,
        })
    }
}
impl serde::Serialize for CompoundFilterType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CompoundFilterTypeAnd {
            #[default]
            #[serde(rename = "and")]
            And,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CompoundFilterTypeOr {
            #[default]
            #[serde(rename = "or")]
            Or,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            And(#[allow(dead_code)] &'a CompoundFilterTypeAnd),
            Or(#[allow(dead_code)] &'a CompoundFilterTypeOr),
        }
        match self {
            Self::And => _S::And(&Default::default()).serialize(serializer),
            Self::Or => _S::Or(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Type of operation: `and` or `or`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CompoundFilterType {
    #[doc = "and"]
    And,
    #[doc = "or"]
    Or,
}
impl<'de> serde::Deserialize<'de> for CompoundFilterFilter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ComparisonFilter(#[allow(dead_code)] ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] CompoundFilter),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ComparisonFilter(_v) => Self::ComparisonFilter(_v),
            _D::CompoundFilter(_v) => Self::CompoundFilter(_v),
        })
    }
}
impl serde::Serialize for CompoundFilterFilter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ComparisonFilter(#[allow(dead_code)] &'a ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] &'a CompoundFilter),
        }
        match self {
            Self::ComparisonFilter(_v) => _S::ComparisonFilter(_v).serialize(serializer),
            Self::CompoundFilter(_v) => _S::CompoundFilter(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CompoundFilterFilter {
    ComparisonFilter(ComparisonFilter),
    CompoundFilter(CompoundFilter),
}
impl<'de> serde::Deserialize<'de> for CompoundFilter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CompoundFilterType,
            #[serde(rename = "filters")]
            #[allow(dead_code)]
            filters: Vec<CompoundFilterFilter>,
        }
        let _D { type_, filters, .. } = _D::deserialize(deserializer)?;
        Ok(CompoundFilter { type_, filters })
    }
}
impl serde::Serialize for CompoundFilter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CompoundFilterType,
            #[serde(rename = "filters")]
            filters: &'a Vec<CompoundFilterFilter>,
        }
        let CompoundFilter { type_, filters } = self;
        _S { type_, filters }.serialize(serializer)
    }
}
#[doc = "Combine multiple filters using `and` or `or`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CompoundFilter {
    #[doc = "Type of operation: `and` or `or`."]
    pub type_: CompoundFilterType,
    #[doc = "Array of filters to combine. Items can be `ComparisonFilter` or `CompoundFilter`."]
    pub filters: Vec<CompoundFilterFilter>,
}
impl<'de> serde::Deserialize<'de> for ComputerAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Click(#[allow(dead_code)] Click),
            DoubleClick(#[allow(dead_code)] DoubleClick),
            Drag(#[allow(dead_code)] Drag),
            Keypress(#[allow(dead_code)] KeyPress),
            Move(#[allow(dead_code)] Move),
            Screenshot(#[allow(dead_code)] Screenshot),
            Scroll(#[allow(dead_code)] Scroll),
            Type(#[allow(dead_code)] Type),
            Wait(#[allow(dead_code)] Wait),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Click(_v) => Self::Click(_v),
            _D::DoubleClick(_v) => Self::DoubleClick(_v),
            _D::Drag(_v) => Self::Drag(_v),
            _D::Keypress(_v) => Self::Keypress(_v),
            _D::Move(_v) => Self::Move(_v),
            _D::Screenshot(_v) => Self::Screenshot(_v),
            _D::Scroll(_v) => Self::Scroll(_v),
            _D::Type(_v) => Self::Type(_v),
            _D::Wait(_v) => Self::Wait(_v),
        })
    }
}
impl serde::Serialize for ComputerAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Click(#[allow(dead_code)] &'a Click),
            DoubleClick(#[allow(dead_code)] &'a DoubleClick),
            Drag(#[allow(dead_code)] &'a Drag),
            Keypress(#[allow(dead_code)] &'a KeyPress),
            Move(#[allow(dead_code)] &'a Move),
            Screenshot(#[allow(dead_code)] &'a Screenshot),
            Scroll(#[allow(dead_code)] &'a Scroll),
            Type(#[allow(dead_code)] &'a Type),
            Wait(#[allow(dead_code)] &'a Wait),
        }
        match self {
            Self::Click(_v) => _S::Click(_v).serialize(serializer),
            Self::DoubleClick(_v) => _S::DoubleClick(_v).serialize(serializer),
            Self::Drag(_v) => _S::Drag(_v).serialize(serializer),
            Self::Keypress(_v) => _S::Keypress(_v).serialize(serializer),
            Self::Move(_v) => _S::Move(_v).serialize(serializer),
            Self::Screenshot(_v) => _S::Screenshot(_v).serialize(serializer),
            Self::Scroll(_v) => _S::Scroll(_v).serialize(serializer),
            Self::Type(_v) => _S::Type(_v).serialize(serializer),
            Self::Wait(_v) => _S::Wait(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerAction {
    Click(Click),
    DoubleClick(DoubleClick),
    Drag(Drag),
    Keypress(KeyPress),
    Move(Move),
    Screenshot(Screenshot),
    Scroll(Scroll),
    Type(Type),
    Wait(Wait),
}
impl<'de> serde::Deserialize<'de> for ComputerScreenshotImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a computer screenshot, this property is \nalways set to `computer_screenshot`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerScreenshotImageType {
            #[default]
            #[serde(rename = "computer_screenshot")]
            ComputerScreenshot,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerScreenshotImageType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: Option<String>,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let _D {
            image_url, file_id, ..
        } = _D::deserialize(deserializer)?;
        Ok(ComputerScreenshotImage { image_url, file_id })
    }
}
impl serde::Serialize for ComputerScreenshotImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a computer screenshot, this property is \nalways set to `computer_screenshot`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerScreenshotImageType {
            #[default]
            #[serde(rename = "computer_screenshot")]
            ComputerScreenshot,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ComputerScreenshotImageType,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let ComputerScreenshotImage { image_url, file_id } = self;
        _S {
            type_: &Default::default(),
            image_url,
            file_id,
        }
        .serialize(serializer)
    }
}
#[doc = "A computer screenshot image used with the computer use tool.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ComputerScreenshotImage {
    #[doc = "The URL of the screenshot image."]
    #[builder(default)]
    pub image_url: Option<String>,
    #[doc = "The identifier of an uploaded file that contains the screenshot."]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] ComputerToolCallStatusInProgress),
            Completed(#[allow(dead_code)] ComputerToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] ComputerToolCallStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for ComputerToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a ComputerToolCallStatusInProgress),
            Completed(#[allow(dead_code)] &'a ComputerToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a ComputerToolCallStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the computer call. Always `computer_call`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallType {
            #[default]
            #[serde(rename = "computer_call")]
            ComputerCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerToolCallType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "action")]
            #[allow(dead_code)]
            action: ComputerAction,
            #[serde(rename = "pending_safety_checks")]
            #[allow(dead_code)]
            pending_safety_checks: Vec<ComputerToolCallSafetyCheck>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: ComputerToolCallStatus,
        }
        let _D {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ComputerToolCall {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        })
    }
}
impl serde::Serialize for ComputerToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the computer call. Always `computer_call`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallType {
            #[default]
            #[serde(rename = "computer_call")]
            ComputerCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ComputerToolCallType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "action")]
            action: &'a ComputerAction,
            #[serde(rename = "pending_safety_checks")]
            pending_safety_checks: &'a Vec<ComputerToolCallSafetyCheck>,
            #[serde(rename = "status")]
            status: &'a ComputerToolCallStatus,
        }
        let ComputerToolCall {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        } = self;
        _S {
            type_: &Default::default(),
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool call to a computer use tool. See the \n[computer use guide](/docs/guides/tools-computer-use) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCall {
    #[doc = "The unique ID of the computer call."]
    pub id: String,
    #[doc = "An identifier used when responding to the tool call with output.\n"]
    pub call_id: String,
    pub action: ComputerAction,
    #[doc = "The pending safety checks for the computer call.\n"]
    pub pending_safety_checks: Vec<ComputerToolCallSafetyCheck>,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    pub status: ComputerToolCallStatus,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallOutputStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] ComputerToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] ComputerToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] ComputerToolCallOutputStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for ComputerToolCallOutputStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a ComputerToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] &'a ComputerToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a ComputerToolCallOutputStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerToolCallOutputStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the computer tool call output. Always `computer_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputType {
            #[default]
            #[serde(rename = "computer_call_output")]
            ComputerCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerToolCallOutputType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "acknowledged_safety_checks")]
            #[allow(dead_code)]
            acknowledged_safety_checks: Option<Vec<ComputerToolCallSafetyCheck>>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: ComputerScreenshotImage,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<ComputerToolCallOutputStatus>,
        }
        let _D {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ComputerToolCallOutput {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        })
    }
}
impl serde::Serialize for ComputerToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the computer tool call output. Always `computer_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputType {
            #[default]
            #[serde(rename = "computer_call_output")]
            ComputerCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ComputerToolCallOutputType,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "acknowledged_safety_checks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            acknowledged_safety_checks: &'a Option<Vec<ComputerToolCallSafetyCheck>>,
            #[serde(rename = "output")]
            output: &'a ComputerScreenshotImage,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<ComputerToolCallOutputStatus>,
        }
        let ComputerToolCallOutput {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        } = self;
        _S {
            type_: &Default::default(),
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a computer tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallOutput {
    #[doc = "The ID of the computer tool call output.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The ID of the computer tool call that produced the output.\n"]
    pub call_id: String,
    #[doc = "The safety checks reported by the API that have been acknowledged by the \ndeveloper.\n"]
    #[builder(default)]
    pub acknowledged_safety_checks: Option<Vec<ComputerToolCallSafetyCheck>>,
    #[builder(default)]
    pub output: ComputerScreenshotImage,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<ComputerToolCallOutputStatus>,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallOutputResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(flatten)]
            #[allow(dead_code)]
            computer_tool_call_output: ComputerToolCallOutput,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D {
            computer_tool_call_output,
            id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ComputerToolCallOutputResource {
            computer_tool_call_output,
            id,
        })
    }
}
impl serde::Serialize for ComputerToolCallOutputResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(flatten)]
            computer_tool_call_output: &'a ComputerToolCallOutput,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let ComputerToolCallOutputResource {
            computer_tool_call_output,
            id,
        } = self;
        _S {
            computer_tool_call_output,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallOutputResource {
    pub computer_tool_call_output: ComputerToolCallOutput,
    #[doc = "The unique ID of the computer call tool output.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallSafetyCheck {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let _D {
            id, code, message, ..
        } = _D::deserialize(deserializer)?;
        Ok(ComputerToolCallSafetyCheck { id, code, message })
    }
}
impl serde::Serialize for ComputerToolCallSafetyCheck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let ComputerToolCallSafetyCheck { id, code, message } = self;
        _S { id, code, message }.serialize(serializer)
    }
}
#[doc = "A pending safety check for the computer call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallSafetyCheck {
    #[doc = "The ID of the pending safety check."]
    pub id: String,
    #[doc = "The type of the pending safety check."]
    pub code: String,
    #[doc = "Details about the pending safety check."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for Content {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InputContent(#[allow(dead_code)] InputContent),
            OutputContent(#[allow(dead_code)] OutputContent),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InputContent(_v) => Self::InputContent(_v),
            _D::OutputContent(_v) => Self::OutputContent(_v),
        })
    }
}
impl serde::Serialize for Content {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InputContent(#[allow(dead_code)] &'a InputContent),
            OutputContent(#[allow(dead_code)] &'a OutputContent),
        }
        match self {
            Self::InputContent(_v) => _S::InputContent(_v).serialize(serializer),
            Self::OutputContent(_v) => _S::OutputContent(_v).serialize(serializer),
        }
    }
}
#[doc = "Multi-modal input and output contents.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Content {
    InputContent(InputContent),
    OutputContent(OutputContent),
}
impl<'de> serde::Deserialize<'de> for Coordinate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
        }
        let _D { x, y, .. } = _D::deserialize(deserializer)?;
        Ok(Coordinate { x, y })
    }
}
impl serde::Serialize for Coordinate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
        }
        let Coordinate { x, y } = self;
        _S { x, y }.serialize(serializer)
    }
}
#[doc = "An x/y coordinate pair, e.g. `{ x: 100, y: 200 }`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct Coordinate {
    #[doc = "The x-coordinate.\n"]
    pub x: u64,
    #[doc = "The y-coordinate.\n"]
    pub y: u64,
}
impl<'de> serde::Deserialize<'de> for CostsResultAmount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: Option<f64>,
            #[serde(rename = "currency")]
            #[allow(dead_code)]
            currency: Option<String>,
        }
        let _D {
            value, currency, ..
        } = _D::deserialize(deserializer)?;
        Ok(CostsResultAmount { value, currency })
    }
}
impl serde::Serialize for CostsResultAmount {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            value: &'a Option<f64>,
            #[serde(rename = "currency")]
            #[serde(skip_serializing_if = "Option::is_none")]
            currency: &'a Option<String>,
        }
        let CostsResultAmount { value, currency } = self;
        _S { value, currency }.serialize(serializer)
    }
}
#[doc = "The monetary value in its associated currency."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CostsResultAmount {
    #[doc = "The numeric value of the cost."]
    #[builder(default)]
    pub value: Option<f64>,
    #[doc = "Lowercase ISO-4217 currency e.g. \"usd\""]
    #[builder(default)]
    pub currency: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CostsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CostsResultObject {
            #[default]
            #[serde(rename = "organization.costs.result")]
            OrganizationCostsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CostsResultObject,
            #[serde(rename = "amount")]
            #[allow(dead_code)]
            amount: Option<CostsResultAmount>,
            #[serde(rename = "line_item")]
            #[allow(dead_code)]
            line_item: Option<String>,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
        }
        let _D {
            amount,
            line_item,
            project_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CostsResult {
            amount,
            line_item,
            project_id,
        })
    }
}
impl serde::Serialize for CostsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CostsResultObject {
            #[default]
            #[serde(rename = "organization.costs.result")]
            OrganizationCostsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a CostsResultObject,
            #[serde(rename = "amount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            amount: &'a Option<CostsResultAmount>,
            #[serde(rename = "line_item")]
            #[serde(skip_serializing_if = "Option::is_none")]
            line_item: &'a Option<String>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
        }
        let CostsResult {
            amount,
            line_item,
            project_id,
        } = self;
        _S {
            object: &Default::default(),
            amount,
            line_item,
            project_id,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated costs details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CostsResult {
    #[doc = "The monetary value in its associated currency."]
    #[builder(default)]
    pub amount: Option<CostsResultAmount>,
    #[doc = "When `group_by=line_item`, this field provides the line item of the grouped costs result."]
    #[builder(default)]
    pub line_item: Option<String>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped costs result."]
    #[builder(default)]
    pub project_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearch),
            Function(#[allow(dead_code)] AssistantToolsFunction),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for CreateAssistantRequestTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearch),
            Function(#[allow(dead_code)] &'a AssistantToolsFunction),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateAssistantRequestTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearch),
    Function(AssistantToolsFunction),
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let _D { file_ids, .. } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequestToolResourcesCodeInterpreter { file_ids })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let CreateAssistantRequestToolResourcesCodeInterpreter { file_ids } = self;
        _S { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_:
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {})
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S < 'a > { # [serde (rename = "type")] type_ : & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType }
        let CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let _D {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
                max_chunk_size_tokens,
                chunk_overlap_tokens,
            },
        )
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        _S {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D { # [serde (rename = "type")] # [allow (dead_code)] type_ : CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] # [allow (dead_code)] static_ : CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic }
        let _D { static_, .. } = _D::deserialize(deserializer)?;
        Ok(
            CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
                static_,
            },
        )
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S < 'a > { # [serde (rename = "type")] type_ : & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] static_ : & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic }
        let CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
            static_,
        } = self;
        _S {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
    pub static_:
        CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(
                #[allow(dead_code)]
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_v) => Self::Auto(_v),
            _D::Static(_v) => Self::Static(_v),
        })
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto (# [allow (dead_code)] & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto) , Static (# [allow (dead_code)] & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic) }
        match self {
            Self::Auto(_v) => _S::Auto(_v).serialize(serializer),
            Self::Static(_v) => _S::Static(_v).serialize(serializer),
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy {
    #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
    Auto(CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto),
    Static(CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic),
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch0VectorStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy:
                Option<CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            file_ids,
            chunking_strategy,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequestToolResourcesFileSearch0VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch0VectorStore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy,
            >,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let CreateAssistantRequestToolResourcesFileSearch0VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        } = self;
        _S {
            file_ids,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0VectorStore {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
    #[builder(default)]
    pub chunking_strategy:
        Option<CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch0 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Vec<String>,
            #[serde(rename = "vector_stores")]
            #[allow(dead_code)]
            vector_stores: Option<Vec<CreateAssistantRequestToolResourcesFileSearch0VectorStore>>,
        }
        let _D {
            vector_store_ids,
            vector_stores,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequestToolResourcesFileSearch0 {
            vector_store_ids,
            vector_stores,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            vector_store_ids: &'a Vec<String>,
            #[serde(rename = "vector_stores")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_stores:
                &'a Option<Vec<CreateAssistantRequestToolResourcesFileSearch0VectorStore>>,
        }
        let CreateAssistantRequestToolResourcesFileSearch0 {
            vector_store_ids,
            vector_stores,
        } = self;
        _S {
            vector_store_ids,
            vector_stores,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0 {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    pub vector_store_ids: Vec<String>,
    #[doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_stores: Option<Vec<CreateAssistantRequestToolResourcesFileSearch0VectorStore>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_:
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {})
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S < 'a > { # [serde (rename = "type")] type_ : & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType }
        let CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let _D {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
                max_chunk_size_tokens,
                chunk_overlap_tokens,
            },
        )
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        _S {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D { # [serde (rename = "type")] # [allow (dead_code)] type_ : CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] # [allow (dead_code)] static_ : CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic }
        let _D { static_, .. } = _D::deserialize(deserializer)?;
        Ok(
            CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
                static_,
            },
        )
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S < 'a > { # [serde (rename = "type")] type_ : & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] static_ : & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic }
        let CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
            static_,
        } = self;
        _S {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
    pub static_:
        CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(
                #[allow(dead_code)]
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_v) => Self::Auto(_v),
            _D::Static(_v) => Self::Static(_v),
        })
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto (# [allow (dead_code)] & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto) , Static (# [allow (dead_code)] & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic) }
        match self {
            Self::Auto(_v) => _S::Auto(_v).serialize(serializer),
            Self::Static(_v) => _S::Static(_v).serialize(serializer),
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy {
    #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
    Auto(CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto),
    Static(CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic),
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch1VectorStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy:
                Option<CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            file_ids,
            chunking_strategy,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequestToolResourcesFileSearch1VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch1VectorStore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy,
            >,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let CreateAssistantRequestToolResourcesFileSearch1VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        } = self;
        _S {
            file_ids,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1VectorStore {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
    #[builder(default)]
    pub chunking_strategy:
        Option<CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
            #[serde(rename = "vector_stores")]
            #[allow(dead_code)]
            vector_stores: Vec<CreateAssistantRequestToolResourcesFileSearch1VectorStore>,
        }
        let _D {
            vector_store_ids,
            vector_stores,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequestToolResourcesFileSearch1 {
            vector_store_ids,
            vector_stores,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch1 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
            #[serde(rename = "vector_stores")]
            vector_stores: &'a Vec<CreateAssistantRequestToolResourcesFileSearch1VectorStore>,
        }
        let CreateAssistantRequestToolResourcesFileSearch1 {
            vector_store_ids,
            vector_stores,
        } = self;
        _S {
            vector_store_ids,
            vector_stores,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1 {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
    #[doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    pub vector_stores: Vec<CreateAssistantRequestToolResourcesFileSearch1VectorStore>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            _0(#[allow(dead_code)] CreateAssistantRequestToolResourcesFileSearch0),
            _1(#[allow(dead_code)] CreateAssistantRequestToolResourcesFileSearch1),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::_0(_v) => Self::_0(_v),
            _D::_1(_v) => Self::_1(_v),
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            _0(#[allow(dead_code)] &'a CreateAssistantRequestToolResourcesFileSearch0),
            _1(#[allow(dead_code)] &'a CreateAssistantRequestToolResourcesFileSearch1),
        }
        match self {
            Self::_0(_v) => _S::_0(_v).serialize(serializer),
            Self::_1(_v) => _S::_1(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateAssistantRequestToolResourcesFileSearch {
    _0(CreateAssistantRequestToolResourcesFileSearch0),
    _1(CreateAssistantRequestToolResourcesFileSearch1),
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<CreateAssistantRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<CreateAssistantRequestToolResourcesFileSearch>,
        }
        let _D {
            code_interpreter,
            file_search,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequestToolResources {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<CreateAssistantRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<CreateAssistantRequestToolResourcesFileSearch>,
        }
        let CreateAssistantRequestToolResources {
            code_interpreter,
            file_search,
        } = self;
        _S {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<CreateAssistantRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<CreateAssistantRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<CreateAssistantRequestTool>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<CreateAssistantRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let _D {
            model,
            name,
            description,
            instructions,
            reasoning_effort,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateAssistantRequest {
            model,
            name,
            description,
            instructions,
            reasoning_effort,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        })
    }
}
impl serde::Serialize for CreateAssistantRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<CreateAssistantRequestTool>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<CreateAssistantRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let CreateAssistantRequest {
            model,
            name,
            description,
            instructions,
            reasoning_effort,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        } = self;
        _S {
            model,
            name,
            description,
            instructions,
            reasoning_effort,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    #[builder(default)]
    pub tools: Option<Vec<CreateAssistantRequestTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<CreateAssistantRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestWebSearchOptionsUserLocation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of location approximation. Always `approximate`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestWebSearchOptionsUserLocationType {
            #[default]
            #[serde(rename = "approximate")]
            Approximate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateChatCompletionRequestWebSearchOptionsUserLocationType,
            #[serde(rename = "approximate")]
            #[allow(dead_code)]
            approximate: WebSearchLocation,
        }
        let _D { approximate, .. } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionRequestWebSearchOptionsUserLocation { approximate })
    }
}
impl serde::Serialize for CreateChatCompletionRequestWebSearchOptionsUserLocation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of location approximation. Always `approximate`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestWebSearchOptionsUserLocationType {
            #[default]
            #[serde(rename = "approximate")]
            Approximate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateChatCompletionRequestWebSearchOptionsUserLocationType,
            #[serde(rename = "approximate")]
            approximate: &'a WebSearchLocation,
        }
        let CreateChatCompletionRequestWebSearchOptionsUserLocation { approximate } = self;
        _S {
            type_: &Default::default(),
            approximate,
        }
        .serialize(serializer)
    }
}
#[doc = "Approximate location parameters for the search.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequestWebSearchOptionsUserLocation {
    #[builder(default)]
    pub approximate: WebSearchLocation,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestWebSearchOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "user_location")]
            #[allow(dead_code)]
            user_location: Option<CreateChatCompletionRequestWebSearchOptionsUserLocation>,
            #[serde(rename = "search_context_size")]
            #[allow(dead_code)]
            search_context_size: Option<WebSearchContextSize>,
        }
        let _D {
            user_location,
            search_context_size,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionRequestWebSearchOptions {
            user_location,
            search_context_size,
        })
    }
}
impl serde::Serialize for CreateChatCompletionRequestWebSearchOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "user_location")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_location: &'a Option<CreateChatCompletionRequestWebSearchOptionsUserLocation>,
            #[serde(rename = "search_context_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            search_context_size: &'a Option<WebSearchContextSize>,
        }
        let CreateChatCompletionRequestWebSearchOptions {
            user_location,
            search_context_size,
        } = self;
        _S {
            user_location,
            search_context_size,
        }
        .serialize(serializer)
    }
}
#[doc = "This tool searches the web for relevant results to use in a response.\nLearn more about the [web search tool](/docs/guides/tools-web-search?api-mode=chat).\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequestWebSearchOptions {
    #[doc = "Approximate location parameters for the search.\n"]
    #[builder(default)]
    pub user_location: Option<CreateChatCompletionRequestWebSearchOptionsUserLocation>,
    #[builder(default)]
    pub search_context_size: Option<WebSearchContextSize>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] ResponseFormatText),
            JsonSchema(#[allow(dead_code)] ResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] ResponseFormatJsonObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_v) => Self::Text(_v),
            _D::JsonSchema(_v) => Self::JsonSchema(_v),
            _D::JsonObject(_v) => Self::JsonObject(_v),
        })
    }
}
impl serde::Serialize for CreateChatCompletionRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a ResponseFormatText),
            JsonSchema(#[allow(dead_code)] &'a ResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] &'a ResponseFormatJsonObject),
        }
        match self {
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
            Self::JsonSchema(_v) => _S::JsonSchema(_v).serialize(serializer),
            Self::JsonObject(_v) => _S::JsonObject(_v).serialize(serializer),
        }
    }
}
#[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestResponseFormat {
    Text(ResponseFormatText),
    JsonSchema(ResponseFormatJsonSchema),
    JsonObject(ResponseFormatJsonObject),
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatAac {
            #[default]
            #[serde(rename = "aac")]
            Aac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatFlac {
            #[default]
            #[serde(rename = "flac")]
            Flac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatOpus {
            #[default]
            #[serde(rename = "opus")]
            Opus,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Wav(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatWav),
            Aac(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatAac),
            Mp3(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatMp3),
            Flac(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatFlac),
            Opus(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatOpus),
            Pcm16(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatPcm16),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Wav(_) => Self::Wav,
            _D::Aac(_) => Self::Aac,
            _D::Mp3(_) => Self::Mp3,
            _D::Flac(_) => Self::Flac,
            _D::Opus(_) => Self::Opus,
            _D::Pcm16(_) => Self::Pcm16,
        })
    }
}
impl serde::Serialize for CreateChatCompletionRequestAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatAac {
            #[default]
            #[serde(rename = "aac")]
            Aac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatFlac {
            #[default]
            #[serde(rename = "flac")]
            Flac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatOpus {
            #[default]
            #[serde(rename = "opus")]
            Opus,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Wav(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatWav),
            Aac(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatAac),
            Mp3(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatMp3),
            Flac(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatFlac),
            Opus(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatOpus),
            Pcm16(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatPcm16),
        }
        match self {
            Self::Wav => _S::Wav(&Default::default()).serialize(serializer),
            Self::Aac => _S::Aac(&Default::default()).serialize(serializer),
            Self::Mp3 => _S::Mp3(&Default::default()).serialize(serializer),
            Self::Flac => _S::Flac(&Default::default()).serialize(serializer),
            Self::Opus => _S::Opus(&Default::default()).serialize(serializer),
            Self::Pcm16 => _S::Pcm16(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,\n`opus`, or `pcm16`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestAudioFormat {
    #[doc = "wav"]
    Wav,
    #[doc = "aac"]
    Aac,
    #[doc = "mp3"]
    Mp3,
    #[doc = "flac"]
    Flac,
    #[doc = "opus"]
    Opus,
    #[doc = "pcm16"]
    Pcm16,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: VoiceIdsShared,
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: CreateChatCompletionRequestAudioFormat,
        }
        let _D { voice, format, .. } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionRequestAudio { voice, format })
    }
}
impl serde::Serialize for CreateChatCompletionRequestAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "voice")]
            voice: &'a VoiceIdsShared,
            #[serde(rename = "format")]
            format: &'a CreateChatCompletionRequestAudioFormat,
        }
        let CreateChatCompletionRequestAudio { voice, format } = self;
        _S { voice, format }.serialize(serializer)
    }
}
#[doc = "Parameters for audio output. Required when audio output is requested with\n`modalities: [\"audio\"]`. [Learn more](/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequestAudio {
    #[doc = "The voice the model uses to respond. Supported voices are \n`alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`, `nova`, `onyx`, `sage`, and `shimmer`.\n"]
    pub voice: VoiceIdsShared,
    #[doc = "Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,\n`opus`, or `pcm16`.\n"]
    pub format: CreateChatCompletionRequestAudioFormat,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestPrediction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            PredictionContent(#[allow(dead_code)] PredictionContent),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::PredictionContent(_v) => Self::PredictionContent(_v),
        })
    }
}
impl serde::Serialize for CreateChatCompletionRequestPrediction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            PredictionContent(#[allow(dead_code)] &'a PredictionContent),
        }
        match self {
            Self::PredictionContent(_v) => _S::PredictionContent(_v).serialize(serializer),
        }
    }
}
#[doc = "Configuration for a [Predicted Output](/docs/guides/predicted-outputs),\nwhich can greatly improve response times when large parts of the model\nresponse are known ahead of time. This is most common when you are\nregenerating a file with only minor changes to most of the content.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestPrediction {
    PredictionContent(PredictionContent),
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestFunctionCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestFunctionCallNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestFunctionCallAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            None(#[allow(dead_code)] CreateChatCompletionRequestFunctionCallNone),
            Auto(#[allow(dead_code)] CreateChatCompletionRequestFunctionCallAuto),
            ChatCompletionFunctionCallOption(#[allow(dead_code)] ChatCompletionFunctionCallOption),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::None(_) => Self::None,
            _D::Auto(_) => Self::Auto,
            _D::ChatCompletionFunctionCallOption(_v) => Self::ChatCompletionFunctionCallOption(_v),
        })
    }
}
impl serde::Serialize for CreateChatCompletionRequestFunctionCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestFunctionCallNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestFunctionCallAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            None(#[allow(dead_code)] &'a CreateChatCompletionRequestFunctionCallNone),
            Auto(#[allow(dead_code)] &'a CreateChatCompletionRequestFunctionCallAuto),
            ChatCompletionFunctionCallOption(
                #[allow(dead_code)] &'a ChatCompletionFunctionCallOption,
            ),
        }
        match self {
            Self::None => _S::None(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::ChatCompletionFunctionCallOption(_v) => {
                _S::ChatCompletionFunctionCallOption(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Deprecated in favor of `tool_choice`.\n\nControls which (if any) function is called by the model.\n\n`none` means the model will not call a function and instead generates a\nmessage.\n\n`auto` means the model can pick between generating a message or calling a\nfunction.\n\nSpecifying a particular function via `{\"name\": \"my_function\"}` forces the\nmodel to call that function.\n\n`none` is the default when no functions are present. `auto` is the default\nif functions are present.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestFunctionCall {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    ChatCompletionFunctionCallOption(ChatCompletionFunctionCallOption),
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(flatten)]
            #[allow(dead_code)]
            create_model_response_properties: CreateModelResponseProperties,
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Vec<ChatCompletionRequestMessage>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: ModelIdsShared,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<ResponseModalities>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "frequency_penalty")]
            #[allow(dead_code)]
            frequency_penalty: Option<f64>,
            #[serde(rename = "presence_penalty")]
            #[allow(dead_code)]
            presence_penalty: Option<f64>,
            #[serde(rename = "web_search_options")]
            #[allow(dead_code)]
            web_search_options: Option<CreateChatCompletionRequestWebSearchOptions>,
            #[serde(rename = "top_logprobs")]
            #[allow(dead_code)]
            top_logprobs: Option<u64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateChatCompletionRequestResponseFormat>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<CreateChatCompletionRequestAudio>,
            #[serde(rename = "store")]
            #[allow(dead_code)]
            store: Option<bool>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "stop")]
            #[allow(dead_code)]
            stop: Option<StopConfiguration>,
            #[serde(rename = "logit_bias")]
            #[allow(dead_code)]
            logit_bias: Option<Vec<u64>>,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<bool>,
            #[serde(rename = "max_tokens")]
            #[allow(dead_code)]
            max_tokens: Option<u64>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "prediction")]
            #[allow(dead_code)]
            prediction: Option<CreateChatCompletionRequestPrediction>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
            #[serde(rename = "stream_options")]
            #[allow(dead_code)]
            stream_options: Option<ChatCompletionStreamOptions>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<ChatCompletionToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "function_call")]
            #[allow(dead_code)]
            function_call: Option<CreateChatCompletionRequestFunctionCall>,
            #[serde(rename = "functions")]
            #[allow(dead_code)]
            functions: Option<Vec<ChatCompletionFunctions>>,
        }
        let _D {
            create_model_response_properties,
            messages,
            model,
            modalities,
            reasoning_effort,
            max_completion_tokens,
            frequency_penalty,
            presence_penalty,
            web_search_options,
            top_logprobs,
            response_format,
            audio,
            store,
            stream,
            stop,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            prediction,
            seed,
            stream_options,
            tools,
            tool_choice,
            parallel_tool_calls,
            function_call,
            functions,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionRequest {
            create_model_response_properties,
            messages,
            model,
            modalities,
            reasoning_effort,
            max_completion_tokens,
            frequency_penalty,
            presence_penalty,
            web_search_options,
            top_logprobs,
            response_format,
            audio,
            store,
            stream,
            stop,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            prediction,
            seed,
            stream_options,
            tools,
            tool_choice,
            parallel_tool_calls,
            function_call,
            functions,
        })
    }
}
impl serde::Serialize for CreateChatCompletionRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(flatten)]
            create_model_response_properties: &'a CreateModelResponseProperties,
            #[serde(rename = "messages")]
            messages: &'a Vec<ChatCompletionRequestMessage>,
            #[serde(rename = "model")]
            model: &'a ModelIdsShared,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<ResponseModalities>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "frequency_penalty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            frequency_penalty: &'a Option<f64>,
            #[serde(rename = "presence_penalty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            presence_penalty: &'a Option<f64>,
            #[serde(rename = "web_search_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            web_search_options: &'a Option<CreateChatCompletionRequestWebSearchOptions>,
            #[serde(rename = "top_logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_logprobs: &'a Option<u64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateChatCompletionRequestResponseFormat>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<CreateChatCompletionRequestAudio>,
            #[serde(rename = "store")]
            #[serde(skip_serializing_if = "Option::is_none")]
            store: &'a Option<bool>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "stop")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stop: &'a Option<StopConfiguration>,
            #[serde(rename = "logit_bias")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logit_bias: &'a Option<Vec<u64>>,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<bool>,
            #[serde(rename = "max_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tokens: &'a Option<u64>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "prediction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prediction: &'a Option<CreateChatCompletionRequestPrediction>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
            #[serde(rename = "stream_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream_options: &'a Option<ChatCompletionStreamOptions>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<ChatCompletionToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<CreateChatCompletionRequestFunctionCall>,
            #[serde(rename = "functions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            functions: &'a Option<Vec<ChatCompletionFunctions>>,
        }
        let CreateChatCompletionRequest {
            create_model_response_properties,
            messages,
            model,
            modalities,
            reasoning_effort,
            max_completion_tokens,
            frequency_penalty,
            presence_penalty,
            web_search_options,
            top_logprobs,
            response_format,
            audio,
            store,
            stream,
            stop,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            prediction,
            seed,
            stream_options,
            tools,
            tool_choice,
            parallel_tool_calls,
            function_call,
            functions,
        } = self;
        _S {
            create_model_response_properties,
            messages,
            model,
            modalities,
            reasoning_effort,
            max_completion_tokens,
            frequency_penalty,
            presence_penalty,
            web_search_options,
            top_logprobs,
            response_format,
            audio,
            store,
            stream,
            stop,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            prediction,
            seed,
            stream_options,
            tools,
            tool_choice,
            parallel_tool_calls,
            function_call,
            functions,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequest {
    #[builder(default)]
    pub create_model_response_properties: CreateModelResponseProperties,
    #[doc = "A list of messages comprising the conversation so far. Depending on the\n[model](/docs/models) you use, different message types (modalities) are\nsupported, like [text](/docs/guides/text-generation),\n[images](/docs/guides/vision), and [audio](/docs/guides/audio).\n"]
    pub messages: Vec<ChatCompletionRequestMessage>,
    #[doc = "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"]
    pub model: ModelIdsShared,
    #[builder(default)]
    pub modalities: Option<ResponseModalities>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on\ntheir existing frequency in the text so far, decreasing the model's\nlikelihood to repeat the same line verbatim.\n"]
    #[builder(default)]
    pub frequency_penalty: Option<f64>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on\nwhether they appear in the text so far, increasing the model's likelihood\nto talk about new topics.\n"]
    #[builder(default)]
    pub presence_penalty: Option<f64>,
    #[doc = "This tool searches the web for relevant results to use in a response.\nLearn more about the [web search tool](/docs/guides/tools-web-search?api-mode=chat).\n"]
    #[builder(default)]
    pub web_search_options: Option<CreateChatCompletionRequestWebSearchOptions>,
    #[doc = "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n`logprobs` must be set to `true` if this parameter is used.\n"]
    #[builder(default)]
    pub top_logprobs: Option<u64>,
    #[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
    #[builder(default)]
    pub response_format: Option<CreateChatCompletionRequestResponseFormat>,
    #[doc = "Parameters for audio output. Required when audio output is requested with\n`modalities: [\"audio\"]`. [Learn more](/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<CreateChatCompletionRequestAudio>,
    #[doc = "Whether or not to store the output of this chat completion request for \nuse in our [model distillation](/docs/guides/distillation) or\n[evals](/docs/guides/evals) products.\n"]
    #[builder(default)]
    pub store: Option<bool>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](https://platform.openai.com/docs/api-reference/chat/streaming)\nfor more information, along with the [streaming responses](/docs/guides/streaming-responses)\nguide for more information on how to handle the streaming events.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[builder(default)]
    pub stop: Option<StopConfiguration>,
    #[doc = "Modify the likelihood of specified tokens appearing in the completion.\n\nAccepts a JSON object that maps tokens (specified by their token ID in the\ntokenizer) to an associated bias value from -100 to 100. Mathematically,\nthe bias is added to the logits generated by the model prior to sampling.\nThe exact effect will vary per model, but values between -1 and 1 should\ndecrease or increase likelihood of selection; values like -100 or 100\nshould result in a ban or exclusive selection of the relevant token.\n"]
    #[builder(default)]
    pub logit_bias: Option<Vec<u64>>,
    #[doc = "Whether to return log probabilities of the output tokens or not. If true,\nreturns the log probabilities of each output token returned in the\n`content` of `message`.\n"]
    #[builder(default)]
    pub logprobs: Option<bool>,
    #[doc = "The maximum number of [tokens](/tokenizer) that can be generated in the\nchat completion. This value can be used to control\n[costs](https://openai.com/api/pricing/) for text generated via API.\n\nThis value is now deprecated in favor of `max_completion_tokens`, and is\nnot compatible with [o-series models](/docs/guides/reasoning).\n"]
    #[builder(default)]
    pub max_tokens: Option<u64>,
    #[doc = "How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs."]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "Configuration for a [Predicted Output](/docs/guides/predicted-outputs),\nwhich can greatly improve response times when large parts of the model\nresponse are known ahead of time. This is most common when you are\nregenerating a file with only minor changes to most of the content.\n"]
    #[builder(default)]
    pub prediction: Option<CreateChatCompletionRequestPrediction>,
    #[doc = "This feature is in Beta.\nIf specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.\nDeterminism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.\n"]
    #[builder(default)]
    pub seed: Option<u64>,
    #[builder(default)]
    pub stream_options: Option<ChatCompletionStreamOptions>,
    #[doc = "A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.\n"]
    #[builder(default)]
    pub tools: Option<Vec<ChatCompletionTool>>,
    #[builder(default)]
    pub tool_choice: Option<ChatCompletionToolChoiceOption>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[doc = "Deprecated in favor of `tool_choice`.\n\nControls which (if any) function is called by the model.\n\n`none` means the model will not call a function and instead generates a\nmessage.\n\n`auto` means the model can pick between generating a message or calling a\nfunction.\n\nSpecifying a particular function via `{\"name\": \"my_function\"}` forces the\nmodel to call that function.\n\n`none` is the default when no functions are present. `auto` is the default\nif functions are present.\n"]
    #[builder(default)]
    pub function_call: Option<CreateChatCompletionRequestFunctionCall>,
    #[doc = "Deprecated in favor of `tools`.\n\nA list of functions the model may generate JSON inputs for.\n"]
    #[builder(default)]
    pub functions: Option<Vec<ChatCompletionFunctions>>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponseChoiceFinishReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Stop(#[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonLength),
            ToolCalls(#[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonToolCalls),
            ContentFilter(
                #[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonContentFilter,
            ),
            FunctionCall(
                #[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonFunctionCall,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Stop(_) => Self::Stop,
            _D::Length(_) => Self::Length,
            _D::ToolCalls(_) => Self::ToolCalls,
            _D::ContentFilter(_) => Self::ContentFilter,
            _D::FunctionCall(_) => Self::FunctionCall,
        })
    }
}
impl serde::Serialize for CreateChatCompletionResponseChoiceFinishReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Stop(#[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonLength),
            ToolCalls(
                #[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonToolCalls,
            ),
            ContentFilter(
                #[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonContentFilter,
            ),
            FunctionCall(
                #[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonFunctionCall,
            ),
        }
        match self {
            Self::Stop => _S::Stop(&Default::default()).serialize(serializer),
            Self::Length => _S::Length(&Default::default()).serialize(serializer),
            Self::ToolCalls => _S::ToolCalls(&Default::default()).serialize(serializer),
            Self::ContentFilter => _S::ContentFilter(&Default::default()).serialize(serializer),
            Self::FunctionCall => _S::FunctionCall(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionResponseChoiceFinishReason {
    #[doc = "stop"]
    Stop,
    #[doc = "length"]
    Length,
    #[doc = "tool_calls"]
    ToolCalls,
    #[doc = "content_filter"]
    ContentFilter,
    #[doc = "function_call"]
    FunctionCall,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponseChoiceLogprobs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<ChatCompletionTokenLogprob>>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<Vec<ChatCompletionTokenLogprob>>,
        }
        let _D {
            content, refusal, ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionResponseChoiceLogprobs { content, refusal })
    }
}
impl serde::Serialize for CreateChatCompletionResponseChoiceLogprobs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<ChatCompletionTokenLogprob>>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<Vec<ChatCompletionTokenLogprob>>,
        }
        let CreateChatCompletionResponseChoiceLogprobs { content, refusal } = self;
        _S { content, refusal }.serialize(serializer)
    }
}
#[doc = "Log probability information for the choice."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionResponseChoiceLogprobs {
    #[doc = "A list of message content tokens with log probability information."]
    #[builder(default)]
    pub content: Option<Vec<ChatCompletionTokenLogprob>>,
    #[doc = "A list of message refusal tokens with log probability information."]
    #[builder(default)]
    pub refusal: Option<Vec<ChatCompletionTokenLogprob>>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponseChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "finish_reason")]
            #[allow(dead_code)]
            finish_reason: CreateChatCompletionResponseChoiceFinishReason,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: ChatCompletionResponseMessage,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<CreateChatCompletionResponseChoiceLogprobs>,
        }
        let _D {
            finish_reason,
            index,
            message,
            logprobs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionResponseChoice {
            finish_reason,
            index,
            message,
            logprobs,
        })
    }
}
impl serde::Serialize for CreateChatCompletionResponseChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "finish_reason")]
            finish_reason: &'a CreateChatCompletionResponseChoiceFinishReason,
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "message")]
            message: &'a ChatCompletionResponseMessage,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<CreateChatCompletionResponseChoiceLogprobs>,
        }
        let CreateChatCompletionResponseChoice {
            finish_reason,
            index,
            message,
            logprobs,
        } = self;
        _S {
            finish_reason,
            index,
            message,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionResponseChoice {
    #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
    pub finish_reason: CreateChatCompletionResponseChoiceFinishReason,
    #[doc = "The index of the choice in the list of choices."]
    pub index: u64,
    #[builder(default)]
    pub message: ChatCompletionResponseMessage,
    #[doc = "Log probability information for the choice."]
    #[builder(default)]
    pub logprobs: Option<CreateChatCompletionResponseChoiceLogprobs>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `chat.completion`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseObject {
            #[default]
            #[serde(rename = "chat.completion")]
            ChatCompletion,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "choices")]
            #[allow(dead_code)]
            choices: Vec<CreateChatCompletionResponseChoice>,
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "service_tier")]
            #[allow(dead_code)]
            service_tier: Option<ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[allow(dead_code)]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CreateChatCompletionResponseObject,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<CompletionUsage>,
        }
        let _D {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateChatCompletionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `chat.completion`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseObject {
            #[default]
            #[serde(rename = "chat.completion")]
            ChatCompletion,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<CreateChatCompletionResponseChoice>,
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a CreateChatCompletionResponseObject,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<CompletionUsage>,
        }
        let CreateChatCompletionResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        } = self;
        _S {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a chat completion response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionResponse {
    #[doc = "A unique identifier for the chat completion."]
    pub id: String,
    #[doc = "A list of chat completion choices. Can be more than one if `n` is greater than 1."]
    pub choices: Vec<CreateChatCompletionResponseChoice>,
    #[doc = "The Unix timestamp (in seconds) of when the chat completion was created."]
    pub created: u64,
    #[doc = "The model used for the chat completion."]
    pub model: String,
    #[builder(default)]
    pub service_tier: Option<ServiceTier>,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\n\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[builder(default)]
    pub usage: Option<CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponseChoiceLogprobs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<ChatCompletionTokenLogprob>>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<Vec<ChatCompletionTokenLogprob>>,
        }
        let _D {
            content, refusal, ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionStreamResponseChoiceLogprobs { content, refusal })
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponseChoiceLogprobs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<ChatCompletionTokenLogprob>>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<Vec<ChatCompletionTokenLogprob>>,
        }
        let CreateChatCompletionStreamResponseChoiceLogprobs { content, refusal } = self;
        _S { content, refusal }.serialize(serializer)
    }
}
#[doc = "Log probability information for the choice."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionStreamResponseChoiceLogprobs {
    #[doc = "A list of message content tokens with log probability information."]
    #[builder(default)]
    pub content: Option<Vec<ChatCompletionTokenLogprob>>,
    #[doc = "A list of message refusal tokens with log probability information."]
    #[builder(default)]
    pub refusal: Option<Vec<ChatCompletionTokenLogprob>>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponseChoiceFinishReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Stop(#[allow(dead_code)] CreateChatCompletionStreamResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] CreateChatCompletionStreamResponseChoiceFinishReasonLength),
            ToolCalls(
                #[allow(dead_code)] CreateChatCompletionStreamResponseChoiceFinishReasonToolCalls,
            ),
            ContentFilter(
                #[allow(dead_code)]
                CreateChatCompletionStreamResponseChoiceFinishReasonContentFilter,
            ),
            FunctionCall(
                #[allow(dead_code)]
                CreateChatCompletionStreamResponseChoiceFinishReasonFunctionCall,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Stop(_) => Self::Stop,
            _D::Length(_) => Self::Length,
            _D::ToolCalls(_) => Self::ToolCalls,
            _D::ContentFilter(_) => Self::ContentFilter,
            _D::FunctionCall(_) => Self::FunctionCall,
        })
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponseChoiceFinishReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Stop(#[allow(dead_code)] &'a CreateChatCompletionStreamResponseChoiceFinishReasonStop),
            Length(
                #[allow(dead_code)] &'a CreateChatCompletionStreamResponseChoiceFinishReasonLength,
            ),
            ToolCalls(
                #[allow(dead_code)]
                &'a CreateChatCompletionStreamResponseChoiceFinishReasonToolCalls,
            ),
            ContentFilter(
                #[allow(dead_code)]
                &'a CreateChatCompletionStreamResponseChoiceFinishReasonContentFilter,
            ),
            FunctionCall(
                #[allow(dead_code)]
                &'a CreateChatCompletionStreamResponseChoiceFinishReasonFunctionCall,
            ),
        }
        match self {
            Self::Stop => _S::Stop(&Default::default()).serialize(serializer),
            Self::Length => _S::Length(&Default::default()).serialize(serializer),
            Self::ToolCalls => _S::ToolCalls(&Default::default()).serialize(serializer),
            Self::ContentFilter => _S::ContentFilter(&Default::default()).serialize(serializer),
            Self::FunctionCall => _S::FunctionCall(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionStreamResponseChoiceFinishReason {
    #[doc = "stop"]
    Stop,
    #[doc = "length"]
    Length,
    #[doc = "tool_calls"]
    ToolCalls,
    #[doc = "content_filter"]
    ContentFilter,
    #[doc = "function_call"]
    FunctionCall,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponseChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: ChatCompletionStreamResponseDelta,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<CreateChatCompletionStreamResponseChoiceLogprobs>,
            #[serde(rename = "finish_reason")]
            #[allow(dead_code)]
            finish_reason: Option<CreateChatCompletionStreamResponseChoiceFinishReason>,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
        }
        let _D {
            delta,
            logprobs,
            finish_reason,
            index,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionStreamResponseChoice {
            delta,
            logprobs,
            finish_reason,
            index,
        })
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponseChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "delta")]
            delta: &'a ChatCompletionStreamResponseDelta,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<CreateChatCompletionStreamResponseChoiceLogprobs>,
            #[serde(rename = "finish_reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            finish_reason: &'a Option<CreateChatCompletionStreamResponseChoiceFinishReason>,
            #[serde(rename = "index")]
            index: &'a u64,
        }
        let CreateChatCompletionStreamResponseChoice {
            delta,
            logprobs,
            finish_reason,
            index,
        } = self;
        _S {
            delta,
            logprobs,
            finish_reason,
            index,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionStreamResponseChoice {
    #[builder(default)]
    pub delta: ChatCompletionStreamResponseDelta,
    #[doc = "Log probability information for the choice."]
    #[builder(default)]
    pub logprobs: Option<CreateChatCompletionStreamResponseChoiceLogprobs>,
    #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
    #[builder(default)]
    pub finish_reason: Option<CreateChatCompletionStreamResponseChoiceFinishReason>,
    #[doc = "The index of the choice in the list of choices."]
    pub index: u64,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `chat.completion.chunk`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseObject {
            #[default]
            #[serde(rename = "chat.completion.chunk")]
            ChatCompletionChunk,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "choices")]
            #[allow(dead_code)]
            choices: Vec<CreateChatCompletionStreamResponseChoice>,
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "service_tier")]
            #[allow(dead_code)]
            service_tier: Option<ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[allow(dead_code)]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CreateChatCompletionStreamResponseObject,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<CompletionUsage>,
        }
        let _D {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateChatCompletionStreamResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `chat.completion.chunk`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseObject {
            #[default]
            #[serde(rename = "chat.completion.chunk")]
            ChatCompletionChunk,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<CreateChatCompletionStreamResponseChoice>,
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a CreateChatCompletionStreamResponseObject,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<CompletionUsage>,
        }
        let CreateChatCompletionStreamResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        } = self;
        _S {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a streamed chunk of a chat completion response returned\nby the model, based on the provided input. \n[Learn more](/docs/guides/streaming-responses).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionStreamResponse {
    #[doc = "A unique identifier for the chat completion. Each chunk has the same ID."]
    pub id: String,
    #[doc = "A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the\nlast chunk if you set `stream_options: {\"include_usage\": true}`.\n"]
    pub choices: Vec<CreateChatCompletionStreamResponseChoice>,
    #[doc = "The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp."]
    pub created: u64,
    #[doc = "The model to generate the completion."]
    pub model: String,
    #[builder(default)]
    pub service_tier: Option<ServiceTier>,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[doc = "An optional field that will only be present when you set\n`stream_options: {\"include_usage\": true}` in your request. When present, it\ncontains a null value **except for the last chunk** which contains the\ntoken usage statistics for the entire request.\n\n**NOTE:** If the stream is interrupted or cancelled, you may not\nreceive the final usage chunk which contains the total token usage for\nthe request.\n"]
    #[builder(default)]
    pub usage: Option<CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionRequestPrompt {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            ArrayOfString(#[allow(dead_code)] Vec<String>),
            ArrayOfInteger(#[allow(dead_code)] Vec<u64>),
            ArrayOfArray(#[allow(dead_code)] Vec<Vec<u64>>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::ArrayOfString(_v) => Self::ArrayOfString(_v),
            _D::ArrayOfInteger(_v) => Self::ArrayOfInteger(_v),
            _D::ArrayOfArray(_v) => Self::ArrayOfArray(_v),
        })
    }
}
impl serde::Serialize for CreateCompletionRequestPrompt {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            ArrayOfString(#[allow(dead_code)] &'a Vec<String>),
            ArrayOfInteger(#[allow(dead_code)] &'a Vec<u64>),
            ArrayOfArray(#[allow(dead_code)] &'a Vec<Vec<u64>>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::ArrayOfString(_v) => _S::ArrayOfString(_v).serialize(serializer),
            Self::ArrayOfInteger(_v) => _S::ArrayOfInteger(_v).serialize(serializer),
            Self::ArrayOfArray(_v) => _S::ArrayOfArray(_v).serialize(serializer),
        }
    }
}
#[doc = "The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.\n\nNote that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateCompletionRequestPrompt {
    String(String),
    ArrayOfString(Vec<String>),
    ArrayOfInteger(Vec<u64>),
    ArrayOfArray(Vec<Vec<u64>>),
}
impl<'de> serde::Deserialize<'de> for CreateCompletionRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<CreateCompletionRequestPrompt>,
            #[serde(rename = "best_of")]
            #[allow(dead_code)]
            best_of: Option<u64>,
            #[serde(rename = "echo")]
            #[allow(dead_code)]
            echo: Option<bool>,
            #[serde(rename = "frequency_penalty")]
            #[allow(dead_code)]
            frequency_penalty: Option<f64>,
            #[serde(rename = "logit_bias")]
            #[allow(dead_code)]
            logit_bias: Option<Vec<u64>>,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<u64>,
            #[serde(rename = "max_tokens")]
            #[allow(dead_code)]
            max_tokens: Option<u64>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "presence_penalty")]
            #[allow(dead_code)]
            presence_penalty: Option<f64>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
            #[serde(rename = "stop")]
            #[allow(dead_code)]
            stop: Option<StopConfiguration>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "stream_options")]
            #[allow(dead_code)]
            stream_options: Option<ChatCompletionStreamOptions>,
            #[serde(rename = "suffix")]
            #[allow(dead_code)]
            suffix: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let _D {
            model,
            prompt,
            best_of,
            echo,
            frequency_penalty,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            presence_penalty,
            seed,
            stop,
            stream,
            stream_options,
            suffix,
            temperature,
            top_p,
            user,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateCompletionRequest {
            model,
            prompt,
            best_of,
            echo,
            frequency_penalty,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            presence_penalty,
            seed,
            stop,
            stream,
            stream_options,
            suffix,
            temperature,
            top_p,
            user,
        })
    }
}
impl serde::Serialize for CreateCompletionRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<CreateCompletionRequestPrompt>,
            #[serde(rename = "best_of")]
            #[serde(skip_serializing_if = "Option::is_none")]
            best_of: &'a Option<u64>,
            #[serde(rename = "echo")]
            #[serde(skip_serializing_if = "Option::is_none")]
            echo: &'a Option<bool>,
            #[serde(rename = "frequency_penalty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            frequency_penalty: &'a Option<f64>,
            #[serde(rename = "logit_bias")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logit_bias: &'a Option<Vec<u64>>,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<u64>,
            #[serde(rename = "max_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tokens: &'a Option<u64>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "presence_penalty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            presence_penalty: &'a Option<f64>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
            #[serde(rename = "stop")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stop: &'a Option<StopConfiguration>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "stream_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream_options: &'a Option<ChatCompletionStreamOptions>,
            #[serde(rename = "suffix")]
            #[serde(skip_serializing_if = "Option::is_none")]
            suffix: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let CreateCompletionRequest {
            model,
            prompt,
            best_of,
            echo,
            frequency_penalty,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            presence_penalty,
            seed,
            stop,
            stream,
            stream_options,
            suffix,
            temperature,
            top_p,
            user,
        } = self;
        _S {
            model,
            prompt,
            best_of,
            echo,
            frequency_penalty,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            presence_penalty,
            seed,
            stop,
            stream,
            stream_options,
            suffix,
            temperature,
            top_p,
            user,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateCompletionRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.\n\nNote that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.\n"]
    #[builder(default)]
    pub prompt: Option<CreateCompletionRequestPrompt>,
    #[doc = "Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.\n\nWhen used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return  `best_of` must be greater than `n`.\n\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.\n"]
    #[builder(default)]
    pub best_of: Option<u64>,
    #[doc = "Echo back the prompt in addition to the completion\n"]
    #[builder(default)]
    pub echo: Option<bool>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.\n\n[See more information about frequency and presence penalties.](/docs/guides/text-generation)\n"]
    #[builder(default)]
    pub frequency_penalty: Option<f64>,
    #[doc = "Modify the likelihood of specified tokens appearing in the completion.\n\nAccepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.\n\nAs an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated.\n"]
    #[builder(default)]
    pub logit_bias: Option<Vec<u64>>,
    #[doc = "Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.\n\nThe maximum value for `logprobs` is 5.\n"]
    #[builder(default)]
    pub logprobs: Option<u64>,
    #[doc = "The maximum number of [tokens](/tokenizer) that can be generated in the completion.\n\nThe token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.\n"]
    #[builder(default)]
    pub max_tokens: Option<u64>,
    #[doc = "How many completions to generate for each prompt.\n\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.\n"]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.\n\n[See more information about frequency and presence penalties.](/docs/guides/text-generation)\n"]
    #[builder(default)]
    pub presence_penalty: Option<f64>,
    #[doc = "If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.\n\nDeterminism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.\n"]
    #[builder(default)]
    pub seed: Option<u64>,
    #[builder(default)]
    pub stop: Option<StopConfiguration>,
    #[doc = "Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[builder(default)]
    pub stream_options: Option<ChatCompletionStreamOptions>,
    #[doc = "The suffix that comes after a completion of inserted text.\n\nThis parameter is only supported for `gpt-3.5-turbo-instruct`.\n"]
    #[builder(default)]
    pub suffix: Option<String>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponseChoiceFinishReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Stop(#[allow(dead_code)] CreateCompletionResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] CreateCompletionResponseChoiceFinishReasonLength),
            ContentFilter(
                #[allow(dead_code)] CreateCompletionResponseChoiceFinishReasonContentFilter,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Stop(_) => Self::Stop,
            _D::Length(_) => Self::Length,
            _D::ContentFilter(_) => Self::ContentFilter,
        })
    }
}
impl serde::Serialize for CreateCompletionResponseChoiceFinishReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Stop(#[allow(dead_code)] &'a CreateCompletionResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] &'a CreateCompletionResponseChoiceFinishReasonLength),
            ContentFilter(
                #[allow(dead_code)] &'a CreateCompletionResponseChoiceFinishReasonContentFilter,
            ),
        }
        match self {
            Self::Stop => _S::Stop(&Default::default()).serialize(serializer),
            Self::Length => _S::Length(&Default::default()).serialize(serializer),
            Self::ContentFilter => _S::ContentFilter(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\nor `content_filter` if content was omitted due to a flag from our content filters.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateCompletionResponseChoiceFinishReason {
    #[doc = "stop"]
    Stop,
    #[doc = "length"]
    Length,
    #[doc = "content_filter"]
    ContentFilter,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponseChoiceLogprobs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "text_offset")]
            #[allow(dead_code)]
            text_offset: Option<Vec<u64>>,
            #[serde(rename = "token_logprobs")]
            #[allow(dead_code)]
            token_logprobs: Option<Vec<f64>>,
            #[serde(rename = "tokens")]
            #[allow(dead_code)]
            tokens: Option<Vec<String>>,
            #[serde(rename = "top_logprobs")]
            #[allow(dead_code)]
            top_logprobs: Option<Vec<Vec<f64>>>,
        }
        let _D {
            text_offset,
            token_logprobs,
            tokens,
            top_logprobs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateCompletionResponseChoiceLogprobs {
            text_offset,
            token_logprobs,
            tokens,
            top_logprobs,
        })
    }
}
impl serde::Serialize for CreateCompletionResponseChoiceLogprobs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "text_offset")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text_offset: &'a Option<Vec<u64>>,
            #[serde(rename = "token_logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token_logprobs: &'a Option<Vec<f64>>,
            #[serde(rename = "tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tokens: &'a Option<Vec<String>>,
            #[serde(rename = "top_logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_logprobs: &'a Option<Vec<Vec<f64>>>,
        }
        let CreateCompletionResponseChoiceLogprobs {
            text_offset,
            token_logprobs,
            tokens,
            top_logprobs,
        } = self;
        _S {
            text_offset,
            token_logprobs,
            tokens,
            top_logprobs,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateCompletionResponseChoiceLogprobs {
    #[builder(default)]
    pub text_offset: Option<Vec<u64>>,
    #[builder(default)]
    pub token_logprobs: Option<Vec<f64>>,
    #[builder(default)]
    pub tokens: Option<Vec<String>>,
    #[builder(default)]
    pub top_logprobs: Option<Vec<Vec<f64>>>,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponseChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "finish_reason")]
            #[allow(dead_code)]
            finish_reason: CreateCompletionResponseChoiceFinishReason,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<CreateCompletionResponseChoiceLogprobs>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D {
            finish_reason,
            index,
            logprobs,
            text,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateCompletionResponseChoice {
            finish_reason,
            index,
            logprobs,
            text,
        })
    }
}
impl serde::Serialize for CreateCompletionResponseChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "finish_reason")]
            finish_reason: &'a CreateCompletionResponseChoiceFinishReason,
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<CreateCompletionResponseChoiceLogprobs>,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let CreateCompletionResponseChoice {
            finish_reason,
            index,
            logprobs,
            text,
        } = self;
        _S {
            finish_reason,
            index,
            logprobs,
            text,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateCompletionResponseChoice {
    #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\nor `content_filter` if content was omitted due to a flag from our content filters.\n"]
    pub finish_reason: CreateCompletionResponseChoiceFinishReason,
    pub index: u64,
    #[builder(default)]
    pub logprobs: Option<CreateCompletionResponseChoiceLogprobs>,
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"text_completion\""]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseObject {
            #[default]
            #[serde(rename = "text_completion")]
            TextCompletion,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "choices")]
            #[allow(dead_code)]
            choices: Vec<CreateCompletionResponseChoice>,
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "system_fingerprint")]
            #[allow(dead_code)]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CreateCompletionResponseObject,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<CompletionUsage>,
        }
        let _D {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateCompletionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateCompletionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"text_completion\""]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseObject {
            #[default]
            #[serde(rename = "text_completion")]
            TextCompletion,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<CreateCompletionResponseChoice>,
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a CreateCompletionResponseObject,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<CompletionUsage>,
        }
        let CreateCompletionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
        } = self;
        _S {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateCompletionResponse {
    #[doc = "A unique identifier for the completion."]
    pub id: String,
    #[doc = "The list of completion choices the model generated for the input prompt."]
    pub choices: Vec<CreateCompletionResponseChoice>,
    #[doc = "The Unix timestamp (in seconds) of when the completion was created."]
    pub created: u64,
    #[doc = "The model used for completion."]
    pub model: String,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\n\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[builder(default)]
    pub usage: Option<CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            ArrayOfString(#[allow(dead_code)] Vec<String>),
            ArrayOfInteger(#[allow(dead_code)] Vec<u64>),
            ArrayOfArray(#[allow(dead_code)] Vec<Vec<u64>>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::ArrayOfString(_v) => Self::ArrayOfString(_v),
            _D::ArrayOfInteger(_v) => Self::ArrayOfInteger(_v),
            _D::ArrayOfArray(_v) => Self::ArrayOfArray(_v),
        })
    }
}
impl serde::Serialize for CreateEmbeddingRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            ArrayOfString(#[allow(dead_code)] &'a Vec<String>),
            ArrayOfInteger(#[allow(dead_code)] &'a Vec<u64>),
            ArrayOfArray(#[allow(dead_code)] &'a Vec<Vec<u64>>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::ArrayOfString(_v) => _S::ArrayOfString(_v).serialize(serializer),
            Self::ArrayOfInteger(_v) => _S::ArrayOfInteger(_v).serialize(serializer),
            Self::ArrayOfArray(_v) => _S::ArrayOfArray(_v).serialize(serializer),
        }
    }
}
#[doc = "Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. Some models may also impose a limit on total number of tokens summed across inputs.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEmbeddingRequestInput {
    #[doc = "The string that will be turned into an embedding."]
    String(String),
    #[doc = "The array of strings that will be turned into an embedding."]
    ArrayOfString(Vec<String>),
    #[doc = "The array of integers that will be turned into an embedding."]
    ArrayOfInteger(Vec<u64>),
    #[doc = "The array of arrays containing integers that will be turned into an embedding."]
    ArrayOfArray(Vec<Vec<u64>>),
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingRequestEncodingFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingRequestEncodingFormatFloat {
            #[default]
            #[serde(rename = "float")]
            Float,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingRequestEncodingFormatBase64 {
            #[default]
            #[serde(rename = "base64")]
            Base64,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Float(#[allow(dead_code)] CreateEmbeddingRequestEncodingFormatFloat),
            Base64(#[allow(dead_code)] CreateEmbeddingRequestEncodingFormatBase64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Float(_) => Self::Float,
            _D::Base64(_) => Self::Base64,
        })
    }
}
impl serde::Serialize for CreateEmbeddingRequestEncodingFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingRequestEncodingFormatFloat {
            #[default]
            #[serde(rename = "float")]
            Float,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingRequestEncodingFormatBase64 {
            #[default]
            #[serde(rename = "base64")]
            Base64,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Float(#[allow(dead_code)] &'a CreateEmbeddingRequestEncodingFormatFloat),
            Base64(#[allow(dead_code)] &'a CreateEmbeddingRequestEncodingFormatBase64),
        }
        match self {
            Self::Float => _S::Float(&Default::default()).serialize(serializer),
            Self::Base64 => _S::Base64(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/)."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEmbeddingRequestEncodingFormat {
    #[doc = "float"]
    #[default]
    Float,
    #[doc = "base64"]
    Base64,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: CreateEmbeddingRequestInput,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "encoding_format")]
            #[allow(dead_code)]
            encoding_format: Option<CreateEmbeddingRequestEncodingFormat>,
            #[serde(rename = "dimensions")]
            #[allow(dead_code)]
            dimensions: Option<u64>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let _D {
            input,
            model,
            encoding_format,
            dimensions,
            user,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEmbeddingRequest {
            input,
            model,
            encoding_format,
            dimensions,
            user,
        })
    }
}
impl serde::Serialize for CreateEmbeddingRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "input")]
            input: &'a CreateEmbeddingRequestInput,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "encoding_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            encoding_format: &'a Option<CreateEmbeddingRequestEncodingFormat>,
            #[serde(rename = "dimensions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            dimensions: &'a Option<u64>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let CreateEmbeddingRequest {
            input,
            model,
            encoding_format,
            dimensions,
            user,
        } = self;
        _S {
            input,
            model,
            encoding_format,
            dimensions,
            user,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEmbeddingRequest {
    #[doc = "Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for `text-embedding-ada-002`), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. Some models may also impose a limit on total number of tokens summed across inputs.\n"]
    pub input: CreateEmbeddingRequestInput,
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/)."]
    #[builder(default)]
    pub encoding_format: Option<CreateEmbeddingRequestEncodingFormat>,
    #[doc = "The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.\n"]
    #[builder(default)]
    pub dimensions: Option<u64>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingResponseUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
        }
        let _D {
            prompt_tokens,
            total_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEmbeddingResponseUsage {
            prompt_tokens,
            total_tokens,
        })
    }
}
impl serde::Serialize for CreateEmbeddingResponseUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
        }
        let CreateEmbeddingResponseUsage {
            prompt_tokens,
            total_tokens,
        } = self;
        _S {
            prompt_tokens,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "The usage information for the request."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateEmbeddingResponseUsage {
    #[doc = "The number of tokens used by the prompt."]
    pub prompt_tokens: u64,
    #[doc = "The total number of tokens used by the request."]
    pub total_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"list\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Embedding>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CreateEmbeddingResponseObject,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: CreateEmbeddingResponseUsage,
        }
        let _D {
            data, model, usage, ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEmbeddingResponse { data, model, usage })
    }
}
impl serde::Serialize for CreateEmbeddingResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"list\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<Embedding>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "object")]
            object: &'a CreateEmbeddingResponseObject,
            #[serde(rename = "usage")]
            usage: &'a CreateEmbeddingResponseUsage,
        }
        let CreateEmbeddingResponse { data, model, usage } = self;
        _S {
            data,
            model,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEmbeddingResponse {
    #[doc = "The list of embeddings generated by the model."]
    pub data: Vec<Embedding>,
    #[doc = "The name of the model used to generate the embedding."]
    pub model: String,
    #[doc = "The usage information for the request."]
    pub usage: CreateEmbeddingResponseUsage,
}
impl<'de> serde::Deserialize<'de>
    for CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            EasyInputMessage(#[allow(dead_code)] EasyInputMessage),
            EvalItem(#[allow(dead_code)] EvalItem),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::EasyInputMessage(_v) => Self::EasyInputMessage(_v),
            _D::EvalItem(_v) => Self::EvalItem(_v),
        })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            EasyInputMessage(#[allow(dead_code)] &'a EasyInputMessage),
            EvalItem(#[allow(dead_code)] &'a EvalItem),
        }
        match self {
            Self::EasyInputMessage(_v) => _S::EasyInputMessage(_v).serialize(serializer),
            Self::EvalItem(_v) => _S::EvalItem(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate {
    EasyInputMessage(EasyInputMessage),
    EvalItem(EvalItem),
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceInputMessagesTemplate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of input messages. Always `template`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceInputMessagesTemplateType {
            #[default]
            #[serde(rename = "template")]
            Template,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalCompletionsRunDataSourceInputMessagesTemplateType,
            #[serde(rename = "template")]
            #[allow(dead_code)]
            template: Vec<CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate>,
        }
        let _D { template, .. } = _D::deserialize(deserializer)?;
        Ok(CreateEvalCompletionsRunDataSourceInputMessagesTemplate { template })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceInputMessagesTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of input messages. Always `template`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceInputMessagesTemplateType {
            #[default]
            #[serde(rename = "template")]
            Template,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalCompletionsRunDataSourceInputMessagesTemplateType,
            #[serde(rename = "template")]
            template: &'a Vec<CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate>,
        }
        let CreateEvalCompletionsRunDataSourceInputMessagesTemplate { template } = self;
        _S {
            type_: &Default::default(),
            template,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSourceInputMessagesTemplate {
    #[doc = "A list of chat messages forming the prompt or context. May include variable references to the \"item\" namespace, ie {{item.name}}."]
    pub template: Vec<CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceInputMessagesItemReference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of input messages. Always `item_reference`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceInputMessagesItemReferenceType {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalCompletionsRunDataSourceInputMessagesItemReferenceType,
            #[serde(rename = "item_reference")]
            #[allow(dead_code)]
            item_reference: String,
        }
        let _D { item_reference, .. } = _D::deserialize(deserializer)?;
        Ok(CreateEvalCompletionsRunDataSourceInputMessagesItemReference { item_reference })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceInputMessagesItemReference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of input messages. Always `item_reference`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceInputMessagesItemReferenceType {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalCompletionsRunDataSourceInputMessagesItemReferenceType,
            #[serde(rename = "item_reference")]
            item_reference: &'a String,
        }
        let CreateEvalCompletionsRunDataSourceInputMessagesItemReference { item_reference } = self;
        _S {
            type_: &Default::default(),
            item_reference,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSourceInputMessagesItemReference {
    #[doc = "A reference to a variable in the \"item\" namespace. Ie, \"item.name\""]
    pub item_reference: String,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Template(#[allow(dead_code)] CreateEvalCompletionsRunDataSourceInputMessagesTemplate),
            ItemReference(
                #[allow(dead_code)] CreateEvalCompletionsRunDataSourceInputMessagesItemReference,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Template(_v) => Self::Template(_v),
            _D::ItemReference(_v) => Self::ItemReference(_v),
        })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Template(
                #[allow(dead_code)] &'a CreateEvalCompletionsRunDataSourceInputMessagesTemplate,
            ),
            ItemReference(
                #[allow(dead_code)]
                &'a CreateEvalCompletionsRunDataSourceInputMessagesItemReference,
            ),
        }
        match self {
            Self::Template(_v) => _S::Template(_v).serialize(serializer),
            Self::ItemReference(_v) => _S::ItemReference(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalCompletionsRunDataSourceInputMessages {
    Template(CreateEvalCompletionsRunDataSourceInputMessagesTemplate),
    ItemReference(CreateEvalCompletionsRunDataSourceInputMessagesItemReference),
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceSamplingParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
        }
        let _D {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEvalCompletionsRunDataSourceSamplingParams {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceSamplingParams {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
        }
        let CreateEvalCompletionsRunDataSourceSamplingParams {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        } = self;
        _S {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSourceSamplingParams {
    #[doc = "A higher temperature increases randomness in the outputs."]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "The maximum number of tokens in the generated output."]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[doc = "An alternative to temperature for nucleus sampling; 1.0 includes all tokens."]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "A seed value to initialize the randomness, during sampling."]
    #[builder(default)]
    pub seed: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileContent(#[allow(dead_code)] EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] EvalJsonlFileIdSource),
            StoredCompletions(#[allow(dead_code)] EvalStoredCompletionsSource),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileContent(_v) => Self::FileContent(_v),
            _D::FileId(_v) => Self::FileId(_v),
            _D::StoredCompletions(_v) => Self::StoredCompletions(_v),
        })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileContent(#[allow(dead_code)] &'a EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] &'a EvalJsonlFileIdSource),
            StoredCompletions(#[allow(dead_code)] &'a EvalStoredCompletionsSource),
        }
        match self {
            Self::FileContent(_v) => _S::FileContent(_v).serialize(serializer),
            Self::FileId(_v) => _S::FileId(_v).serialize(serializer),
            Self::StoredCompletions(_v) => _S::StoredCompletions(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalCompletionsRunDataSourceSource {
    FileContent(EvalJsonlFileContentSource),
    FileId(EvalJsonlFileIdSource),
    StoredCompletions(EvalStoredCompletionsSource),
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of run data source. Always `completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceType {
            #[default]
            #[serde(rename = "completions")]
            Completions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalCompletionsRunDataSourceType,
            #[serde(rename = "input_messages")]
            #[allow(dead_code)]
            input_messages: Option<CreateEvalCompletionsRunDataSourceInputMessages>,
            #[serde(rename = "sampling_params")]
            #[allow(dead_code)]
            sampling_params: Option<CreateEvalCompletionsRunDataSourceSamplingParams>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: CreateEvalCompletionsRunDataSourceSource,
        }
        let _D {
            input_messages,
            sampling_params,
            model,
            source,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEvalCompletionsRunDataSource {
            input_messages,
            sampling_params,
            model,
            source,
        })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of run data source. Always `completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceType {
            #[default]
            #[serde(rename = "completions")]
            Completions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalCompletionsRunDataSourceType,
            #[serde(rename = "input_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_messages: &'a Option<CreateEvalCompletionsRunDataSourceInputMessages>,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params: &'a Option<CreateEvalCompletionsRunDataSourceSamplingParams>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "source")]
            source: &'a CreateEvalCompletionsRunDataSourceSource,
        }
        let CreateEvalCompletionsRunDataSource {
            input_messages,
            sampling_params,
            model,
            source,
        } = self;
        _S {
            type_: &Default::default(),
            input_messages,
            sampling_params,
            model,
            source,
        }
        .serialize(serializer)
    }
}
#[doc = "A CompletionsRunDataSource object describing a model sampling configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSource {
    #[builder(default)]
    pub input_messages: Option<CreateEvalCompletionsRunDataSourceInputMessages>,
    #[builder(default)]
    pub sampling_params: Option<CreateEvalCompletionsRunDataSourceSamplingParams>,
    #[doc = "The name of the model to use for generating completions (e.g. \"o3-mini\")."]
    #[builder(default)]
    pub model: Option<String>,
    pub source: CreateEvalCompletionsRunDataSourceSource,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCustomDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `custom`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCustomDataSourceConfigType {
            #[default]
            #[serde(rename = "custom")]
            Custom,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalCustomDataSourceConfigType,
            #[serde(rename = "item_schema")]
            #[allow(dead_code)]
            item_schema: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "include_sample_schema")]
            #[allow(dead_code)]
            include_sample_schema: Option<bool>,
        }
        let _D {
            item_schema,
            include_sample_schema,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEvalCustomDataSourceConfig {
            item_schema,
            include_sample_schema,
        })
    }
}
impl serde::Serialize for CreateEvalCustomDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `custom`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCustomDataSourceConfigType {
            #[default]
            #[serde(rename = "custom")]
            Custom,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalCustomDataSourceConfigType,
            #[serde(rename = "item_schema")]
            item_schema: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "include_sample_schema")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_sample_schema: &'a Option<bool>,
        }
        let CreateEvalCustomDataSourceConfig {
            item_schema,
            include_sample_schema,
        } = self;
        _S {
            type_: &Default::default(),
            item_schema,
            include_sample_schema,
        }
        .serialize(serializer)
    }
}
#[doc = "A CustomDataSourceConfig object that defines the schema for the data source used for the evaluation runs.\nThis schema is used to define the shape of the data that will be:\n- Used to define your testing criteria and\n- What data is required when creating a run\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCustomDataSourceConfig {
    #[doc = "The json schema for each row in the data source."]
    pub item_schema: std::collections::HashMap<String, serde_json::Value>,
    #[doc = "Whether the eval should expect you to populate the sample namespace (ie, by generating responses off of your data source)"]
    #[builder(default)]
    pub include_sample_schema: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalItem0 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: String,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: String,
        }
        let _D { role, content, .. } = _D::deserialize(deserializer)?;
        Ok(CreateEvalItem0 { role, content })
    }
}
impl serde::Serialize for CreateEvalItem0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a String,
            #[serde(rename = "content")]
            content: &'a String,
        }
        let CreateEvalItem0 { role, content } = self;
        _S { role, content }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalItem0 {
    #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
    pub role: String,
    #[doc = "The content of the message."]
    pub content: String,
}
impl<'de> serde::Deserialize<'de> for CreateEvalItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            _0(#[allow(dead_code)] CreateEvalItem0),
            EvalItem(#[allow(dead_code)] EvalItem),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::_0(_v) => Self::_0(_v),
            _D::EvalItem(_v) => Self::EvalItem(_v),
        })
    }
}
impl serde::Serialize for CreateEvalItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            _0(#[allow(dead_code)] &'a CreateEvalItem0),
            EvalItem(#[allow(dead_code)] &'a EvalItem),
        }
        match self {
            Self::_0(_v) => _S::_0(_v).serialize(serializer),
            Self::EvalItem(_v) => _S::EvalItem(_v).serialize(serializer),
        }
    }
}
#[doc = "A chat message that makes up the prompt or context. May include variable references to the \"item\" namespace, ie {{item.name}}."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalItem {
    _0(CreateEvalItem0),
    EvalItem(EvalItem),
}
impl<'de> serde::Deserialize<'de> for CreateEvalJsonlRunDataSourceSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileContent(#[allow(dead_code)] EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] EvalJsonlFileIdSource),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileContent(_v) => Self::FileContent(_v),
            _D::FileId(_v) => Self::FileId(_v),
        })
    }
}
impl serde::Serialize for CreateEvalJsonlRunDataSourceSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileContent(#[allow(dead_code)] &'a EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] &'a EvalJsonlFileIdSource),
        }
        match self {
            Self::FileContent(_v) => _S::FileContent(_v).serialize(serializer),
            Self::FileId(_v) => _S::FileId(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalJsonlRunDataSourceSource {
    FileContent(EvalJsonlFileContentSource),
    FileId(EvalJsonlFileIdSource),
}
impl<'de> serde::Deserialize<'de> for CreateEvalJsonlRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `jsonl`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalJsonlRunDataSourceType {
            #[default]
            #[serde(rename = "jsonl")]
            Jsonl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalJsonlRunDataSourceType,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: CreateEvalJsonlRunDataSourceSource,
        }
        let _D { source, .. } = _D::deserialize(deserializer)?;
        Ok(CreateEvalJsonlRunDataSource { source })
    }
}
impl serde::Serialize for CreateEvalJsonlRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `jsonl`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalJsonlRunDataSourceType {
            #[default]
            #[serde(rename = "jsonl")]
            Jsonl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalJsonlRunDataSourceType,
            #[serde(rename = "source")]
            source: &'a CreateEvalJsonlRunDataSourceSource,
        }
        let CreateEvalJsonlRunDataSource { source } = self;
        _S {
            type_: &Default::default(),
            source,
        }
        .serialize(serializer)
    }
}
#[doc = "A JsonlRunDataSource object with that specifies a JSONL file that matches the eval \n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalJsonlRunDataSource {
    pub source: CreateEvalJsonlRunDataSourceSource,
}
impl<'de> serde::Deserialize<'de> for CreateEvalLabelModelGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `label_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalLabelModelGraderType {
            #[default]
            #[serde(rename = "label_model")]
            LabelModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalLabelModelGraderType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Vec<CreateEvalItem>,
            #[serde(rename = "labels")]
            #[allow(dead_code)]
            labels: Vec<String>,
            #[serde(rename = "passing_labels")]
            #[allow(dead_code)]
            passing_labels: Vec<String>,
        }
        let _D {
            name,
            model,
            input,
            labels,
            passing_labels,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEvalLabelModelGrader {
            name,
            model,
            input,
            labels,
            passing_labels,
        })
    }
}
impl serde::Serialize for CreateEvalLabelModelGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `label_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalLabelModelGraderType {
            #[default]
            #[serde(rename = "label_model")]
            LabelModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalLabelModelGraderType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a Vec<CreateEvalItem>,
            #[serde(rename = "labels")]
            labels: &'a Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: &'a Vec<String>,
        }
        let CreateEvalLabelModelGrader {
            name,
            model,
            input,
            labels,
            passing_labels,
        } = self;
        _S {
            type_: &Default::default(),
            name,
            model,
            input,
            labels,
            passing_labels,
        }
        .serialize(serializer)
    }
}
#[doc = "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalLabelModelGrader {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation. Must support structured outputs."]
    pub model: String,
    #[doc = "A list of chat messages forming the prompt or context. May include variable references to the \"item\" namespace, ie {{item.name}}."]
    pub input: Vec<CreateEvalItem>,
    #[doc = "The labels to classify to each item in the evaluation."]
    pub labels: Vec<String>,
    #[doc = "The labels that indicate a passing result. Must be a subset of labels."]
    pub passing_labels: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalLogsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalLogsDataSourceConfigType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalLogsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let _D { metadata, .. } = _D::deserialize(deserializer)?;
        Ok(CreateEvalLogsDataSourceConfig { metadata })
    }
}
impl serde::Serialize for CreateEvalLogsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalLogsDataSourceConfigType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalLogsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let CreateEvalLogsDataSourceConfig { metadata } = self;
        _S {
            type_: &Default::default(),
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "A data source config which specifies the metadata property of your stored completions query.\nThis is usually metadata like `usecase=chatbot` or `prompt-version=v2`, etc.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateEvalLogsDataSourceConfig {
    #[doc = "Metadata filters for the logs data source."]
    #[builder(default)]
    pub metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalRequestDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Custom(#[allow(dead_code)] CreateEvalCustomDataSourceConfig),
            Logs(#[allow(dead_code)] CreateEvalLogsDataSourceConfig),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Custom(_v) => Self::Custom(_v),
            _D::Logs(_v) => Self::Logs(_v),
        })
    }
}
impl serde::Serialize for CreateEvalRequestDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Custom(#[allow(dead_code)] &'a CreateEvalCustomDataSourceConfig),
            Logs(#[allow(dead_code)] &'a CreateEvalLogsDataSourceConfig),
        }
        match self {
            Self::Custom(_v) => _S::Custom(_v).serialize(serializer),
            Self::Logs(_v) => _S::Logs(_v).serialize(serializer),
        }
    }
}
#[doc = "The configuration for the data source used for the evaluation runs."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalRequestDataSourceConfig {
    Custom(CreateEvalCustomDataSourceConfig),
    Logs(CreateEvalLogsDataSourceConfig),
}
impl<'de> serde::Deserialize<'de> for CreateEvalRequestTestingCriteria {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            LabelModel(#[allow(dead_code)] CreateEvalLabelModelGrader),
            StringCheck(#[allow(dead_code)] EvalStringCheckGrader),
            TextSimilarity(#[allow(dead_code)] EvalTextSimilarityGrader),
            Python(#[allow(dead_code)] EvalPythonGrader),
            ScoreModel(#[allow(dead_code)] EvalScoreModelGrader),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::LabelModel(_v) => Self::LabelModel(_v),
            _D::StringCheck(_v) => Self::StringCheck(_v),
            _D::TextSimilarity(_v) => Self::TextSimilarity(_v),
            _D::Python(_v) => Self::Python(_v),
            _D::ScoreModel(_v) => Self::ScoreModel(_v),
        })
    }
}
impl serde::Serialize for CreateEvalRequestTestingCriteria {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            LabelModel(#[allow(dead_code)] &'a CreateEvalLabelModelGrader),
            StringCheck(#[allow(dead_code)] &'a EvalStringCheckGrader),
            TextSimilarity(#[allow(dead_code)] &'a EvalTextSimilarityGrader),
            Python(#[allow(dead_code)] &'a EvalPythonGrader),
            ScoreModel(#[allow(dead_code)] &'a EvalScoreModelGrader),
        }
        match self {
            Self::LabelModel(_v) => _S::LabelModel(_v).serialize(serializer),
            Self::StringCheck(_v) => _S::StringCheck(_v).serialize(serializer),
            Self::TextSimilarity(_v) => _S::TextSimilarity(_v).serialize(serializer),
            Self::Python(_v) => _S::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => _S::ScoreModel(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalRequestTestingCriteria {
    LabelModel(CreateEvalLabelModelGrader),
    StringCheck(EvalStringCheckGrader),
    TextSimilarity(EvalTextSimilarityGrader),
    Python(EvalPythonGrader),
    ScoreModel(EvalScoreModelGrader),
}
impl<'de> serde::Deserialize<'de> for CreateEvalRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "data_source_config")]
            #[allow(dead_code)]
            data_source_config: CreateEvalRequestDataSourceConfig,
            #[serde(rename = "testing_criteria")]
            #[allow(dead_code)]
            testing_criteria: Vec<CreateEvalRequestTestingCriteria>,
        }
        let _D {
            name,
            metadata,
            data_source_config,
            testing_criteria,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEvalRequest {
            name,
            metadata,
            data_source_config,
            testing_criteria,
        })
    }
}
impl serde::Serialize for CreateEvalRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "data_source_config")]
            data_source_config: &'a CreateEvalRequestDataSourceConfig,
            #[serde(rename = "testing_criteria")]
            testing_criteria: &'a Vec<CreateEvalRequestTestingCriteria>,
        }
        let CreateEvalRequest {
            name,
            metadata,
            data_source_config,
            testing_criteria,
        } = self;
        _S {
            name,
            metadata,
            data_source_config,
            testing_criteria,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalRequest {
    #[doc = "The name of the evaluation."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "The configuration for the data source used for the evaluation runs."]
    pub data_source_config: CreateEvalRequestDataSourceConfig,
    #[doc = "A list of graders for all eval runs in this group."]
    pub testing_criteria: Vec<CreateEvalRequestTestingCriteria>,
}
impl<'de> serde::Deserialize<'de>
    for CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: String,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: String,
        }
        let _D { role, content, .. } = _D::deserialize(deserializer)?;
        Ok(CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 { role, content })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a String,
            #[serde(rename = "content")]
            content: &'a String,
        }
        let CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 { role, content } = self;
        _S { role, content }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 {
    #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
    pub role: String,
    #[doc = "The content of the message."]
    pub content: String,
}
impl<'de> serde::Deserialize<'de>
    for CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            _0(#[allow(dead_code)] CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0),
            EvalItem(#[allow(dead_code)] EvalItem),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::_0(_v) => Self::_0(_v),
            _D::EvalItem(_v) => Self::EvalItem(_v),
        })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            _0(
                #[allow(dead_code)]
                &'a CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0,
            ),
            EvalItem(#[allow(dead_code)] &'a EvalItem),
        }
        match self {
            Self::_0(_v) => _S::_0(_v).serialize(serializer),
            Self::EvalItem(_v) => _S::EvalItem(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate {
    _0(CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0),
    EvalItem(EvalItem),
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceInputMessagesTemplate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of input messages. Always `template`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceInputMessagesTemplateType {
            #[default]
            #[serde(rename = "template")]
            Template,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalResponsesRunDataSourceInputMessagesTemplateType,
            #[serde(rename = "template")]
            #[allow(dead_code)]
            template: Vec<CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate>,
        }
        let _D { template, .. } = _D::deserialize(deserializer)?;
        Ok(CreateEvalResponsesRunDataSourceInputMessagesTemplate { template })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessagesTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of input messages. Always `template`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceInputMessagesTemplateType {
            #[default]
            #[serde(rename = "template")]
            Template,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalResponsesRunDataSourceInputMessagesTemplateType,
            #[serde(rename = "template")]
            template: &'a Vec<CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate>,
        }
        let CreateEvalResponsesRunDataSourceInputMessagesTemplate { template } = self;
        _S {
            type_: &Default::default(),
            template,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceInputMessagesTemplate {
    #[doc = "A list of chat messages forming the prompt or context. May include variable references to the \"item\" namespace, ie {{item.name}}."]
    pub template: Vec<CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceInputMessagesItemReference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of input messages. Always `item_reference`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceInputMessagesItemReferenceType {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalResponsesRunDataSourceInputMessagesItemReferenceType,
            #[serde(rename = "item_reference")]
            #[allow(dead_code)]
            item_reference: String,
        }
        let _D { item_reference, .. } = _D::deserialize(deserializer)?;
        Ok(CreateEvalResponsesRunDataSourceInputMessagesItemReference { item_reference })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessagesItemReference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of input messages. Always `item_reference`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceInputMessagesItemReferenceType {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalResponsesRunDataSourceInputMessagesItemReferenceType,
            #[serde(rename = "item_reference")]
            item_reference: &'a String,
        }
        let CreateEvalResponsesRunDataSourceInputMessagesItemReference { item_reference } = self;
        _S {
            type_: &Default::default(),
            item_reference,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceInputMessagesItemReference {
    #[doc = "A reference to a variable in the \"item\" namespace. Ie, \"item.name\""]
    pub item_reference: String,
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Template(#[allow(dead_code)] CreateEvalResponsesRunDataSourceInputMessagesTemplate),
            ItemReference(
                #[allow(dead_code)] CreateEvalResponsesRunDataSourceInputMessagesItemReference,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Template(_v) => Self::Template(_v),
            _D::ItemReference(_v) => Self::ItemReference(_v),
        })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Template(#[allow(dead_code)] &'a CreateEvalResponsesRunDataSourceInputMessagesTemplate),
            ItemReference(
                #[allow(dead_code)] &'a CreateEvalResponsesRunDataSourceInputMessagesItemReference,
            ),
        }
        match self {
            Self::Template(_v) => _S::Template(_v).serialize(serializer),
            Self::ItemReference(_v) => _S::ItemReference(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalResponsesRunDataSourceInputMessages {
    Template(CreateEvalResponsesRunDataSourceInputMessagesTemplate),
    ItemReference(CreateEvalResponsesRunDataSourceInputMessagesItemReference),
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceSamplingParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
        }
        let _D {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEvalResponsesRunDataSourceSamplingParams {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceSamplingParams {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
        }
        let CreateEvalResponsesRunDataSourceSamplingParams {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        } = self;
        _S {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceSamplingParams {
    #[doc = "A higher temperature increases randomness in the outputs."]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "The maximum number of tokens in the generated output."]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[doc = "An alternative to temperature for nucleus sampling; 1.0 includes all tokens."]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "A seed value to initialize the randomness, during sampling."]
    #[builder(default)]
    pub seed: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileContent(#[allow(dead_code)] EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] EvalJsonlFileIdSource),
            Responses(#[allow(dead_code)] EvalResponsesSource),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileContent(_v) => Self::FileContent(_v),
            _D::FileId(_v) => Self::FileId(_v),
            _D::Responses(_v) => Self::Responses(_v),
        })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileContent(#[allow(dead_code)] &'a EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] &'a EvalJsonlFileIdSource),
            Responses(#[allow(dead_code)] &'a EvalResponsesSource),
        }
        match self {
            Self::FileContent(_v) => _S::FileContent(_v).serialize(serializer),
            Self::FileId(_v) => _S::FileId(_v).serialize(serializer),
            Self::Responses(_v) => _S::Responses(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalResponsesRunDataSourceSource {
    FileContent(EvalJsonlFileContentSource),
    FileId(EvalJsonlFileIdSource),
    Responses(EvalResponsesSource),
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of run data source. Always `completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceType {
            #[default]
            #[serde(rename = "completions")]
            Completions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalResponsesRunDataSourceType,
            #[serde(rename = "input_messages")]
            #[allow(dead_code)]
            input_messages: Option<CreateEvalResponsesRunDataSourceInputMessages>,
            #[serde(rename = "sampling_params")]
            #[allow(dead_code)]
            sampling_params: Option<CreateEvalResponsesRunDataSourceSamplingParams>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: CreateEvalResponsesRunDataSourceSource,
        }
        let _D {
            input_messages,
            sampling_params,
            model,
            source,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEvalResponsesRunDataSource {
            input_messages,
            sampling_params,
            model,
            source,
        })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of run data source. Always `completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceType {
            #[default]
            #[serde(rename = "completions")]
            Completions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalResponsesRunDataSourceType,
            #[serde(rename = "input_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_messages: &'a Option<CreateEvalResponsesRunDataSourceInputMessages>,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params: &'a Option<CreateEvalResponsesRunDataSourceSamplingParams>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "source")]
            source: &'a CreateEvalResponsesRunDataSourceSource,
        }
        let CreateEvalResponsesRunDataSource {
            input_messages,
            sampling_params,
            model,
            source,
        } = self;
        _S {
            type_: &Default::default(),
            input_messages,
            sampling_params,
            model,
            source,
        }
        .serialize(serializer)
    }
}
#[doc = "A ResponsesRunDataSource object describing a model sampling configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSource {
    #[builder(default)]
    pub input_messages: Option<CreateEvalResponsesRunDataSourceInputMessages>,
    #[builder(default)]
    pub sampling_params: Option<CreateEvalResponsesRunDataSourceSamplingParams>,
    #[doc = "The name of the model to use for generating completions (e.g. \"o3-mini\")."]
    #[builder(default)]
    pub model: Option<String>,
    pub source: CreateEvalResponsesRunDataSourceSource,
}
impl<'de> serde::Deserialize<'de> for CreateEvalRunRequestDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Jsonl(#[allow(dead_code)] CreateEvalJsonlRunDataSource),
            CreateEvalCompletionsRunDataSource(
                #[allow(dead_code)] CreateEvalCompletionsRunDataSource,
            ),
            CreateEvalResponsesRunDataSource(#[allow(dead_code)] CreateEvalResponsesRunDataSource),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Jsonl(_v) => Self::Jsonl(_v),
            _D::CreateEvalCompletionsRunDataSource(_v) => {
                Self::CreateEvalCompletionsRunDataSource(_v)
            }
            _D::CreateEvalResponsesRunDataSource(_v) => Self::CreateEvalResponsesRunDataSource(_v),
        })
    }
}
impl serde::Serialize for CreateEvalRunRequestDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Jsonl(#[allow(dead_code)] &'a CreateEvalJsonlRunDataSource),
            CreateEvalCompletionsRunDataSource(
                #[allow(dead_code)] &'a CreateEvalCompletionsRunDataSource,
            ),
            CreateEvalResponsesRunDataSource(
                #[allow(dead_code)] &'a CreateEvalResponsesRunDataSource,
            ),
        }
        match self {
            Self::Jsonl(_v) => _S::Jsonl(_v).serialize(serializer),
            Self::CreateEvalCompletionsRunDataSource(_v) => {
                _S::CreateEvalCompletionsRunDataSource(_v).serialize(serializer)
            }
            Self::CreateEvalResponsesRunDataSource(_v) => {
                _S::CreateEvalResponsesRunDataSource(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Details about the run's data source."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalRunRequestDataSource {
    Jsonl(CreateEvalJsonlRunDataSource),
    CreateEvalCompletionsRunDataSource(CreateEvalCompletionsRunDataSource),
    CreateEvalResponsesRunDataSource(CreateEvalResponsesRunDataSource),
}
impl<'de> serde::Deserialize<'de> for CreateEvalRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "data_source")]
            #[allow(dead_code)]
            data_source: CreateEvalRunRequestDataSource,
        }
        let _D {
            name,
            metadata,
            data_source,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateEvalRunRequest {
            name,
            metadata,
            data_source,
        })
    }
}
impl serde::Serialize for CreateEvalRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "data_source")]
            data_source: &'a CreateEvalRunRequestDataSource,
        }
        let CreateEvalRunRequest {
            name,
            metadata,
            data_source,
        } = self;
        _S {
            name,
            metadata,
            data_source,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalRunRequest {
    #[doc = "The name of the run."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "Details about the run's data source."]
    pub data_source: CreateEvalRunRequestDataSource,
}
impl<'de> serde::Deserialize<'de> for CreateFileRequestPurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeUserData {
            #[default]
            #[serde(rename = "user_data")]
            UserData,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeEvals {
            #[default]
            #[serde(rename = "evals")]
            Evals,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Assistants(#[allow(dead_code)] CreateFileRequestPurposeAssistants),
            Batch(#[allow(dead_code)] CreateFileRequestPurposeBatch),
            FineTune(#[allow(dead_code)] CreateFileRequestPurposeFineTune),
            Vision(#[allow(dead_code)] CreateFileRequestPurposeVision),
            UserData(#[allow(dead_code)] CreateFileRequestPurposeUserData),
            Evals(#[allow(dead_code)] CreateFileRequestPurposeEvals),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Assistants(_) => Self::Assistants,
            _D::Batch(_) => Self::Batch,
            _D::FineTune(_) => Self::FineTune,
            _D::Vision(_) => Self::Vision,
            _D::UserData(_) => Self::UserData,
            _D::Evals(_) => Self::Evals,
        })
    }
}
impl serde::Serialize for CreateFileRequestPurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeUserData {
            #[default]
            #[serde(rename = "user_data")]
            UserData,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFileRequestPurposeEvals {
            #[default]
            #[serde(rename = "evals")]
            Evals,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Assistants(#[allow(dead_code)] &'a CreateFileRequestPurposeAssistants),
            Batch(#[allow(dead_code)] &'a CreateFileRequestPurposeBatch),
            FineTune(#[allow(dead_code)] &'a CreateFileRequestPurposeFineTune),
            Vision(#[allow(dead_code)] &'a CreateFileRequestPurposeVision),
            UserData(#[allow(dead_code)] &'a CreateFileRequestPurposeUserData),
            Evals(#[allow(dead_code)] &'a CreateFileRequestPurposeEvals),
        }
        match self {
            Self::Assistants => _S::Assistants(&Default::default()).serialize(serializer),
            Self::Batch => _S::Batch(&Default::default()).serialize(serializer),
            Self::FineTune => _S::FineTune(&Default::default()).serialize(serializer),
            Self::Vision => _S::Vision(&Default::default()).serialize(serializer),
            Self::UserData => _S::UserData(&Default::default()).serialize(serializer),
            Self::Evals => _S::Evals(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The intended purpose of the uploaded file. One of: - `assistants`: Used in the Assistants API - `batch`: Used in the Batch API - `fine-tune`: Used for fine-tuning - `vision`: Images used for vision fine-tuning - `user_data`: Flexible file type for any purpose - `evals`: Used for eval data sets\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFileRequestPurpose {
    #[doc = "assistants"]
    Assistants,
    #[doc = "batch"]
    Batch,
    #[doc = "fine-tune"]
    FineTune,
    #[doc = "vision"]
    Vision,
    #[doc = "user_data"]
    UserData,
    #[doc = "evals"]
    Evals,
}
impl<'de> serde::Deserialize<'de> for CreateFileRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Vec<u8>,
            #[serde(rename = "purpose")]
            #[allow(dead_code)]
            purpose: CreateFileRequestPurpose,
        }
        let _D { file, purpose, .. } = _D::deserialize(deserializer)?;
        Ok(CreateFileRequest { file, purpose })
    }
}
impl serde::Serialize for CreateFileRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            file: &'a Vec<u8>,
            #[serde(rename = "purpose")]
            purpose: &'a CreateFileRequestPurpose,
        }
        let CreateFileRequest { file, purpose } = self;
        _S { file, purpose }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFileRequest {
    #[doc = "The File object (not file name) to be uploaded.\n"]
    pub file: Vec<u8>,
    #[doc = "The intended purpose of the uploaded file. One of: - `assistants`: Used in the Assistants API - `batch`: Used in the Batch API - `fine-tune`: Used for fine-tuning - `vision`: Images used for vision fine-tuning - `user_data`: Flexible file type for any purpose - `evals`: Used for eval data sets\n"]
    pub purpose: CreateFileRequestPurpose,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningCheckpointPermissionRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "project_ids")]
            #[allow(dead_code)]
            project_ids: Vec<String>,
        }
        let _D { project_ids, .. } = _D::deserialize(deserializer)?;
        Ok(CreateFineTuningCheckpointPermissionRequest { project_ids })
    }
}
impl serde::Serialize for CreateFineTuningCheckpointPermissionRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "project_ids")]
            project_ids: &'a Vec<String>,
        }
        let CreateFineTuningCheckpointPermissionRequest { project_ids } = self;
        _S { project_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningCheckpointPermissionRequest {
    #[doc = "The project identifiers to grant access to."]
    pub project_ids: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] CreateFineTuningJobRequestHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Integer(_v) => Self::Integer(_v),
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a CreateFineTuningJobRequestHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de>
    for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(
                #[allow(dead_code)]
                CreateFineTuningJobRequestHyperparametersLearningRateMultiplierAuto,
            ),
            Float(#[allow(dead_code)] f64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Float(_v) => Self::Float(_v),
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(
                #[allow(dead_code)]
                &'a CreateFineTuningJobRequestHyperparametersLearningRateMultiplierAuto,
            ),
            Float(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Float(_v) => _S::Float(_v).serialize(serializer),
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Float(f64),
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] CreateFineTuningJobRequestHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Integer(_v) => Self::Integer(_v),
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a CreateFineTuningJobRequestHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<CreateFineTuningJobRequestHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier:
                Option<CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<CreateFineTuningJobRequestHyperparametersNEpochs>,
        }
        let _D {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateFineTuningJobRequestHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<CreateFineTuningJobRequestHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier:
                &'a Option<CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<CreateFineTuningJobRequestHyperparametersNEpochs>,
        }
        let CreateFineTuningJobRequestHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        } = self;
        _S {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the fine-tuning job.\nThis value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequestHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<CreateFineTuningJobRequestHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier:
        Option<CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<CreateFineTuningJobRequestHyperparametersNEpochs>,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestIntegrationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestIntegrationTypeWandb {
            #[default]
            #[serde(rename = "wandb")]
            Wandb,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Wandb(#[allow(dead_code)] CreateFineTuningJobRequestIntegrationTypeWandb),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Wandb(_) => Self::Wandb,
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestIntegrationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestIntegrationTypeWandb {
            #[default]
            #[serde(rename = "wandb")]
            Wandb,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Wandb(#[allow(dead_code)] &'a CreateFineTuningJobRequestIntegrationTypeWandb),
        }
        match self {
            Self::Wandb => _S::Wandb(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of integration to enable. Currently, only \"wandb\" (Weights and Biases) is supported.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestIntegrationType {
    #[doc = "wandb"]
    Wandb,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestIntegrationWandb {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "project")]
            #[allow(dead_code)]
            project: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "entity")]
            #[allow(dead_code)]
            entity: Option<String>,
            #[serde(rename = "tags")]
            #[allow(dead_code)]
            tags: Option<Vec<String>>,
        }
        let _D {
            project,
            name,
            entity,
            tags,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateFineTuningJobRequestIntegrationWandb {
            project,
            name,
            entity,
            tags,
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestIntegrationWandb {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "project")]
            project: &'a String,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "entity")]
            #[serde(skip_serializing_if = "Option::is_none")]
            entity: &'a Option<String>,
            #[serde(rename = "tags")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tags: &'a Option<Vec<String>>,
        }
        let CreateFineTuningJobRequestIntegrationWandb {
            project,
            name,
            entity,
            tags,
        } = self;
        _S {
            project,
            name,
            entity,
            tags,
        }
        .serialize(serializer)
    }
}
#[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequestIntegrationWandb {
    #[doc = "The name of the project that the new run will be created under.\n"]
    pub project: String,
    #[doc = "A display name to set for the run. If not set, we will use the Job ID as the name.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The entity to use for the run. This allows you to set the team or username of the WandB user that you would\nlike associated with the run. If not set, the default entity for the registered WandB API key is used.\n"]
    #[builder(default)]
    pub entity: Option<String>,
    #[doc = "A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some\ndefault tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n"]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestIntegration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateFineTuningJobRequestIntegrationType,
            #[serde(rename = "wandb")]
            #[allow(dead_code)]
            wandb: CreateFineTuningJobRequestIntegrationWandb,
        }
        let _D { type_, wandb, .. } = _D::deserialize(deserializer)?;
        Ok(CreateFineTuningJobRequestIntegration { type_, wandb })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestIntegration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateFineTuningJobRequestIntegrationType,
            #[serde(rename = "wandb")]
            wandb: &'a CreateFineTuningJobRequestIntegrationWandb,
        }
        let CreateFineTuningJobRequestIntegration { type_, wandb } = self;
        _S { type_, wandb }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequestIntegration {
    #[doc = "The type of integration to enable. Currently, only \"wandb\" (Weights and Biases) is supported.\n"]
    pub type_: CreateFineTuningJobRequestIntegrationType,
    #[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
    pub wandb: CreateFineTuningJobRequestIntegrationWandb,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "training_file")]
            #[allow(dead_code)]
            training_file: String,
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: Option<CreateFineTuningJobRequestHyperparameters>,
            #[serde(rename = "suffix")]
            #[allow(dead_code)]
            suffix: Option<String>,
            #[serde(rename = "validation_file")]
            #[allow(dead_code)]
            validation_file: Option<String>,
            #[serde(rename = "integrations")]
            #[allow(dead_code)]
            integrations: Option<Vec<CreateFineTuningJobRequestIntegration>>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
            #[serde(rename = "method")]
            #[allow(dead_code)]
            method: Option<FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            model,
            training_file,
            hyperparameters,
            suffix,
            validation_file,
            integrations,
            seed,
            method,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateFineTuningJobRequest {
            model,
            training_file,
            hyperparameters,
            suffix,
            validation_file,
            integrations,
            seed,
            method,
            metadata,
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "training_file")]
            training_file: &'a String,
            #[serde(rename = "hyperparameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            hyperparameters: &'a Option<CreateFineTuningJobRequestHyperparameters>,
            #[serde(rename = "suffix")]
            #[serde(skip_serializing_if = "Option::is_none")]
            suffix: &'a Option<String>,
            #[serde(rename = "validation_file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            validation_file: &'a Option<String>,
            #[serde(rename = "integrations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            integrations: &'a Option<Vec<CreateFineTuningJobRequestIntegration>>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
            #[serde(rename = "method")]
            #[serde(skip_serializing_if = "Option::is_none")]
            method: &'a Option<FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let CreateFineTuningJobRequest {
            model,
            training_file,
            hyperparameters,
            suffix,
            validation_file,
            integrations,
            seed,
            method,
            metadata,
        } = self;
        _S {
            model,
            training_file,
            hyperparameters,
            suffix,
            validation_file,
            integrations,
            seed,
            method,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequest {
    #[doc = "The name of the model to fine-tune. You can select one of the\n[supported models](/docs/guides/fine-tuning#which-models-can-be-fine-tuned).\n"]
    pub model: String,
    #[doc = "The ID of an uploaded file that contains training data.\n\nSee [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.\n\nYour dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.\n\nThe contents of the file should differ depending on if the model uses the [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input), [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](https://platform.openai.com/docs/api-reference/fine-tuning/preference-input) format.\n\nSee the [fine-tuning guide](/docs/guides/fine-tuning) for more details.\n"]
    pub training_file: String,
    #[doc = "The hyperparameters used for the fine-tuning job.\nThis value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.\n"]
    #[builder(default)]
    pub hyperparameters: Option<CreateFineTuningJobRequestHyperparameters>,
    #[doc = "A string of up to 64 characters that will be added to your fine-tuned model name.\n\nFor example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.\n"]
    #[builder(default)]
    pub suffix: Option<String>,
    #[doc = "The ID of an uploaded file that contains validation data.\n\nIf you provide this file, the data is used to generate validation\nmetrics periodically during fine-tuning. These metrics can be viewed in\nthe fine-tuning results file.\nThe same data should not be present in both train and validation files.\n\nYour dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.\n\nSee the [fine-tuning guide](/docs/guides/fine-tuning) for more details.\n"]
    #[builder(default)]
    pub validation_file: Option<String>,
    #[doc = "A list of integrations to enable for your fine-tuning job."]
    #[builder(default)]
    pub integrations: Option<Vec<CreateFineTuningJobRequestIntegration>>,
    #[doc = "The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.\nIf a seed is not specified, one will be generated for you.\n"]
    #[builder(default)]
    pub seed: Option<u64>,
    #[builder(default)]
    pub method: Option<FineTuneMethod>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Bytes(
                #[serde_as(as = "serde_with::base64::Base64")]
                #[allow(dead_code)]
                Vec<u8>,
            ),
            Array(
                #[serde_as(as = "Vec<serde_with::base64::Base64>")]
                #[allow(dead_code)]
                Vec<Vec<u8>>,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Bytes(_v) => Self::Bytes(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for CreateImageEditRequestImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Bytes(
                #[serde_as(as = "serde_with::base64::Base64")]
                #[allow(dead_code)]
                &'a Vec<u8>,
            ),
            Array(
                #[serde_as(as = "Vec<serde_with::base64::Base64>")]
                #[allow(dead_code)]
                &'a Vec<Vec<u8>>,
            ),
        }
        match self {
            Self::Bytes(_v) => _S::Bytes(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The image(s) to edit. Must be a supported image file or an array of images.\n\nFor `gpt-image-1`, each image should be a `png`, `webp`, or `jpg` file less \nthan 25MB. You can provide up to 16 images.\n\nFor `dall-e-2`, you can only provide one image, and it should be a square \n`png` file less than 4MB.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestImage {
    Bytes(Vec<u8>),
    Array(Vec<Vec<u8>>),
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            _256x256(#[allow(dead_code)] CreateImageEditRequestSize256x256),
            _512x512(#[allow(dead_code)] CreateImageEditRequestSize512x512),
            _1024x1024(#[allow(dead_code)] CreateImageEditRequestSize1024x1024),
            _1536x1024(#[allow(dead_code)] CreateImageEditRequestSize1536x1024),
            _1024x1536(#[allow(dead_code)] CreateImageEditRequestSize1024x1536),
            Auto(#[allow(dead_code)] CreateImageEditRequestSizeAuto),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::_256x256(_) => Self::_256x256,
            _D::_512x512(_) => Self::_512x512,
            _D::_1024x1024(_) => Self::_1024x1024,
            _D::_1536x1024(_) => Self::_1536x1024,
            _D::_1024x1536(_) => Self::_1024x1536,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for CreateImageEditRequestSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            _256x256(#[allow(dead_code)] &'a CreateImageEditRequestSize256x256),
            _512x512(#[allow(dead_code)] &'a CreateImageEditRequestSize512x512),
            _1024x1024(#[allow(dead_code)] &'a CreateImageEditRequestSize1024x1024),
            _1536x1024(#[allow(dead_code)] &'a CreateImageEditRequestSize1536x1024),
            _1024x1536(#[allow(dead_code)] &'a CreateImageEditRequestSize1024x1536),
            Auto(#[allow(dead_code)] &'a CreateImageEditRequestSizeAuto),
        }
        match self {
            Self::_256x256 => _S::_256x256(&Default::default()).serialize(serializer),
            Self::_512x512 => _S::_512x512(&Default::default()).serialize(serializer),
            Self::_1024x1024 => _S::_1024x1024(&Default::default()).serialize(serializer),
            Self::_1536x1024 => _S::_1536x1024(&Default::default()).serialize(serializer),
            Self::_1024x1536 => _S::_1024x1536(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, and one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestSize {
    #[doc = "256x256"]
    _256x256,
    #[doc = "512x512"]
    _512x512,
    #[doc = "1024x1024"]
    #[default]
    _1024x1024,
    #[doc = "1536x1024"]
    _1536x1024,
    #[doc = "1024x1536"]
    _1024x1536,
    #[doc = "auto"]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Url(#[allow(dead_code)] CreateImageEditRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] CreateImageEditRequestResponseFormatB64Json),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Url(_) => Self::Url,
            _D::B64Json(_) => Self::B64Json,
        })
    }
}
impl serde::Serialize for CreateImageEditRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Url(#[allow(dead_code)] &'a CreateImageEditRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] &'a CreateImageEditRequestResponseFormatB64Json),
        }
        match self {
            Self::Url => _S::Url(&Default::default()).serialize(serializer),
            Self::B64Json => _S::B64Json(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter is only supported for `dall-e-2`, as `gpt-image-1` will always return base64-encoded images."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestResponseFormat {
    #[doc = "url"]
    #[default]
    Url,
    #[doc = "b64_json"]
    B64Json,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestQuality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityStandard {
            #[default]
            #[serde(rename = "standard")]
            Standard,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Standard(#[allow(dead_code)] CreateImageEditRequestQualityStandard),
            Low(#[allow(dead_code)] CreateImageEditRequestQualityLow),
            Medium(#[allow(dead_code)] CreateImageEditRequestQualityMedium),
            High(#[allow(dead_code)] CreateImageEditRequestQualityHigh),
            Auto(#[allow(dead_code)] CreateImageEditRequestQualityAuto),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Standard(_) => Self::Standard,
            _D::Low(_) => Self::Low,
            _D::Medium(_) => Self::Medium,
            _D::High(_) => Self::High,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for CreateImageEditRequestQuality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityStandard {
            #[default]
            #[serde(rename = "standard")]
            Standard,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Standard(#[allow(dead_code)] &'a CreateImageEditRequestQualityStandard),
            Low(#[allow(dead_code)] &'a CreateImageEditRequestQualityLow),
            Medium(#[allow(dead_code)] &'a CreateImageEditRequestQualityMedium),
            High(#[allow(dead_code)] &'a CreateImageEditRequestQualityHigh),
            Auto(#[allow(dead_code)] &'a CreateImageEditRequestQualityAuto),
        }
        match self {
            Self::Standard => _S::Standard(&Default::default()).serialize(serializer),
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Medium => _S::Medium(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The quality of the image that will be generated. `high`, `medium` and `low` are only supported for `gpt-image-1`. `dall-e-2` only supports `standard` quality. Defaults to `auto`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestQuality {
    #[doc = "standard"]
    Standard,
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "image")]
            #[allow(dead_code)]
            image: CreateImageEditRequestImage,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: String,
            #[serde_as(as = "Option<serde_with::base64::Base64>")]
            #[serde(rename = "mask")]
            #[allow(dead_code)]
            mask: Option<Vec<u8>>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<CreateImageEditRequestSize>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateImageEditRequestResponseFormat>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
            #[serde(rename = "quality")]
            #[allow(dead_code)]
            quality: Option<CreateImageEditRequestQuality>,
        }
        let _D {
            image,
            prompt,
            mask,
            model,
            n,
            size,
            response_format,
            user,
            quality,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateImageEditRequest {
            image,
            prompt,
            mask,
            model,
            n,
            size,
            response_format,
            user,
            quality,
        })
    }
}
impl serde::Serialize for CreateImageEditRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "image")]
            image: &'a CreateImageEditRequestImage,
            #[serde(rename = "prompt")]
            prompt: &'a String,
            #[serde_as(as = "Option<serde_with::base64::Base64>")]
            #[serde(rename = "mask")]
            #[serde(skip_serializing_if = "Option::is_none")]
            mask: &'a Option<Vec<u8>>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<CreateImageEditRequestSize>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateImageEditRequestResponseFormat>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            quality: &'a Option<CreateImageEditRequestQuality>,
        }
        let CreateImageEditRequest {
            image,
            prompt,
            mask,
            model,
            n,
            size,
            response_format,
            user,
            quality,
        } = self;
        _S {
            image,
            prompt,
            mask,
            model,
            n,
            size,
            response_format,
            user,
            quality,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateImageEditRequest {
    #[doc = "The image(s) to edit. Must be a supported image file or an array of images.\n\nFor `gpt-image-1`, each image should be a `png`, `webp`, or `jpg` file less \nthan 25MB. You can provide up to 16 images.\n\nFor `dall-e-2`, you can only provide one image, and it should be a square \n`png` file less than 4MB.\n"]
    pub image: CreateImageEditRequestImage,
    #[doc = "A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2`, and 32000 characters for `gpt-image-1`."]
    pub prompt: String,
    #[doc = "An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where `image` should be edited. If there are multiple images provided, the mask will be applied on the first image. Must be a valid PNG file, less than 4MB, and have the same dimensions as `image`."]
    #[builder(default)]
    pub mask: Option<Vec<u8>>,
    #[doc = "The model to use for image generation. Only `dall-e-2` and `gpt-image-1` are supported. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The number of images to generate. Must be between 1 and 10."]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, and one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`."]
    #[builder(default)]
    pub size: Option<CreateImageEditRequestSize>,
    #[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter is only supported for `dall-e-2`, as `gpt-image-1` will always return base64-encoded images."]
    #[builder(default)]
    pub response_format: Option<CreateImageEditRequestResponseFormat>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
    #[doc = "The quality of the image that will be generated. `high`, `medium` and `low` are only supported for `gpt-image-1`. `dall-e-2` only supports `standard` quality. Defaults to `auto`.\n"]
    #[builder(default)]
    pub quality: Option<CreateImageEditRequestQuality>,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestQuality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityStandard {
            #[default]
            #[serde(rename = "standard")]
            Standard,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityHd {
            #[default]
            #[serde(rename = "hd")]
            Hd,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Standard(#[allow(dead_code)] CreateImageRequestQualityStandard),
            Hd(#[allow(dead_code)] CreateImageRequestQualityHd),
            Low(#[allow(dead_code)] CreateImageRequestQualityLow),
            Medium(#[allow(dead_code)] CreateImageRequestQualityMedium),
            High(#[allow(dead_code)] CreateImageRequestQualityHigh),
            Auto(#[allow(dead_code)] CreateImageRequestQualityAuto),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Standard(_) => Self::Standard,
            _D::Hd(_) => Self::Hd,
            _D::Low(_) => Self::Low,
            _D::Medium(_) => Self::Medium,
            _D::High(_) => Self::High,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for CreateImageRequestQuality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityStandard {
            #[default]
            #[serde(rename = "standard")]
            Standard,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityHd {
            #[default]
            #[serde(rename = "hd")]
            Hd,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Standard(#[allow(dead_code)] &'a CreateImageRequestQualityStandard),
            Hd(#[allow(dead_code)] &'a CreateImageRequestQualityHd),
            Low(#[allow(dead_code)] &'a CreateImageRequestQualityLow),
            Medium(#[allow(dead_code)] &'a CreateImageRequestQualityMedium),
            High(#[allow(dead_code)] &'a CreateImageRequestQualityHigh),
            Auto(#[allow(dead_code)] &'a CreateImageRequestQualityAuto),
        }
        match self {
            Self::Standard => _S::Standard(&Default::default()).serialize(serializer),
            Self::Hd => _S::Hd(&Default::default()).serialize(serializer),
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Medium => _S::Medium(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The quality of the image that will be generated. \n\n- `auto` (default value) will automatically select the best quality for the given model.\n- `high`, `medium` and `low` are supported for `gpt-image-1`.\n- `hd` and `standard` are supported for `dall-e-3`.\n- `standard` is the only option for `dall-e-2`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestQuality {
    #[doc = "standard"]
    Standard,
    #[doc = "hd"]
    Hd,
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Url(#[allow(dead_code)] CreateImageRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] CreateImageRequestResponseFormatB64Json),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Url(_) => Self::Url,
            _D::B64Json(_) => Self::B64Json,
        })
    }
}
impl serde::Serialize for CreateImageRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Url(#[allow(dead_code)] &'a CreateImageRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] &'a CreateImageRequestResponseFormatB64Json),
        }
        match self {
            Self::Url => _S::Url(&Default::default()).serialize(serializer),
            Self::B64Json => _S::B64Json(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestResponseFormat {
    #[doc = "url"]
    #[default]
    Url,
    #[doc = "b64_json"]
    B64Json,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestOutputFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatPng {
            #[default]
            #[serde(rename = "png")]
            Png,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatJpeg {
            #[default]
            #[serde(rename = "jpeg")]
            Jpeg,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatWebp {
            #[default]
            #[serde(rename = "webp")]
            Webp,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Png(#[allow(dead_code)] CreateImageRequestOutputFormatPng),
            Jpeg(#[allow(dead_code)] CreateImageRequestOutputFormatJpeg),
            Webp(#[allow(dead_code)] CreateImageRequestOutputFormatWebp),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Png(_) => Self::Png,
            _D::Jpeg(_) => Self::Jpeg,
            _D::Webp(_) => Self::Webp,
        })
    }
}
impl serde::Serialize for CreateImageRequestOutputFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatPng {
            #[default]
            #[serde(rename = "png")]
            Png,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatJpeg {
            #[default]
            #[serde(rename = "jpeg")]
            Jpeg,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatWebp {
            #[default]
            #[serde(rename = "webp")]
            Webp,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Png(#[allow(dead_code)] &'a CreateImageRequestOutputFormatPng),
            Jpeg(#[allow(dead_code)] &'a CreateImageRequestOutputFormatJpeg),
            Webp(#[allow(dead_code)] &'a CreateImageRequestOutputFormatWebp),
        }
        match self {
            Self::Png => _S::Png(&Default::default()).serialize(serializer),
            Self::Jpeg => _S::Jpeg(&Default::default()).serialize(serializer),
            Self::Webp => _S::Webp(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format in which the generated images are returned. This parameter is only supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestOutputFormat {
    #[doc = "png"]
    #[default]
    Png,
    #[doc = "jpeg"]
    Jpeg,
    #[doc = "webp"]
    Webp,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1792x1024 {
            #[default]
            #[serde(rename = "1792x1024")]
            _1792x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1792 {
            #[default]
            #[serde(rename = "1024x1792")]
            _1024x1792,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] CreateImageRequestSizeAuto),
            _1024x1024(#[allow(dead_code)] CreateImageRequestSize1024x1024),
            _1536x1024(#[allow(dead_code)] CreateImageRequestSize1536x1024),
            _1024x1536(#[allow(dead_code)] CreateImageRequestSize1024x1536),
            _256x256(#[allow(dead_code)] CreateImageRequestSize256x256),
            _512x512(#[allow(dead_code)] CreateImageRequestSize512x512),
            _1792x1024(#[allow(dead_code)] CreateImageRequestSize1792x1024),
            _1024x1792(#[allow(dead_code)] CreateImageRequestSize1024x1792),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::_1024x1024(_) => Self::_1024x1024,
            _D::_1536x1024(_) => Self::_1536x1024,
            _D::_1024x1536(_) => Self::_1024x1536,
            _D::_256x256(_) => Self::_256x256,
            _D::_512x512(_) => Self::_512x512,
            _D::_1792x1024(_) => Self::_1792x1024,
            _D::_1024x1792(_) => Self::_1024x1792,
        })
    }
}
impl serde::Serialize for CreateImageRequestSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1792x1024 {
            #[default]
            #[serde(rename = "1792x1024")]
            _1792x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1792 {
            #[default]
            #[serde(rename = "1024x1792")]
            _1024x1792,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a CreateImageRequestSizeAuto),
            _1024x1024(#[allow(dead_code)] &'a CreateImageRequestSize1024x1024),
            _1536x1024(#[allow(dead_code)] &'a CreateImageRequestSize1536x1024),
            _1024x1536(#[allow(dead_code)] &'a CreateImageRequestSize1024x1536),
            _256x256(#[allow(dead_code)] &'a CreateImageRequestSize256x256),
            _512x512(#[allow(dead_code)] &'a CreateImageRequestSize512x512),
            _1792x1024(#[allow(dead_code)] &'a CreateImageRequestSize1792x1024),
            _1024x1792(#[allow(dead_code)] &'a CreateImageRequestSize1024x1792),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::_1024x1024 => _S::_1024x1024(&Default::default()).serialize(serializer),
            Self::_1536x1024 => _S::_1536x1024(&Default::default()).serialize(serializer),
            Self::_1024x1536 => _S::_1024x1536(&Default::default()).serialize(serializer),
            Self::_256x256 => _S::_256x256(&Default::default()).serialize(serializer),
            Self::_512x512 => _S::_512x512(&Default::default()).serialize(serializer),
            Self::_1792x1024 => _S::_1792x1024(&Default::default()).serialize(serializer),
            Self::_1024x1792 => _S::_1024x1792(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestSize {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "1024x1024"]
    _1024x1024,
    #[doc = "1536x1024"]
    _1536x1024,
    #[doc = "1024x1536"]
    _1024x1536,
    #[doc = "256x256"]
    _256x256,
    #[doc = "512x512"]
    _512x512,
    #[doc = "1792x1024"]
    _1792x1024,
    #[doc = "1024x1792"]
    _1024x1792,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestModeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestModerationLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestModerationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Low(#[allow(dead_code)] CreateImageRequestModerationLow),
            Auto(#[allow(dead_code)] CreateImageRequestModerationAuto),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Low(_) => Self::Low,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for CreateImageRequestModeration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestModerationLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestModerationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Low(#[allow(dead_code)] &'a CreateImageRequestModerationLow),
            Auto(#[allow(dead_code)] &'a CreateImageRequestModerationAuto),
        }
        match self {
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` for less restrictive filtering or `auto` (default value)."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestModeration {
    #[doc = "low"]
    Low,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestBackground {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundTransparent {
            #[default]
            #[serde(rename = "transparent")]
            Transparent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundOpaque {
            #[default]
            #[serde(rename = "opaque")]
            Opaque,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Transparent(#[allow(dead_code)] CreateImageRequestBackgroundTransparent),
            Opaque(#[allow(dead_code)] CreateImageRequestBackgroundOpaque),
            Auto(#[allow(dead_code)] CreateImageRequestBackgroundAuto),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Transparent(_) => Self::Transparent,
            _D::Opaque(_) => Self::Opaque,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for CreateImageRequestBackground {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundTransparent {
            #[default]
            #[serde(rename = "transparent")]
            Transparent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundOpaque {
            #[default]
            #[serde(rename = "opaque")]
            Opaque,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Transparent(#[allow(dead_code)] &'a CreateImageRequestBackgroundTransparent),
            Opaque(#[allow(dead_code)] &'a CreateImageRequestBackgroundOpaque),
            Auto(#[allow(dead_code)] &'a CreateImageRequestBackgroundAuto),
        }
        match self {
            Self::Transparent => _S::Transparent(&Default::default()).serialize(serializer),
            Self::Opaque => _S::Opaque(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestBackground {
    #[doc = "transparent"]
    Transparent,
    #[doc = "opaque"]
    Opaque,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestStyle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestStyleVivid {
            #[default]
            #[serde(rename = "vivid")]
            Vivid,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestStyleNatural {
            #[default]
            #[serde(rename = "natural")]
            Natural,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Vivid(#[allow(dead_code)] CreateImageRequestStyleVivid),
            Natural(#[allow(dead_code)] CreateImageRequestStyleNatural),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Vivid(_) => Self::Vivid,
            _D::Natural(_) => Self::Natural,
        })
    }
}
impl serde::Serialize for CreateImageRequestStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestStyleVivid {
            #[default]
            #[serde(rename = "vivid")]
            Vivid,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestStyleNatural {
            #[default]
            #[serde(rename = "natural")]
            Natural,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Vivid(#[allow(dead_code)] &'a CreateImageRequestStyleVivid),
            Natural(#[allow(dead_code)] &'a CreateImageRequestStyleNatural),
        }
        match self {
            Self::Vivid => _S::Vivid(&Default::default()).serialize(serializer),
            Self::Natural => _S::Natural(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestStyle {
    #[doc = "vivid"]
    #[default]
    Vivid,
    #[doc = "natural"]
    Natural,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "quality")]
            #[allow(dead_code)]
            quality: Option<CreateImageRequestQuality>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateImageRequestResponseFormat>,
            #[serde(rename = "output_format")]
            #[allow(dead_code)]
            output_format: Option<CreateImageRequestOutputFormat>,
            #[serde(rename = "output_compression")]
            #[allow(dead_code)]
            output_compression: Option<u64>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<CreateImageRequestSize>,
            #[serde(rename = "moderation")]
            #[allow(dead_code)]
            moderation: Option<CreateImageRequestModeration>,
            #[serde(rename = "background")]
            #[allow(dead_code)]
            background: Option<CreateImageRequestBackground>,
            #[serde(rename = "style")]
            #[allow(dead_code)]
            style: Option<CreateImageRequestStyle>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let _D {
            prompt,
            model,
            n,
            quality,
            response_format,
            output_format,
            output_compression,
            size,
            moderation,
            background,
            style,
            user,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateImageRequest {
            prompt,
            model,
            n,
            quality,
            response_format,
            output_format,
            output_compression,
            size,
            moderation,
            background,
            style,
            user,
        })
    }
}
impl serde::Serialize for CreateImageRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "prompt")]
            prompt: &'a String,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            quality: &'a Option<CreateImageRequestQuality>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateImageRequestResponseFormat>,
            #[serde(rename = "output_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_format: &'a Option<CreateImageRequestOutputFormat>,
            #[serde(rename = "output_compression")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_compression: &'a Option<u64>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<CreateImageRequestSize>,
            #[serde(rename = "moderation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            moderation: &'a Option<CreateImageRequestModeration>,
            #[serde(rename = "background")]
            #[serde(skip_serializing_if = "Option::is_none")]
            background: &'a Option<CreateImageRequestBackground>,
            #[serde(rename = "style")]
            #[serde(skip_serializing_if = "Option::is_none")]
            style: &'a Option<CreateImageRequestStyle>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let CreateImageRequest {
            prompt,
            model,
            n,
            quality,
            response_format,
            output_format,
            output_compression,
            size,
            moderation,
            background,
            style,
            user,
        } = self;
        _S {
            prompt,
            model,
            n,
            quality,
            response_format,
            output_format,
            output_compression,
            size,
            moderation,
            background,
            style,
            user,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateImageRequest {
    #[doc = "A text description of the desired image(s). The maximum length is 32000 characters for `gpt-image-1`, 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`."]
    pub prompt: String,
    #[doc = "The model to use for image generation. One of `dall-e-2`, `dall-e-3`, or `gpt-image-1`. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported."]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "The quality of the image that will be generated. \n\n- `auto` (default value) will automatically select the best quality for the given model.\n- `high`, `medium` and `low` are supported for `gpt-image-1`.\n- `hd` and `standard` are supported for `dall-e-3`.\n- `standard` is the only option for `dall-e-2`.\n"]
    #[builder(default)]
    pub quality: Option<CreateImageRequestQuality>,
    #[doc = "The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."]
    #[builder(default)]
    pub response_format: Option<CreateImageRequestResponseFormat>,
    #[doc = "The format in which the generated images are returned. This parameter is only supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`."]
    #[builder(default)]
    pub output_format: Option<CreateImageRequestOutputFormat>,
    #[doc = "The compression level (0-100%) for the generated images. This parameter is only supported for `gpt-image-1` with the `webp` or `jpeg` output formats, and defaults to 100."]
    #[builder(default)]
    pub output_compression: Option<u64>,
    #[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`."]
    #[builder(default)]
    pub size: Option<CreateImageRequestSize>,
    #[doc = "Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` for less restrictive filtering or `auto` (default value)."]
    #[builder(default)]
    pub moderation: Option<CreateImageRequestModeration>,
    #[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
    #[builder(default)]
    pub background: Option<CreateImageRequestBackground>,
    #[doc = "The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images."]
    #[builder(default)]
    pub style: Option<CreateImageRequestStyle>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateImageVariationRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Url(#[allow(dead_code)] CreateImageVariationRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] CreateImageVariationRequestResponseFormatB64Json),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Url(_) => Self::Url,
            _D::B64Json(_) => Self::B64Json,
        })
    }
}
impl serde::Serialize for CreateImageVariationRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Url(#[allow(dead_code)] &'a CreateImageVariationRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] &'a CreateImageVariationRequestResponseFormatB64Json),
        }
        match self {
            Self::Url => _S::Url(&Default::default()).serialize(serializer),
            Self::B64Json => _S::B64Json(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageVariationRequestResponseFormat {
    #[doc = "url"]
    #[default]
    Url,
    #[doc = "b64_json"]
    B64Json,
}
impl<'de> serde::Deserialize<'de> for CreateImageVariationRequestSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            _256x256(#[allow(dead_code)] CreateImageVariationRequestSize256x256),
            _512x512(#[allow(dead_code)] CreateImageVariationRequestSize512x512),
            _1024x1024(#[allow(dead_code)] CreateImageVariationRequestSize1024x1024),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::_256x256(_) => Self::_256x256,
            _D::_512x512(_) => Self::_512x512,
            _D::_1024x1024(_) => Self::_1024x1024,
        })
    }
}
impl serde::Serialize for CreateImageVariationRequestSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            _256x256(#[allow(dead_code)] &'a CreateImageVariationRequestSize256x256),
            _512x512(#[allow(dead_code)] &'a CreateImageVariationRequestSize512x512),
            _1024x1024(#[allow(dead_code)] &'a CreateImageVariationRequestSize1024x1024),
        }
        match self {
            Self::_256x256 => _S::_256x256(&Default::default()).serialize(serializer),
            Self::_512x512 => _S::_512x512(&Default::default()).serialize(serializer),
            Self::_1024x1024 => _S::_1024x1024(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageVariationRequestSize {
    #[doc = "256x256"]
    _256x256,
    #[doc = "512x512"]
    _512x512,
    #[doc = "1024x1024"]
    #[default]
    _1024x1024,
}
impl<'de> serde::Deserialize<'de> for CreateImageVariationRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "image")]
            #[allow(dead_code)]
            image: Vec<u8>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateImageVariationRequestResponseFormat>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<CreateImageVariationRequestSize>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let _D {
            image,
            model,
            n,
            response_format,
            size,
            user,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateImageVariationRequest {
            image,
            model,
            n,
            response_format,
            size,
            user,
        })
    }
}
impl serde::Serialize for CreateImageVariationRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "image")]
            image: &'a Vec<u8>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateImageVariationRequestResponseFormat>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<CreateImageVariationRequestSize>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let CreateImageVariationRequest {
            image,
            model,
            n,
            response_format,
            size,
            user,
        } = self;
        _S {
            image,
            model,
            n,
            response_format,
            size,
            user,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateImageVariationRequest {
    #[doc = "The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square."]
    pub image: Vec<u8>,
    #[doc = "The model to use for image generation. Only `dall-e-2` is supported at this time."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The number of images to generate. Must be between 1 and 10."]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."]
    #[builder(default)]
    pub response_format: Option<CreateImageVariationRequestResponseFormat>,
    #[doc = "The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."]
    #[builder(default)]
    pub size: Option<CreateImageVariationRequestSize>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateMessageRequestRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateMessageRequestRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] CreateMessageRequestRoleUser),
            Assistant(#[allow(dead_code)] CreateMessageRequestRoleAssistant),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
        })
    }
}
impl serde::Serialize for CreateMessageRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateMessageRequestRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateMessageRequestRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a CreateMessageRequestRoleUser),
            Assistant(#[allow(dead_code)] &'a CreateMessageRequestRoleAssistant),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the entity that is creating the message. Allowed values include:\n- `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.\n- `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateMessageRequestRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestContentArray {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ImageFile(#[allow(dead_code)] MessageContentImageFileObject),
            ImageUrl(#[allow(dead_code)] MessageContentImageUrlObject),
            Text(#[allow(dead_code)] MessageRequestContentTextObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ImageFile(_v) => Self::ImageFile(_v),
            _D::ImageUrl(_v) => Self::ImageUrl(_v),
            _D::Text(_v) => Self::Text(_v),
        })
    }
}
impl serde::Serialize for CreateMessageRequestContentArray {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ImageFile(#[allow(dead_code)] &'a MessageContentImageFileObject),
            ImageUrl(#[allow(dead_code)] &'a MessageContentImageUrlObject),
            Text(#[allow(dead_code)] &'a MessageRequestContentTextObject),
        }
        match self {
            Self::ImageFile(_v) => _S::ImageFile(_v).serialize(serializer),
            Self::ImageUrl(_v) => _S::ImageUrl(_v).serialize(serializer),
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateMessageRequestContentArray {
    ImageFile(MessageContentImageFileObject),
    ImageUrl(MessageContentImageUrlObject),
    Text(MessageRequestContentTextObject),
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<CreateMessageRequestContentArray>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for CreateMessageRequestContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<CreateMessageRequestContentArray>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateMessageRequestContent {
    #[doc = "The text contents of the message."]
    String(String),
    #[doc = "An array of content parts with a defined type, each can be of type `text` or images can be passed with `image_url` or `image_file`. Image types are only supported on [Vision-compatible models](/docs/models)."]
    Array(Vec<CreateMessageRequestContentArray>),
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestAttachmentsTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearchTypeOnly),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
        })
    }
}
impl serde::Serialize for CreateMessageRequestAttachmentsTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearchTypeOnly),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateMessageRequestAttachmentsTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearchTypeOnly),
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestAttachments {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Vec<CreateMessageRequestAttachmentsTool>,
        }
        let _D { file_id, tools, .. } = _D::deserialize(deserializer)?;
        Ok(CreateMessageRequestAttachments { file_id, tools })
    }
}
impl serde::Serialize for CreateMessageRequestAttachments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "tools")]
            tools: &'a Vec<CreateMessageRequestAttachmentsTool>,
        }
        let CreateMessageRequestAttachments { file_id, tools } = self;
        _S { file_id, tools }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateMessageRequestAttachments {
    #[doc = "The ID of the file to attach to the message."]
    pub file_id: String,
    #[doc = "The tools to add this file to."]
    pub tools: Vec<CreateMessageRequestAttachmentsTool>,
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: CreateMessageRequestRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: CreateMessageRequestContent,
            #[serde(rename = "attachments")]
            #[allow(dead_code)]
            attachments: Option<Vec<CreateMessageRequestAttachments>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            role,
            content,
            attachments,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateMessageRequest {
            role,
            content,
            attachments,
            metadata,
        })
    }
}
impl serde::Serialize for CreateMessageRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a CreateMessageRequestRole,
            #[serde(rename = "content")]
            content: &'a CreateMessageRequestContent,
            #[serde(rename = "attachments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attachments: &'a Option<Vec<CreateMessageRequestAttachments>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let CreateMessageRequest {
            role,
            content,
            attachments,
            metadata,
        } = self;
        _S {
            role,
            content,
            attachments,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateMessageRequest {
    #[doc = "The role of the entity that is creating the message. Allowed values include:\n- `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.\n- `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.\n"]
    pub role: CreateMessageRequestRole,
    pub content: CreateMessageRequestContent,
    #[doc = "A list of files attached to the message, and the tools they should be added to."]
    #[builder(default)]
    pub attachments: Option<Vec<CreateMessageRequestAttachments>>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
pub type CreateModelResponseProperties = ModelResponseProperties;
impl<'de> serde::Deserialize<'de> for CreateModerationRequestInput2ImageUrlImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
        }
        let _D { url, .. } = _D::deserialize(deserializer)?;
        Ok(CreateModerationRequestInput2ImageUrlImageUrl { url })
    }
}
impl serde::Serialize for CreateModerationRequestInput2ImageUrlImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "url")]
            url: &'a String,
        }
        let CreateModerationRequestInput2ImageUrlImageUrl { url } = self;
        _S { url }.serialize(serializer)
    }
}
#[doc = "Contains either an image URL or a data URL for a base64 encoded image."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationRequestInput2ImageUrlImageUrl {
    #[doc = "Either a URL of the image or the base64 encoded image data."]
    pub url: String,
}
impl<'de> serde::Deserialize<'de> for CreateModerationRequestInput2ImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image_url`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationRequestInput2ImageUrlType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateModerationRequestInput2ImageUrlType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: CreateModerationRequestInput2ImageUrlImageUrl,
        }
        let _D { image_url, .. } = _D::deserialize(deserializer)?;
        Ok(CreateModerationRequestInput2ImageUrl { image_url })
    }
}
impl serde::Serialize for CreateModerationRequestInput2ImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image_url`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationRequestInput2ImageUrlType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateModerationRequestInput2ImageUrlType,
            #[serde(rename = "image_url")]
            image_url: &'a CreateModerationRequestInput2ImageUrlImageUrl,
        }
        let CreateModerationRequestInput2ImageUrl { image_url } = self;
        _S {
            type_: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[doc = "An object describing an image to classify."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationRequestInput2ImageUrl {
    #[doc = "Contains either an image URL or a data URL for a base64 encoded image."]
    pub image_url: CreateModerationRequestInput2ImageUrlImageUrl,
}
impl<'de> serde::Deserialize<'de> for CreateModerationRequestInput2Text {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationRequestInput2TextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateModerationRequestInput2TextType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(CreateModerationRequestInput2Text { text })
    }
}
impl serde::Serialize for CreateModerationRequestInput2Text {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationRequestInput2TextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateModerationRequestInput2TextType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let CreateModerationRequestInput2Text { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "An object describing text to classify."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationRequestInput2Text {
    #[doc = "A string of text to classify."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for CreateModerationRequestInput2 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ImageUrl(#[allow(dead_code)] CreateModerationRequestInput2ImageUrl),
            Text(#[allow(dead_code)] CreateModerationRequestInput2Text),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ImageUrl(_v) => Self::ImageUrl(_v),
            _D::Text(_v) => Self::Text(_v),
        })
    }
}
impl serde::Serialize for CreateModerationRequestInput2 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ImageUrl(#[allow(dead_code)] &'a CreateModerationRequestInput2ImageUrl),
            Text(#[allow(dead_code)] &'a CreateModerationRequestInput2Text),
        }
        match self {
            Self::ImageUrl(_v) => _S::ImageUrl(_v).serialize(serializer),
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationRequestInput2 {
    #[doc = "An object describing an image to classify."]
    ImageUrl(CreateModerationRequestInput2ImageUrl),
    #[doc = "An object describing text to classify."]
    Text(CreateModerationRequestInput2Text),
}
impl<'de> serde::Deserialize<'de> for CreateModerationRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            ArrayOfString(#[allow(dead_code)] Vec<String>),
            _2(#[allow(dead_code)] Vec<CreateModerationRequestInput2>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::ArrayOfString(_v) => Self::ArrayOfString(_v),
            _D::_2(_v) => Self::_2(_v),
        })
    }
}
impl serde::Serialize for CreateModerationRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            ArrayOfString(#[allow(dead_code)] &'a Vec<String>),
            _2(#[allow(dead_code)] &'a Vec<CreateModerationRequestInput2>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::ArrayOfString(_v) => _S::ArrayOfString(_v).serialize(serializer),
            Self::_2(_v) => _S::_2(_v).serialize(serializer),
        }
    }
}
#[doc = "Input (or inputs) to classify. Can be a single string, an array of strings, or\nan array of multi-modal input objects similar to other models.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationRequestInput {
    #[doc = "A string of text to classify for moderation."]
    String(String),
    #[doc = "An array of strings to classify for moderation."]
    ArrayOfString(Vec<String>),
    #[doc = "An array of multi-modal inputs to the moderation model."]
    _2(Vec<CreateModerationRequestInput2>),
}
impl<'de> serde::Deserialize<'de> for CreateModerationRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: CreateModerationRequestInput,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let _D { input, model, .. } = _D::deserialize(deserializer)?;
        Ok(CreateModerationRequest { input, model })
    }
}
impl serde::Serialize for CreateModerationRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "input")]
            input: &'a CreateModerationRequestInput,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let CreateModerationRequest { input, model } = self;
        _S { input, model }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationRequest {
    #[doc = "Input (or inputs) to classify. Can be a single string, an array of strings, or\nan array of multi-modal input objects similar to other models.\n"]
    pub input: CreateModerationRequestInput,
    #[doc = "The content moderation model you would like to use. Learn more in\n[the moderation guide](/docs/guides/moderation), and learn about\navailable models [here](/docs/models#moderation).\n"]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponseResultCategories {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "hate")]
            #[allow(dead_code)]
            hate: bool,
            #[serde(rename = "hate/threatening")]
            #[allow(dead_code)]
            hate_threatening: bool,
            #[serde(rename = "harassment")]
            #[allow(dead_code)]
            harassment: bool,
            #[serde(rename = "harassment/threatening")]
            #[allow(dead_code)]
            harassment_threatening: bool,
            #[serde(rename = "illicit")]
            #[allow(dead_code)]
            illicit: Option<bool>,
            #[serde(rename = "illicit/violent")]
            #[allow(dead_code)]
            illicit_violent: Option<bool>,
            #[serde(rename = "self-harm")]
            #[allow(dead_code)]
            self_harm: bool,
            #[serde(rename = "self-harm/intent")]
            #[allow(dead_code)]
            self_harm_intent: bool,
            #[serde(rename = "self-harm/instructions")]
            #[allow(dead_code)]
            self_harm_instructions: bool,
            #[serde(rename = "sexual")]
            #[allow(dead_code)]
            sexual: bool,
            #[serde(rename = "sexual/minors")]
            #[allow(dead_code)]
            sexual_minors: bool,
            #[serde(rename = "violence")]
            #[allow(dead_code)]
            violence: bool,
            #[serde(rename = "violence/graphic")]
            #[allow(dead_code)]
            violence_graphic: bool,
        }
        let _D {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateModerationResponseResultCategories {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategories {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "hate")]
            hate: &'a bool,
            #[serde(rename = "hate/threatening")]
            hate_threatening: &'a bool,
            #[serde(rename = "harassment")]
            harassment: &'a bool,
            #[serde(rename = "harassment/threatening")]
            harassment_threatening: &'a bool,
            #[serde(rename = "illicit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            illicit: &'a Option<bool>,
            #[serde(rename = "illicit/violent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            illicit_violent: &'a Option<bool>,
            #[serde(rename = "self-harm")]
            self_harm: &'a bool,
            #[serde(rename = "self-harm/intent")]
            self_harm_intent: &'a bool,
            #[serde(rename = "self-harm/instructions")]
            self_harm_instructions: &'a bool,
            #[serde(rename = "sexual")]
            sexual: &'a bool,
            #[serde(rename = "sexual/minors")]
            sexual_minors: &'a bool,
            #[serde(rename = "violence")]
            violence: &'a bool,
            #[serde(rename = "violence/graphic")]
            violence_graphic: &'a bool,
        }
        let CreateModerationResponseResultCategories {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        } = self;
        _S {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of the categories, and whether they are flagged or not."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponseResultCategories {
    #[doc = "Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment."]
    pub hate: bool,
    #[doc = "Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste."]
    pub hate_threatening: bool,
    #[doc = "Content that expresses, incites, or promotes harassing language towards any target."]
    pub harassment: bool,
    #[doc = "Harassment content that also includes violence or serious harm towards any target."]
    pub harassment_threatening: bool,
    #[doc = "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \"how to shoplift\" would fit this category."]
    #[builder(default)]
    pub illicit: Option<bool>,
    #[doc = "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon."]
    #[builder(default)]
    pub illicit_violent: Option<bool>,
    #[doc = "Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders."]
    pub self_harm: bool,
    #[doc = "Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders."]
    pub self_harm_intent: bool,
    #[doc = "Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts."]
    pub self_harm_instructions: bool,
    #[doc = "Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness)."]
    pub sexual: bool,
    #[doc = "Sexual content that includes an individual who is under 18 years old."]
    pub sexual_minors: bool,
    #[doc = "Content that depicts death, violence, or physical injury."]
    pub violence: bool,
    #[doc = "Content that depicts death, violence, or physical injury in graphic detail."]
    pub violence_graphic: bool,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponseResultCategoryScores {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "hate")]
            #[allow(dead_code)]
            hate: f64,
            #[serde(rename = "hate/threatening")]
            #[allow(dead_code)]
            hate_threatening: f64,
            #[serde(rename = "harassment")]
            #[allow(dead_code)]
            harassment: f64,
            #[serde(rename = "harassment/threatening")]
            #[allow(dead_code)]
            harassment_threatening: f64,
            #[serde(rename = "illicit")]
            #[allow(dead_code)]
            illicit: f64,
            #[serde(rename = "illicit/violent")]
            #[allow(dead_code)]
            illicit_violent: f64,
            #[serde(rename = "self-harm")]
            #[allow(dead_code)]
            self_harm: f64,
            #[serde(rename = "self-harm/intent")]
            #[allow(dead_code)]
            self_harm_intent: f64,
            #[serde(rename = "self-harm/instructions")]
            #[allow(dead_code)]
            self_harm_instructions: f64,
            #[serde(rename = "sexual")]
            #[allow(dead_code)]
            sexual: f64,
            #[serde(rename = "sexual/minors")]
            #[allow(dead_code)]
            sexual_minors: f64,
            #[serde(rename = "violence")]
            #[allow(dead_code)]
            violence: f64,
            #[serde(rename = "violence/graphic")]
            #[allow(dead_code)]
            violence_graphic: f64,
        }
        let _D {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateModerationResponseResultCategoryScores {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryScores {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "hate")]
            hate: &'a f64,
            #[serde(rename = "hate/threatening")]
            hate_threatening: &'a f64,
            #[serde(rename = "harassment")]
            harassment: &'a f64,
            #[serde(rename = "harassment/threatening")]
            harassment_threatening: &'a f64,
            #[serde(rename = "illicit")]
            illicit: &'a f64,
            #[serde(rename = "illicit/violent")]
            illicit_violent: &'a f64,
            #[serde(rename = "self-harm")]
            self_harm: &'a f64,
            #[serde(rename = "self-harm/intent")]
            self_harm_intent: &'a f64,
            #[serde(rename = "self-harm/instructions")]
            self_harm_instructions: &'a f64,
            #[serde(rename = "sexual")]
            sexual: &'a f64,
            #[serde(rename = "sexual/minors")]
            sexual_minors: &'a f64,
            #[serde(rename = "violence")]
            violence: &'a f64,
            #[serde(rename = "violence/graphic")]
            violence_graphic: &'a f64,
        }
        let CreateModerationResponseResultCategoryScores {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        } = self;
        _S {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of the categories along with their scores as predicted by model."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponseResultCategoryScores {
    #[doc = "The score for the category 'hate'."]
    pub hate: f64,
    #[doc = "The score for the category 'hate/threatening'."]
    pub hate_threatening: f64,
    #[doc = "The score for the category 'harassment'."]
    pub harassment: f64,
    #[doc = "The score for the category 'harassment/threatening'."]
    pub harassment_threatening: f64,
    #[doc = "The score for the category 'illicit'."]
    pub illicit: f64,
    #[doc = "The score for the category 'illicit/violent'."]
    pub illicit_violent: f64,
    #[doc = "The score for the category 'self-harm'."]
    pub self_harm: f64,
    #[doc = "The score for the category 'self-harm/intent'."]
    pub self_harm_intent: f64,
    #[doc = "The score for the category 'self-harm/instructions'."]
    pub self_harm_instructions: f64,
    #[doc = "The score for the category 'sexual'."]
    pub sexual: f64,
    #[doc = "The score for the category 'sexual/minors'."]
    pub sexual_minors: f64,
    #[doc = "The score for the category 'violence'."]
    pub violence: f64,
    #[doc = "The score for the category 'violence/graphic'."]
    pub violence_graphic: f64,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesHate {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesHateThreatening {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesHarassment {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesHarassmentThreatening {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesIllicit {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesIllicitViolent {
    #[default]
    #[serde(rename = "text")]
    Text,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmImage,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Image(_) => Self::Image,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmImage,
            ),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Image => _S::Image(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentImage,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Image(_) => Self::Image,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentImage,
            ),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Image => _S::Image(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsImage,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Image(_) => Self::Image,
        })
    }
}
impl serde::Serialize
    for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text (# [allow (dead_code)] & 'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsText) , Image (# [allow (dead_code)] & 'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsImage) }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Image => _S::Image(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesSexual
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexualText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexualImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSexualText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSexualImage,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Image(_) => Self::Image,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesSexual {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexualText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexualImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSexualText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSexualImage,
            ),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Image => _S::Image(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSexual {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSexualMinors {
    #[default]
    #[serde(rename = "text")]
    Text,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesViolence
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceImage,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Image(_) => Self::Image,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesViolence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesViolenceText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesViolenceImage,
            ),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Image => _S::Image(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesViolence {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicImage,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Image(_) => Self::Image,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicImage,
            ),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Image => _S::Image(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponseResultCategoryAppliedInputTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "hate")]
            #[allow(dead_code)]
            hate: Vec<CreateModerationResponseResultCategoryAppliedInputTypesHate>,
            #[serde(rename = "hate/threatening")]
            #[allow(dead_code)]
            hate_threatening:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesHateThreatening>,
            #[serde(rename = "harassment")]
            #[allow(dead_code)]
            harassment: Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassment>,
            #[serde(rename = "harassment/threatening")]
            #[allow(dead_code)]
            harassment_threatening:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassmentThreatening>,
            #[serde(rename = "illicit")]
            #[allow(dead_code)]
            illicit: Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicit>,
            #[serde(rename = "illicit/violent")]
            #[allow(dead_code)]
            illicit_violent:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicitViolent>,
            #[serde(rename = "self-harm")]
            #[allow(dead_code)]
            self_harm: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm>,
            #[serde(rename = "self-harm/intent")]
            #[allow(dead_code)]
            self_harm_intent:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent>,
            #[serde(rename = "self-harm/instructions")]
            #[allow(dead_code)]
            self_harm_instructions:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions>,
            #[serde(rename = "sexual")]
            #[allow(dead_code)]
            sexual: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexual>,
            #[serde(rename = "sexual/minors")]
            #[allow(dead_code)]
            sexual_minors: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexualMinors>,
            #[serde(rename = "violence")]
            #[allow(dead_code)]
            violence: Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolence>,
            #[serde(rename = "violence/graphic")]
            #[allow(dead_code)]
            violence_graphic:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic>,
        }
        let _D {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateModerationResponseResultCategoryAppliedInputTypes {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "hate")]
            hate: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesHate>,
            #[serde(rename = "hate/threatening")]
            hate_threatening:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesHateThreatening>,
            #[serde(rename = "harassment")]
            harassment: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassment>,
            #[serde(rename = "harassment/threatening")]
            harassment_threatening: &'a Vec<
                CreateModerationResponseResultCategoryAppliedInputTypesHarassmentThreatening,
            >,
            #[serde(rename = "illicit")]
            illicit: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicit>,
            #[serde(rename = "illicit/violent")]
            illicit_violent:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicitViolent>,
            #[serde(rename = "self-harm")]
            self_harm: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm>,
            #[serde(rename = "self-harm/intent")]
            self_harm_intent:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent>,
            #[serde(rename = "self-harm/instructions")]
            self_harm_instructions: &'a Vec<
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions,
            >,
            #[serde(rename = "sexual")]
            sexual: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexual>,
            #[serde(rename = "sexual/minors")]
            sexual_minors:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexualMinors>,
            #[serde(rename = "violence")]
            violence: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolence>,
            #[serde(rename = "violence/graphic")]
            violence_graphic:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic>,
        }
        let CreateModerationResponseResultCategoryAppliedInputTypes {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        } = self;
        _S {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of the categories along with the input type(s) that the score applies to."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponseResultCategoryAppliedInputTypes {
    #[doc = "The applied input type(s) for the category 'hate'."]
    pub hate: Vec<CreateModerationResponseResultCategoryAppliedInputTypesHate>,
    #[doc = "The applied input type(s) for the category 'hate/threatening'."]
    pub hate_threatening:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesHateThreatening>,
    #[doc = "The applied input type(s) for the category 'harassment'."]
    pub harassment: Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassment>,
    #[doc = "The applied input type(s) for the category 'harassment/threatening'."]
    pub harassment_threatening:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassmentThreatening>,
    #[doc = "The applied input type(s) for the category 'illicit'."]
    pub illicit: Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicit>,
    #[doc = "The applied input type(s) for the category 'illicit/violent'."]
    pub illicit_violent: Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicitViolent>,
    #[doc = "The applied input type(s) for the category 'self-harm'."]
    pub self_harm: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm>,
    #[doc = "The applied input type(s) for the category 'self-harm/intent'."]
    pub self_harm_intent:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent>,
    #[doc = "The applied input type(s) for the category 'self-harm/instructions'."]
    pub self_harm_instructions:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions>,
    #[doc = "The applied input type(s) for the category 'sexual'."]
    pub sexual: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexual>,
    #[doc = "The applied input type(s) for the category 'sexual/minors'."]
    pub sexual_minors: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexualMinors>,
    #[doc = "The applied input type(s) for the category 'violence'."]
    pub violence: Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolence>,
    #[doc = "The applied input type(s) for the category 'violence/graphic'."]
    pub violence_graphic:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic>,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponseResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "flagged")]
            #[allow(dead_code)]
            flagged: bool,
            #[serde(rename = "categories")]
            #[allow(dead_code)]
            categories: CreateModerationResponseResultCategories,
            #[serde(rename = "category_scores")]
            #[allow(dead_code)]
            category_scores: CreateModerationResponseResultCategoryScores,
            #[serde(rename = "category_applied_input_types")]
            #[allow(dead_code)]
            category_applied_input_types: CreateModerationResponseResultCategoryAppliedInputTypes,
        }
        let _D {
            flagged,
            categories,
            category_scores,
            category_applied_input_types,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateModerationResponseResult {
            flagged,
            categories,
            category_scores,
            category_applied_input_types,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "flagged")]
            flagged: &'a bool,
            #[serde(rename = "categories")]
            categories: &'a CreateModerationResponseResultCategories,
            #[serde(rename = "category_scores")]
            category_scores: &'a CreateModerationResponseResultCategoryScores,
            #[serde(rename = "category_applied_input_types")]
            category_applied_input_types:
                &'a CreateModerationResponseResultCategoryAppliedInputTypes,
        }
        let CreateModerationResponseResult {
            flagged,
            categories,
            category_scores,
            category_applied_input_types,
        } = self;
        _S {
            flagged,
            categories,
            category_scores,
            category_applied_input_types,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponseResult {
    #[doc = "Whether any of the below categories are flagged."]
    pub flagged: bool,
    #[doc = "A list of the categories, and whether they are flagged or not."]
    pub categories: CreateModerationResponseResultCategories,
    #[doc = "A list of the categories along with their scores as predicted by model."]
    pub category_scores: CreateModerationResponseResultCategoryScores,
    #[doc = "A list of the categories along with the input type(s) that the score applies to."]
    pub category_applied_input_types: CreateModerationResponseResultCategoryAppliedInputTypes,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Vec<CreateModerationResponseResult>,
        }
        let _D {
            id, model, results, ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateModerationResponse { id, model, results })
    }
}
impl serde::Serialize for CreateModerationResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "results")]
            results: &'a Vec<CreateModerationResponseResult>,
        }
        let CreateModerationResponse { id, model, results } = self;
        _S { id, model, results }.serialize(serializer)
    }
}
#[doc = "Represents if a given text input is potentially harmful."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponse {
    #[doc = "The unique identifier for the moderation request."]
    pub id: String,
    #[doc = "The model used to generate the moderation results."]
    pub model: String,
    #[doc = "A list of moderation objects."]
    pub results: Vec<CreateModerationResponseResult>,
}
impl<'de> serde::Deserialize<'de> for CreateResponseInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<InputItem>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for CreateResponseInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<InputItem>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "Text, image, or file inputs to the model, used to generate a response.\n\nLearn more:\n- [Text inputs and outputs](/docs/guides/text)\n- [Image inputs](/docs/guides/images)\n- [File inputs](/docs/guides/pdf-files)\n- [Conversation state](/docs/guides/conversation-state)\n- [Function calling](/docs/guides/function-calling)\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateResponseInput {
    #[doc = "A text input to the model, equivalent to a text input with the \n`user` role.\n"]
    String(String),
    #[doc = "A list of one or many input items to the model, containing \ndifferent content types.\n"]
    Array(Vec<InputItem>),
}
impl<'de> serde::Deserialize<'de> for CreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(flatten)]
            #[allow(dead_code)]
            create_model_response_properties: CreateModelResponseProperties,
            #[serde(flatten)]
            #[allow(dead_code)]
            response_properties: ResponseProperties,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: CreateResponseInput,
            #[serde(rename = "include")]
            #[allow(dead_code)]
            include: Option<Vec<Includable>>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<bool>,
            #[serde(rename = "store")]
            #[allow(dead_code)]
            store: Option<bool>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
        }
        let _D {
            create_model_response_properties,
            response_properties,
            input,
            include,
            parallel_tool_calls,
            store,
            stream,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateResponse {
            create_model_response_properties,
            response_properties,
            input,
            include,
            parallel_tool_calls,
            store,
            stream,
        })
    }
}
impl serde::Serialize for CreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(flatten)]
            create_model_response_properties: &'a CreateModelResponseProperties,
            #[serde(flatten)]
            response_properties: &'a ResponseProperties,
            #[serde(rename = "input")]
            input: &'a CreateResponseInput,
            #[serde(rename = "include")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include: &'a Option<Vec<Includable>>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<bool>,
            #[serde(rename = "store")]
            #[serde(skip_serializing_if = "Option::is_none")]
            store: &'a Option<bool>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
        }
        let CreateResponse {
            create_model_response_properties,
            response_properties,
            input,
            include,
            parallel_tool_calls,
            store,
            stream,
        } = self;
        _S {
            create_model_response_properties,
            response_properties,
            input,
            include,
            parallel_tool_calls,
            store,
            stream,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateResponse {
    #[builder(default)]
    pub create_model_response_properties: CreateModelResponseProperties,
    #[builder(default)]
    pub response_properties: ResponseProperties,
    #[doc = "Text, image, or file inputs to the model, used to generate a response.\n\nLearn more:\n- [Text inputs and outputs](/docs/guides/text)\n- [Image inputs](/docs/guides/images)\n- [File inputs](/docs/guides/pdf-files)\n- [Conversation state](/docs/guides/conversation-state)\n- [Function calling](/docs/guides/function-calling)\n"]
    pub input: CreateResponseInput,
    #[doc = "Specify additional output data to include in the model response. Currently\nsupported values are:\n- `file_search_call.results`: Include the search results of\n  the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n"]
    #[builder(default)]
    pub include: Option<Vec<Includable>>,
    #[doc = "Whether to allow the model to run tool calls in parallel.\n"]
    #[builder(default)]
    pub parallel_tool_calls: Option<bool>,
    #[doc = "Whether to store the generated model response for later retrieval via\nAPI.\n"]
    #[builder(default)]
    pub store: Option<bool>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](https://platform.openai.com/docs/api-reference/responses-streaming)\nfor more information.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for CreateRunRequestTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearch),
            Function(#[allow(dead_code)] AssistantToolsFunction),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for CreateRunRequestTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearch),
            Function(#[allow(dead_code)] &'a AssistantToolsFunction),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateRunRequestTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearch),
    Function(AssistantToolsFunction),
}
impl<'de> serde::Deserialize<'de> for CreateRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "additional_instructions")]
            #[allow(dead_code)]
            additional_instructions: Option<String>,
            #[serde(rename = "additional_messages")]
            #[allow(dead_code)]
            additional_messages: Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<CreateRunRequestTool>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "max_prompt_tokens")]
            #[allow(dead_code)]
            max_prompt_tokens: Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[allow(dead_code)]
            truncation_strategy: Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let _D {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateRunRequest {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for CreateRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "additional_instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            additional_instructions: &'a Option<String>,
            #[serde(rename = "additional_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            additional_messages: &'a Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<CreateRunRequestTool>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let CreateRunRequest {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        _S {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateRunRequest {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    pub assistant_id: String,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[builder(default)]
    pub model: Option<String>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions."]
    #[builder(default)]
    pub additional_instructions: Option<String>,
    #[doc = "Adds additional messages to the thread before creating the run."]
    #[builder(default)]
    pub additional_messages: Option<Vec<CreateMessageRequest>>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub tools: Option<Vec<CreateRunRequestTool>>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<u64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[builder(default)]
    pub truncation_strategy: Option<TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<AssistantsApiToolChoiceOption>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for CreateSpeechRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatOpus {
            #[default]
            #[serde(rename = "opus")]
            Opus,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatAac {
            #[default]
            #[serde(rename = "aac")]
            Aac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatFlac {
            #[default]
            #[serde(rename = "flac")]
            Flac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatPcm {
            #[default]
            #[serde(rename = "pcm")]
            Pcm,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Mp3(#[allow(dead_code)] CreateSpeechRequestResponseFormatMp3),
            Opus(#[allow(dead_code)] CreateSpeechRequestResponseFormatOpus),
            Aac(#[allow(dead_code)] CreateSpeechRequestResponseFormatAac),
            Flac(#[allow(dead_code)] CreateSpeechRequestResponseFormatFlac),
            Wav(#[allow(dead_code)] CreateSpeechRequestResponseFormatWav),
            Pcm(#[allow(dead_code)] CreateSpeechRequestResponseFormatPcm),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Mp3(_) => Self::Mp3,
            _D::Opus(_) => Self::Opus,
            _D::Aac(_) => Self::Aac,
            _D::Flac(_) => Self::Flac,
            _D::Wav(_) => Self::Wav,
            _D::Pcm(_) => Self::Pcm,
        })
    }
}
impl serde::Serialize for CreateSpeechRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatOpus {
            #[default]
            #[serde(rename = "opus")]
            Opus,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatAac {
            #[default]
            #[serde(rename = "aac")]
            Aac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatFlac {
            #[default]
            #[serde(rename = "flac")]
            Flac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatPcm {
            #[default]
            #[serde(rename = "pcm")]
            Pcm,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Mp3(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatMp3),
            Opus(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatOpus),
            Aac(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatAac),
            Flac(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatFlac),
            Wav(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatWav),
            Pcm(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatPcm),
        }
        match self {
            Self::Mp3 => _S::Mp3(&Default::default()).serialize(serializer),
            Self::Opus => _S::Opus(&Default::default()).serialize(serializer),
            Self::Aac => _S::Aac(&Default::default()).serialize(serializer),
            Self::Flac => _S::Flac(&Default::default()).serialize(serializer),
            Self::Wav => _S::Wav(&Default::default()).serialize(serializer),
            Self::Pcm => _S::Pcm(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateSpeechRequestResponseFormat {
    #[doc = "mp3"]
    #[default]
    Mp3,
    #[doc = "opus"]
    Opus,
    #[doc = "aac"]
    Aac,
    #[doc = "flac"]
    Flac,
    #[doc = "wav"]
    Wav,
    #[doc = "pcm"]
    Pcm,
}
impl<'de> serde::Deserialize<'de> for CreateSpeechRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: String,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: VoiceIdsShared,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateSpeechRequestResponseFormat>,
            #[serde(rename = "speed")]
            #[allow(dead_code)]
            speed: Option<f64>,
        }
        let _D {
            model,
            input,
            instructions,
            voice,
            response_format,
            speed,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateSpeechRequest {
            model,
            input,
            instructions,
            voice,
            response_format,
            speed,
        })
    }
}
impl serde::Serialize for CreateSpeechRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            voice: &'a VoiceIdsShared,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateSpeechRequestResponseFormat>,
            #[serde(rename = "speed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            speed: &'a Option<f64>,
        }
        let CreateSpeechRequest {
            model,
            input,
            instructions,
            voice,
            response_format,
            speed,
        } = self;
        _S {
            model,
            input,
            instructions,
            voice,
            response_format,
            speed,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateSpeechRequest {
    #[doc = "One of the available [TTS models](/docs/models#tts): `tts-1`, `tts-1-hd` or `gpt-4o-mini-tts`.\n"]
    pub model: String,
    #[doc = "The text to generate audio for. The maximum length is 4096 characters."]
    pub input: String,
    #[doc = "Control the voice of your generated audio with additional instructions. Does not work with `tts-1` or `tts-1-hd`."]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice to use when generating the audio. Supported voices are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`, `onyx`, `nova`, `sage`, `shimmer`, and `verse`. Previews of the voices are available in the [Text to speech guide](/docs/guides/text-to-speech#voice-options)."]
    pub voice: VoiceIdsShared,
    #[doc = "The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`."]
    #[builder(default)]
    pub response_format: Option<CreateSpeechRequestResponseFormat>,
    #[doc = "The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default."]
    #[builder(default)]
    pub speed: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearch),
            Function(#[allow(dead_code)] AssistantToolsFunction),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearch),
            Function(#[allow(dead_code)] &'a AssistantToolsFunction),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateThreadAndRunRequestTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearch),
    Function(AssistantToolsFunction),
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let _D { file_ids, .. } = _D::deserialize(deserializer)?;
        Ok(CreateThreadAndRunRequestToolResourcesCodeInterpreter { file_ids })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let CreateThreadAndRunRequestToolResourcesCodeInterpreter { file_ids } = self;
        _S { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let _D {
            vector_store_ids, ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadAndRunRequestToolResourcesFileSearch { vector_store_ids })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let CreateThreadAndRunRequestToolResourcesFileSearch { vector_store_ids } = self;
        _S { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestToolResourcesFileSearch {
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<CreateThreadAndRunRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<CreateThreadAndRunRequestToolResourcesFileSearch>,
        }
        let _D {
            code_interpreter,
            file_search,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadAndRunRequestToolResources {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<CreateThreadAndRunRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<CreateThreadAndRunRequestToolResourcesFileSearch>,
        }
        let CreateThreadAndRunRequestToolResources {
            code_interpreter,
            file_search,
        } = self;
        _S {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<CreateThreadAndRunRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<CreateThreadAndRunRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "thread")]
            #[allow(dead_code)]
            thread: Option<CreateThreadRequest>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<CreateThreadAndRunRequestTool>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<CreateThreadAndRunRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "max_prompt_tokens")]
            #[allow(dead_code)]
            max_prompt_tokens: Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[allow(dead_code)]
            truncation_strategy: Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let _D {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadAndRunRequest {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for CreateThreadAndRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "thread")]
            #[serde(skip_serializing_if = "Option::is_none")]
            thread: &'a Option<CreateThreadRequest>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<CreateThreadAndRunRequestTool>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<CreateThreadAndRunRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let CreateThreadAndRunRequest {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        _S {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequest {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    pub assistant_id: String,
    #[builder(default)]
    pub thread: Option<CreateThreadRequest>,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub tools: Option<Vec<CreateThreadAndRunRequestTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<CreateThreadAndRunRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<u64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[builder(default)]
    pub truncation_strategy: Option<TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<AssistantsApiToolChoiceOption>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let _D { file_ids, .. } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequestToolResourcesCodeInterpreter { file_ids })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let CreateThreadRequestToolResourcesCodeInterpreter { file_ids } = self;
        _S { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {})
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_:
                &'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType,
        }
        let CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let _D {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
                max_chunk_size_tokens,
                chunk_overlap_tokens,
            },
        )
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        _S {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType,
            #[serde(rename = "static")]
            #[allow(dead_code)]
            static_:
                CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic,
        }
        let _D { static_, .. } = _D::deserialize(deserializer)?;
        Ok(
            CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
                static_,
            },
        )
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S < 'a > { # [serde (rename = "type")] type_ : & 'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] static_ : & 'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic }
        let CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
            static_,
        } = self;
        _S {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
    pub static_: CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(
                #[allow(dead_code)]
                CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_v) => Self::Auto(_v),
            _D::Static(_v) => Self::Static(_v),
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(
                #[allow(dead_code)]
                &'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                &'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic,
            ),
        }
        match self {
            Self::Auto(_v) => _S::Auto(_v).serialize(serializer),
            Self::Static(_v) => _S::Static(_v).serialize(serializer),
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy {
    #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
    Auto(CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto),
    Static(CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic),
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch0VectorStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy:
                Option<CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            file_ids,
            chunking_strategy,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequestToolResourcesFileSearch0VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch0VectorStore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy:
                &'a Option<CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let CreateThreadRequestToolResourcesFileSearch0VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        } = self;
        _S {
            file_ids,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0VectorStore {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
    #[builder(default)]
    pub chunking_strategy:
        Option<CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch0 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Vec<String>,
            #[serde(rename = "vector_stores")]
            #[allow(dead_code)]
            vector_stores: Option<Vec<CreateThreadRequestToolResourcesFileSearch0VectorStore>>,
        }
        let _D {
            vector_store_ids,
            vector_stores,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequestToolResourcesFileSearch0 {
            vector_store_ids,
            vector_stores,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            vector_store_ids: &'a Vec<String>,
            #[serde(rename = "vector_stores")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_stores: &'a Option<Vec<CreateThreadRequestToolResourcesFileSearch0VectorStore>>,
        }
        let CreateThreadRequestToolResourcesFileSearch0 {
            vector_store_ids,
            vector_stores,
        } = self;
        _S {
            vector_store_ids,
            vector_stores,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0 {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    pub vector_store_ids: Vec<String>,
    #[doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    #[builder(default)]
    pub vector_stores: Option<Vec<CreateThreadRequestToolResourcesFileSearch0VectorStore>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {})
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_:
                &'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType,
        }
        let CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let _D {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
                max_chunk_size_tokens,
                chunk_overlap_tokens,
            },
        )
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        _S {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType,
            #[serde(rename = "static")]
            #[allow(dead_code)]
            static_:
                CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic,
        }
        let _D { static_, .. } = _D::deserialize(deserializer)?;
        Ok(
            CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
                static_,
            },
        )
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S < 'a > { # [serde (rename = "type")] type_ : & 'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] static_ : & 'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic }
        let CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
            static_,
        } = self;
        _S {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
    pub static_: CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(
                #[allow(dead_code)]
                CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_v) => Self::Auto(_v),
            _D::Static(_v) => Self::Static(_v),
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(
                #[allow(dead_code)]
                &'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                &'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic,
            ),
        }
        match self {
            Self::Auto(_v) => _S::Auto(_v).serialize(serializer),
            Self::Static(_v) => _S::Static(_v).serialize(serializer),
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy {
    #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
    Auto(CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto),
    Static(CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic),
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch1VectorStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy:
                Option<CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            file_ids,
            chunking_strategy,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequestToolResourcesFileSearch1VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch1VectorStore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy:
                &'a Option<CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let CreateThreadRequestToolResourcesFileSearch1VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        } = self;
        _S {
            file_ids,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1VectorStore {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
    #[builder(default)]
    pub chunking_strategy:
        Option<CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
            #[serde(rename = "vector_stores")]
            #[allow(dead_code)]
            vector_stores: Vec<CreateThreadRequestToolResourcesFileSearch1VectorStore>,
        }
        let _D {
            vector_store_ids,
            vector_stores,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequestToolResourcesFileSearch1 {
            vector_store_ids,
            vector_stores,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch1 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
            #[serde(rename = "vector_stores")]
            vector_stores: &'a Vec<CreateThreadRequestToolResourcesFileSearch1VectorStore>,
        }
        let CreateThreadRequestToolResourcesFileSearch1 {
            vector_store_ids,
            vector_stores,
        } = self;
        _S {
            vector_store_ids,
            vector_stores,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1 {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
    #[doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    pub vector_stores: Vec<CreateThreadRequestToolResourcesFileSearch1VectorStore>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            _0(#[allow(dead_code)] CreateThreadRequestToolResourcesFileSearch0),
            _1(#[allow(dead_code)] CreateThreadRequestToolResourcesFileSearch1),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::_0(_v) => Self::_0(_v),
            _D::_1(_v) => Self::_1(_v),
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            _0(#[allow(dead_code)] &'a CreateThreadRequestToolResourcesFileSearch0),
            _1(#[allow(dead_code)] &'a CreateThreadRequestToolResourcesFileSearch1),
        }
        match self {
            Self::_0(_v) => _S::_0(_v).serialize(serializer),
            Self::_1(_v) => _S::_1(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateThreadRequestToolResourcesFileSearch {
    _0(CreateThreadRequestToolResourcesFileSearch0),
    _1(CreateThreadRequestToolResourcesFileSearch1),
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<CreateThreadRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<CreateThreadRequestToolResourcesFileSearch>,
        }
        let _D {
            code_interpreter,
            file_search,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequestToolResources {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<CreateThreadRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<CreateThreadRequestToolResourcesFileSearch>,
        }
        let CreateThreadRequestToolResources {
            code_interpreter,
            file_search,
        } = self;
        _S {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<CreateThreadRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<CreateThreadRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<CreateThreadRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            messages,
            tool_resources,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateThreadRequest {
            messages,
            tool_resources,
            metadata,
        })
    }
}
impl serde::Serialize for CreateThreadRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            messages: &'a Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<CreateThreadRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let CreateThreadRequest {
            messages,
            tool_resources,
            metadata,
        } = self;
        _S {
            messages,
            tool_resources,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Options to create a new thread. If no thread is provided when running a \nrequest, an empty thread will be created.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequest {
    #[doc = "A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with."]
    #[builder(default)]
    pub messages: Option<Vec<CreateMessageRequest>>,
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<CreateThreadRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionRequestTimestampGranularities {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranscriptionRequestTimestampGranularitiesWord {
            #[default]
            #[serde(rename = "word")]
            Word,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranscriptionRequestTimestampGranularitiesSegment {
            #[default]
            #[serde(rename = "segment")]
            Segment,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Word(#[allow(dead_code)] CreateTranscriptionRequestTimestampGranularitiesWord),
            Segment(#[allow(dead_code)] CreateTranscriptionRequestTimestampGranularitiesSegment),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Word(_) => Self::Word,
            _D::Segment(_) => Self::Segment,
        })
    }
}
impl serde::Serialize for CreateTranscriptionRequestTimestampGranularities {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranscriptionRequestTimestampGranularitiesWord {
            #[default]
            #[serde(rename = "word")]
            Word,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranscriptionRequestTimestampGranularitiesSegment {
            #[default]
            #[serde(rename = "segment")]
            Segment,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Word(#[allow(dead_code)] &'a CreateTranscriptionRequestTimestampGranularitiesWord),
            Segment(
                #[allow(dead_code)] &'a CreateTranscriptionRequestTimestampGranularitiesSegment,
            ),
        }
        match self {
            Self::Word => _S::Word(&Default::default()).serialize(serializer),
            Self::Segment => _S::Segment(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateTranscriptionRequestTimestampGranularities {
    #[doc = "word"]
    Word,
    #[doc = "segment"]
    Segment,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Vec<u8>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AudioResponseFormat>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "include[]")]
            #[allow(dead_code)]
            include: Option<Vec<TranscriptionInclude>>,
            #[serde(rename = "timestamp_granularities[]")]
            #[allow(dead_code)]
            timestamp_granularities: Option<Vec<CreateTranscriptionRequestTimestampGranularities>>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
        }
        let _D {
            file,
            model,
            language,
            prompt,
            response_format,
            temperature,
            include,
            timestamp_granularities,
            stream,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateTranscriptionRequest {
            file,
            model,
            language,
            prompt,
            response_format,
            temperature,
            include,
            timestamp_granularities,
            stream,
        })
    }
}
impl serde::Serialize for CreateTranscriptionRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            file: &'a Vec<u8>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AudioResponseFormat>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "include[]")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include: &'a Option<Vec<TranscriptionInclude>>,
            #[serde(rename = "timestamp_granularities[]")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timestamp_granularities:
                &'a Option<Vec<CreateTranscriptionRequestTimestampGranularities>>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
        }
        let CreateTranscriptionRequest {
            file,
            model,
            language,
            prompt,
            response_format,
            temperature,
            include,
            timestamp_granularities,
            stream,
        } = self;
        _S {
            file,
            model,
            language,
            prompt,
            response_format,
            temperature,
            include,
            timestamp_granularities,
            stream,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionRequest {
    #[doc = "The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n"]
    pub file: Vec<u8>,
    #[doc = "ID of the model to use. The options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1` (which is powered by our open source Whisper V2 model).\n"]
    pub model: String,
    #[doc = "The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format will improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should match the audio language.\n"]
    #[builder(default)]
    pub prompt: Option<String>,
    #[builder(default)]
    pub response_format: Option<AudioResponseFormat>,
    #[doc = "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Additional information to include in the transcription response. \n`logprobs` will return the log probabilities of the tokens in the \nresponse to understand the model's confidence in the transcription. \n`logprobs` only works with response_format set to `json` and only with \nthe models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe`.\n"]
    #[builder(default)]
    pub include: Option<Vec<TranscriptionInclude>>,
    #[doc = "The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.\n"]
    #[builder(default)]
    pub timestamp_granularities: Option<Vec<CreateTranscriptionRequestTimestampGranularities>>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format). \nSee the [Streaming section of the Speech-to-Text guide](/docs/guides/speech-to-text?lang=curl#streaming-transcriptions)\nfor more information.\n\nNote: Streaming is not supported for the `whisper-1` model and will be ignored.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionResponseJsonLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: Option<String>,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: Option<f64>,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<f64>>,
        }
        let _D {
            token,
            logprob,
            bytes,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateTranscriptionResponseJsonLogprob {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for CreateTranscriptionResponseJsonLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token: &'a Option<String>,
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprob: &'a Option<f64>,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<f64>>,
        }
        let CreateTranscriptionResponseJsonLogprob {
            token,
            logprob,
            bytes,
        } = self;
        _S {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionResponseJsonLogprob {
    #[doc = "The token in the transcription."]
    #[builder(default)]
    pub token: Option<String>,
    #[doc = "The log probability of the token."]
    #[builder(default)]
    pub logprob: Option<f64>,
    #[doc = "The bytes of the token."]
    #[builder(default)]
    pub bytes: Option<Vec<f64>>,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionResponseJson {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<CreateTranscriptionResponseJsonLogprob>>,
        }
        let _D { text, logprobs, .. } = _D::deserialize(deserializer)?;
        Ok(CreateTranscriptionResponseJson { text, logprobs })
    }
}
impl serde::Serialize for CreateTranscriptionResponseJson {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<CreateTranscriptionResponseJsonLogprob>>,
        }
        let CreateTranscriptionResponseJson { text, logprobs } = self;
        _S { text, logprobs }.serialize(serializer)
    }
}
#[doc = "Represents a transcription response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionResponseJson {
    #[doc = "The transcribed text."]
    pub text: String,
    #[doc = "The log probabilities of the tokens in the transcription. Only returned with the models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe` if `logprobs` is added to the `include` array.\n"]
    #[builder(default)]
    pub logprobs: Option<Vec<CreateTranscriptionResponseJsonLogprob>>,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionResponseStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            TranscriptTextDelta(#[allow(dead_code)] TranscriptTextDeltaEvent),
            TranscriptTextDone(#[allow(dead_code)] TranscriptTextDoneEvent),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::TranscriptTextDelta(_v) => Self::TranscriptTextDelta(_v),
            _D::TranscriptTextDone(_v) => Self::TranscriptTextDone(_v),
        })
    }
}
impl serde::Serialize for CreateTranscriptionResponseStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            TranscriptTextDelta(#[allow(dead_code)] &'a TranscriptTextDeltaEvent),
            TranscriptTextDone(#[allow(dead_code)] &'a TranscriptTextDoneEvent),
        }
        match self {
            Self::TranscriptTextDelta(_v) => _S::TranscriptTextDelta(_v).serialize(serializer),
            Self::TranscriptTextDone(_v) => _S::TranscriptTextDone(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateTranscriptionResponseStreamEvent {
    TranscriptTextDelta(TranscriptTextDeltaEvent),
    TranscriptTextDone(TranscriptTextDoneEvent),
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionResponseVerboseJson {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: String,
            #[serde(rename = "duration")]
            #[allow(dead_code)]
            duration: f64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "words")]
            #[allow(dead_code)]
            words: Option<Vec<TranscriptionWord>>,
            #[serde(rename = "segments")]
            #[allow(dead_code)]
            segments: Option<Vec<TranscriptionSegment>>,
        }
        let _D {
            language,
            duration,
            text,
            words,
            segments,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateTranscriptionResponseVerboseJson {
            language,
            duration,
            text,
            words,
            segments,
        })
    }
}
impl serde::Serialize for CreateTranscriptionResponseVerboseJson {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "language")]
            language: &'a String,
            #[serde(rename = "duration")]
            duration: &'a f64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "words")]
            #[serde(skip_serializing_if = "Option::is_none")]
            words: &'a Option<Vec<TranscriptionWord>>,
            #[serde(rename = "segments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            segments: &'a Option<Vec<TranscriptionSegment>>,
        }
        let CreateTranscriptionResponseVerboseJson {
            language,
            duration,
            text,
            words,
            segments,
        } = self;
        _S {
            language,
            duration,
            text,
            words,
            segments,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a verbose json transcription response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionResponseVerboseJson {
    #[doc = "The language of the input audio."]
    pub language: String,
    #[doc = "The duration of the input audio."]
    pub duration: f64,
    #[doc = "The transcribed text."]
    pub text: String,
    #[doc = "Extracted words and their corresponding timestamps."]
    #[builder(default)]
    pub words: Option<Vec<TranscriptionWord>>,
    #[doc = "Segments of the transcribed text and their corresponding details."]
    #[builder(default)]
    pub segments: Option<Vec<TranscriptionSegment>>,
}
impl<'de> serde::Deserialize<'de> for CreateTranslationRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatJson {
            #[default]
            #[serde(rename = "json")]
            Json,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatSrt {
            #[default]
            #[serde(rename = "srt")]
            Srt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatVerboseJson {
            #[default]
            #[serde(rename = "verbose_json")]
            VerboseJson,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatVtt {
            #[default]
            #[serde(rename = "vtt")]
            Vtt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Json(#[allow(dead_code)] CreateTranslationRequestResponseFormatJson),
            Text(#[allow(dead_code)] CreateTranslationRequestResponseFormatText),
            Srt(#[allow(dead_code)] CreateTranslationRequestResponseFormatSrt),
            VerboseJson(#[allow(dead_code)] CreateTranslationRequestResponseFormatVerboseJson),
            Vtt(#[allow(dead_code)] CreateTranslationRequestResponseFormatVtt),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Json(_) => Self::Json,
            _D::Text(_) => Self::Text,
            _D::Srt(_) => Self::Srt,
            _D::VerboseJson(_) => Self::VerboseJson,
            _D::Vtt(_) => Self::Vtt,
        })
    }
}
impl serde::Serialize for CreateTranslationRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatJson {
            #[default]
            #[serde(rename = "json")]
            Json,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatSrt {
            #[default]
            #[serde(rename = "srt")]
            Srt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatVerboseJson {
            #[default]
            #[serde(rename = "verbose_json")]
            VerboseJson,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatVtt {
            #[default]
            #[serde(rename = "vtt")]
            Vtt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Json(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatJson),
            Text(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatText),
            Srt(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatSrt),
            VerboseJson(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatVerboseJson),
            Vtt(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatVtt),
        }
        match self {
            Self::Json => _S::Json(&Default::default()).serialize(serializer),
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Srt => _S::Srt(&Default::default()).serialize(serializer),
            Self::VerboseJson => _S::VerboseJson(&Default::default()).serialize(serializer),
            Self::Vtt => _S::Vtt(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateTranslationRequestResponseFormat {
    #[doc = "json"]
    #[default]
    Json,
    #[doc = "text"]
    Text,
    #[doc = "srt"]
    Srt,
    #[doc = "verbose_json"]
    VerboseJson,
    #[doc = "vtt"]
    Vtt,
}
impl<'de> serde::Deserialize<'de> for CreateTranslationRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Vec<u8>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateTranslationRequestResponseFormat>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
        }
        let _D {
            file,
            model,
            prompt,
            response_format,
            temperature,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateTranslationRequest {
            file,
            model,
            prompt,
            response_format,
            temperature,
        })
    }
}
impl serde::Serialize for CreateTranslationRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            file: &'a Vec<u8>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateTranslationRequestResponseFormat>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
        }
        let CreateTranslationRequest {
            file,
            model,
            prompt,
            response_format,
            temperature,
        } = self;
        _S {
            file,
            model,
            prompt,
            response_format,
            temperature,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranslationRequest {
    #[doc = "The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n"]
    pub file: Vec<u8>,
    #[doc = "ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.\n"]
    pub model: String,
    #[doc = "An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text#prompting) should be in English.\n"]
    #[builder(default)]
    pub prompt: Option<String>,
    #[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.\n"]
    #[builder(default)]
    pub response_format: Option<CreateTranslationRequestResponseFormat>,
    #[doc = "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for CreateTranslationResponseJson {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(CreateTranslationResponseJson { text })
    }
}
impl serde::Serialize for CreateTranslationResponseJson {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "text")]
            text: &'a String,
        }
        let CreateTranslationResponseJson { text } = self;
        _S { text }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranslationResponseJson {
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for CreateTranslationResponseVerboseJson {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: String,
            #[serde(rename = "duration")]
            #[allow(dead_code)]
            duration: f64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "segments")]
            #[allow(dead_code)]
            segments: Option<Vec<TranscriptionSegment>>,
        }
        let _D {
            language,
            duration,
            text,
            segments,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateTranslationResponseVerboseJson {
            language,
            duration,
            text,
            segments,
        })
    }
}
impl serde::Serialize for CreateTranslationResponseVerboseJson {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "language")]
            language: &'a String,
            #[serde(rename = "duration")]
            duration: &'a f64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "segments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            segments: &'a Option<Vec<TranscriptionSegment>>,
        }
        let CreateTranslationResponseVerboseJson {
            language,
            duration,
            text,
            segments,
        } = self;
        _S {
            language,
            duration,
            text,
            segments,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranslationResponseVerboseJson {
    #[doc = "The language of the output translation (always `english`)."]
    pub language: String,
    #[doc = "The duration of the input audio."]
    pub duration: f64,
    #[doc = "The translated text."]
    pub text: String,
    #[doc = "Segments of the translated text and their corresponding details."]
    #[builder(default)]
    pub segments: Option<Vec<TranscriptionSegment>>,
}
impl<'de> serde::Deserialize<'de> for CreateUploadRequestPurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Assistants(#[allow(dead_code)] CreateUploadRequestPurposeAssistants),
            Batch(#[allow(dead_code)] CreateUploadRequestPurposeBatch),
            FineTune(#[allow(dead_code)] CreateUploadRequestPurposeFineTune),
            Vision(#[allow(dead_code)] CreateUploadRequestPurposeVision),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Assistants(_) => Self::Assistants,
            _D::Batch(_) => Self::Batch,
            _D::FineTune(_) => Self::FineTune,
            _D::Vision(_) => Self::Vision,
        })
    }
}
impl serde::Serialize for CreateUploadRequestPurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Assistants(#[allow(dead_code)] &'a CreateUploadRequestPurposeAssistants),
            Batch(#[allow(dead_code)] &'a CreateUploadRequestPurposeBatch),
            FineTune(#[allow(dead_code)] &'a CreateUploadRequestPurposeFineTune),
            Vision(#[allow(dead_code)] &'a CreateUploadRequestPurposeVision),
        }
        match self {
            Self::Assistants => _S::Assistants(&Default::default()).serialize(serializer),
            Self::Batch => _S::Batch(&Default::default()).serialize(serializer),
            Self::FineTune => _S::FineTune(&Default::default()).serialize(serializer),
            Self::Vision => _S::Vision(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The intended purpose of the uploaded file.\n\nSee the [documentation on File purposes](https://platform.openai.com/docs/api-reference/files/create#files-create-purpose).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateUploadRequestPurpose {
    #[doc = "assistants"]
    Assistants,
    #[doc = "batch"]
    Batch,
    #[doc = "fine-tune"]
    FineTune,
    #[doc = "vision"]
    Vision,
}
impl<'de> serde::Deserialize<'de> for CreateUploadRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: String,
            #[serde(rename = "purpose")]
            #[allow(dead_code)]
            purpose: CreateUploadRequestPurpose,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: u64,
            #[serde(rename = "mime_type")]
            #[allow(dead_code)]
            mime_type: String,
        }
        let _D {
            filename,
            purpose,
            bytes,
            mime_type,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateUploadRequest {
            filename,
            purpose,
            bytes,
            mime_type,
        })
    }
}
impl serde::Serialize for CreateUploadRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "purpose")]
            purpose: &'a CreateUploadRequestPurpose,
            #[serde(rename = "bytes")]
            bytes: &'a u64,
            #[serde(rename = "mime_type")]
            mime_type: &'a String,
        }
        let CreateUploadRequest {
            filename,
            purpose,
            bytes,
            mime_type,
        } = self;
        _S {
            filename,
            purpose,
            bytes,
            mime_type,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateUploadRequest {
    #[doc = "The name of the file to upload.\n"]
    pub filename: String,
    #[doc = "The intended purpose of the uploaded file.\n\nSee the [documentation on File purposes](https://platform.openai.com/docs/api-reference/files/create#files-create-purpose).\n"]
    pub purpose: CreateUploadRequestPurpose,
    #[doc = "The number of bytes in the file you are uploading.\n"]
    pub bytes: u64,
    #[doc = "The MIME type of the file.\n\nThis must fall within the supported MIME types for your file purpose. See the supported MIME types for assistants and vision.\n"]
    pub mime_type: String,
}
impl<'de> serde::Deserialize<'de> for CreateVectorStoreFileBatchRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Vec<String>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
        }
        let _D {
            file_ids,
            chunking_strategy,
            attributes,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateVectorStoreFileBatchRequest {
            file_ids,
            chunking_strategy,
            attributes,
        })
    }
}
impl serde::Serialize for CreateVectorStoreFileBatchRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            file_ids: &'a Vec<String>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
        }
        let CreateVectorStoreFileBatchRequest {
            file_ids,
            chunking_strategy,
            attributes,
        } = self;
        _S {
            file_ids,
            chunking_strategy,
            attributes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreFileBatchRequest {
    #[doc = "A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files."]
    pub file_ids: Vec<String>,
    #[builder(default)]
    pub chunking_strategy: Option<ChunkingStrategyRequestParam>,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
}
impl<'de> serde::Deserialize<'de> for CreateVectorStoreFileRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
        }
        let _D {
            file_id,
            chunking_strategy,
            attributes,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateVectorStoreFileRequest {
            file_id,
            chunking_strategy,
            attributes,
        })
    }
}
impl serde::Serialize for CreateVectorStoreFileRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
        }
        let CreateVectorStoreFileRequest {
            file_id,
            chunking_strategy,
            attributes,
        } = self;
        _S {
            file_id,
            chunking_strategy,
            attributes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreFileRequest {
    #[doc = "A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files."]
    pub file_id: String,
    #[builder(default)]
    pub chunking_strategy: Option<ChunkingStrategyRequestParam>,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
}
impl<'de> serde::Deserialize<'de> for CreateVectorStoreRequestChunkingStrategy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] AutoChunkingStrategyRequestParam),
            Static(#[allow(dead_code)] StaticChunkingStrategyRequestParam),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_v) => Self::Auto(_v),
            _D::Static(_v) => Self::Static(_v),
        })
    }
}
impl serde::Serialize for CreateVectorStoreRequestChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a AutoChunkingStrategyRequestParam),
            Static(#[allow(dead_code)] &'a StaticChunkingStrategyRequestParam),
        }
        match self {
            Self::Auto(_v) => _S::Auto(_v).serialize(serializer),
            Self::Static(_v) => _S::Static(_v).serialize(serializer),
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateVectorStoreRequestChunkingStrategy {
    Auto(AutoChunkingStrategyRequestParam),
    Static(StaticChunkingStrategyRequestParam),
}
impl<'de> serde::Deserialize<'de> for CreateVectorStoreRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "expires_after")]
            #[allow(dead_code)]
            expires_after: Option<VectorStoreExpirationAfter>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<CreateVectorStoreRequestChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            file_ids,
            name,
            expires_after,
            chunking_strategy,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(CreateVectorStoreRequest {
            file_ids,
            name,
            expires_after,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateVectorStoreRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<VectorStoreExpirationAfter>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<CreateVectorStoreRequestChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let CreateVectorStoreRequest {
            file_ids,
            name,
            expires_after,
            chunking_strategy,
            metadata,
        } = self;
        _S {
            file_ids,
            name,
            expires_after,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreRequest {
    #[doc = "A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files."]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The name of the vector store."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub expires_after: Option<VectorStoreExpirationAfter>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty."]
    #[builder(default)]
    pub chunking_strategy: Option<CreateVectorStoreRequestChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for DeleteAssistantResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteAssistantResponseObject {
            #[default]
            #[serde(rename = "assistant.deleted")]
            AssistantDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteAssistantResponseObject,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(DeleteAssistantResponse { id, deleted })
    }
}
impl serde::Serialize for DeleteAssistantResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteAssistantResponseObject {
            #[default]
            #[serde(rename = "assistant.deleted")]
            AssistantDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteAssistantResponseObject,
        }
        let DeleteAssistantResponse { id, deleted } = self;
        _S {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteAssistantResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteCertificateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, must be `certificate.deleted`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteCertificateResponseObject {
            #[default]
            #[serde(rename = "certificate.deleted")]
            CertificateDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteCertificateResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(DeleteCertificateResponse { id })
    }
}
impl serde::Serialize for DeleteCertificateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, must be `certificate.deleted`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteCertificateResponseObject {
            #[default]
            #[serde(rename = "certificate.deleted")]
            CertificateDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a DeleteCertificateResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let DeleteCertificateResponse { id } = self;
        _S {
            object: &Default::default(),
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteCertificateResponse {
    #[doc = "The ID of the certificate that was deleted."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for DeleteFileResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteFileResponseObject {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteFileResponseObject,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(DeleteFileResponse { id, deleted })
    }
}
impl serde::Serialize for DeleteFileResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteFileResponseObject {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a DeleteFileResponseObject,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let DeleteFileResponse { id, deleted } = self;
        _S {
            id,
            object: &Default::default(),
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteFileResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteFineTuningCheckpointPermissionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"checkpoint.permission\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteFineTuningCheckpointPermissionResponseObject {
            #[default]
            #[serde(rename = "checkpoint.permission")]
            CheckpointPermission,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteFineTuningCheckpointPermissionResponseObject,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(DeleteFineTuningCheckpointPermissionResponse { id, deleted })
    }
}
impl serde::Serialize for DeleteFineTuningCheckpointPermissionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"checkpoint.permission\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteFineTuningCheckpointPermissionResponseObject {
            #[default]
            #[serde(rename = "checkpoint.permission")]
            CheckpointPermission,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a DeleteFineTuningCheckpointPermissionResponseObject,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let DeleteFineTuningCheckpointPermissionResponse { id, deleted } = self;
        _S {
            id,
            object: &Default::default(),
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteFineTuningCheckpointPermissionResponse {
    #[doc = "The ID of the fine-tuned model checkpoint permission that was deleted."]
    pub id: String,
    #[doc = "Whether the fine-tuned model checkpoint permission was successfully deleted."]
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteMessageResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteMessageResponseObject {
            #[default]
            #[serde(rename = "thread.message.deleted")]
            ThreadMessageDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteMessageResponseObject,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(DeleteMessageResponse { id, deleted })
    }
}
impl serde::Serialize for DeleteMessageResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteMessageResponseObject {
            #[default]
            #[serde(rename = "thread.message.deleted")]
            ThreadMessageDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteMessageResponseObject,
        }
        let DeleteMessageResponse { id, deleted } = self;
        _S {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteMessageResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteModelResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
        }
        let _D {
            id,
            deleted,
            object,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(DeleteModelResponse {
            id,
            deleted,
            object,
        })
    }
}
impl serde::Serialize for DeleteModelResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a String,
        }
        let DeleteModelResponse {
            id,
            deleted,
            object,
        } = self;
        _S {
            id,
            deleted,
            object,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteModelResponse {
    pub id: String,
    pub deleted: bool,
    pub object: String,
}
impl<'de> serde::Deserialize<'de> for DeleteThreadResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteThreadResponseObject {
            #[default]
            #[serde(rename = "thread.deleted")]
            ThreadDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteThreadResponseObject,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(DeleteThreadResponse { id, deleted })
    }
}
impl serde::Serialize for DeleteThreadResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteThreadResponseObject {
            #[default]
            #[serde(rename = "thread.deleted")]
            ThreadDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteThreadResponseObject,
        }
        let DeleteThreadResponse { id, deleted } = self;
        _S {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteThreadResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteVectorStoreFileResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteVectorStoreFileResponseObject {
            #[default]
            #[serde(rename = "vector_store.file.deleted")]
            VectorStoreFileDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteVectorStoreFileResponseObject,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(DeleteVectorStoreFileResponse { id, deleted })
    }
}
impl serde::Serialize for DeleteVectorStoreFileResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteVectorStoreFileResponseObject {
            #[default]
            #[serde(rename = "vector_store.file.deleted")]
            VectorStoreFileDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteVectorStoreFileResponseObject,
        }
        let DeleteVectorStoreFileResponse { id, deleted } = self;
        _S {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteVectorStoreFileResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteVectorStoreResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteVectorStoreResponseObject {
            #[default]
            #[serde(rename = "vector_store.deleted")]
            VectorStoreDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteVectorStoreResponseObject,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(DeleteVectorStoreResponse { id, deleted })
    }
}
impl serde::Serialize for DeleteVectorStoreResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteVectorStoreResponseObject {
            #[default]
            #[serde(rename = "vector_store.deleted")]
            VectorStoreDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteVectorStoreResponseObject,
        }
        let DeleteVectorStoreResponse { id, deleted } = self;
        _S {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteVectorStoreResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoneEventEvent {
            #[default]
            #[serde(rename = "done")]
            Done,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoneEventData {
            #[default]
            #[serde(rename = "[DONE]")]
            Done,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: DoneEventEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: DoneEventData,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(DoneEvent {})
    }
}
impl serde::Serialize for DoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoneEventEvent {
            #[default]
            #[serde(rename = "done")]
            Done,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoneEventData {
            #[default]
            #[serde(rename = "[DONE]")]
            Done,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a DoneEventEvent,
            #[serde(rename = "data")]
            data: &'a DoneEventData,
        }
        let DoneEvent {} = self;
        _S {
            event: &Default::default(),
            data: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a stream ends."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct DoneEvent {}
impl<'de> serde::Deserialize<'de> for DoubleClick {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a double click action, this property is \nalways set to `double_click`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoubleClickType {
            #[default]
            #[serde(rename = "double_click")]
            DoubleClick,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: DoubleClickType,
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
        }
        let _D { x, y, .. } = _D::deserialize(deserializer)?;
        Ok(DoubleClick { x, y })
    }
}
impl serde::Serialize for DoubleClick {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a double click action, this property is \nalways set to `double_click`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoubleClickType {
            #[default]
            #[serde(rename = "double_click")]
            DoubleClick,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a DoubleClickType,
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
        }
        let DoubleClick { x, y } = self;
        _S {
            type_: &Default::default(),
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[doc = "A double click action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct DoubleClick {
    #[doc = "The x-coordinate where the double click occurred.\n"]
    pub x: u64,
    #[doc = "The y-coordinate where the double click occurred.\n"]
    pub y: u64,
}
impl<'de> serde::Deserialize<'de> for Drag {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a drag action, this property is \nalways set to `drag`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DragType {
            #[default]
            #[serde(rename = "drag")]
            Drag,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: DragType,
            #[serde(rename = "path")]
            #[allow(dead_code)]
            path: Vec<Coordinate>,
        }
        let _D { path, .. } = _D::deserialize(deserializer)?;
        Ok(Drag { path })
    }
}
impl serde::Serialize for Drag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a drag action, this property is \nalways set to `drag`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DragType {
            #[default]
            #[serde(rename = "drag")]
            Drag,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a DragType,
            #[serde(rename = "path")]
            path: &'a Vec<Coordinate>,
        }
        let Drag { path } = self;
        _S {
            type_: &Default::default(),
            path,
        }
        .serialize(serializer)
    }
}
#[doc = "A drag action.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Drag {
    #[doc = "An array of coordinates representing the path of the drag action. Coordinates will appear as an array\nof objects, eg\n```\n[\n  { x: 100, y: 200 },\n  { x: 200, y: 300 }\n]\n```\n"]
    pub path: Vec<Coordinate>,
}
impl<'de> serde::Deserialize<'de> for EasyInputMessageRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] EasyInputMessageRoleUser),
            Assistant(#[allow(dead_code)] EasyInputMessageRoleAssistant),
            System(#[allow(dead_code)] EasyInputMessageRoleSystem),
            Developer(#[allow(dead_code)] EasyInputMessageRoleDeveloper),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
            _D::System(_) => Self::System,
            _D::Developer(_) => Self::Developer,
        })
    }
}
impl serde::Serialize for EasyInputMessageRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a EasyInputMessageRoleUser),
            Assistant(#[allow(dead_code)] &'a EasyInputMessageRoleAssistant),
            System(#[allow(dead_code)] &'a EasyInputMessageRoleSystem),
            Developer(#[allow(dead_code)] &'a EasyInputMessageRoleDeveloper),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
            Self::System => _S::System(&Default::default()).serialize(serializer),
            Self::Developer => _S::Developer(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum EasyInputMessageRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "system"]
    System,
    #[doc = "developer"]
    Developer,
}
impl<'de> serde::Deserialize<'de> for EasyInputMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            InputMessageContentList(#[allow(dead_code)] InputMessageContentList),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::InputMessageContentList(_v) => Self::InputMessageContentList(_v),
        })
    }
}
impl serde::Serialize for EasyInputMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            InputMessageContentList(#[allow(dead_code)] &'a InputMessageContentList),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::InputMessageContentList(_v) => {
                _S::InputMessageContentList(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EasyInputMessageContent {
    #[doc = "A text input to the model.\n"]
    String(String),
    InputMessageContentList(InputMessageContentList),
}
#[doc = "The type of the message input. Always `message`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum EasyInputMessageType {
    #[default]
    #[serde(rename = "message")]
    Message,
}
impl<'de> serde::Deserialize<'de> for EasyInputMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: EasyInputMessageRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: EasyInputMessageContent,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<EasyInputMessageType>,
        }
        let _D {
            role,
            content,
            type_,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EasyInputMessage {
            role,
            content,
            type_,
        })
    }
}
impl serde::Serialize for EasyInputMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a EasyInputMessageRole,
            #[serde(rename = "content")]
            content: &'a EasyInputMessageContent,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<EasyInputMessageType>,
        }
        let EasyInputMessage {
            role,
            content,
            type_,
        } = self;
        _S {
            role,
            content,
            type_,
        }
        .serialize(serializer)
    }
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EasyInputMessage {
    #[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
    pub role: EasyInputMessageRole,
    #[doc = "Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n"]
    pub content: EasyInputMessageContent,
    #[doc = "The type of the message input. Always `message`.\n"]
    #[builder(default)]
    pub type_: Option<EasyInputMessageType>,
}
impl<'de> serde::Deserialize<'de> for Embedding {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"embedding\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EmbeddingObject {
            #[default]
            #[serde(rename = "embedding")]
            Embedding,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "embedding")]
            #[allow(dead_code)]
            embedding: Vec<f64>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EmbeddingObject,
        }
        let _D {
            index, embedding, ..
        } = _D::deserialize(deserializer)?;
        Ok(Embedding { index, embedding })
    }
}
impl serde::Serialize for Embedding {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"embedding\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EmbeddingObject {
            #[default]
            #[serde(rename = "embedding")]
            Embedding,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "embedding")]
            embedding: &'a Vec<f64>,
            #[serde(rename = "object")]
            object: &'a EmbeddingObject,
        }
        let Embedding { index, embedding } = self;
        _S {
            index,
            embedding,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an embedding vector returned by embedding endpoint.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Embedding {
    #[doc = "The index of the embedding in the list of embeddings."]
    pub index: u64,
    #[doc = "The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](/docs/guides/embeddings).\n"]
    pub embedding: Vec<f64>,
}
impl<'de> serde::Deserialize<'de> for Error {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: String,
        }
        let _D {
            code,
            message,
            param,
            type_,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Error {
            code,
            message,
            param,
            type_,
        })
    }
}
impl serde::Serialize for Error {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a String,
        }
        let Error {
            code,
            message,
            param,
            type_,
        } = self;
        _S {
            code,
            message,
            param,
            type_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Error {
    #[builder(default)]
    pub code: Option<String>,
    pub message: String,
    #[builder(default)]
    pub param: Option<String>,
    pub type_: String,
}
impl<'de> serde::Deserialize<'de> for ErrorEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ErrorEventEvent {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: ErrorEventEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Error,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(ErrorEvent { data })
    }
}
impl serde::Serialize for ErrorEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ErrorEventEvent {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a ErrorEventEvent,
            #[serde(rename = "data")]
            data: &'a Error,
        }
        let ErrorEvent { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when an [error](/docs/guides/error-codes#api-errors) occurs. This can happen due to an internal server error or a timeout."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ErrorEvent {
    pub data: Error,
}
impl<'de> serde::Deserialize<'de> for ErrorResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Error,
        }
        let _D { error, .. } = _D::deserialize(deserializer)?;
        Ok(ErrorResponse { error })
    }
}
impl serde::Serialize for ErrorResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "error")]
            error: &'a Error,
        }
        let ErrorResponse { error } = self;
        _S { error }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ErrorResponse {
    pub error: Error,
}
impl<'de> serde::Deserialize<'de> for EvalDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Custom(#[allow(dead_code)] EvalCustomDataSourceConfig),
            StoredCompletions(#[allow(dead_code)] EvalStoredCompletionsDataSourceConfig),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Custom(_v) => Self::Custom(_v),
            _D::StoredCompletions(_v) => Self::StoredCompletions(_v),
        })
    }
}
impl serde::Serialize for EvalDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Custom(#[allow(dead_code)] &'a EvalCustomDataSourceConfig),
            StoredCompletions(#[allow(dead_code)] &'a EvalStoredCompletionsDataSourceConfig),
        }
        match self {
            Self::Custom(_v) => _S::Custom(_v).serialize(serializer),
            Self::StoredCompletions(_v) => _S::StoredCompletions(_v).serialize(serializer),
        }
    }
}
#[doc = "Configuration of data sources used in runs of the evaluation."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EvalDataSourceConfig {
    Custom(EvalCustomDataSourceConfig),
    StoredCompletions(EvalStoredCompletionsDataSourceConfig),
}
impl<'de> serde::Deserialize<'de> for EvalTestingCriteria {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            LabelModel(#[allow(dead_code)] EvalLabelModelGrader),
            StringCheck(#[allow(dead_code)] EvalStringCheckGrader),
            TextSimilarity(#[allow(dead_code)] EvalTextSimilarityGrader),
            Python(#[allow(dead_code)] EvalPythonGrader),
            ScoreModel(#[allow(dead_code)] EvalScoreModelGrader),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::LabelModel(_v) => Self::LabelModel(_v),
            _D::StringCheck(_v) => Self::StringCheck(_v),
            _D::TextSimilarity(_v) => Self::TextSimilarity(_v),
            _D::Python(_v) => Self::Python(_v),
            _D::ScoreModel(_v) => Self::ScoreModel(_v),
        })
    }
}
impl serde::Serialize for EvalTestingCriteria {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            LabelModel(#[allow(dead_code)] &'a EvalLabelModelGrader),
            StringCheck(#[allow(dead_code)] &'a EvalStringCheckGrader),
            TextSimilarity(#[allow(dead_code)] &'a EvalTextSimilarityGrader),
            Python(#[allow(dead_code)] &'a EvalPythonGrader),
            ScoreModel(#[allow(dead_code)] &'a EvalScoreModelGrader),
        }
        match self {
            Self::LabelModel(_v) => _S::LabelModel(_v).serialize(serializer),
            Self::StringCheck(_v) => _S::StringCheck(_v).serialize(serializer),
            Self::TextSimilarity(_v) => _S::TextSimilarity(_v).serialize(serializer),
            Self::Python(_v) => _S::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => _S::ScoreModel(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EvalTestingCriteria {
    LabelModel(EvalLabelModelGrader),
    StringCheck(EvalStringCheckGrader),
    TextSimilarity(EvalTextSimilarityGrader),
    Python(EvalPythonGrader),
    ScoreModel(EvalScoreModelGrader),
}
impl<'de> serde::Deserialize<'de> for Eval {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalObject {
            #[default]
            #[serde(rename = "eval")]
            Eval,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "data_source_config")]
            #[allow(dead_code)]
            data_source_config: EvalDataSourceConfig,
            #[serde(rename = "testing_criteria")]
            #[allow(dead_code)]
            testing_criteria: Vec<EvalTestingCriteria>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Metadata,
        }
        let _D {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Eval {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        })
    }
}
impl serde::Serialize for Eval {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalObject {
            #[default]
            #[serde(rename = "eval")]
            Eval,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a EvalObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "data_source_config")]
            data_source_config: &'a EvalDataSourceConfig,
            #[serde(rename = "testing_criteria")]
            testing_criteria: &'a Vec<EvalTestingCriteria>,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "metadata")]
            metadata: &'a Metadata,
        }
        let Eval {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        } = self;
        _S {
            object: &Default::default(),
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "An Eval object with a data source config and testing criteria.\nAn Eval represents a task to be done for your LLM integration.\nLike:\n - Improve the quality of my chatbot\n - See how well my chatbot handles customer support\n - Check if o3-mini is better at my usecase than gpt-4o\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Eval {
    #[doc = "Unique identifier for the evaluation."]
    pub id: String,
    #[doc = "The name of the evaluation."]
    pub name: String,
    #[doc = "Configuration of data sources used in runs of the evaluation."]
    pub data_source_config: EvalDataSourceConfig,
    #[doc = "A list of testing criteria."]
    pub testing_criteria: Vec<EvalTestingCriteria>,
    #[doc = "The Unix timestamp (in seconds) for when the eval was created."]
    pub created_at: u64,
    pub metadata: Metadata,
}
impl<'de> serde::Deserialize<'de> for EvalApiError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let _D { code, message, .. } = _D::deserialize(deserializer)?;
        Ok(EvalApiError { code, message })
    }
}
impl serde::Serialize for EvalApiError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let EvalApiError { code, message } = self;
        _S { code, message }.serialize(serializer)
    }
}
#[doc = "An object representing an error response from the Eval API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalApiError {
    #[doc = "The error code."]
    pub code: String,
    #[doc = "The error message."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for EvalCustomDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `custom`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalCustomDataSourceConfigType {
            #[default]
            #[serde(rename = "custom")]
            Custom,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalCustomDataSourceConfigType,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: std::collections::HashMap<String, serde_json::Value>,
        }
        let _D { schema, .. } = _D::deserialize(deserializer)?;
        Ok(EvalCustomDataSourceConfig { schema })
    }
}
impl serde::Serialize for EvalCustomDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `custom`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalCustomDataSourceConfigType {
            #[default]
            #[serde(rename = "custom")]
            Custom,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalCustomDataSourceConfigType,
            #[serde(rename = "schema")]
            schema: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let EvalCustomDataSourceConfig { schema } = self;
        _S {
            type_: &Default::default(),
            schema,
        }
        .serialize(serializer)
    }
}
#[doc = "A CustomDataSourceConfig which specifies the schema of your `item` and optionally `sample` namespaces.\nThe response schema defines the shape of the data that will be:\n- Used to define your testing criteria and\n- What data is required when creating a run\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalCustomDataSourceConfig {
    #[doc = "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
    pub schema: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for EvalItemRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] EvalItemRoleUser),
            Assistant(#[allow(dead_code)] EvalItemRoleAssistant),
            System(#[allow(dead_code)] EvalItemRoleSystem),
            Developer(#[allow(dead_code)] EvalItemRoleDeveloper),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
            _D::System(_) => Self::System,
            _D::Developer(_) => Self::Developer,
        })
    }
}
impl serde::Serialize for EvalItemRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a EvalItemRoleUser),
            Assistant(#[allow(dead_code)] &'a EvalItemRoleAssistant),
            System(#[allow(dead_code)] &'a EvalItemRoleSystem),
            Developer(#[allow(dead_code)] &'a EvalItemRoleDeveloper),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
            Self::System => _S::System(&Default::default()).serialize(serializer),
            Self::Developer => _S::Developer(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum EvalItemRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "system"]
    System,
    #[doc = "developer"]
    Developer,
}
impl<'de> serde::Deserialize<'de> for EvalItemContentOutputText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the output text. Always `output_text`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemContentOutputTextType {
            #[default]
            #[serde(rename = "output_text")]
            OutputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalItemContentOutputTextType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(EvalItemContentOutputText { text })
    }
}
impl serde::Serialize for EvalItemContentOutputText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the output text. Always `output_text`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemContentOutputTextType {
            #[default]
            #[serde(rename = "output_text")]
            OutputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalItemContentOutputTextType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let EvalItemContentOutputText { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "A text output from the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalItemContentOutputText {
    #[doc = "The text output from the model.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for EvalItemContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            InputText(#[allow(dead_code)] InputTextContent),
            OutputText(#[allow(dead_code)] EvalItemContentOutputText),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::InputText(_v) => Self::InputText(_v),
            _D::OutputText(_v) => Self::OutputText(_v),
        })
    }
}
impl serde::Serialize for EvalItemContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            InputText(#[allow(dead_code)] &'a InputTextContent),
            OutputText(#[allow(dead_code)] &'a EvalItemContentOutputText),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::InputText(_v) => _S::InputText(_v).serialize(serializer),
            Self::OutputText(_v) => _S::OutputText(_v).serialize(serializer),
        }
    }
}
#[doc = "Text inputs to the model - can contain template strings.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EvalItemContent {
    #[doc = "A text input to the model.\n"]
    String(String),
    InputText(InputTextContent),
    #[doc = "A text output from the model.\n"]
    OutputText(EvalItemContentOutputText),
}
#[doc = "The type of the message input. Always `message`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum EvalItemType {
    #[default]
    #[serde(rename = "message")]
    Message,
}
impl<'de> serde::Deserialize<'de> for EvalItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: EvalItemRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: EvalItemContent,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<EvalItemType>,
        }
        let _D {
            role,
            content,
            type_,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalItem {
            role,
            content,
            type_,
        })
    }
}
impl serde::Serialize for EvalItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a EvalItemRole,
            #[serde(rename = "content")]
            content: &'a EvalItemContent,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<EvalItemType>,
        }
        let EvalItem {
            role,
            content,
            type_,
        } = self;
        _S {
            role,
            content,
            type_,
        }
        .serialize(serializer)
    }
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalItem {
    #[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
    pub role: EvalItemRole,
    #[doc = "Text inputs to the model - can contain template strings.\n"]
    pub content: EvalItemContent,
    #[doc = "The type of the message input. Always `message`.\n"]
    #[builder(default)]
    pub type_: Option<EvalItemType>,
}
impl<'de> serde::Deserialize<'de> for EvalJsonlFileContentSourceContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sample")]
            #[allow(dead_code)]
            sample: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let _D { item, sample, .. } = _D::deserialize(deserializer)?;
        Ok(EvalJsonlFileContentSourceContent { item, sample })
    }
}
impl serde::Serialize for EvalJsonlFileContentSourceContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "item")]
            item: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sample")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sample: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let EvalJsonlFileContentSourceContent { item, sample } = self;
        _S { item, sample }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalJsonlFileContentSourceContent {
    pub item: std::collections::HashMap<String, serde_json::Value>,
    #[builder(default)]
    pub sample: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for EvalJsonlFileContentSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of jsonl source. Always `file_content`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalJsonlFileContentSourceType {
            #[default]
            #[serde(rename = "file_content")]
            FileContent,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalJsonlFileContentSourceType,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Vec<EvalJsonlFileContentSourceContent>,
        }
        let _D { content, .. } = _D::deserialize(deserializer)?;
        Ok(EvalJsonlFileContentSource { content })
    }
}
impl serde::Serialize for EvalJsonlFileContentSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of jsonl source. Always `file_content`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalJsonlFileContentSourceType {
            #[default]
            #[serde(rename = "file_content")]
            FileContent,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalJsonlFileContentSourceType,
            #[serde(rename = "content")]
            content: &'a Vec<EvalJsonlFileContentSourceContent>,
        }
        let EvalJsonlFileContentSource { content } = self;
        _S {
            type_: &Default::default(),
            content,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalJsonlFileContentSource {
    #[doc = "The content of the jsonl file."]
    pub content: Vec<EvalJsonlFileContentSourceContent>,
}
impl<'de> serde::Deserialize<'de> for EvalJsonlFileIdSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of jsonl source. Always `file_id`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalJsonlFileIdSourceType {
            #[default]
            #[serde(rename = "file_id")]
            FileId,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalJsonlFileIdSourceType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D { id, .. } = _D::deserialize(deserializer)?;
        Ok(EvalJsonlFileIdSource { id })
    }
}
impl serde::Serialize for EvalJsonlFileIdSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of jsonl source. Always `file_id`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalJsonlFileIdSourceType {
            #[default]
            #[serde(rename = "file_id")]
            FileId,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalJsonlFileIdSourceType,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let EvalJsonlFileIdSource { id } = self;
        _S {
            type_: &Default::default(),
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalJsonlFileIdSource {
    #[doc = "The identifier of the file."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for EvalLabelModelGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `label_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalLabelModelGraderType {
            #[default]
            #[serde(rename = "label_model")]
            LabelModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalLabelModelGraderType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Vec<EvalItem>,
            #[serde(rename = "labels")]
            #[allow(dead_code)]
            labels: Vec<String>,
            #[serde(rename = "passing_labels")]
            #[allow(dead_code)]
            passing_labels: Vec<String>,
        }
        let _D {
            name,
            model,
            input,
            labels,
            passing_labels,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalLabelModelGrader {
            name,
            model,
            input,
            labels,
            passing_labels,
        })
    }
}
impl serde::Serialize for EvalLabelModelGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `label_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalLabelModelGraderType {
            #[default]
            #[serde(rename = "label_model")]
            LabelModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalLabelModelGraderType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a Vec<EvalItem>,
            #[serde(rename = "labels")]
            labels: &'a Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: &'a Vec<String>,
        }
        let EvalLabelModelGrader {
            name,
            model,
            input,
            labels,
            passing_labels,
        } = self;
        _S {
            type_: &Default::default(),
            name,
            model,
            input,
            labels,
            passing_labels,
        }
        .serialize(serializer)
    }
}
#[doc = "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalLabelModelGrader {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation. Must support structured outputs."]
    pub model: String,
    pub input: Vec<EvalItem>,
    #[doc = "The labels to assign to each item in the evaluation."]
    pub labels: Vec<String>,
    #[doc = "The labels that indicate a passing result. Must be a subset of labels."]
    pub passing_labels: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for EvalList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Eval>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalList {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a EvalListObject,
            #[serde(rename = "data")]
            data: &'a Vec<Eval>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let EvalList {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of evals.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalList {
    #[doc = "An array of eval objects.\n"]
    pub data: Vec<Eval>,
    #[doc = "The identifier of the first eval in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more evals available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalPythonGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `python`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalPythonGraderType {
            #[default]
            #[serde(rename = "python")]
            Python,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalPythonGraderType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: String,
            #[serde(rename = "pass_threshold")]
            #[allow(dead_code)]
            pass_threshold: Option<f64>,
            #[serde(rename = "image_tag")]
            #[allow(dead_code)]
            image_tag: Option<String>,
        }
        let _D {
            name,
            source,
            pass_threshold,
            image_tag,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalPythonGrader {
            name,
            source,
            pass_threshold,
            image_tag,
        })
    }
}
impl serde::Serialize for EvalPythonGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `python`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalPythonGraderType {
            #[default]
            #[serde(rename = "python")]
            Python,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalPythonGraderType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "source")]
            source: &'a String,
            #[serde(rename = "pass_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pass_threshold: &'a Option<f64>,
            #[serde(rename = "image_tag")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_tag: &'a Option<String>,
        }
        let EvalPythonGrader {
            name,
            source,
            pass_threshold,
            image_tag,
        } = self;
        _S {
            type_: &Default::default(),
            name,
            source,
            pass_threshold,
            image_tag,
        }
        .serialize(serializer)
    }
}
#[doc = "A PythonGrader object that runs a python script on the input.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalPythonGrader {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The source code of the python script."]
    pub source: String,
    #[doc = "The threshold for the score."]
    #[builder(default)]
    pub pass_threshold: Option<f64>,
    #[doc = "The image tag to use for the python script."]
    #[builder(default)]
    pub image_tag: Option<String>,
}
impl<'de> serde::Deserialize<'de> for EvalResponsesSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of run data source. Always `responses`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalResponsesSourceType {
            #[default]
            #[serde(rename = "responses")]
            Responses,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalResponsesSourceType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "instructions_search")]
            #[allow(dead_code)]
            instructions_search: Option<String>,
            #[serde(rename = "created_after")]
            #[allow(dead_code)]
            created_after: Option<u64>,
            #[serde(rename = "created_before")]
            #[allow(dead_code)]
            created_before: Option<u64>,
            #[serde(rename = "has_tool_calls")]
            #[allow(dead_code)]
            has_tool_calls: Option<bool>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "users")]
            #[allow(dead_code)]
            users: Option<Vec<String>>,
            #[serde(rename = "allow_parallel_tool_calls")]
            #[allow(dead_code)]
            allow_parallel_tool_calls: Option<bool>,
        }
        let _D {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            has_tool_calls,
            reasoning_effort,
            temperature,
            top_p,
            users,
            allow_parallel_tool_calls,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalResponsesSource {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            has_tool_calls,
            reasoning_effort,
            temperature,
            top_p,
            users,
            allow_parallel_tool_calls,
        })
    }
}
impl serde::Serialize for EvalResponsesSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of run data source. Always `responses`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalResponsesSourceType {
            #[default]
            #[serde(rename = "responses")]
            Responses,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalResponsesSourceType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "instructions_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions_search: &'a Option<String>,
            #[serde(rename = "created_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_after: &'a Option<u64>,
            #[serde(rename = "created_before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_before: &'a Option<u64>,
            #[serde(rename = "has_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            has_tool_calls: &'a Option<bool>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "users")]
            #[serde(skip_serializing_if = "Option::is_none")]
            users: &'a Option<Vec<String>>,
            #[serde(rename = "allow_parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            allow_parallel_tool_calls: &'a Option<bool>,
        }
        let EvalResponsesSource {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            has_tool_calls,
            reasoning_effort,
            temperature,
            top_p,
            users,
            allow_parallel_tool_calls,
        } = self;
        _S {
            type_: &Default::default(),
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            has_tool_calls,
            reasoning_effort,
            temperature,
            top_p,
            users,
            allow_parallel_tool_calls,
        }
        .serialize(serializer)
    }
}
#[doc = "A EvalResponsesSource object describing a run data source configuration.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct EvalResponsesSource {
    #[doc = "Metadata filter for the responses. This is a query parameter used to select responses."]
    #[builder(default)]
    pub metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[doc = "The name of the model to find responses for. This is a query parameter used to select responses."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Optional search string for instructions. This is a query parameter used to select responses."]
    #[builder(default)]
    pub instructions_search: Option<String>,
    #[doc = "Only include items created after this timestamp (inclusive). This is a query parameter used to select responses."]
    #[builder(default)]
    pub created_after: Option<u64>,
    #[doc = "Only include items created before this timestamp (inclusive). This is a query parameter used to select responses."]
    #[builder(default)]
    pub created_before: Option<u64>,
    #[doc = "Whether the response has tool calls. This is a query parameter used to select responses."]
    #[builder(default)]
    pub has_tool_calls: Option<bool>,
    #[doc = "Optional reasoning effort parameter. This is a query parameter used to select responses."]
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "Sampling temperature. This is a query parameter used to select responses."]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Nucleus sampling parameter. This is a query parameter used to select responses."]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "List of user identifiers. This is a query parameter used to select responses."]
    #[builder(default)]
    pub users: Option<Vec<String>>,
    #[doc = "Whether to allow parallel tool calls. This is a query parameter used to select responses."]
    #[builder(default)]
    pub allow_parallel_tool_calls: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for EvalRunResultCounts {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "total")]
            #[allow(dead_code)]
            total: u64,
            #[serde(rename = "errored")]
            #[allow(dead_code)]
            errored: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
            #[serde(rename = "passed")]
            #[allow(dead_code)]
            passed: u64,
        }
        let _D {
            total,
            errored,
            failed,
            passed,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRunResultCounts {
            total,
            errored,
            failed,
            passed,
        })
    }
}
impl serde::Serialize for EvalRunResultCounts {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "total")]
            total: &'a u64,
            #[serde(rename = "errored")]
            errored: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
            #[serde(rename = "passed")]
            passed: &'a u64,
        }
        let EvalRunResultCounts {
            total,
            errored,
            failed,
            passed,
        } = self;
        _S {
            total,
            errored,
            failed,
            passed,
        }
        .serialize(serializer)
    }
}
#[doc = "Counters summarizing the outcomes of the evaluation run."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct EvalRunResultCounts {
    #[doc = "Total number of executed output items."]
    pub total: u64,
    #[doc = "Number of output items that resulted in an error."]
    pub errored: u64,
    #[doc = "Number of output items that failed to pass the evaluation."]
    pub failed: u64,
    #[doc = "Number of output items that passed the evaluation."]
    pub passed: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunPerModelUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model_name")]
            #[allow(dead_code)]
            model_name: String,
            #[serde(rename = "invocation_count")]
            #[allow(dead_code)]
            invocation_count: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: u64,
        }
        let _D {
            model_name,
            invocation_count,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            cached_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRunPerModelUsage {
            model_name,
            invocation_count,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            cached_tokens,
        })
    }
}
impl serde::Serialize for EvalRunPerModelUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model_name")]
            model_name: &'a String,
            #[serde(rename = "invocation_count")]
            invocation_count: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
            #[serde(rename = "cached_tokens")]
            cached_tokens: &'a u64,
        }
        let EvalRunPerModelUsage {
            model_name,
            invocation_count,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            cached_tokens,
        } = self;
        _S {
            model_name,
            invocation_count,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            cached_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunPerModelUsage {
    #[doc = "The name of the model."]
    pub model_name: String,
    #[doc = "The number of invocations."]
    pub invocation_count: u64,
    #[doc = "The number of prompt tokens used."]
    pub prompt_tokens: u64,
    #[doc = "The number of completion tokens generated."]
    pub completion_tokens: u64,
    #[doc = "The total number of tokens used."]
    pub total_tokens: u64,
    #[doc = "The number of tokens retrieved from cache."]
    pub cached_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunPerTestingCriteriaResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "testing_criteria")]
            #[allow(dead_code)]
            testing_criteria: String,
            #[serde(rename = "passed")]
            #[allow(dead_code)]
            passed: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
        }
        let _D {
            testing_criteria,
            passed,
            failed,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRunPerTestingCriteriaResult {
            testing_criteria,
            passed,
            failed,
        })
    }
}
impl serde::Serialize for EvalRunPerTestingCriteriaResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "testing_criteria")]
            testing_criteria: &'a String,
            #[serde(rename = "passed")]
            passed: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
        }
        let EvalRunPerTestingCriteriaResult {
            testing_criteria,
            passed,
            failed,
        } = self;
        _S {
            testing_criteria,
            passed,
            failed,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunPerTestingCriteriaResult {
    #[doc = "A description of the testing criteria."]
    pub testing_criteria: String,
    #[doc = "Number of tests passed for this criteria."]
    pub passed: u64,
    #[doc = "Number of tests failed for this criteria."]
    pub failed: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Jsonl(#[allow(dead_code)] CreateEvalJsonlRunDataSource),
            CreateEvalCompletionsRunDataSource(
                #[allow(dead_code)] CreateEvalCompletionsRunDataSource,
            ),
            CreateEvalResponsesRunDataSource(#[allow(dead_code)] CreateEvalResponsesRunDataSource),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Jsonl(_v) => Self::Jsonl(_v),
            _D::CreateEvalCompletionsRunDataSource(_v) => {
                Self::CreateEvalCompletionsRunDataSource(_v)
            }
            _D::CreateEvalResponsesRunDataSource(_v) => Self::CreateEvalResponsesRunDataSource(_v),
        })
    }
}
impl serde::Serialize for EvalRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Jsonl(#[allow(dead_code)] &'a CreateEvalJsonlRunDataSource),
            CreateEvalCompletionsRunDataSource(
                #[allow(dead_code)] &'a CreateEvalCompletionsRunDataSource,
            ),
            CreateEvalResponsesRunDataSource(
                #[allow(dead_code)] &'a CreateEvalResponsesRunDataSource,
            ),
        }
        match self {
            Self::Jsonl(_v) => _S::Jsonl(_v).serialize(serializer),
            Self::CreateEvalCompletionsRunDataSource(_v) => {
                _S::CreateEvalCompletionsRunDataSource(_v).serialize(serializer)
            }
            Self::CreateEvalResponsesRunDataSource(_v) => {
                _S::CreateEvalResponsesRunDataSource(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Information about the run's data source."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EvalRunDataSource {
    Jsonl(CreateEvalJsonlRunDataSource),
    CreateEvalCompletionsRunDataSource(CreateEvalCompletionsRunDataSource),
    CreateEvalResponsesRunDataSource(CreateEvalResponsesRunDataSource),
}
impl<'de> serde::Deserialize<'de> for EvalRun {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the object. Always \"eval.run\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunObject {
            #[default]
            #[serde(rename = "eval.run")]
            EvalRun,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalRunObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "eval_id")]
            #[allow(dead_code)]
            eval_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "report_url")]
            #[allow(dead_code)]
            report_url: String,
            #[serde(rename = "result_counts")]
            #[allow(dead_code)]
            result_counts: EvalRunResultCounts,
            #[serde(rename = "per_model_usage")]
            #[allow(dead_code)]
            per_model_usage: Vec<EvalRunPerModelUsage>,
            #[serde(rename = "per_testing_criteria_results")]
            #[allow(dead_code)]
            per_testing_criteria_results: Vec<EvalRunPerTestingCriteriaResult>,
            #[serde(rename = "data_source")]
            #[allow(dead_code)]
            data_source: EvalRunDataSource,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Metadata,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: EvalApiError,
        }
        let _D {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRun {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        })
    }
}
impl serde::Serialize for EvalRun {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the object. Always \"eval.run\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunObject {
            #[default]
            #[serde(rename = "eval.run")]
            EvalRun,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a EvalRunObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "eval_id")]
            eval_id: &'a String,
            #[serde(rename = "status")]
            status: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "report_url")]
            report_url: &'a String,
            #[serde(rename = "result_counts")]
            result_counts: &'a EvalRunResultCounts,
            #[serde(rename = "per_model_usage")]
            per_model_usage: &'a Vec<EvalRunPerModelUsage>,
            #[serde(rename = "per_testing_criteria_results")]
            per_testing_criteria_results: &'a Vec<EvalRunPerTestingCriteriaResult>,
            #[serde(rename = "data_source")]
            data_source: &'a EvalRunDataSource,
            #[serde(rename = "metadata")]
            metadata: &'a Metadata,
            #[serde(rename = "error")]
            error: &'a EvalApiError,
        }
        let EvalRun {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        } = self;
        _S {
            object: &Default::default(),
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "A schema representing an evaluation run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRun {
    #[doc = "Unique identifier for the evaluation run."]
    pub id: String,
    #[doc = "The identifier of the associated evaluation."]
    pub eval_id: String,
    #[doc = "The status of the evaluation run."]
    pub status: String,
    #[doc = "The model that is evaluated, if applicable."]
    pub model: String,
    #[doc = "The name of the evaluation run."]
    pub name: String,
    #[doc = "Unix timestamp (in seconds) when the evaluation run was created."]
    pub created_at: u64,
    #[doc = "The URL to the rendered evaluation run report on the UI dashboard."]
    pub report_url: String,
    #[doc = "Counters summarizing the outcomes of the evaluation run."]
    pub result_counts: EvalRunResultCounts,
    #[doc = "Usage statistics for each model during the evaluation run."]
    pub per_model_usage: Vec<EvalRunPerModelUsage>,
    #[doc = "Results per testing criteria applied during the evaluation run."]
    pub per_testing_criteria_results: Vec<EvalRunPerTestingCriteriaResult>,
    #[doc = "Information about the run's data source."]
    pub data_source: EvalRunDataSource,
    pub metadata: Metadata,
    pub error: EvalApiError,
}
impl<'de> serde::Deserialize<'de> for EvalRunList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalRunListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<EvalRun>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRunList {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalRunList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a EvalRunListObject,
            #[serde(rename = "data")]
            data: &'a Vec<EvalRun>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let EvalRunList {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of runs for an evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunList {
    #[doc = "An array of eval run objects.\n"]
    pub data: Vec<EvalRun>,
    #[doc = "The identifier of the first eval run in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval run in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more evals available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemSampleInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: String,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: String,
        }
        let _D { role, content, .. } = _D::deserialize(deserializer)?;
        Ok(EvalRunOutputItemSampleInput { role, content })
    }
}
impl serde::Serialize for EvalRunOutputItemSampleInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a String,
            #[serde(rename = "content")]
            content: &'a String,
        }
        let EvalRunOutputItemSampleInput { role, content } = self;
        _S { role, content }.serialize(serializer)
    }
}
#[doc = "An input message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemSampleInput {
    #[doc = "The role of the message sender (e.g., system, user, developer)."]
    pub role: String,
    #[doc = "The content of the message."]
    pub content: String,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemSampleOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
        }
        let _D { role, content, .. } = _D::deserialize(deserializer)?;
        Ok(EvalRunOutputItemSampleOutput { role, content })
    }
}
impl serde::Serialize for EvalRunOutputItemSampleOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
        }
        let EvalRunOutputItemSampleOutput { role, content } = self;
        _S { role, content }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemSampleOutput {
    #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
    #[builder(default)]
    pub role: Option<String>,
    #[doc = "The content of the message."]
    #[builder(default)]
    pub content: Option<String>,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemSampleUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: u64,
        }
        let _D {
            total_tokens,
            completion_tokens,
            prompt_tokens,
            cached_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRunOutputItemSampleUsage {
            total_tokens,
            completion_tokens,
            prompt_tokens,
            cached_tokens,
        })
    }
}
impl serde::Serialize for EvalRunOutputItemSampleUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "cached_tokens")]
            cached_tokens: &'a u64,
        }
        let EvalRunOutputItemSampleUsage {
            total_tokens,
            completion_tokens,
            prompt_tokens,
            cached_tokens,
        } = self;
        _S {
            total_tokens,
            completion_tokens,
            prompt_tokens,
            cached_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Token usage details for the sample."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemSampleUsage {
    #[doc = "The total number of tokens used."]
    pub total_tokens: u64,
    #[doc = "The number of completion tokens generated."]
    pub completion_tokens: u64,
    #[doc = "The number of prompt tokens used."]
    pub prompt_tokens: u64,
    #[doc = "The number of tokens retrieved from cache."]
    pub cached_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemSample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Vec<EvalRunOutputItemSampleInput>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Vec<EvalRunOutputItemSampleOutput>,
            #[serde(rename = "finish_reason")]
            #[allow(dead_code)]
            finish_reason: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: EvalRunOutputItemSampleUsage,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: EvalApiError,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: f64,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: u64,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: f64,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: u64,
        }
        let _D {
            input,
            output,
            finish_reason,
            model,
            usage,
            error,
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRunOutputItemSample {
            input,
            output,
            finish_reason,
            model,
            usage,
            error,
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        })
    }
}
impl serde::Serialize for EvalRunOutputItemSample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "input")]
            input: &'a Vec<EvalRunOutputItemSampleInput>,
            #[serde(rename = "output")]
            output: &'a Vec<EvalRunOutputItemSampleOutput>,
            #[serde(rename = "finish_reason")]
            finish_reason: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "usage")]
            usage: &'a EvalRunOutputItemSampleUsage,
            #[serde(rename = "error")]
            error: &'a EvalApiError,
            #[serde(rename = "temperature")]
            temperature: &'a f64,
            #[serde(rename = "max_completion_tokens")]
            max_completion_tokens: &'a u64,
            #[serde(rename = "top_p")]
            top_p: &'a f64,
            #[serde(rename = "seed")]
            seed: &'a u64,
        }
        let EvalRunOutputItemSample {
            input,
            output,
            finish_reason,
            model,
            usage,
            error,
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        } = self;
        _S {
            input,
            output,
            finish_reason,
            model,
            usage,
            error,
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        }
        .serialize(serializer)
    }
}
#[doc = "A sample containing the input and output of the evaluation run."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemSample {
    #[doc = "An array of input messages."]
    pub input: Vec<EvalRunOutputItemSampleInput>,
    #[doc = "An array of output messages."]
    pub output: Vec<EvalRunOutputItemSampleOutput>,
    #[doc = "The reason why the sample generation was finished."]
    pub finish_reason: String,
    #[doc = "The model used for generating the sample."]
    pub model: String,
    #[doc = "Token usage details for the sample."]
    pub usage: EvalRunOutputItemSampleUsage,
    pub error: EvalApiError,
    #[doc = "The sampling temperature used."]
    pub temperature: f64,
    #[doc = "The maximum number of tokens allowed for completion."]
    pub max_completion_tokens: u64,
    #[doc = "The top_p value used for sampling."]
    pub top_p: f64,
    #[doc = "The seed used for generating the sample."]
    pub seed: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the object. Always \"eval.run.output_item\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunOutputItemObject {
            #[default]
            #[serde(rename = "eval.run.output_item")]
            EvalRunOutputItem,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalRunOutputItemObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "run_id")]
            #[allow(dead_code)]
            run_id: String,
            #[serde(rename = "eval_id")]
            #[allow(dead_code)]
            eval_id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: String,
            #[serde(rename = "datasource_item_id")]
            #[allow(dead_code)]
            datasource_item_id: u64,
            #[serde(rename = "datasource_item")]
            #[allow(dead_code)]
            datasource_item: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Vec<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "sample")]
            #[allow(dead_code)]
            sample: EvalRunOutputItemSample,
        }
        let _D {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRunOutputItem {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        })
    }
}
impl serde::Serialize for EvalRunOutputItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the object. Always \"eval.run.output_item\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunOutputItemObject {
            #[default]
            #[serde(rename = "eval.run.output_item")]
            EvalRunOutputItem,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a EvalRunOutputItemObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "run_id")]
            run_id: &'a String,
            #[serde(rename = "eval_id")]
            eval_id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "status")]
            status: &'a String,
            #[serde(rename = "datasource_item_id")]
            datasource_item_id: &'a u64,
            #[serde(rename = "datasource_item")]
            datasource_item: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "results")]
            results: &'a Vec<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "sample")]
            sample: &'a EvalRunOutputItemSample,
        }
        let EvalRunOutputItem {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        } = self;
        _S {
            object: &Default::default(),
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        }
        .serialize(serializer)
    }
}
#[doc = "A schema representing an evaluation run output item.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItem {
    #[doc = "Unique identifier for the evaluation run output item."]
    pub id: String,
    #[doc = "The identifier of the evaluation run associated with this output item."]
    pub run_id: String,
    #[doc = "The identifier of the evaluation group."]
    pub eval_id: String,
    #[doc = "Unix timestamp (in seconds) when the evaluation run was created."]
    pub created_at: u64,
    #[doc = "The status of the evaluation run."]
    pub status: String,
    #[doc = "The identifier for the data source item."]
    pub datasource_item_id: u64,
    #[doc = "Details of the input data source item."]
    pub datasource_item: std::collections::HashMap<String, serde_json::Value>,
    #[doc = "A list of results from the evaluation run."]
    pub results: Vec<std::collections::HashMap<String, serde_json::Value>>,
    #[doc = "A sample containing the input and output of the evaluation run."]
    pub sample: EvalRunOutputItemSample,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunOutputItemListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalRunOutputItemListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<EvalRunOutputItem>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalRunOutputItemList {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalRunOutputItemList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunOutputItemListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a EvalRunOutputItemListObject,
            #[serde(rename = "data")]
            data: &'a Vec<EvalRunOutputItem>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let EvalRunOutputItemList {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of output items for an evaluation run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemList {
    #[doc = "An array of eval run output item objects.\n"]
    pub data: Vec<EvalRunOutputItem>,
    #[doc = "The identifier of the first eval run output item in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval run output item in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more eval run output items available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalScoreModelGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `score_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalScoreModelGraderType {
            #[default]
            #[serde(rename = "score_model")]
            ScoreModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalScoreModelGraderType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "sampling_params")]
            #[allow(dead_code)]
            sampling_params: Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Vec<EvalItem>,
            #[serde(rename = "pass_threshold")]
            #[allow(dead_code)]
            pass_threshold: Option<f64>,
            #[serde(rename = "range")]
            #[allow(dead_code)]
            range: Option<Vec<f64>>,
        }
        let _D {
            name,
            model,
            sampling_params,
            input,
            pass_threshold,
            range,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalScoreModelGrader {
            name,
            model,
            sampling_params,
            input,
            pass_threshold,
            range,
        })
    }
}
impl serde::Serialize for EvalScoreModelGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `score_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalScoreModelGraderType {
            #[default]
            #[serde(rename = "score_model")]
            ScoreModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalScoreModelGraderType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "input")]
            input: &'a Vec<EvalItem>,
            #[serde(rename = "pass_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pass_threshold: &'a Option<f64>,
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            range: &'a Option<Vec<f64>>,
        }
        let EvalScoreModelGrader {
            name,
            model,
            sampling_params,
            input,
            pass_threshold,
            range,
        } = self;
        _S {
            type_: &Default::default(),
            name,
            model,
            sampling_params,
            input,
            pass_threshold,
            range,
        }
        .serialize(serializer)
    }
}
#[doc = "A ScoreModelGrader object that uses a model to assign a score to the input.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalScoreModelGrader {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation."]
    pub model: String,
    #[doc = "The sampling parameters for the model."]
    #[builder(default)]
    pub sampling_params: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[doc = "The input text. This may include template strings."]
    pub input: Vec<EvalItem>,
    #[doc = "The threshold for the score."]
    #[builder(default)]
    pub pass_threshold: Option<f64>,
    #[doc = "The range of the score. Defaults to `[0, 1]`."]
    #[builder(default)]
    pub range: Option<Vec<f64>>,
}
impl<'de> serde::Deserialize<'de> for EvalStoredCompletionsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStoredCompletionsDataSourceConfigType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalStoredCompletionsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: std::collections::HashMap<String, serde_json::Value>,
        }
        let _D {
            metadata, schema, ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalStoredCompletionsDataSourceConfig { metadata, schema })
    }
}
impl serde::Serialize for EvalStoredCompletionsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStoredCompletionsDataSourceConfigType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalStoredCompletionsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "schema")]
            schema: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let EvalStoredCompletionsDataSourceConfig { metadata, schema } = self;
        _S {
            type_: &Default::default(),
            metadata,
            schema,
        }
        .serialize(serializer)
    }
}
#[doc = "A StoredCompletionsDataSourceConfig which specifies the metadata property of your stored completions query.\nThis is usually metadata like `usecase=chatbot` or `prompt-version=v2`, etc.\nThe schema returned by this data source config is used to defined what variables are available in your evals.\n`item` and `sample` are both defined when using this data source config.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalStoredCompletionsDataSourceConfig {
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
    pub schema: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for EvalStoredCompletionsSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStoredCompletionsSourceType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalStoredCompletionsSourceType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "created_after")]
            #[allow(dead_code)]
            created_after: Option<u64>,
            #[serde(rename = "created_before")]
            #[allow(dead_code)]
            created_before: Option<u64>,
            #[serde(rename = "limit")]
            #[allow(dead_code)]
            limit: Option<u64>,
        }
        let _D {
            metadata,
            model,
            created_after,
            created_before,
            limit,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalStoredCompletionsSource {
            metadata,
            model,
            created_after,
            created_before,
            limit,
        })
    }
}
impl serde::Serialize for EvalStoredCompletionsSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStoredCompletionsSourceType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalStoredCompletionsSourceType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "created_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_after: &'a Option<u64>,
            #[serde(rename = "created_before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_before: &'a Option<u64>,
            #[serde(rename = "limit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            limit: &'a Option<u64>,
        }
        let EvalStoredCompletionsSource {
            metadata,
            model,
            created_after,
            created_before,
            limit,
        } = self;
        _S {
            type_: &Default::default(),
            metadata,
            model,
            created_after,
            created_before,
            limit,
        }
        .serialize(serializer)
    }
}
#[doc = "A StoredCompletionsRunDataSource configuration describing a set of filters\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct EvalStoredCompletionsSource {
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "An optional model to filter by (e.g., 'gpt-4o')."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "An optional Unix timestamp to filter items created after this time."]
    #[builder(default)]
    pub created_after: Option<u64>,
    #[doc = "An optional Unix timestamp to filter items created before this time."]
    #[builder(default)]
    pub created_before: Option<u64>,
    #[doc = "An optional maximum number of items to return."]
    #[builder(default)]
    pub limit: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for EvalStringCheckGraderOperation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderOperationEq {
            #[default]
            #[serde(rename = "eq")]
            Eq,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderOperationNe {
            #[default]
            #[serde(rename = "ne")]
            Ne,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderOperationLike {
            #[default]
            #[serde(rename = "like")]
            Like,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderOperationIlike {
            #[default]
            #[serde(rename = "ilike")]
            Ilike,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Eq(#[allow(dead_code)] EvalStringCheckGraderOperationEq),
            Ne(#[allow(dead_code)] EvalStringCheckGraderOperationNe),
            Like(#[allow(dead_code)] EvalStringCheckGraderOperationLike),
            Ilike(#[allow(dead_code)] EvalStringCheckGraderOperationIlike),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Eq(_) => Self::Eq,
            _D::Ne(_) => Self::Ne,
            _D::Like(_) => Self::Like,
            _D::Ilike(_) => Self::Ilike,
        })
    }
}
impl serde::Serialize for EvalStringCheckGraderOperation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderOperationEq {
            #[default]
            #[serde(rename = "eq")]
            Eq,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderOperationNe {
            #[default]
            #[serde(rename = "ne")]
            Ne,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderOperationLike {
            #[default]
            #[serde(rename = "like")]
            Like,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderOperationIlike {
            #[default]
            #[serde(rename = "ilike")]
            Ilike,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Eq(#[allow(dead_code)] &'a EvalStringCheckGraderOperationEq),
            Ne(#[allow(dead_code)] &'a EvalStringCheckGraderOperationNe),
            Like(#[allow(dead_code)] &'a EvalStringCheckGraderOperationLike),
            Ilike(#[allow(dead_code)] &'a EvalStringCheckGraderOperationIlike),
        }
        match self {
            Self::Eq => _S::Eq(&Default::default()).serialize(serializer),
            Self::Ne => _S::Ne(&Default::default()).serialize(serializer),
            Self::Like => _S::Like(&Default::default()).serialize(serializer),
            Self::Ilike => _S::Ilike(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum EvalStringCheckGraderOperation {
    #[doc = "eq"]
    Eq,
    #[doc = "ne"]
    Ne,
    #[doc = "like"]
    Like,
    #[doc = "ilike"]
    Ilike,
}
impl<'de> serde::Deserialize<'de> for EvalStringCheckGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `string_check`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderType {
            #[default]
            #[serde(rename = "string_check")]
            StringCheck,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalStringCheckGraderType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: String,
            #[serde(rename = "reference")]
            #[allow(dead_code)]
            reference: String,
            #[serde(rename = "operation")]
            #[allow(dead_code)]
            operation: EvalStringCheckGraderOperation,
        }
        let _D {
            name,
            input,
            reference,
            operation,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalStringCheckGrader {
            name,
            input,
            reference,
            operation,
        })
    }
}
impl serde::Serialize for EvalStringCheckGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `string_check`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStringCheckGraderType {
            #[default]
            #[serde(rename = "string_check")]
            StringCheck,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalStringCheckGraderType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "reference")]
            reference: &'a String,
            #[serde(rename = "operation")]
            operation: &'a EvalStringCheckGraderOperation,
        }
        let EvalStringCheckGrader {
            name,
            input,
            reference,
            operation,
        } = self;
        _S {
            type_: &Default::default(),
            name,
            input,
            reference,
            operation,
        }
        .serialize(serializer)
    }
}
#[doc = "A StringCheckGrader object that performs a string comparison between input and reference using a specified operation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalStringCheckGrader {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The input text. This may include template strings."]
    pub input: String,
    #[doc = "The reference text. This may include template strings."]
    pub reference: String,
    #[doc = "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."]
    pub operation: EvalStringCheckGraderOperation,
}
impl<'de> serde::Deserialize<'de> for EvalTextSimilarityGraderEvaluationMetric {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricFuzzyMatch {
            #[default]
            #[serde(rename = "fuzzy_match")]
            FuzzyMatch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricBleu {
            #[default]
            #[serde(rename = "bleu")]
            Bleu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricGleu {
            #[default]
            #[serde(rename = "gleu")]
            Gleu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricMeteor {
            #[default]
            #[serde(rename = "meteor")]
            Meteor,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge1 {
            #[default]
            #[serde(rename = "rouge_1")]
            Rouge1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge2 {
            #[default]
            #[serde(rename = "rouge_2")]
            Rouge2,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge3 {
            #[default]
            #[serde(rename = "rouge_3")]
            Rouge3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge4 {
            #[default]
            #[serde(rename = "rouge_4")]
            Rouge4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge5 {
            #[default]
            #[serde(rename = "rouge_5")]
            Rouge5,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRougeL {
            #[default]
            #[serde(rename = "rouge_l")]
            RougeL,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FuzzyMatch(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricFuzzyMatch),
            Bleu(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricBleu),
            Gleu(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricGleu),
            Meteor(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricMeteor),
            Rouge1(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricRouge1),
            Rouge2(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricRouge2),
            Rouge3(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricRouge3),
            Rouge4(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricRouge4),
            Rouge5(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricRouge5),
            RougeL(#[allow(dead_code)] EvalTextSimilarityGraderEvaluationMetricRougeL),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FuzzyMatch(_) => Self::FuzzyMatch,
            _D::Bleu(_) => Self::Bleu,
            _D::Gleu(_) => Self::Gleu,
            _D::Meteor(_) => Self::Meteor,
            _D::Rouge1(_) => Self::Rouge1,
            _D::Rouge2(_) => Self::Rouge2,
            _D::Rouge3(_) => Self::Rouge3,
            _D::Rouge4(_) => Self::Rouge4,
            _D::Rouge5(_) => Self::Rouge5,
            _D::RougeL(_) => Self::RougeL,
        })
    }
}
impl serde::Serialize for EvalTextSimilarityGraderEvaluationMetric {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricFuzzyMatch {
            #[default]
            #[serde(rename = "fuzzy_match")]
            FuzzyMatch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricBleu {
            #[default]
            #[serde(rename = "bleu")]
            Bleu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricGleu {
            #[default]
            #[serde(rename = "gleu")]
            Gleu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricMeteor {
            #[default]
            #[serde(rename = "meteor")]
            Meteor,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge1 {
            #[default]
            #[serde(rename = "rouge_1")]
            Rouge1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge2 {
            #[default]
            #[serde(rename = "rouge_2")]
            Rouge2,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge3 {
            #[default]
            #[serde(rename = "rouge_3")]
            Rouge3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge4 {
            #[default]
            #[serde(rename = "rouge_4")]
            Rouge4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRouge5 {
            #[default]
            #[serde(rename = "rouge_5")]
            Rouge5,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderEvaluationMetricRougeL {
            #[default]
            #[serde(rename = "rouge_l")]
            RougeL,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FuzzyMatch(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricFuzzyMatch),
            Bleu(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricBleu),
            Gleu(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricGleu),
            Meteor(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricMeteor),
            Rouge1(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricRouge1),
            Rouge2(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricRouge2),
            Rouge3(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricRouge3),
            Rouge4(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricRouge4),
            Rouge5(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricRouge5),
            RougeL(#[allow(dead_code)] &'a EvalTextSimilarityGraderEvaluationMetricRougeL),
        }
        match self {
            Self::FuzzyMatch => _S::FuzzyMatch(&Default::default()).serialize(serializer),
            Self::Bleu => _S::Bleu(&Default::default()).serialize(serializer),
            Self::Gleu => _S::Gleu(&Default::default()).serialize(serializer),
            Self::Meteor => _S::Meteor(&Default::default()).serialize(serializer),
            Self::Rouge1 => _S::Rouge1(&Default::default()).serialize(serializer),
            Self::Rouge2 => _S::Rouge2(&Default::default()).serialize(serializer),
            Self::Rouge3 => _S::Rouge3(&Default::default()).serialize(serializer),
            Self::Rouge4 => _S::Rouge4(&Default::default()).serialize(serializer),
            Self::Rouge5 => _S::Rouge5(&Default::default()).serialize(serializer),
            Self::RougeL => _S::RougeL(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The evaluation metric to use. One of `fuzzy_match`, `bleu`, `gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, or `rouge_l`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum EvalTextSimilarityGraderEvaluationMetric {
    #[doc = "fuzzy_match"]
    FuzzyMatch,
    #[doc = "bleu"]
    Bleu,
    #[doc = "gleu"]
    Gleu,
    #[doc = "meteor"]
    Meteor,
    #[doc = "rouge_1"]
    Rouge1,
    #[doc = "rouge_2"]
    Rouge2,
    #[doc = "rouge_3"]
    Rouge3,
    #[doc = "rouge_4"]
    Rouge4,
    #[doc = "rouge_5"]
    Rouge5,
    #[doc = "rouge_l"]
    RougeL,
}
impl<'de> serde::Deserialize<'de> for EvalTextSimilarityGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of grader."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderType {
            #[default]
            #[serde(rename = "text_similarity")]
            TextSimilarity,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalTextSimilarityGraderType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: String,
            #[serde(rename = "reference")]
            #[allow(dead_code)]
            reference: String,
            #[serde(rename = "pass_threshold")]
            #[allow(dead_code)]
            pass_threshold: f64,
            #[serde(rename = "evaluation_metric")]
            #[allow(dead_code)]
            evaluation_metric: EvalTextSimilarityGraderEvaluationMetric,
        }
        let _D {
            name,
            input,
            reference,
            pass_threshold,
            evaluation_metric,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(EvalTextSimilarityGrader {
            name,
            input,
            reference,
            pass_threshold,
            evaluation_metric,
        })
    }
}
impl serde::Serialize for EvalTextSimilarityGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of grader."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalTextSimilarityGraderType {
            #[default]
            #[serde(rename = "text_similarity")]
            TextSimilarity,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalTextSimilarityGraderType,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "reference")]
            reference: &'a String,
            #[serde(rename = "pass_threshold")]
            pass_threshold: &'a f64,
            #[serde(rename = "evaluation_metric")]
            evaluation_metric: &'a EvalTextSimilarityGraderEvaluationMetric,
        }
        let EvalTextSimilarityGrader {
            name,
            input,
            reference,
            pass_threshold,
            evaluation_metric,
        } = self;
        _S {
            type_: &Default::default(),
            name,
            input,
            reference,
            pass_threshold,
            evaluation_metric,
        }
        .serialize(serializer)
    }
}
#[doc = "A TextSimilarityGrader object which grades text based on similarity metrics.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalTextSimilarityGrader {
    #[doc = "The name of the grader."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The text being graded."]
    pub input: String,
    #[doc = "The text being graded against."]
    pub reference: String,
    #[doc = "A float score where a value greater than or equal indicates a passing grade."]
    pub pass_threshold: f64,
    #[doc = "The evaluation metric to use. One of `fuzzy_match`, `bleu`, `gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, or `rouge_l`."]
    pub evaluation_metric: EvalTextSimilarityGraderEvaluationMetric,
}
impl<'de> serde::Deserialize<'de> for FilePath {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the file path. Always `file_path`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePathType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FilePathType,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
        }
        let _D { file_id, index, .. } = _D::deserialize(deserializer)?;
        Ok(FilePath { file_id, index })
    }
}
impl serde::Serialize for FilePath {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the file path. Always `file_path`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePathType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a FilePathType,
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "index")]
            index: &'a u64,
        }
        let FilePath { file_id, index } = self;
        _S {
            type_: &Default::default(),
            file_id,
            index,
        }
        .serialize(serializer)
    }
}
#[doc = "A path to a file.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FilePath {
    #[doc = "The ID of the file.\n"]
    pub file_id: String,
    #[doc = "The index of the file in the list of files.\n"]
    pub index: u64,
}
impl<'de> serde::Deserialize<'de> for FileSearchRanker {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchRankerDefault2024_08_21 {
            #[default]
            #[serde(rename = "default_2024_08_21")]
            Default2024_08_21,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FileSearchRankerAuto),
            Default2024_08_21(#[allow(dead_code)] FileSearchRankerDefault2024_08_21),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Default2024_08_21(_) => Self::Default2024_08_21,
        })
    }
}
impl serde::Serialize for FileSearchRanker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchRankerDefault2024_08_21 {
            #[default]
            #[serde(rename = "default_2024_08_21")]
            Default2024_08_21,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FileSearchRankerAuto),
            Default2024_08_21(#[allow(dead_code)] &'a FileSearchRankerDefault2024_08_21),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Default2024_08_21 => {
                _S::Default2024_08_21(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The ranker to use for the file search. If not specified will use the `auto` ranker."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FileSearchRanker {
    #[doc = "auto"]
    Auto,
    #[doc = "default_2024_08_21"]
    Default2024_08_21,
}
impl<'de> serde::Deserialize<'de> for FileSearchRankingOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "ranker")]
            #[allow(dead_code)]
            ranker: Option<FileSearchRanker>,
            #[serde(rename = "score_threshold")]
            #[allow(dead_code)]
            score_threshold: f64,
        }
        let _D {
            ranker,
            score_threshold,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FileSearchRankingOptions {
            ranker,
            score_threshold,
        })
    }
}
impl serde::Serialize for FileSearchRankingOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "ranker")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranker: &'a Option<FileSearchRanker>,
            #[serde(rename = "score_threshold")]
            score_threshold: &'a f64,
        }
        let FileSearchRankingOptions {
            ranker,
            score_threshold,
        } = self;
        _S {
            ranker,
            score_threshold,
        }
        .serialize(serializer)
    }
}
#[doc = "The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.\n\nSee the [file search tool documentation](/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct FileSearchRankingOptions {
    #[builder(default)]
    pub ranker: Option<FileSearchRanker>,
    #[doc = "The score threshold for the file search. All values must be a floating point number between 0 and 1."]
    pub score_threshold: f64,
}
impl<'de> serde::Deserialize<'de> for FileSearchToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusSearching {
            #[default]
            #[serde(rename = "searching")]
            Searching,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] FileSearchToolCallStatusInProgress),
            Searching(#[allow(dead_code)] FileSearchToolCallStatusSearching),
            Completed(#[allow(dead_code)] FileSearchToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] FileSearchToolCallStatusIncomplete),
            Failed(#[allow(dead_code)] FileSearchToolCallStatusFailed),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Searching(_) => Self::Searching,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
            _D::Failed(_) => Self::Failed,
        })
    }
}
impl serde::Serialize for FileSearchToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusSearching {
            #[default]
            #[serde(rename = "searching")]
            Searching,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a FileSearchToolCallStatusInProgress),
            Searching(#[allow(dead_code)] &'a FileSearchToolCallStatusSearching),
            Completed(#[allow(dead_code)] &'a FileSearchToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a FileSearchToolCallStatusIncomplete),
            Failed(#[allow(dead_code)] &'a FileSearchToolCallStatusFailed),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Searching => _S::Searching(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the file search tool call. One of `in_progress`, \n`searching`, `incomplete` or `failed`,\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FileSearchToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "searching"]
    Searching,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for FileSearchToolCallResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: Option<String>,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
            #[serde(rename = "score")]
            #[allow(dead_code)]
            score: Option<f64>,
        }
        let _D {
            file_id,
            text,
            filename,
            attributes,
            score,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FileSearchToolCallResult {
            file_id,
            text,
            filename,
            attributes,
            score,
        })
    }
}
impl serde::Serialize for FileSearchToolCallResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "filename")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filename: &'a Option<String>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
            #[serde(rename = "score")]
            #[serde(skip_serializing_if = "Option::is_none")]
            score: &'a Option<f64>,
        }
        let FileSearchToolCallResult {
            file_id,
            text,
            filename,
            attributes,
            score,
        } = self;
        _S {
            file_id,
            text,
            filename,
            attributes,
            score,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FileSearchToolCallResult {
    #[doc = "The unique ID of the file.\n"]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The text that was retrieved from the file.\n"]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "The name of the file.\n"]
    #[builder(default)]
    pub filename: Option<String>,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
    #[doc = "The relevance score of the file - a value between 0 and 1.\n"]
    #[builder(default)]
    pub score: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for FileSearchToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the file search tool call. Always `file_search_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallType {
            #[default]
            #[serde(rename = "file_search_call")]
            FileSearchCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FileSearchToolCallType,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: FileSearchToolCallStatus,
            #[serde(rename = "queries")]
            #[allow(dead_code)]
            queries: Vec<String>,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Option<Vec<FileSearchToolCallResult>>,
        }
        let _D {
            id,
            status,
            queries,
            results,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FileSearchToolCall {
            id,
            status,
            queries,
            results,
        })
    }
}
impl serde::Serialize for FileSearchToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the file search tool call. Always `file_search_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallType {
            #[default]
            #[serde(rename = "file_search_call")]
            FileSearchCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a FileSearchToolCallType,
            #[serde(rename = "status")]
            status: &'a FileSearchToolCallStatus,
            #[serde(rename = "queries")]
            queries: &'a Vec<String>,
            #[serde(rename = "results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            results: &'a Option<Vec<FileSearchToolCallResult>>,
        }
        let FileSearchToolCall {
            id,
            status,
            queries,
            results,
        } = self;
        _S {
            id,
            type_: &Default::default(),
            status,
            queries,
            results,
        }
        .serialize(serializer)
    }
}
#[doc = "The results of a file search tool call. See the \n[file search guide](/docs/guides/tools-file-search) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileSearchToolCall {
    #[doc = "The unique ID of the file search tool call.\n"]
    pub id: String,
    #[doc = "The status of the file search tool call. One of `in_progress`, \n`searching`, `incomplete` or `failed`,\n"]
    pub status: FileSearchToolCallStatus,
    #[doc = "The queries used to search for files.\n"]
    pub queries: Vec<String>,
    #[doc = "The results of the file search tool call.\n"]
    #[builder(default)]
    pub results: Option<Vec<FileSearchToolCallResult>>,
}
impl<'de> serde::Deserialize<'de> for FineTuneChatCompletionRequestAssistantMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "weight")]
            #[allow(dead_code)]
            weight: Option<u64>,
            #[serde(flatten)]
            #[allow(dead_code)]
            chat_completion_request_assistant_message: ChatCompletionRequestAssistantMessage,
        }
        let _D {
            weight,
            chat_completion_request_assistant_message,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuneChatCompletionRequestAssistantMessage {
            weight,
            chat_completion_request_assistant_message,
        })
    }
}
impl serde::Serialize for FineTuneChatCompletionRequestAssistantMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "weight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            weight: &'a Option<u64>,
            #[serde(flatten)]
            chat_completion_request_assistant_message: &'a ChatCompletionRequestAssistantMessage,
        }
        let FineTuneChatCompletionRequestAssistantMessage {
            weight,
            chat_completion_request_assistant_message,
        } = self;
        _S {
            weight,
            chat_completion_request_assistant_message,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneChatCompletionRequestAssistantMessage {
    #[doc = "Controls whether the assistant message is trained against (0 or 1)"]
    #[builder(default)]
    pub weight: Option<u64>,
    #[builder(default)]
    pub chat_completion_request_assistant_message: ChatCompletionRequestAssistantMessage,
}
impl<'de> serde::Deserialize<'de> for FineTuneChatRequestInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            System(#[allow(dead_code)] ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] ChatCompletionRequestFunctionMessage),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::System(_v) => Self::System(_v),
            _D::User(_v) => Self::User(_v),
            _D::Assistant(_v) => Self::Assistant(_v),
            _D::Tool(_v) => Self::Tool(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for FineTuneChatRequestInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            System(#[allow(dead_code)] &'a ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] &'a ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] &'a FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] &'a ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] &'a ChatCompletionRequestFunctionMessage),
        }
        match self {
            Self::System(_v) => _S::System(_v).serialize(serializer),
            Self::User(_v) => _S::User(_v).serialize(serializer),
            Self::Assistant(_v) => _S::Assistant(_v).serialize(serializer),
            Self::Tool(_v) => _S::Tool(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneChatRequestInputMessages {
    System(ChatCompletionRequestSystemMessage),
    User(ChatCompletionRequestUserMessage),
    Assistant(FineTuneChatCompletionRequestAssistantMessage),
    Tool(ChatCompletionRequestToolMessage),
    Function(ChatCompletionRequestFunctionMessage),
}
impl<'de> serde::Deserialize<'de> for FineTuneChatRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Option<Vec<FineTuneChatRequestInputMessages>>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "functions")]
            #[allow(dead_code)]
            functions: Option<Vec<ChatCompletionFunctions>>,
        }
        let _D {
            messages,
            tools,
            parallel_tool_calls,
            functions,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuneChatRequestInput {
            messages,
            tools,
            parallel_tool_calls,
            functions,
        })
    }
}
impl serde::Serialize for FineTuneChatRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            messages: &'a Option<Vec<FineTuneChatRequestInputMessages>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "functions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            functions: &'a Option<Vec<ChatCompletionFunctions>>,
        }
        let FineTuneChatRequestInput {
            messages,
            tools,
            parallel_tool_calls,
            functions,
        } = self;
        _S {
            messages,
            tools,
            parallel_tool_calls,
            functions,
        }
        .serialize(serializer)
    }
}
#[doc = "The per-line training example of a fine-tuning input file for chat models using the supervised method."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneChatRequestInput {
    #[builder(default)]
    pub messages: Option<Vec<FineTuneChatRequestInputMessages>>,
    #[doc = "A list of tools the model may generate JSON inputs for."]
    #[builder(default)]
    pub tools: Option<Vec<ChatCompletionTool>>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[doc = "A list of functions the model may generate JSON inputs for."]
    #[builder(default)]
    pub functions: Option<Vec<ChatCompletionFunctions>>,
}
impl<'de> serde::Deserialize<'de> for FineTuneCompletionRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
            #[serde(rename = "completion")]
            #[allow(dead_code)]
            completion: Option<String>,
        }
        let _D {
            prompt, completion, ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuneCompletionRequestInput { prompt, completion })
    }
}
impl serde::Serialize for FineTuneCompletionRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
            #[serde(rename = "completion")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completion: &'a Option<String>,
        }
        let FineTuneCompletionRequestInput { prompt, completion } = self;
        _S { prompt, completion }.serialize(serializer)
    }
}
#[doc = "The per-line training example of a fine-tuning input file for completions models"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneCompletionRequestInput {
    #[doc = "The input prompt for this training example."]
    #[builder(default)]
    pub prompt: Option<String>,
    #[doc = "The desired completion for this training example."]
    #[builder(default)]
    pub completion: Option<String>,
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoMethodHyperparametersBeta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoMethodHyperparametersBetaAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuneDpoMethodHyperparametersBetaAuto),
            Float(#[allow(dead_code)] f64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Float(_v) => Self::Float(_v),
        })
    }
}
impl serde::Serialize for FineTuneDpoMethodHyperparametersBeta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoMethodHyperparametersBetaAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneDpoMethodHyperparametersBetaAuto),
            Float(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Float(_v) => _S::Float(_v).serialize(serializer),
        }
    }
}
#[doc = "The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneDpoMethodHyperparametersBeta {
    #[doc = "auto"]
    Auto,
    Float(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoMethodHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoMethodHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuneDpoMethodHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Integer(_v) => Self::Integer(_v),
        })
    }
}
impl serde::Serialize for FineTuneDpoMethodHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoMethodHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneDpoMethodHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneDpoMethodHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoMethodHyperparametersLearningRateMultiplier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoMethodHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuneDpoMethodHyperparametersLearningRateMultiplierAuto),
            Float(#[allow(dead_code)] f64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Float(_v) => Self::Float(_v),
        })
    }
}
impl serde::Serialize for FineTuneDpoMethodHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoMethodHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(
                #[allow(dead_code)] &'a FineTuneDpoMethodHyperparametersLearningRateMultiplierAuto,
            ),
            Float(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Float(_v) => _S::Float(_v).serialize(serializer),
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneDpoMethodHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Float(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoMethodHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoMethodHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuneDpoMethodHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Integer(_v) => Self::Integer(_v),
        })
    }
}
impl serde::Serialize for FineTuneDpoMethodHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoMethodHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneDpoMethodHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneDpoMethodHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoMethodHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "beta")]
            #[allow(dead_code)]
            beta: Option<FineTuneDpoMethodHyperparametersBeta>,
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<FineTuneDpoMethodHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier:
                Option<FineTuneDpoMethodHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<FineTuneDpoMethodHyperparametersNEpochs>,
        }
        let _D {
            beta,
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuneDpoMethodHyperparameters {
            beta,
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        })
    }
}
impl serde::Serialize for FineTuneDpoMethodHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "beta")]
            #[serde(skip_serializing_if = "Option::is_none")]
            beta: &'a Option<FineTuneDpoMethodHyperparametersBeta>,
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<FineTuneDpoMethodHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier:
                &'a Option<FineTuneDpoMethodHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<FineTuneDpoMethodHyperparametersNEpochs>,
        }
        let FineTuneDpoMethodHyperparameters {
            beta,
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        } = self;
        _S {
            beta,
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the fine-tuning job."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneDpoMethodHyperparameters {
    #[doc = "The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model.\n"]
    #[builder(default)]
    pub beta: Option<FineTuneDpoMethodHyperparametersBeta>,
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<FineTuneDpoMethodHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier: Option<FineTuneDpoMethodHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<FineTuneDpoMethodHyperparametersNEpochs>,
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: Option<FineTuneDpoMethodHyperparameters>,
        }
        let _D {
            hyperparameters, ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuneDpoMethod { hyperparameters })
    }
}
impl serde::Serialize for FineTuneDpoMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "hyperparameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            hyperparameters: &'a Option<FineTuneDpoMethodHyperparameters>,
        }
        let FineTuneDpoMethod { hyperparameters } = self;
        _S { hyperparameters }.serialize(serializer)
    }
}
#[doc = "Configuration for the DPO fine-tuning method."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneDpoMethod {
    #[doc = "The hyperparameters used for the fine-tuning job."]
    #[builder(default)]
    pub hyperparameters: Option<FineTuneDpoMethodHyperparameters>,
}
impl<'de> serde::Deserialize<'de> for FineTuneMethodType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeSupervised {
            #[default]
            #[serde(rename = "supervised")]
            Supervised,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeDpo {
            #[default]
            #[serde(rename = "dpo")]
            Dpo,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Supervised(#[allow(dead_code)] FineTuneMethodTypeSupervised),
            Dpo(#[allow(dead_code)] FineTuneMethodTypeDpo),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Supervised(_) => Self::Supervised,
            _D::Dpo(_) => Self::Dpo,
        })
    }
}
impl serde::Serialize for FineTuneMethodType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeSupervised {
            #[default]
            #[serde(rename = "supervised")]
            Supervised,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeDpo {
            #[default]
            #[serde(rename = "dpo")]
            Dpo,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Supervised(#[allow(dead_code)] &'a FineTuneMethodTypeSupervised),
            Dpo(#[allow(dead_code)] &'a FineTuneMethodTypeDpo),
        }
        match self {
            Self::Supervised => _S::Supervised(&Default::default()).serialize(serializer),
            Self::Dpo => _S::Dpo(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of method. Is either `supervised` or `dpo`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneMethodType {
    #[doc = "supervised"]
    Supervised,
    #[doc = "dpo"]
    Dpo,
}
impl<'de> serde::Deserialize<'de> for FineTuneMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<FineTuneMethodType>,
            #[serde(rename = "supervised")]
            #[allow(dead_code)]
            supervised: Option<FineTuneSupervisedMethod>,
            #[serde(rename = "dpo")]
            #[allow(dead_code)]
            dpo: Option<FineTuneDpoMethod>,
        }
        let _D {
            type_,
            supervised,
            dpo,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuneMethod {
            type_,
            supervised,
            dpo,
        })
    }
}
impl serde::Serialize for FineTuneMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<FineTuneMethodType>,
            #[serde(rename = "supervised")]
            #[serde(skip_serializing_if = "Option::is_none")]
            supervised: &'a Option<FineTuneSupervisedMethod>,
            #[serde(rename = "dpo")]
            #[serde(skip_serializing_if = "Option::is_none")]
            dpo: &'a Option<FineTuneDpoMethod>,
        }
        let FineTuneMethod {
            type_,
            supervised,
            dpo,
        } = self;
        _S {
            type_,
            supervised,
            dpo,
        }
        .serialize(serializer)
    }
}
#[doc = "The method used for fine-tuning."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneMethod {
    #[doc = "The type of method. Is either `supervised` or `dpo`."]
    #[builder(default)]
    pub type_: Option<FineTuneMethodType>,
    #[builder(default)]
    pub supervised: Option<FineTuneSupervisedMethod>,
    #[builder(default)]
    pub dpo: Option<FineTuneDpoMethod>,
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInputInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            System(#[allow(dead_code)] ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] ChatCompletionRequestFunctionMessage),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::System(_v) => Self::System(_v),
            _D::User(_v) => Self::User(_v),
            _D::Assistant(_v) => Self::Assistant(_v),
            _D::Tool(_v) => Self::Tool(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInputInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            System(#[allow(dead_code)] &'a ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] &'a ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] &'a FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] &'a ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] &'a ChatCompletionRequestFunctionMessage),
        }
        match self {
            Self::System(_v) => _S::System(_v).serialize(serializer),
            Self::User(_v) => _S::User(_v).serialize(serializer),
            Self::Assistant(_v) => _S::Assistant(_v).serialize(serializer),
            Self::Tool(_v) => _S::Tool(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTunePreferenceRequestInputInputMessages {
    System(ChatCompletionRequestSystemMessage),
    User(ChatCompletionRequestUserMessage),
    Assistant(FineTuneChatCompletionRequestAssistantMessage),
    Tool(ChatCompletionRequestToolMessage),
    Function(ChatCompletionRequestFunctionMessage),
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInputInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Option<Vec<FineTunePreferenceRequestInputInputMessages>>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
        }
        let _D {
            messages,
            tools,
            parallel_tool_calls,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTunePreferenceRequestInputInput {
            messages,
            tools,
            parallel_tool_calls,
        })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInputInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            messages: &'a Option<Vec<FineTunePreferenceRequestInputInputMessages>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
        }
        let FineTunePreferenceRequestInputInput {
            messages,
            tools,
            parallel_tool_calls,
        } = self;
        _S {
            messages,
            tools,
            parallel_tool_calls,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTunePreferenceRequestInputInput {
    #[builder(default)]
    pub messages: Option<Vec<FineTunePreferenceRequestInputInputMessages>>,
    #[doc = "A list of tools the model may generate JSON inputs for."]
    #[builder(default)]
    pub tools: Option<Vec<ChatCompletionTool>>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInputPreferredCompletion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ChatCompletionRequestAssistantMessage(
                #[allow(dead_code)] ChatCompletionRequestAssistantMessage,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ChatCompletionRequestAssistantMessage(_v) => {
                Self::ChatCompletionRequestAssistantMessage(_v)
            }
        })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInputPreferredCompletion {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ChatCompletionRequestAssistantMessage(
                #[allow(dead_code)] &'a ChatCompletionRequestAssistantMessage,
            ),
        }
        match self {
            Self::ChatCompletionRequestAssistantMessage(_v) => {
                _S::ChatCompletionRequestAssistantMessage(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTunePreferenceRequestInputPreferredCompletion {
    ChatCompletionRequestAssistantMessage(ChatCompletionRequestAssistantMessage),
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInputNonPreferredCompletion {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ChatCompletionRequestAssistantMessage(
                #[allow(dead_code)] ChatCompletionRequestAssistantMessage,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ChatCompletionRequestAssistantMessage(_v) => {
                Self::ChatCompletionRequestAssistantMessage(_v)
            }
        })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInputNonPreferredCompletion {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ChatCompletionRequestAssistantMessage(
                #[allow(dead_code)] &'a ChatCompletionRequestAssistantMessage,
            ),
        }
        match self {
            Self::ChatCompletionRequestAssistantMessage(_v) => {
                _S::ChatCompletionRequestAssistantMessage(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTunePreferenceRequestInputNonPreferredCompletion {
    ChatCompletionRequestAssistantMessage(ChatCompletionRequestAssistantMessage),
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Option<FineTunePreferenceRequestInputInput>,
            #[serde(rename = "preferred_completion")]
            #[allow(dead_code)]
            preferred_completion: Option<Vec<FineTunePreferenceRequestInputPreferredCompletion>>,
            #[serde(rename = "non_preferred_completion")]
            #[allow(dead_code)]
            non_preferred_completion:
                Option<Vec<FineTunePreferenceRequestInputNonPreferredCompletion>>,
        }
        let _D {
            input,
            preferred_completion,
            non_preferred_completion,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTunePreferenceRequestInput {
            input,
            preferred_completion,
            non_preferred_completion,
        })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "input")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input: &'a Option<FineTunePreferenceRequestInputInput>,
            #[serde(rename = "preferred_completion")]
            #[serde(skip_serializing_if = "Option::is_none")]
            preferred_completion:
                &'a Option<Vec<FineTunePreferenceRequestInputPreferredCompletion>>,
            #[serde(rename = "non_preferred_completion")]
            #[serde(skip_serializing_if = "Option::is_none")]
            non_preferred_completion:
                &'a Option<Vec<FineTunePreferenceRequestInputNonPreferredCompletion>>,
        }
        let FineTunePreferenceRequestInput {
            input,
            preferred_completion,
            non_preferred_completion,
        } = self;
        _S {
            input,
            preferred_completion,
            non_preferred_completion,
        }
        .serialize(serializer)
    }
}
#[doc = "The per-line training example of a fine-tuning input file for chat models using the dpo method."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTunePreferenceRequestInput {
    #[builder(default)]
    pub input: Option<FineTunePreferenceRequestInputInput>,
    #[doc = "The preferred completion message for the output."]
    #[builder(default)]
    pub preferred_completion: Option<Vec<FineTunePreferenceRequestInputPreferredCompletion>>,
    #[doc = "The non-preferred completion message for the output."]
    #[builder(default)]
    pub non_preferred_completion: Option<Vec<FineTunePreferenceRequestInputNonPreferredCompletion>>,
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedMethodHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedMethodHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuneSupervisedMethodHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Integer(_v) => Self::Integer(_v),
        })
    }
}
impl serde::Serialize for FineTuneSupervisedMethodHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedMethodHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneSupervisedMethodHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneSupervisedMethodHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de>
    for FineTuneSupervisedMethodHyperparametersLearningRateMultiplier
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedMethodHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(
                #[allow(dead_code)]
                FineTuneSupervisedMethodHyperparametersLearningRateMultiplierAuto,
            ),
            Float(#[allow(dead_code)] f64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Float(_v) => Self::Float(_v),
        })
    }
}
impl serde::Serialize for FineTuneSupervisedMethodHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedMethodHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(
                #[allow(dead_code)]
                &'a FineTuneSupervisedMethodHyperparametersLearningRateMultiplierAuto,
            ),
            Float(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Float(_v) => _S::Float(_v).serialize(serializer),
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneSupervisedMethodHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Float(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedMethodHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedMethodHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuneSupervisedMethodHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Integer(_v) => Self::Integer(_v),
        })
    }
}
impl serde::Serialize for FineTuneSupervisedMethodHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedMethodHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneSupervisedMethodHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneSupervisedMethodHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedMethodHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<FineTuneSupervisedMethodHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier:
                Option<FineTuneSupervisedMethodHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<FineTuneSupervisedMethodHyperparametersNEpochs>,
        }
        let _D {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuneSupervisedMethodHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        })
    }
}
impl serde::Serialize for FineTuneSupervisedMethodHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<FineTuneSupervisedMethodHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier:
                &'a Option<FineTuneSupervisedMethodHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<FineTuneSupervisedMethodHyperparametersNEpochs>,
        }
        let FineTuneSupervisedMethodHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        } = self;
        _S {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the fine-tuning job."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneSupervisedMethodHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<FineTuneSupervisedMethodHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier:
        Option<FineTuneSupervisedMethodHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<FineTuneSupervisedMethodHyperparametersNEpochs>,
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: Option<FineTuneSupervisedMethodHyperparameters>,
        }
        let _D {
            hyperparameters, ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuneSupervisedMethod { hyperparameters })
    }
}
impl serde::Serialize for FineTuneSupervisedMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "hyperparameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            hyperparameters: &'a Option<FineTuneSupervisedMethodHyperparameters>,
        }
        let FineTuneSupervisedMethod { hyperparameters } = self;
        _S { hyperparameters }.serialize(serializer)
    }
}
#[doc = "Configuration for the supervised fine-tuning method."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneSupervisedMethod {
    #[doc = "The hyperparameters used for the fine-tuning job."]
    #[builder(default)]
    pub hyperparameters: Option<FineTuneSupervisedMethodHyperparameters>,
}
impl<'de> serde::Deserialize<'de> for FineTuningCheckpointPermission {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"checkpoint.permission\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningCheckpointPermissionObject {
            #[default]
            #[serde(rename = "checkpoint.permission")]
            CheckpointPermission,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: FineTuningCheckpointPermissionObject,
        }
        let _D {
            id,
            created_at,
            project_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuningCheckpointPermission {
            id,
            created_at,
            project_id,
        })
    }
}
impl serde::Serialize for FineTuningCheckpointPermission {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"checkpoint.permission\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningCheckpointPermissionObject {
            #[default]
            #[serde(rename = "checkpoint.permission")]
            CheckpointPermission,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "project_id")]
            project_id: &'a String,
            #[serde(rename = "object")]
            object: &'a FineTuningCheckpointPermissionObject,
        }
        let FineTuningCheckpointPermission {
            id,
            created_at,
            project_id,
        } = self;
        _S {
            id,
            created_at,
            project_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The `checkpoint.permission` object represents a permission for a fine-tuned model checkpoint.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningCheckpointPermission {
    #[doc = "The permission identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the permission was created."]
    pub created_at: u64,
    #[doc = "The project identifier that the permission is for."]
    pub project_id: String,
}
impl<'de> serde::Deserialize<'de> for FineTuningIntegrationWandb {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "project")]
            #[allow(dead_code)]
            project: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "entity")]
            #[allow(dead_code)]
            entity: Option<String>,
            #[serde(rename = "tags")]
            #[allow(dead_code)]
            tags: Option<Vec<String>>,
        }
        let _D {
            project,
            name,
            entity,
            tags,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuningIntegrationWandb {
            project,
            name,
            entity,
            tags,
        })
    }
}
impl serde::Serialize for FineTuningIntegrationWandb {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "project")]
            project: &'a String,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "entity")]
            #[serde(skip_serializing_if = "Option::is_none")]
            entity: &'a Option<String>,
            #[serde(rename = "tags")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tags: &'a Option<Vec<String>>,
        }
        let FineTuningIntegrationWandb {
            project,
            name,
            entity,
            tags,
        } = self;
        _S {
            project,
            name,
            entity,
            tags,
        }
        .serialize(serializer)
    }
}
#[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningIntegrationWandb {
    #[doc = "The name of the project that the new run will be created under.\n"]
    pub project: String,
    #[doc = "A display name to set for the run. If not set, we will use the Job ID as the name.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The entity to use for the run. This allows you to set the team or username of the WandB user that you would\nlike associated with the run. If not set, the default entity for the registered WandB API key is used.\n"]
    #[builder(default)]
    pub entity: Option<String>,
    #[doc = "A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some\ndefault tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n"]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for FineTuningIntegration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the integration being enabled for the fine-tuning job"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningIntegrationType {
            #[default]
            #[serde(rename = "wandb")]
            Wandb,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FineTuningIntegrationType,
            #[serde(rename = "wandb")]
            #[allow(dead_code)]
            wandb: FineTuningIntegrationWandb,
        }
        let _D { wandb, .. } = _D::deserialize(deserializer)?;
        Ok(FineTuningIntegration { wandb })
    }
}
impl serde::Serialize for FineTuningIntegration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the integration being enabled for the fine-tuning job"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningIntegrationType {
            #[default]
            #[serde(rename = "wandb")]
            Wandb,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a FineTuningIntegrationType,
            #[serde(rename = "wandb")]
            wandb: &'a FineTuningIntegrationWandb,
        }
        let FineTuningIntegration { wandb } = self;
        _S {
            type_: &Default::default(),
            wandb,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningIntegration {
    #[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
    pub wandb: FineTuningIntegrationWandb,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
        }
        let _D {
            code,
            message,
            param,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuningJobError {
            code,
            message,
            param,
        })
    }
}
impl serde::Serialize for FineTuningJobError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
        }
        let FineTuningJobError {
            code,
            message,
            param,
        } = self;
        _S {
            code,
            message,
            param,
        }
        .serialize(serializer)
    }
}
#[doc = "For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJobError {
    #[doc = "A machine-readable error code."]
    pub code: String,
    #[doc = "A human-readable error message."]
    pub message: String,
    #[doc = "The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific."]
    #[builder(default)]
    pub param: Option<String>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuningJobHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Integer(_v) => Self::Integer(_v),
        })
    }
}
impl serde::Serialize for FineTuningJobHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FineTuningJobHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuningJobHyperparametersLearningRateMultiplier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuningJobHyperparametersLearningRateMultiplierAuto),
            Float(#[allow(dead_code)] f64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Float(_v) => Self::Float(_v),
        })
    }
}
impl serde::Serialize for FineTuningJobHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FineTuningJobHyperparametersLearningRateMultiplierAuto),
            Float(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Float(_v) => _S::Float(_v).serialize(serializer),
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Float(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuningJobHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] FineTuningJobHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Integer(_v) => Self::Integer(_v),
        })
    }
}
impl serde::Serialize for FineTuningJobHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a FineTuningJobHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuningJobHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<FineTuningJobHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier: Option<FineTuningJobHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<FineTuningJobHyperparametersNEpochs>,
        }
        let _D {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuningJobHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        })
    }
}
impl serde::Serialize for FineTuningJobHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<FineTuningJobHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier:
                &'a Option<FineTuningJobHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<FineTuningJobHyperparametersNEpochs>,
        }
        let FineTuningJobHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        } = self;
        _S {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuningJobHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<FineTuningJobHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier: Option<FineTuningJobHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<FineTuningJobHyperparametersNEpochs>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusValidatingFiles {
            #[default]
            #[serde(rename = "validating_files")]
            ValidatingFiles,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusRunning {
            #[default]
            #[serde(rename = "running")]
            Running,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusSucceeded {
            #[default]
            #[serde(rename = "succeeded")]
            Succeeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ValidatingFiles(#[allow(dead_code)] FineTuningJobStatusValidatingFiles),
            Queued(#[allow(dead_code)] FineTuningJobStatusQueued),
            Running(#[allow(dead_code)] FineTuningJobStatusRunning),
            Succeeded(#[allow(dead_code)] FineTuningJobStatusSucceeded),
            Failed(#[allow(dead_code)] FineTuningJobStatusFailed),
            Cancelled(#[allow(dead_code)] FineTuningJobStatusCancelled),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ValidatingFiles(_) => Self::ValidatingFiles,
            _D::Queued(_) => Self::Queued,
            _D::Running(_) => Self::Running,
            _D::Succeeded(_) => Self::Succeeded,
            _D::Failed(_) => Self::Failed,
            _D::Cancelled(_) => Self::Cancelled,
        })
    }
}
impl serde::Serialize for FineTuningJobStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusValidatingFiles {
            #[default]
            #[serde(rename = "validating_files")]
            ValidatingFiles,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusRunning {
            #[default]
            #[serde(rename = "running")]
            Running,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusSucceeded {
            #[default]
            #[serde(rename = "succeeded")]
            Succeeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ValidatingFiles(#[allow(dead_code)] &'a FineTuningJobStatusValidatingFiles),
            Queued(#[allow(dead_code)] &'a FineTuningJobStatusQueued),
            Running(#[allow(dead_code)] &'a FineTuningJobStatusRunning),
            Succeeded(#[allow(dead_code)] &'a FineTuningJobStatusSucceeded),
            Failed(#[allow(dead_code)] &'a FineTuningJobStatusFailed),
            Cancelled(#[allow(dead_code)] &'a FineTuningJobStatusCancelled),
        }
        match self {
            Self::ValidatingFiles => _S::ValidatingFiles(&Default::default()).serialize(serializer),
            Self::Queued => _S::Queued(&Default::default()).serialize(serializer),
            Self::Running => _S::Running(&Default::default()).serialize(serializer),
            Self::Succeeded => _S::Succeeded(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobStatus {
    #[doc = "validating_files"]
    ValidatingFiles,
    #[doc = "queued"]
    Queued,
    #[doc = "running"]
    Running,
    #[doc = "succeeded"]
    Succeeded,
    #[doc = "failed"]
    Failed,
    #[doc = "cancelled"]
    Cancelled,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobIntegration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FineTuningIntegration(#[allow(dead_code)] FineTuningIntegration),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FineTuningIntegration(_v) => Self::FineTuningIntegration(_v),
        })
    }
}
impl serde::Serialize for FineTuningJobIntegration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FineTuningIntegration(#[allow(dead_code)] &'a FineTuningIntegration),
        }
        match self {
            Self::FineTuningIntegration(_v) => _S::FineTuningIntegration(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobIntegration {
    FineTuningIntegration(FineTuningIntegration),
}
impl<'de> serde::Deserialize<'de> for FineTuningJob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"fine_tuning.job\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobObject {
            #[default]
            #[serde(rename = "fine_tuning.job")]
            FineTuningJob,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<FineTuningJobError>,
            #[serde(rename = "fine_tuned_model")]
            #[allow(dead_code)]
            fine_tuned_model: Option<String>,
            #[serde(rename = "finished_at")]
            #[allow(dead_code)]
            finished_at: Option<u64>,
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: FineTuningJobHyperparameters,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: FineTuningJobObject,
            #[serde(rename = "organization_id")]
            #[allow(dead_code)]
            organization_id: String,
            #[serde(rename = "result_files")]
            #[allow(dead_code)]
            result_files: Vec<String>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: FineTuningJobStatus,
            #[serde(rename = "trained_tokens")]
            #[allow(dead_code)]
            trained_tokens: Option<u64>,
            #[serde(rename = "training_file")]
            #[allow(dead_code)]
            training_file: String,
            #[serde(rename = "validation_file")]
            #[allow(dead_code)]
            validation_file: Option<String>,
            #[serde(rename = "integrations")]
            #[allow(dead_code)]
            integrations: Option<Vec<FineTuningJobIntegration>>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: u64,
            #[serde(rename = "estimated_finish")]
            #[allow(dead_code)]
            estimated_finish: Option<u64>,
            #[serde(rename = "method")]
            #[allow(dead_code)]
            method: Option<FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuningJob {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        })
    }
}
impl serde::Serialize for FineTuningJob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"fine_tuning.job\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobObject {
            #[default]
            #[serde(rename = "fine_tuning.job")]
            FineTuningJob,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<FineTuningJobError>,
            #[serde(rename = "fine_tuned_model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            fine_tuned_model: &'a Option<String>,
            #[serde(rename = "finished_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            finished_at: &'a Option<u64>,
            #[serde(rename = "hyperparameters")]
            hyperparameters: &'a FineTuningJobHyperparameters,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "object")]
            object: &'a FineTuningJobObject,
            #[serde(rename = "organization_id")]
            organization_id: &'a String,
            #[serde(rename = "result_files")]
            result_files: &'a Vec<String>,
            #[serde(rename = "status")]
            status: &'a FineTuningJobStatus,
            #[serde(rename = "trained_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            trained_tokens: &'a Option<u64>,
            #[serde(rename = "training_file")]
            training_file: &'a String,
            #[serde(rename = "validation_file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            validation_file: &'a Option<String>,
            #[serde(rename = "integrations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            integrations: &'a Option<Vec<FineTuningJobIntegration>>,
            #[serde(rename = "seed")]
            seed: &'a u64,
            #[serde(rename = "estimated_finish")]
            #[serde(skip_serializing_if = "Option::is_none")]
            estimated_finish: &'a Option<u64>,
            #[serde(rename = "method")]
            #[serde(skip_serializing_if = "Option::is_none")]
            method: &'a Option<FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let FineTuningJob {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        } = self;
        _S {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            object: &Default::default(),
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "The `fine_tuning.job` object represents a fine-tuning job that has been created through the API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJob {
    #[doc = "The object identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was created."]
    pub created_at: u64,
    #[doc = "For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure."]
    #[builder(default)]
    pub error: Option<FineTuningJobError>,
    #[doc = "The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub fine_tuned_model: Option<String>,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub finished_at: Option<u64>,
    #[doc = "The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs."]
    #[builder(default)]
    pub hyperparameters: FineTuningJobHyperparameters,
    #[doc = "The base model that is being fine-tuned."]
    pub model: String,
    #[doc = "The organization that owns the fine-tuning job."]
    pub organization_id: String,
    #[doc = "The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    pub result_files: Vec<String>,
    #[doc = "The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`."]
    pub status: FineTuningJobStatus,
    #[doc = "The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub trained_tokens: Option<u64>,
    #[doc = "The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    pub training_file: String,
    #[doc = "The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    #[builder(default)]
    pub validation_file: Option<String>,
    #[doc = "A list of integrations to enable for this fine-tuning job."]
    #[builder(default)]
    pub integrations: Option<Vec<FineTuningJobIntegration>>,
    #[doc = "The seed used for the fine-tuning job."]
    pub seed: u64,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running."]
    #[builder(default)]
    pub estimated_finish: Option<u64>,
    #[builder(default)]
    pub method: Option<FineTuneMethod>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobCheckpointMetrics {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "step")]
            #[allow(dead_code)]
            step: Option<f64>,
            #[serde(rename = "train_loss")]
            #[allow(dead_code)]
            train_loss: Option<f64>,
            #[serde(rename = "train_mean_token_accuracy")]
            #[allow(dead_code)]
            train_mean_token_accuracy: Option<f64>,
            #[serde(rename = "valid_loss")]
            #[allow(dead_code)]
            valid_loss: Option<f64>,
            #[serde(rename = "valid_mean_token_accuracy")]
            #[allow(dead_code)]
            valid_mean_token_accuracy: Option<f64>,
            #[serde(rename = "full_valid_loss")]
            #[allow(dead_code)]
            full_valid_loss: Option<f64>,
            #[serde(rename = "full_valid_mean_token_accuracy")]
            #[allow(dead_code)]
            full_valid_mean_token_accuracy: Option<f64>,
        }
        let _D {
            step,
            train_loss,
            train_mean_token_accuracy,
            valid_loss,
            valid_mean_token_accuracy,
            full_valid_loss,
            full_valid_mean_token_accuracy,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuningJobCheckpointMetrics {
            step,
            train_loss,
            train_mean_token_accuracy,
            valid_loss,
            valid_mean_token_accuracy,
            full_valid_loss,
            full_valid_mean_token_accuracy,
        })
    }
}
impl serde::Serialize for FineTuningJobCheckpointMetrics {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "step")]
            #[serde(skip_serializing_if = "Option::is_none")]
            step: &'a Option<f64>,
            #[serde(rename = "train_loss")]
            #[serde(skip_serializing_if = "Option::is_none")]
            train_loss: &'a Option<f64>,
            #[serde(rename = "train_mean_token_accuracy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            train_mean_token_accuracy: &'a Option<f64>,
            #[serde(rename = "valid_loss")]
            #[serde(skip_serializing_if = "Option::is_none")]
            valid_loss: &'a Option<f64>,
            #[serde(rename = "valid_mean_token_accuracy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            valid_mean_token_accuracy: &'a Option<f64>,
            #[serde(rename = "full_valid_loss")]
            #[serde(skip_serializing_if = "Option::is_none")]
            full_valid_loss: &'a Option<f64>,
            #[serde(rename = "full_valid_mean_token_accuracy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            full_valid_mean_token_accuracy: &'a Option<f64>,
        }
        let FineTuningJobCheckpointMetrics {
            step,
            train_loss,
            train_mean_token_accuracy,
            valid_loss,
            valid_mean_token_accuracy,
            full_valid_loss,
            full_valid_mean_token_accuracy,
        } = self;
        _S {
            step,
            train_loss,
            train_mean_token_accuracy,
            valid_loss,
            valid_mean_token_accuracy,
            full_valid_loss,
            full_valid_mean_token_accuracy,
        }
        .serialize(serializer)
    }
}
#[doc = "Metrics at the step number during the fine-tuning job."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuningJobCheckpointMetrics {
    #[builder(default)]
    pub step: Option<f64>,
    #[builder(default)]
    pub train_loss: Option<f64>,
    #[builder(default)]
    pub train_mean_token_accuracy: Option<f64>,
    #[builder(default)]
    pub valid_loss: Option<f64>,
    #[builder(default)]
    pub valid_mean_token_accuracy: Option<f64>,
    #[builder(default)]
    pub full_valid_loss: Option<f64>,
    #[builder(default)]
    pub full_valid_mean_token_accuracy: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobCheckpoint {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"fine_tuning.job.checkpoint\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobCheckpointObject {
            #[default]
            #[serde(rename = "fine_tuning.job.checkpoint")]
            FineTuningJobCheckpoint,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            #[allow(dead_code)]
            fine_tuned_model_checkpoint: String,
            #[serde(rename = "step_number")]
            #[allow(dead_code)]
            step_number: u64,
            #[serde(rename = "metrics")]
            #[allow(dead_code)]
            metrics: FineTuningJobCheckpointMetrics,
            #[serde(rename = "fine_tuning_job_id")]
            #[allow(dead_code)]
            fine_tuning_job_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: FineTuningJobCheckpointObject,
        }
        let _D {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuningJobCheckpoint {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
        })
    }
}
impl serde::Serialize for FineTuningJobCheckpoint {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"fine_tuning.job.checkpoint\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobCheckpointObject {
            #[default]
            #[serde(rename = "fine_tuning.job.checkpoint")]
            FineTuningJobCheckpoint,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            fine_tuned_model_checkpoint: &'a String,
            #[serde(rename = "step_number")]
            step_number: &'a u64,
            #[serde(rename = "metrics")]
            metrics: &'a FineTuningJobCheckpointMetrics,
            #[serde(rename = "fine_tuning_job_id")]
            fine_tuning_job_id: &'a String,
            #[serde(rename = "object")]
            object: &'a FineTuningJobCheckpointObject,
        }
        let FineTuningJobCheckpoint {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
        } = self;
        _S {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJobCheckpoint {
    #[doc = "The checkpoint identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the checkpoint was created."]
    pub created_at: u64,
    #[doc = "The name of the fine-tuned checkpoint model that is created."]
    pub fine_tuned_model_checkpoint: String,
    #[doc = "The step number that the checkpoint was created at."]
    pub step_number: u64,
    #[doc = "Metrics at the step number during the fine-tuning job."]
    #[builder(default)]
    pub metrics: FineTuningJobCheckpointMetrics,
    #[doc = "The name of the fine-tuning job that this checkpoint was created from."]
    pub fine_tuning_job_id: String,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobEventLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelInfo {
            #[default]
            #[serde(rename = "info")]
            Info,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelWarn {
            #[default]
            #[serde(rename = "warn")]
            Warn,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelError {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Info(#[allow(dead_code)] FineTuningJobEventLevelInfo),
            Warn(#[allow(dead_code)] FineTuningJobEventLevelWarn),
            Error(#[allow(dead_code)] FineTuningJobEventLevelError),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Info(_) => Self::Info,
            _D::Warn(_) => Self::Warn,
            _D::Error(_) => Self::Error,
        })
    }
}
impl serde::Serialize for FineTuningJobEventLevel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelInfo {
            #[default]
            #[serde(rename = "info")]
            Info,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelWarn {
            #[default]
            #[serde(rename = "warn")]
            Warn,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelError {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Info(#[allow(dead_code)] &'a FineTuningJobEventLevelInfo),
            Warn(#[allow(dead_code)] &'a FineTuningJobEventLevelWarn),
            Error(#[allow(dead_code)] &'a FineTuningJobEventLevelError),
        }
        match self {
            Self::Info => _S::Info(&Default::default()).serialize(serializer),
            Self::Warn => _S::Warn(&Default::default()).serialize(serializer),
            Self::Error => _S::Error(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The log level of the event."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobEventLevel {
    #[doc = "info"]
    Info,
    #[doc = "warn"]
    Warn,
    #[doc = "error"]
    Error,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobEventType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventTypeMetrics {
            #[default]
            #[serde(rename = "metrics")]
            Metrics,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Message(#[allow(dead_code)] FineTuningJobEventTypeMessage),
            Metrics(#[allow(dead_code)] FineTuningJobEventTypeMetrics),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Message(_) => Self::Message,
            _D::Metrics(_) => Self::Metrics,
        })
    }
}
impl serde::Serialize for FineTuningJobEventType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventTypeMetrics {
            #[default]
            #[serde(rename = "metrics")]
            Metrics,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Message(#[allow(dead_code)] &'a FineTuningJobEventTypeMessage),
            Metrics(#[allow(dead_code)] &'a FineTuningJobEventTypeMetrics),
        }
        match self {
            Self::Message => _S::Message(&Default::default()).serialize(serializer),
            Self::Metrics => _S::Metrics(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of event."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobEventType {
    #[doc = "message"]
    Message,
    #[doc = "metrics"]
    Metrics,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"fine_tuning.job.event\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventObject {
            #[default]
            #[serde(rename = "fine_tuning.job.event")]
            FineTuningJobEvent,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: FineTuningJobEventObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "level")]
            #[allow(dead_code)]
            level: FineTuningJobEventLevel,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<FineTuningJobEventType>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let _D {
            id,
            created_at,
            level,
            message,
            type_,
            data,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FineTuningJobEvent {
            id,
            created_at,
            level,
            message,
            type_,
            data,
        })
    }
}
impl serde::Serialize for FineTuningJobEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"fine_tuning.job.event\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventObject {
            #[default]
            #[serde(rename = "fine_tuning.job.event")]
            FineTuningJobEvent,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a FineTuningJobEventObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "level")]
            level: &'a FineTuningJobEventLevel,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<FineTuningJobEventType>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let FineTuningJobEvent {
            id,
            created_at,
            level,
            message,
            type_,
            data,
        } = self;
        _S {
            object: &Default::default(),
            id,
            created_at,
            level,
            message,
            type_,
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Fine-tuning job event object"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJobEvent {
    #[doc = "The object identifier."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was created."]
    pub created_at: u64,
    #[doc = "The log level of the event."]
    pub level: FineTuningJobEventLevel,
    #[doc = "The message of the event."]
    pub message: String,
    #[doc = "The type of event."]
    #[builder(default)]
    pub type_: Option<FineTuningJobEventType>,
    #[doc = "The data associated with the event."]
    #[builder(default)]
    pub data: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for FunctionObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<FunctionParameters>,
            #[serde(rename = "strict")]
            #[allow(dead_code)]
            strict: Option<bool>,
        }
        let _D {
            description,
            name,
            parameters,
            strict,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FunctionObject {
            description,
            name,
            parameters,
            strict,
        })
    }
}
impl serde::Serialize for FunctionObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<FunctionParameters>,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let FunctionObject {
            description,
            name,
            parameters,
            strict,
        } = self;
        _S {
            description,
            name,
            parameters,
            strict,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionObject {
    #[doc = "A description of what the function does, used by the model to choose when and how to call the function."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."]
    pub name: String,
    #[builder(default)]
    pub parameters: Option<FunctionParameters>,
    #[doc = "Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling)."]
    #[builder(default)]
    pub strict: Option<bool>,
}
#[doc = "The parameters the functions accepts, described as a JSON Schema object. See the [guide](/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format. \n\nOmitting `parameters` defines a function with an empty parameter list."]
pub type FunctionParameters = std::collections::HashMap<String, serde_json::Value>;
impl<'de> serde::Deserialize<'de> for FunctionToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] FunctionToolCallStatusInProgress),
            Completed(#[allow(dead_code)] FunctionToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] FunctionToolCallStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for FunctionToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a FunctionToolCallStatusInProgress),
            Completed(#[allow(dead_code)] &'a FunctionToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a FunctionToolCallStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FunctionToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the function tool call. Always `function_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallType {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FunctionToolCallType,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<FunctionToolCallStatus>,
        }
        let _D {
            id,
            call_id,
            name,
            arguments,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FunctionToolCall {
            id,
            call_id,
            name,
            arguments,
            status,
        })
    }
}
impl serde::Serialize for FunctionToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the function tool call. Always `function_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallType {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a FunctionToolCallType,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<FunctionToolCallStatus>,
        }
        let FunctionToolCall {
            id,
            call_id,
            name,
            arguments,
            status,
        } = self;
        _S {
            id,
            type_: &Default::default(),
            call_id,
            name,
            arguments,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool call to run a function. See the \n[function calling guide](/docs/guides/function-calling) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCall {
    #[doc = "The unique ID of the function tool call.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model.\n"]
    pub call_id: String,
    #[doc = "The name of the function to run.\n"]
    pub name: String,
    #[doc = "A JSON string of the arguments to pass to the function.\n"]
    pub arguments: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<FunctionToolCallStatus>,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallOutputStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] FunctionToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] FunctionToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] FunctionToolCallOutputStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for FunctionToolCallOutputStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a FunctionToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] &'a FunctionToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a FunctionToolCallOutputStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FunctionToolCallOutputStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the function tool call output. Always `function_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputType {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FunctionToolCallOutputType,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<FunctionToolCallOutputStatus>,
        }
        let _D {
            id,
            call_id,
            output,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FunctionToolCallOutput {
            id,
            call_id,
            output,
            status,
        })
    }
}
impl serde::Serialize for FunctionToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the function tool call output. Always `function_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputType {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a FunctionToolCallOutputType,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<FunctionToolCallOutputStatus>,
        }
        let FunctionToolCallOutput {
            id,
            call_id,
            output,
            status,
        } = self;
        _S {
            id,
            type_: &Default::default(),
            call_id,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a function tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallOutput {
    #[doc = "The unique ID of the function tool call output. Populated when this item\nis returned via API.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model.\n"]
    pub call_id: String,
    #[doc = "A JSON string of the output of the function tool call.\n"]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<FunctionToolCallOutputStatus>,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallOutputResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(flatten)]
            #[allow(dead_code)]
            function_tool_call_output: FunctionToolCallOutput,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D {
            function_tool_call_output,
            id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FunctionToolCallOutputResource {
            function_tool_call_output,
            id,
        })
    }
}
impl serde::Serialize for FunctionToolCallOutputResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(flatten)]
            function_tool_call_output: &'a FunctionToolCallOutput,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let FunctionToolCallOutputResource {
            function_tool_call_output,
            id,
        } = self;
        _S {
            function_tool_call_output,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallOutputResource {
    pub function_tool_call_output: FunctionToolCallOutput,
    #[doc = "The unique ID of the function call tool output.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(flatten)]
            #[allow(dead_code)]
            function_tool_call: FunctionToolCall,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D {
            function_tool_call,
            id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FunctionToolCallResource {
            function_tool_call,
            id,
        })
    }
}
impl serde::Serialize for FunctionToolCallResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(flatten)]
            function_tool_call: &'a FunctionToolCall,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let FunctionToolCallResource {
            function_tool_call,
            id,
        } = self;
        _S {
            function_tool_call,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallResource {
    pub function_tool_call: FunctionToolCall,
    #[doc = "The unique ID of the function tool call.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for Image {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "b64_json")]
            #[allow(dead_code)]
            b64_json: Option<String>,
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: Option<String>,
            #[serde(rename = "revised_prompt")]
            #[allow(dead_code)]
            revised_prompt: Option<String>,
        }
        let _D {
            b64_json,
            url,
            revised_prompt,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Image {
            b64_json,
            url,
            revised_prompt,
        })
    }
}
impl serde::Serialize for Image {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "b64_json")]
            #[serde(skip_serializing_if = "Option::is_none")]
            b64_json: &'a Option<String>,
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            url: &'a Option<String>,
            #[serde(rename = "revised_prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            revised_prompt: &'a Option<String>,
        }
        let Image {
            b64_json,
            url,
            revised_prompt,
        } = self;
        _S {
            b64_json,
            url,
            revised_prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents the content or the URL of an image generated by the OpenAI API."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct Image {
    #[doc = "The base64-encoded JSON of the generated image. Default value for `gpt-image-1`, and only present if `response_format` is set to `b64_json` for `dall-e-2` and `dall-e-3`."]
    #[builder(default)]
    pub b64_json: Option<String>,
    #[doc = "When using `dall-e-2` or `dall-e-3`, the URL of the generated image if `response_format` is set to `url` (default value). Unsupported for `gpt-image-1`."]
    #[builder(default)]
    pub url: Option<String>,
    #[doc = "For `dall-e-3` only, the revised prompt that was used to generate the image."]
    #[builder(default)]
    pub revised_prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ImagesResponseUsageInputTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "text_tokens")]
            #[allow(dead_code)]
            text_tokens: u64,
            #[serde(rename = "image_tokens")]
            #[allow(dead_code)]
            image_tokens: u64,
        }
        let _D {
            text_tokens,
            image_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ImagesResponseUsageInputTokensDetails {
            text_tokens,
            image_tokens,
        })
    }
}
impl serde::Serialize for ImagesResponseUsageInputTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "text_tokens")]
            text_tokens: &'a u64,
            #[serde(rename = "image_tokens")]
            image_tokens: &'a u64,
        }
        let ImagesResponseUsageInputTokensDetails {
            text_tokens,
            image_tokens,
        } = self;
        _S {
            text_tokens,
            image_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "The input tokens detailed information for the image generation."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ImagesResponseUsageInputTokensDetails {
    #[doc = "The number of text tokens in the input prompt."]
    pub text_tokens: u64,
    #[doc = "The number of image tokens in the input prompt."]
    pub image_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for ImagesResponseUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "output_tokens")]
            #[allow(dead_code)]
            output_tokens: u64,
            #[serde(rename = "input_tokens_details")]
            #[allow(dead_code)]
            input_tokens_details: ImagesResponseUsageInputTokensDetails,
        }
        let _D {
            total_tokens,
            input_tokens,
            output_tokens,
            input_tokens_details,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ImagesResponseUsage {
            total_tokens,
            input_tokens,
            output_tokens,
            input_tokens_details,
        })
    }
}
impl serde::Serialize for ImagesResponseUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "output_tokens")]
            output_tokens: &'a u64,
            #[serde(rename = "input_tokens_details")]
            input_tokens_details: &'a ImagesResponseUsageInputTokensDetails,
        }
        let ImagesResponseUsage {
            total_tokens,
            input_tokens,
            output_tokens,
            input_tokens_details,
        } = self;
        _S {
            total_tokens,
            input_tokens,
            output_tokens,
            input_tokens_details,
        }
        .serialize(serializer)
    }
}
#[doc = "For `gpt-image-1` only, the token usage information for the image generation.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ImagesResponseUsage {
    #[doc = "The total number of tokens (images and text) used for the image generation."]
    pub total_tokens: u64,
    #[doc = "The number of tokens (images and text) in the input prompt."]
    pub input_tokens: u64,
    #[doc = "The number of image tokens in the output image."]
    pub output_tokens: u64,
    #[doc = "The input tokens detailed information for the image generation."]
    pub input_tokens_details: ImagesResponseUsageInputTokensDetails,
}
impl<'de> serde::Deserialize<'de> for ImagesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<Vec<Image>>,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<ImagesResponseUsage>,
        }
        let _D {
            created,
            data,
            usage,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ImagesResponse {
            created,
            data,
            usage,
        })
    }
}
impl serde::Serialize for ImagesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<Vec<Image>>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<ImagesResponseUsage>,
        }
        let ImagesResponse {
            created,
            data,
            usage,
        } = self;
        _S {
            created,
            data,
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "The response from the image generation endpoint."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImagesResponse {
    #[doc = "The Unix timestamp (in seconds) of when the image was created."]
    pub created: u64,
    #[doc = "The list of generated images."]
    #[builder(default)]
    pub data: Option<Vec<Image>>,
    #[doc = "For `gpt-image-1` only, the token usage information for the image generation.\n"]
    #[builder(default)]
    pub usage: Option<ImagesResponseUsage>,
}
impl<'de> serde::Deserialize<'de> for Includable {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableFileSearchCallResults {
            #[default]
            #[serde(rename = "file_search_call.results")]
            FileSearchCallResults,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableMessageInputImageImageUrl {
            #[default]
            #[serde(rename = "message.input_image.image_url")]
            MessageInputImageImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableComputerCallOutputOutputImageUrl {
            #[default]
            #[serde(rename = "computer_call_output.output.image_url")]
            ComputerCallOutputOutputImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileSearchCallResults(#[allow(dead_code)] IncludableFileSearchCallResults),
            MessageInputImageImageUrl(#[allow(dead_code)] IncludableMessageInputImageImageUrl),
            ComputerCallOutputOutputImageUrl(
                #[allow(dead_code)] IncludableComputerCallOutputOutputImageUrl,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileSearchCallResults(_) => Self::FileSearchCallResults,
            _D::MessageInputImageImageUrl(_) => Self::MessageInputImageImageUrl,
            _D::ComputerCallOutputOutputImageUrl(_) => Self::ComputerCallOutputOutputImageUrl,
        })
    }
}
impl serde::Serialize for Includable {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableFileSearchCallResults {
            #[default]
            #[serde(rename = "file_search_call.results")]
            FileSearchCallResults,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableMessageInputImageImageUrl {
            #[default]
            #[serde(rename = "message.input_image.image_url")]
            MessageInputImageImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableComputerCallOutputOutputImageUrl {
            #[default]
            #[serde(rename = "computer_call_output.output.image_url")]
            ComputerCallOutputOutputImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileSearchCallResults(#[allow(dead_code)] &'a IncludableFileSearchCallResults),
            MessageInputImageImageUrl(#[allow(dead_code)] &'a IncludableMessageInputImageImageUrl),
            ComputerCallOutputOutputImageUrl(
                #[allow(dead_code)] &'a IncludableComputerCallOutputOutputImageUrl,
            ),
        }
        match self {
            Self::FileSearchCallResults => {
                _S::FileSearchCallResults(&Default::default()).serialize(serializer)
            }
            Self::MessageInputImageImageUrl => {
                _S::MessageInputImageImageUrl(&Default::default()).serialize(serializer)
            }
            Self::ComputerCallOutputOutputImageUrl => {
                _S::ComputerCallOutputOutputImageUrl(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "Specify additional output data to include in the model response. Currently\nsupported values are:\n- `file_search_call.results`: Include the search results of\n  the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum Includable {
    #[doc = "file_search_call.results"]
    FileSearchCallResults,
    #[doc = "message.input_image.image_url"]
    MessageInputImageImageUrl,
    #[doc = "computer_call_output.output.image_url"]
    ComputerCallOutputOutputImageUrl,
}
impl<'de> serde::Deserialize<'de> for InputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Mp3(#[allow(dead_code)] InputAudioFormatMp3),
            Wav(#[allow(dead_code)] InputAudioFormatWav),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Mp3(_) => Self::Mp3,
            _D::Wav(_) => Self::Wav,
        })
    }
}
impl serde::Serialize for InputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Mp3(#[allow(dead_code)] &'a InputAudioFormatMp3),
            Wav(#[allow(dead_code)] &'a InputAudioFormatWav),
        }
        match self {
            Self::Mp3 => _S::Mp3(&Default::default()).serialize(serializer),
            Self::Wav => _S::Wav(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InputAudioFormat {
    #[doc = "mp3"]
    Mp3,
    #[doc = "wav"]
    Wav,
}
impl<'de> serde::Deserialize<'de> for InputAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the input item. Always `input_audio`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioType {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: InputAudioType,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: String,
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: InputAudioFormat,
        }
        let _D { data, format, .. } = _D::deserialize(deserializer)?;
        Ok(InputAudio { data, format })
    }
}
impl serde::Serialize for InputAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the input item. Always `input_audio`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioType {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a InputAudioType,
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "format")]
            format: &'a InputAudioFormat,
        }
        let InputAudio { data, format } = self;
        _S {
            type_: &Default::default(),
            data,
            format,
        }
        .serialize(serializer)
    }
}
#[doc = "An audio input to the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputAudio {
    #[doc = "Base64-encoded audio data.\n"]
    pub data: String,
    #[doc = "The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n"]
    pub format: InputAudioFormat,
}
impl<'de> serde::Deserialize<'de> for InputContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InputText(#[allow(dead_code)] InputTextContent),
            InputImage(#[allow(dead_code)] InputImageContent),
            InputFile(#[allow(dead_code)] InputFileContent),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InputText(_v) => Self::InputText(_v),
            _D::InputImage(_v) => Self::InputImage(_v),
            _D::InputFile(_v) => Self::InputFile(_v),
        })
    }
}
impl serde::Serialize for InputContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InputText(#[allow(dead_code)] &'a InputTextContent),
            InputImage(#[allow(dead_code)] &'a InputImageContent),
            InputFile(#[allow(dead_code)] &'a InputFileContent),
        }
        match self {
            Self::InputText(_v) => _S::InputText(_v).serialize(serializer),
            Self::InputImage(_v) => _S::InputImage(_v).serialize(serializer),
            Self::InputFile(_v) => _S::InputFile(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum InputContent {
    InputText(InputTextContent),
    InputImage(InputImageContent),
    InputFile(InputFileContent),
}
impl<'de> serde::Deserialize<'de> for InputItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            EasyInputMessage(#[allow(dead_code)] EasyInputMessage),
            Item(#[allow(dead_code)] Item),
            ItemReferenceParam(#[allow(dead_code)] ItemReferenceParam),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::EasyInputMessage(_v) => Self::EasyInputMessage(_v),
            _D::Item(_v) => Self::Item(_v),
            _D::ItemReferenceParam(_v) => Self::ItemReferenceParam(_v),
        })
    }
}
impl serde::Serialize for InputItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            EasyInputMessage(#[allow(dead_code)] &'a EasyInputMessage),
            Item(#[allow(dead_code)] &'a Item),
            ItemReferenceParam(#[allow(dead_code)] &'a ItemReferenceParam),
        }
        match self {
            Self::EasyInputMessage(_v) => _S::EasyInputMessage(_v).serialize(serializer),
            Self::Item(_v) => _S::Item(_v).serialize(serializer),
            Self::ItemReferenceParam(_v) => _S::ItemReferenceParam(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum InputItem {
    EasyInputMessage(EasyInputMessage),
    #[doc = "An item representing part of the context for the response to be \ngenerated by the model. Can contain text, images, and audio inputs,\nas well as previous assistant responses and tool call outputs.\n"]
    Item(Item),
    ItemReferenceParam(ItemReferenceParam),
}
#[doc = "The type of the message input. Always set to `message`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum InputMessageType {
    #[default]
    #[serde(rename = "message")]
    Message,
}
impl<'de> serde::Deserialize<'de> for InputMessageRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] InputMessageRoleUser),
            System(#[allow(dead_code)] InputMessageRoleSystem),
            Developer(#[allow(dead_code)] InputMessageRoleDeveloper),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::System(_) => Self::System,
            _D::Developer(_) => Self::Developer,
        })
    }
}
impl serde::Serialize for InputMessageRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a InputMessageRoleUser),
            System(#[allow(dead_code)] &'a InputMessageRoleSystem),
            Developer(#[allow(dead_code)] &'a InputMessageRoleDeveloper),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::System => _S::System(&Default::default()).serialize(serializer),
            Self::Developer => _S::Developer(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the message input. One of `user`, `system`, or `developer`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InputMessageRole {
    #[doc = "user"]
    User,
    #[doc = "system"]
    System,
    #[doc = "developer"]
    Developer,
}
impl<'de> serde::Deserialize<'de> for InputMessageStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] InputMessageStatusInProgress),
            Completed(#[allow(dead_code)] InputMessageStatusCompleted),
            Incomplete(#[allow(dead_code)] InputMessageStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for InputMessageStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a InputMessageStatusInProgress),
            Completed(#[allow(dead_code)] &'a InputMessageStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a InputMessageStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InputMessageStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for InputMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<InputMessageType>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: InputMessageRole,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<InputMessageStatus>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: InputMessageContentList,
        }
        let _D {
            type_,
            role,
            status,
            content,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(InputMessage {
            type_,
            role,
            status,
            content,
        })
    }
}
impl serde::Serialize for InputMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<InputMessageType>,
            #[serde(rename = "role")]
            role: &'a InputMessageRole,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<InputMessageStatus>,
            #[serde(rename = "content")]
            content: &'a InputMessageContentList,
        }
        let InputMessage {
            type_,
            role,
            status,
            content,
        } = self;
        _S {
            type_,
            role,
            status,
            content,
        }
        .serialize(serializer)
    }
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputMessage {
    #[doc = "The type of the message input. Always set to `message`.\n"]
    #[builder(default)]
    pub type_: Option<InputMessageType>,
    #[doc = "The role of the message input. One of `user`, `system`, or `developer`.\n"]
    pub role: InputMessageRole,
    #[doc = "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<InputMessageStatus>,
    pub content: InputMessageContentList,
}
#[doc = "A list of one or many input items to the model, containing different content \ntypes.\n"]
pub type InputMessageContentList = Vec<InputContent>;
impl<'de> serde::Deserialize<'de> for InputMessageResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(flatten)]
            #[allow(dead_code)]
            input_message: InputMessage,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D {
            input_message, id, ..
        } = _D::deserialize(deserializer)?;
        Ok(InputMessageResource { input_message, id })
    }
}
impl serde::Serialize for InputMessageResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(flatten)]
            input_message: &'a InputMessage,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let InputMessageResource { input_message, id } = self;
        _S { input_message, id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputMessageResource {
    pub input_message: InputMessage,
    #[doc = "The unique ID of the message input.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for InviteRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Owner(#[allow(dead_code)] InviteRoleOwner),
            Reader(#[allow(dead_code)] InviteRoleReader),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Owner(_) => Self::Owner,
            _D::Reader(_) => Self::Reader,
        })
    }
}
impl serde::Serialize for InviteRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Owner(#[allow(dead_code)] &'a InviteRoleOwner),
            Reader(#[allow(dead_code)] &'a InviteRoleReader),
        }
        match self {
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
            Self::Reader => _S::Reader(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `reader`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteRole {
    #[doc = "owner"]
    Owner,
    #[doc = "reader"]
    Reader,
}
impl<'de> serde::Deserialize<'de> for InviteStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusAccepted {
            #[default]
            #[serde(rename = "accepted")]
            Accepted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusPending {
            #[default]
            #[serde(rename = "pending")]
            Pending,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Accepted(#[allow(dead_code)] InviteStatusAccepted),
            Expired(#[allow(dead_code)] InviteStatusExpired),
            Pending(#[allow(dead_code)] InviteStatusPending),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Accepted(_) => Self::Accepted,
            _D::Expired(_) => Self::Expired,
            _D::Pending(_) => Self::Pending,
        })
    }
}
impl serde::Serialize for InviteStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusAccepted {
            #[default]
            #[serde(rename = "accepted")]
            Accepted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusPending {
            #[default]
            #[serde(rename = "pending")]
            Pending,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Accepted(#[allow(dead_code)] &'a InviteStatusAccepted),
            Expired(#[allow(dead_code)] &'a InviteStatusExpired),
            Pending(#[allow(dead_code)] &'a InviteStatusPending),
        }
        match self {
            Self::Accepted => _S::Accepted(&Default::default()).serialize(serializer),
            Self::Expired => _S::Expired(&Default::default()).serialize(serializer),
            Self::Pending => _S::Pending(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`accepted`,`expired`, or `pending`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteStatus {
    #[doc = "accepted"]
    Accepted,
    #[doc = "expired"]
    Expired,
    #[doc = "pending"]
    Pending,
}
impl<'de> serde::Deserialize<'de> for InviteProjectsRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteProjectsRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteProjectsRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Member(#[allow(dead_code)] InviteProjectsRoleMember),
            Owner(#[allow(dead_code)] InviteProjectsRoleOwner),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Member(_) => Self::Member,
            _D::Owner(_) => Self::Owner,
        })
    }
}
impl serde::Serialize for InviteProjectsRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteProjectsRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteProjectsRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Member(#[allow(dead_code)] &'a InviteProjectsRoleMember),
            Owner(#[allow(dead_code)] &'a InviteProjectsRoleOwner),
        }
        match self {
            Self::Member => _S::Member(&Default::default()).serialize(serializer),
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Project membership role"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteProjectsRole {
    #[doc = "member"]
    Member,
    #[doc = "owner"]
    Owner,
}
impl<'de> serde::Deserialize<'de> for InviteProjects {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<InviteProjectsRole>,
        }
        let _D { id, role, .. } = _D::deserialize(deserializer)?;
        Ok(InviteProjects { id, role })
    }
}
impl serde::Serialize for InviteProjects {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<InviteProjectsRole>,
        }
        let InviteProjects { id, role } = self;
        _S { id, role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct InviteProjects {
    #[doc = "Project's public ID"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "Project membership role"]
    #[builder(default)]
    pub role: Option<InviteProjectsRole>,
}
impl<'de> serde::Deserialize<'de> for Invite {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.invite`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteObject {
            #[default]
            #[serde(rename = "organization.invite")]
            OrganizationInvite,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: InviteObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: InviteRole,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: InviteStatus,
            #[serde(rename = "invited_at")]
            #[allow(dead_code)]
            invited_at: u64,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
            #[serde(rename = "accepted_at")]
            #[allow(dead_code)]
            accepted_at: Option<u64>,
            #[serde(rename = "projects")]
            #[allow(dead_code)]
            projects: Option<Vec<InviteProjects>>,
        }
        let _D {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Invite {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        })
    }
}
impl serde::Serialize for Invite {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.invite`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteObject {
            #[default]
            #[serde(rename = "organization.invite")]
            OrganizationInvite,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a InviteObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a InviteRole,
            #[serde(rename = "status")]
            status: &'a InviteStatus,
            #[serde(rename = "invited_at")]
            invited_at: &'a u64,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
            #[serde(rename = "accepted_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            accepted_at: &'a Option<u64>,
            #[serde(rename = "projects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            projects: &'a Option<Vec<InviteProjects>>,
        }
        let Invite {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        } = self;
        _S {
            object: &Default::default(),
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual `invite` to the organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Invite {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The email address of the individual to whom the invite was sent"]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    pub role: InviteRole,
    #[doc = "`accepted`,`expired`, or `pending`"]
    pub status: InviteStatus,
    #[doc = "The Unix timestamp (in seconds) of when the invite was sent."]
    pub invited_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the invite expires."]
    pub expires_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the invite was accepted."]
    #[builder(default)]
    pub accepted_at: Option<u64>,
    #[doc = "The projects that were granted membership upon acceptance of the invite."]
    #[builder(default)]
    pub projects: Option<Vec<InviteProjects>>,
}
impl<'de> serde::Deserialize<'de> for InviteDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.invite.deleted`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.invite.deleted")]
            OrganizationInviteDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: InviteDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(InviteDeleteResponse { id, deleted })
    }
}
impl serde::Serialize for InviteDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.invite.deleted`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.invite.deleted")]
            OrganizationInviteDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a InviteDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let InviteDeleteResponse { id, deleted } = self;
        _S {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for InviteListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `list`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: InviteListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Invite>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: Option<bool>,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(InviteListResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for InviteListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `list`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a InviteListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<Invite>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            #[serde(skip_serializing_if = "Option::is_none")]
            has_more: &'a Option<bool>,
        }
        let InviteListResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteListResponse {
    pub data: Vec<Invite>,
    #[doc = "The first `invite_id` in the retrieved `list`"]
    #[builder(default)]
    pub first_id: Option<String>,
    #[doc = "The last `invite_id` in the retrieved `list`"]
    #[builder(default)]
    pub last_id: Option<String>,
    #[doc = "The `has_more` property is used for pagination to indicate there are additional results."]
    #[builder(default)]
    pub has_more: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for InviteRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Reader(#[allow(dead_code)] InviteRequestRoleReader),
            Owner(#[allow(dead_code)] InviteRequestRoleOwner),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Reader(_) => Self::Reader,
            _D::Owner(_) => Self::Owner,
        })
    }
}
impl serde::Serialize for InviteRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Reader(#[allow(dead_code)] &'a InviteRequestRoleReader),
            Owner(#[allow(dead_code)] &'a InviteRequestRoleOwner),
        }
        match self {
            Self::Reader => _S::Reader(&Default::default()).serialize(serializer),
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `reader`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteRequestRole {
    #[doc = "reader"]
    Reader,
    #[doc = "owner"]
    Owner,
}
impl<'de> serde::Deserialize<'de> for InviteRequestProjectsRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestProjectsRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestProjectsRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Member(#[allow(dead_code)] InviteRequestProjectsRoleMember),
            Owner(#[allow(dead_code)] InviteRequestProjectsRoleOwner),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Member(_) => Self::Member,
            _D::Owner(_) => Self::Owner,
        })
    }
}
impl serde::Serialize for InviteRequestProjectsRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestProjectsRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestProjectsRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Member(#[allow(dead_code)] &'a InviteRequestProjectsRoleMember),
            Owner(#[allow(dead_code)] &'a InviteRequestProjectsRoleOwner),
        }
        match self {
            Self::Member => _S::Member(&Default::default()).serialize(serializer),
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Project membership role"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteRequestProjectsRole {
    #[doc = "member"]
    Member,
    #[doc = "owner"]
    Owner,
}
impl<'de> serde::Deserialize<'de> for InviteRequestProjects {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: InviteRequestProjectsRole,
        }
        let _D { id, role, .. } = _D::deserialize(deserializer)?;
        Ok(InviteRequestProjects { id, role })
    }
}
impl serde::Serialize for InviteRequestProjects {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "role")]
            role: &'a InviteRequestProjectsRole,
        }
        let InviteRequestProjects { id, role } = self;
        _S { id, role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteRequestProjects {
    #[doc = "Project's public ID"]
    pub id: String,
    #[doc = "Project membership role"]
    pub role: InviteRequestProjectsRole,
}
impl<'de> serde::Deserialize<'de> for InviteRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: InviteRequestRole,
            #[serde(rename = "projects")]
            #[allow(dead_code)]
            projects: Option<Vec<InviteRequestProjects>>,
        }
        let _D {
            email,
            role,
            projects,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(InviteRequest {
            email,
            role,
            projects,
        })
    }
}
impl serde::Serialize for InviteRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a InviteRequestRole,
            #[serde(rename = "projects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            projects: &'a Option<Vec<InviteRequestProjects>>,
        }
        let InviteRequest {
            email,
            role,
            projects,
        } = self;
        _S {
            email,
            role,
            projects,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteRequest {
    #[doc = "Send an email to this address"]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    pub role: InviteRequestRole,
    #[doc = "An array of projects to which membership is granted at the same time the org invite is accepted. If omitted, the user will be invited to the default project for compatibility with legacy behavior."]
    #[builder(default)]
    pub projects: Option<Vec<InviteRequestProjects>>,
}
impl<'de> serde::Deserialize<'de> for Item {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InputMessage(#[allow(dead_code)] InputMessage),
            OutputMessage(#[allow(dead_code)] OutputMessage),
            FileSearchToolCall(#[allow(dead_code)] FileSearchToolCall),
            ComputerToolCall(#[allow(dead_code)] ComputerToolCall),
            ComputerCallOutputItemParam(#[allow(dead_code)] ComputerCallOutputItemParam),
            WebSearchToolCall(#[allow(dead_code)] WebSearchToolCall),
            FunctionToolCall(#[allow(dead_code)] FunctionToolCall),
            FunctionCallOutputItemParam(#[allow(dead_code)] FunctionCallOutputItemParam),
            ReasoningItem(#[allow(dead_code)] ReasoningItem),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InputMessage(_v) => Self::InputMessage(_v),
            _D::OutputMessage(_v) => Self::OutputMessage(_v),
            _D::FileSearchToolCall(_v) => Self::FileSearchToolCall(_v),
            _D::ComputerToolCall(_v) => Self::ComputerToolCall(_v),
            _D::ComputerCallOutputItemParam(_v) => Self::ComputerCallOutputItemParam(_v),
            _D::WebSearchToolCall(_v) => Self::WebSearchToolCall(_v),
            _D::FunctionToolCall(_v) => Self::FunctionToolCall(_v),
            _D::FunctionCallOutputItemParam(_v) => Self::FunctionCallOutputItemParam(_v),
            _D::ReasoningItem(_v) => Self::ReasoningItem(_v),
        })
    }
}
impl serde::Serialize for Item {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InputMessage(#[allow(dead_code)] &'a InputMessage),
            OutputMessage(#[allow(dead_code)] &'a OutputMessage),
            FileSearchToolCall(#[allow(dead_code)] &'a FileSearchToolCall),
            ComputerToolCall(#[allow(dead_code)] &'a ComputerToolCall),
            ComputerCallOutputItemParam(#[allow(dead_code)] &'a ComputerCallOutputItemParam),
            WebSearchToolCall(#[allow(dead_code)] &'a WebSearchToolCall),
            FunctionToolCall(#[allow(dead_code)] &'a FunctionToolCall),
            FunctionCallOutputItemParam(#[allow(dead_code)] &'a FunctionCallOutputItemParam),
            ReasoningItem(#[allow(dead_code)] &'a ReasoningItem),
        }
        match self {
            Self::InputMessage(_v) => _S::InputMessage(_v).serialize(serializer),
            Self::OutputMessage(_v) => _S::OutputMessage(_v).serialize(serializer),
            Self::FileSearchToolCall(_v) => _S::FileSearchToolCall(_v).serialize(serializer),
            Self::ComputerToolCall(_v) => _S::ComputerToolCall(_v).serialize(serializer),
            Self::ComputerCallOutputItemParam(_v) => {
                _S::ComputerCallOutputItemParam(_v).serialize(serializer)
            }
            Self::WebSearchToolCall(_v) => _S::WebSearchToolCall(_v).serialize(serializer),
            Self::FunctionToolCall(_v) => _S::FunctionToolCall(_v).serialize(serializer),
            Self::FunctionCallOutputItemParam(_v) => {
                _S::FunctionCallOutputItemParam(_v).serialize(serializer)
            }
            Self::ReasoningItem(_v) => _S::ReasoningItem(_v).serialize(serializer),
        }
    }
}
#[doc = "Content item used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Item {
    InputMessage(InputMessage),
    OutputMessage(OutputMessage),
    FileSearchToolCall(FileSearchToolCall),
    ComputerToolCall(ComputerToolCall),
    ComputerCallOutputItemParam(ComputerCallOutputItemParam),
    WebSearchToolCall(WebSearchToolCall),
    FunctionToolCall(FunctionToolCall),
    FunctionCallOutputItemParam(FunctionCallOutputItemParam),
    ReasoningItem(ReasoningItem),
}
impl<'de> serde::Deserialize<'de> for ItemResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InputMessageResource(#[allow(dead_code)] InputMessageResource),
            OutputMessage(#[allow(dead_code)] OutputMessage),
            FileSearchToolCall(#[allow(dead_code)] FileSearchToolCall),
            ComputerToolCall(#[allow(dead_code)] ComputerToolCall),
            ComputerToolCallOutputResource(#[allow(dead_code)] ComputerToolCallOutputResource),
            WebSearchToolCall(#[allow(dead_code)] WebSearchToolCall),
            FunctionToolCallResource(#[allow(dead_code)] FunctionToolCallResource),
            FunctionToolCallOutputResource(#[allow(dead_code)] FunctionToolCallOutputResource),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InputMessageResource(_v) => Self::InputMessageResource(_v),
            _D::OutputMessage(_v) => Self::OutputMessage(_v),
            _D::FileSearchToolCall(_v) => Self::FileSearchToolCall(_v),
            _D::ComputerToolCall(_v) => Self::ComputerToolCall(_v),
            _D::ComputerToolCallOutputResource(_v) => Self::ComputerToolCallOutputResource(_v),
            _D::WebSearchToolCall(_v) => Self::WebSearchToolCall(_v),
            _D::FunctionToolCallResource(_v) => Self::FunctionToolCallResource(_v),
            _D::FunctionToolCallOutputResource(_v) => Self::FunctionToolCallOutputResource(_v),
        })
    }
}
impl serde::Serialize for ItemResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InputMessageResource(#[allow(dead_code)] &'a InputMessageResource),
            OutputMessage(#[allow(dead_code)] &'a OutputMessage),
            FileSearchToolCall(#[allow(dead_code)] &'a FileSearchToolCall),
            ComputerToolCall(#[allow(dead_code)] &'a ComputerToolCall),
            ComputerToolCallOutputResource(#[allow(dead_code)] &'a ComputerToolCallOutputResource),
            WebSearchToolCall(#[allow(dead_code)] &'a WebSearchToolCall),
            FunctionToolCallResource(#[allow(dead_code)] &'a FunctionToolCallResource),
            FunctionToolCallOutputResource(#[allow(dead_code)] &'a FunctionToolCallOutputResource),
        }
        match self {
            Self::InputMessageResource(_v) => _S::InputMessageResource(_v).serialize(serializer),
            Self::OutputMessage(_v) => _S::OutputMessage(_v).serialize(serializer),
            Self::FileSearchToolCall(_v) => _S::FileSearchToolCall(_v).serialize(serializer),
            Self::ComputerToolCall(_v) => _S::ComputerToolCall(_v).serialize(serializer),
            Self::ComputerToolCallOutputResource(_v) => {
                _S::ComputerToolCallOutputResource(_v).serialize(serializer)
            }
            Self::WebSearchToolCall(_v) => _S::WebSearchToolCall(_v).serialize(serializer),
            Self::FunctionToolCallResource(_v) => {
                _S::FunctionToolCallResource(_v).serialize(serializer)
            }
            Self::FunctionToolCallOutputResource(_v) => {
                _S::FunctionToolCallOutputResource(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Content item used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ItemResource {
    InputMessageResource(InputMessageResource),
    OutputMessage(OutputMessage),
    FileSearchToolCall(FileSearchToolCall),
    ComputerToolCall(ComputerToolCall),
    ComputerToolCallOutputResource(ComputerToolCallOutputResource),
    WebSearchToolCall(WebSearchToolCall),
    FunctionToolCallResource(FunctionToolCallResource),
    FunctionToolCallOutputResource(FunctionToolCallOutputResource),
}
impl<'de> serde::Deserialize<'de> for KeyPress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a keypress action, this property is \nalways set to `keypress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum KeyPressType {
            #[default]
            #[serde(rename = "keypress")]
            Keypress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: KeyPressType,
            #[serde(rename = "keys")]
            #[allow(dead_code)]
            keys: Vec<String>,
        }
        let _D { keys, .. } = _D::deserialize(deserializer)?;
        Ok(KeyPress { keys })
    }
}
impl serde::Serialize for KeyPress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a keypress action, this property is \nalways set to `keypress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum KeyPressType {
            #[default]
            #[serde(rename = "keypress")]
            Keypress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a KeyPressType,
            #[serde(rename = "keys")]
            keys: &'a Vec<String>,
        }
        let KeyPress { keys } = self;
        _S {
            type_: &Default::default(),
            keys,
        }
        .serialize(serializer)
    }
}
#[doc = "A collection of keypresses the model would like to perform.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct KeyPress {
    #[doc = "The combination of keys the model is requesting to be pressed. This is an\narray of strings, each representing a key.\n"]
    pub keys: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for ListAssistantsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<AssistantObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListAssistantsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListAssistantsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<AssistantObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListAssistantsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListAssistantsResponse {
    pub object: String,
    pub data: Vec<AssistantObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListAuditLogsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListAuditLogsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListAuditLogsResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<AuditLog>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListAuditLogsResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListAuditLogsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListAuditLogsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ListAuditLogsResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<AuditLog>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListAuditLogsResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListAuditLogsResponse {
    pub data: Vec<AuditLog>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListBatchesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListBatchesResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Batch>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListBatchesResponseObject,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListBatchesResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListBatchesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListBatchesResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<Batch>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a ListBatchesResponseObject,
        }
        let ListBatchesResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            data,
            first_id,
            last_id,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListBatchesResponse {
    pub data: Vec<Batch>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListCertificatesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListCertificatesResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Certificate>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListCertificatesResponseObject,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListCertificatesResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListCertificatesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListCertificatesResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<Certificate>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a ListCertificatesResponseObject,
        }
        let ListCertificatesResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            data,
            first_id,
            last_id,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListCertificatesResponse {
    pub data: Vec<Certificate>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFilesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<OpenAiFile>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListFilesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<OpenAiFile>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFilesResponse {
    pub object: String,
    pub data: Vec<OpenAiFile>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningCheckpointPermissionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningCheckpointPermissionResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<FineTuningCheckpointPermission>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListFineTuningCheckpointPermissionResponseObject,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListFineTuningCheckpointPermissionResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListFineTuningCheckpointPermissionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningCheckpointPermissionResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<FineTuningCheckpointPermission>,
            #[serde(rename = "object")]
            object: &'a ListFineTuningCheckpointPermissionResponseObject,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListFineTuningCheckpointPermissionResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            data,
            object: &Default::default(),
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningCheckpointPermissionResponse {
    pub data: Vec<FineTuningCheckpointPermission>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningJobCheckpointsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningJobCheckpointsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<FineTuningJobCheckpoint>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListFineTuningJobCheckpointsResponseObject,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListFineTuningJobCheckpointsResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListFineTuningJobCheckpointsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningJobCheckpointsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<FineTuningJobCheckpoint>,
            #[serde(rename = "object")]
            object: &'a ListFineTuningJobCheckpointsResponseObject,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListFineTuningJobCheckpointsResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            data,
            object: &Default::default(),
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningJobCheckpointsResponse {
    pub data: Vec<FineTuningJobCheckpoint>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningJobEventsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningJobEventsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<FineTuningJobEvent>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListFineTuningJobEventsResponseObject,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D { data, has_more, .. } = _D::deserialize(deserializer)?;
        Ok(ListFineTuningJobEventsResponse { data, has_more })
    }
}
impl serde::Serialize for ListFineTuningJobEventsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningJobEventsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<FineTuningJobEvent>,
            #[serde(rename = "object")]
            object: &'a ListFineTuningJobEventsResponseObject,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListFineTuningJobEventsResponse { data, has_more } = self;
        _S {
            data,
            object: &Default::default(),
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningJobEventsResponse {
    pub data: Vec<FineTuningJobEvent>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListMessagesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<MessageObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListMessagesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListMessagesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<MessageObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListMessagesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListMessagesResponse {
    pub object: String,
    pub data: Vec<MessageObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListModelsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListModelsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListModelsResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Model>,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(ListModelsResponse { data })
    }
}
impl serde::Serialize for ListModelsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListModelsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ListModelsResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<Model>,
        }
        let ListModelsResponse { data } = self;
        _S {
            object: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListModelsResponse {
    pub data: Vec<Model>,
}
impl<'de> serde::Deserialize<'de> for ListPaginatedFineTuningJobsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListPaginatedFineTuningJobsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<FineTuningJob>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListPaginatedFineTuningJobsResponseObject,
        }
        let _D { data, has_more, .. } = _D::deserialize(deserializer)?;
        Ok(ListPaginatedFineTuningJobsResponse { data, has_more })
    }
}
impl serde::Serialize for ListPaginatedFineTuningJobsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListPaginatedFineTuningJobsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<FineTuningJob>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a ListPaginatedFineTuningJobsResponseObject,
        }
        let ListPaginatedFineTuningJobsResponse { data, has_more } = self;
        _S {
            data,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListPaginatedFineTuningJobsResponse {
    pub data: Vec<FineTuningJob>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListRunStepsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<RunStepObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListRunStepsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListRunStepsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<RunStepObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListRunStepsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListRunStepsResponse {
    pub object: String,
    pub data: Vec<RunStepObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListRunsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<RunObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListRunsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListRunsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<RunObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListRunsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListRunsResponse {
    pub object: String,
    pub data: Vec<RunObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListVectorStoreFilesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<VectorStoreFileObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListVectorStoreFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListVectorStoreFilesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<VectorStoreFileObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListVectorStoreFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListVectorStoreFilesResponse {
    pub object: String,
    pub data: Vec<VectorStoreFileObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListVectorStoresResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<VectorStoreObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ListVectorStoresResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListVectorStoresResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<VectorStoreObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ListVectorStoresResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListVectorStoresResponse {
    pub object: String,
    pub data: Vec<VectorStoreObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for LogProbProperties {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: String,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: f64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Vec<u64>,
        }
        let _D {
            token,
            logprob,
            bytes,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(LogProbProperties {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for LogProbProperties {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "token")]
            token: &'a String,
            #[serde(rename = "logprob")]
            logprob: &'a f64,
            #[serde(rename = "bytes")]
            bytes: &'a Vec<u64>,
        }
        let LogProbProperties {
            token,
            logprob,
            bytes,
        } = self;
        _S {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[doc = "A log probability object.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LogProbProperties {
    #[doc = "The token that was used to generate the log probability.\n"]
    pub token: String,
    #[doc = "The log probability of the token.\n"]
    pub logprob: f64,
    #[doc = "The bytes that were used to generate the log probability.\n"]
    pub bytes: Vec<u64>,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageFileObjectImageFileDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] MessageContentImageFileObjectImageFileDetailAuto),
            Low(#[allow(dead_code)] MessageContentImageFileObjectImageFileDetailLow),
            High(#[allow(dead_code)] MessageContentImageFileObjectImageFileDetailHigh),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Low(_) => Self::Low,
            _D::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for MessageContentImageFileObjectImageFileDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a MessageContentImageFileObjectImageFileDetailAuto),
            Low(#[allow(dead_code)] &'a MessageContentImageFileObjectImageFileDetailLow),
            High(#[allow(dead_code)] &'a MessageContentImageFileObjectImageFileDetailHigh),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContentImageFileObjectImageFileDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageFileObjectImageFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<MessageContentImageFileObjectImageFileDetail>,
        }
        let _D {
            file_id, detail, ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageContentImageFileObjectImageFile { file_id, detail })
    }
}
impl serde::Serialize for MessageContentImageFileObjectImageFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<MessageContentImageFileObjectImageFileDetail>,
        }
        let MessageContentImageFileObjectImageFile { file_id, detail } = self;
        _S { file_id, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageFileObjectImageFile {
    #[doc = "The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content."]
    pub file_id: String,
    #[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
    #[builder(default)]
    pub detail: Option<MessageContentImageFileObjectImageFileDetail>,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectType {
            #[default]
            #[serde(rename = "image_file")]
            ImageFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentImageFileObjectType,
            #[serde(rename = "image_file")]
            #[allow(dead_code)]
            image_file: MessageContentImageFileObjectImageFile,
        }
        let _D { image_file, .. } = _D::deserialize(deserializer)?;
        Ok(MessageContentImageFileObject { image_file })
    }
}
impl serde::Serialize for MessageContentImageFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectType {
            #[default]
            #[serde(rename = "image_file")]
            ImageFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentImageFileObjectType,
            #[serde(rename = "image_file")]
            image_file: &'a MessageContentImageFileObjectImageFile,
        }
        let MessageContentImageFileObject { image_file } = self;
        _S {
            type_: &Default::default(),
            image_file,
        }
        .serialize(serializer)
    }
}
#[doc = "References an image [File](https://platform.openai.com/docs/api-reference/files) in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageFileObject {
    pub image_file: MessageContentImageFileObjectImageFile,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageUrlObjectImageUrlDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] MessageContentImageUrlObjectImageUrlDetailAuto),
            Low(#[allow(dead_code)] MessageContentImageUrlObjectImageUrlDetailLow),
            High(#[allow(dead_code)] MessageContentImageUrlObjectImageUrlDetailHigh),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Low(_) => Self::Low,
            _D::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for MessageContentImageUrlObjectImageUrlDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a MessageContentImageUrlObjectImageUrlDetailAuto),
            Low(#[allow(dead_code)] &'a MessageContentImageUrlObjectImageUrlDetailLow),
            High(#[allow(dead_code)] &'a MessageContentImageUrlObjectImageUrlDetailHigh),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContentImageUrlObjectImageUrlDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageUrlObjectImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<MessageContentImageUrlObjectImageUrlDetail>,
        }
        let _D { url, detail, .. } = _D::deserialize(deserializer)?;
        Ok(MessageContentImageUrlObjectImageUrl { url, detail })
    }
}
impl serde::Serialize for MessageContentImageUrlObjectImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<MessageContentImageUrlObjectImageUrlDetail>,
        }
        let MessageContentImageUrlObjectImageUrl { url, detail } = self;
        _S { url, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageUrlObjectImageUrl {
    #[doc = "The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp."]
    pub url: String,
    #[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`"]
    #[builder(default)]
    pub detail: Option<MessageContentImageUrlObjectImageUrlDetail>,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageUrlObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentImageUrlObjectType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: MessageContentImageUrlObjectImageUrl,
        }
        let _D { image_url, .. } = _D::deserialize(deserializer)?;
        Ok(MessageContentImageUrlObject { image_url })
    }
}
impl serde::Serialize for MessageContentImageUrlObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentImageUrlObjectType,
            #[serde(rename = "image_url")]
            image_url: &'a MessageContentImageUrlObjectImageUrl,
        }
        let MessageContentImageUrlObject { image_url } = self;
        _S {
            type_: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[doc = "References an image URL in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageUrlObject {
    pub image_url: MessageContentImageUrlObjectImageUrl,
}
impl<'de> serde::Deserialize<'de> for MessageContentRefusalObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentRefusalObjectType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentRefusalObjectType,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: String,
        }
        let _D { refusal, .. } = _D::deserialize(deserializer)?;
        Ok(MessageContentRefusalObject { refusal })
    }
}
impl serde::Serialize for MessageContentRefusalObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentRefusalObjectType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentRefusalObjectType,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let MessageContentRefusalObject { refusal } = self;
        _S {
            type_: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "The refusal content generated by the assistant."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentRefusalObject {
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFileCitationObjectFileCitation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
        }
        let _D { file_id, .. } = _D::deserialize(deserializer)?;
        Ok(MessageContentTextAnnotationsFileCitationObjectFileCitation { file_id })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFileCitationObjectFileCitation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
        }
        let MessageContentTextAnnotationsFileCitationObjectFileCitation { file_id } = self;
        _S { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFileCitationObjectFileCitation {
    #[doc = "The ID of the specific File the citation is from."]
    pub file_id: String,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFileCitationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextAnnotationsFileCitationObjectType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentTextAnnotationsFileCitationObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "file_citation")]
            #[allow(dead_code)]
            file_citation: MessageContentTextAnnotationsFileCitationObjectFileCitation,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
        }
        let _D {
            text,
            file_citation,
            start_index,
            end_index,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageContentTextAnnotationsFileCitationObject {
            text,
            file_citation,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFileCitationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextAnnotationsFileCitationObjectType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentTextAnnotationsFileCitationObjectType,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "file_citation")]
            file_citation: &'a MessageContentTextAnnotationsFileCitationObjectFileCitation,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "end_index")]
            end_index: &'a u64,
        }
        let MessageContentTextAnnotationsFileCitationObject {
            text,
            file_citation,
            start_index,
            end_index,
        } = self;
        _S {
            type_: &Default::default(),
            text,
            file_citation,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFileCitationObject {
    #[doc = "The text in the message content that needs to be replaced."]
    pub text: String,
    pub file_citation: MessageContentTextAnnotationsFileCitationObjectFileCitation,
    pub start_index: u64,
    pub end_index: u64,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFilePathObjectFilePath {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
        }
        let _D { file_id, .. } = _D::deserialize(deserializer)?;
        Ok(MessageContentTextAnnotationsFilePathObjectFilePath { file_id })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFilePathObjectFilePath {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
        }
        let MessageContentTextAnnotationsFilePathObjectFilePath { file_id } = self;
        _S { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFilePathObjectFilePath {
    #[doc = "The ID of the file that was generated."]
    pub file_id: String,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFilePathObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `file_path`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextAnnotationsFilePathObjectType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentTextAnnotationsFilePathObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "file_path")]
            #[allow(dead_code)]
            file_path: MessageContentTextAnnotationsFilePathObjectFilePath,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
        }
        let _D {
            text,
            file_path,
            start_index,
            end_index,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageContentTextAnnotationsFilePathObject {
            text,
            file_path,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFilePathObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `file_path`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextAnnotationsFilePathObjectType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentTextAnnotationsFilePathObjectType,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "file_path")]
            file_path: &'a MessageContentTextAnnotationsFilePathObjectFilePath,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "end_index")]
            end_index: &'a u64,
        }
        let MessageContentTextAnnotationsFilePathObject {
            text,
            file_path,
            start_index,
            end_index,
        } = self;
        _S {
            type_: &Default::default(),
            text,
            file_path,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFilePathObject {
    #[doc = "The text in the message content that needs to be replaced."]
    pub text: String,
    pub file_path: MessageContentTextAnnotationsFilePathObjectFilePath,
    pub start_index: u64,
    pub end_index: u64,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextObjectTextAnnotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileCitation(#[allow(dead_code)] MessageContentTextAnnotationsFileCitationObject),
            FilePath(#[allow(dead_code)] MessageContentTextAnnotationsFilePathObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileCitation(_v) => Self::FileCitation(_v),
            _D::FilePath(_v) => Self::FilePath(_v),
        })
    }
}
impl serde::Serialize for MessageContentTextObjectTextAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileCitation(#[allow(dead_code)] &'a MessageContentTextAnnotationsFileCitationObject),
            FilePath(#[allow(dead_code)] &'a MessageContentTextAnnotationsFilePathObject),
        }
        match self {
            Self::FileCitation(_v) => _S::FileCitation(_v).serialize(serializer),
            Self::FilePath(_v) => _S::FilePath(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContentTextObjectTextAnnotation {
    FileCitation(MessageContentTextAnnotationsFileCitationObject),
    FilePath(MessageContentTextAnnotationsFilePathObject),
}
impl<'de> serde::Deserialize<'de> for MessageContentTextObjectText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: String,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Vec<MessageContentTextObjectTextAnnotation>,
        }
        let _D {
            value, annotations, ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageContentTextObjectText { value, annotations })
    }
}
impl serde::Serialize for MessageContentTextObjectText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "annotations")]
            annotations: &'a Vec<MessageContentTextObjectTextAnnotation>,
        }
        let MessageContentTextObjectText { value, annotations } = self;
        _S { value, annotations }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextObjectText {
    #[doc = "The data that makes up the text."]
    pub value: String,
    pub annotations: Vec<MessageContentTextObjectTextAnnotation>,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentTextObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: MessageContentTextObjectText,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(MessageContentTextObject { text })
    }
}
impl serde::Serialize for MessageContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentTextObjectType,
            #[serde(rename = "text")]
            text: &'a MessageContentTextObjectText,
        }
        let MessageContentTextObject { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextObject {
    pub text: MessageContentTextObjectText,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageFileObjectImageFileDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] MessageDeltaContentImageFileObjectImageFileDetailAuto),
            Low(#[allow(dead_code)] MessageDeltaContentImageFileObjectImageFileDetailLow),
            High(#[allow(dead_code)] MessageDeltaContentImageFileObjectImageFileDetailHigh),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Low(_) => Self::Low,
            _D::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for MessageDeltaContentImageFileObjectImageFileDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a MessageDeltaContentImageFileObjectImageFileDetailAuto),
            Low(#[allow(dead_code)] &'a MessageDeltaContentImageFileObjectImageFileDetailLow),
            High(#[allow(dead_code)] &'a MessageDeltaContentImageFileObjectImageFileDetailHigh),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum MessageDeltaContentImageFileObjectImageFileDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageFileObjectImageFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<MessageDeltaContentImageFileObjectImageFileDetail>,
        }
        let _D {
            file_id, detail, ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentImageFileObjectImageFile { file_id, detail })
    }
}
impl serde::Serialize for MessageDeltaContentImageFileObjectImageFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<MessageDeltaContentImageFileObjectImageFileDetail>,
        }
        let MessageDeltaContentImageFileObjectImageFile { file_id, detail } = self;
        _S { file_id, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageFileObjectImageFile {
    #[doc = "The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
    #[builder(default)]
    pub detail: Option<MessageDeltaContentImageFileObjectImageFileDetail>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectType {
            #[default]
            #[serde(rename = "image_file")]
            ImageFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentImageFileObjectType,
            #[serde(rename = "image_file")]
            #[allow(dead_code)]
            image_file: Option<MessageDeltaContentImageFileObjectImageFile>,
        }
        let _D {
            index, image_file, ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentImageFileObject { index, image_file })
    }
}
impl serde::Serialize for MessageDeltaContentImageFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectType {
            #[default]
            #[serde(rename = "image_file")]
            ImageFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentImageFileObjectType,
            #[serde(rename = "image_file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_file: &'a Option<MessageDeltaContentImageFileObjectImageFile>,
        }
        let MessageDeltaContentImageFileObject { index, image_file } = self;
        _S {
            index,
            type_: &Default::default(),
            image_file,
        }
        .serialize(serializer)
    }
}
#[doc = "References an image [File](https://platform.openai.com/docs/api-reference/files) in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageFileObject {
    #[doc = "The index of the content part in the message."]
    pub index: u64,
    #[builder(default)]
    pub image_file: Option<MessageDeltaContentImageFileObjectImageFile>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageUrlObjectImageUrlDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] MessageDeltaContentImageUrlObjectImageUrlDetailAuto),
            Low(#[allow(dead_code)] MessageDeltaContentImageUrlObjectImageUrlDetailLow),
            High(#[allow(dead_code)] MessageDeltaContentImageUrlObjectImageUrlDetailHigh),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Low(_) => Self::Low,
            _D::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for MessageDeltaContentImageUrlObjectImageUrlDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a MessageDeltaContentImageUrlObjectImageUrlDetailAuto),
            Low(#[allow(dead_code)] &'a MessageDeltaContentImageUrlObjectImageUrlDetailLow),
            High(#[allow(dead_code)] &'a MessageDeltaContentImageUrlObjectImageUrlDetailHigh),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum MessageDeltaContentImageUrlObjectImageUrlDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageUrlObjectImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: Option<String>,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<MessageDeltaContentImageUrlObjectImageUrlDetail>,
        }
        let _D { url, detail, .. } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentImageUrlObjectImageUrl { url, detail })
    }
}
impl serde::Serialize for MessageDeltaContentImageUrlObjectImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            url: &'a Option<String>,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<MessageDeltaContentImageUrlObjectImageUrlDetail>,
        }
        let MessageDeltaContentImageUrlObjectImageUrl { url, detail } = self;
        _S { url, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageUrlObjectImageUrl {
    #[doc = "The URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp."]
    #[builder(default)]
    pub url: Option<String>,
    #[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
    #[builder(default)]
    pub detail: Option<MessageDeltaContentImageUrlObjectImageUrlDetail>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageUrlObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image_url`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentImageUrlObjectType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: Option<MessageDeltaContentImageUrlObjectImageUrl>,
        }
        let _D {
            index, image_url, ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentImageUrlObject { index, image_url })
    }
}
impl serde::Serialize for MessageDeltaContentImageUrlObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image_url`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentImageUrlObjectType,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<MessageDeltaContentImageUrlObjectImageUrl>,
        }
        let MessageDeltaContentImageUrlObject { index, image_url } = self;
        _S {
            index,
            type_: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[doc = "References an image URL in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageUrlObject {
    #[doc = "The index of the content part in the message."]
    pub index: u64,
    #[builder(default)]
    pub image_url: Option<MessageDeltaContentImageUrlObjectImageUrl>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentRefusalObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentRefusalObjectType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentRefusalObjectType,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<String>,
        }
        let _D { index, refusal, .. } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentRefusalObject { index, refusal })
    }
}
impl serde::Serialize for MessageDeltaContentRefusalObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentRefusalObjectType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentRefusalObjectType,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
        }
        let MessageDeltaContentRefusalObject { index, refusal } = self;
        _S {
            index,
            type_: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "The refusal content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentRefusalObject {
    #[doc = "The index of the refusal part in the message."]
    pub index: u64,
    #[builder(default)]
    pub refusal: Option<String>,
}
impl<'de> serde::Deserialize<'de>
    for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "quote")]
            #[allow(dead_code)]
            quote: Option<String>,
        }
        let _D { file_id, quote, .. } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation { file_id, quote })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "quote")]
            #[serde(skip_serializing_if = "Option::is_none")]
            quote: &'a Option<String>,
        }
        let MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation { file_id, quote } =
            self;
        _S { file_id, quote }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    #[doc = "The ID of the specific File the citation is from."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The specific quote in the file."]
    #[builder(default)]
    pub quote: Option<String>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextAnnotationsFileCitationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextAnnotationsFileCitationObjectType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentTextAnnotationsFileCitationObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "file_citation")]
            #[allow(dead_code)]
            file_citation: Option<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: Option<u64>,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: Option<u64>,
        }
        let _D {
            index,
            text,
            file_citation,
            start_index,
            end_index,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentTextAnnotationsFileCitationObject {
            index,
            text,
            file_citation,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFileCitationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextAnnotationsFileCitationObjectType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentTextAnnotationsFileCitationObjectType,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "file_citation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_citation:
                &'a Option<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,
            #[serde(rename = "start_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            start_index: &'a Option<u64>,
            #[serde(rename = "end_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            end_index: &'a Option<u64>,
        }
        let MessageDeltaContentTextAnnotationsFileCitationObject {
            index,
            text,
            file_citation,
            start_index,
            end_index,
        } = self;
        _S {
            index,
            type_: &Default::default(),
            text,
            file_citation,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFileCitationObject {
    #[doc = "The index of the annotation in the text content part."]
    pub index: u64,
    #[doc = "The text in the message content that needs to be replaced."]
    #[builder(default)]
    pub text: Option<String>,
    #[builder(default)]
    pub file_citation: Option<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,
    #[builder(default)]
    pub start_index: Option<u64>,
    #[builder(default)]
    pub end_index: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let _D { file_id, .. } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentTextAnnotationsFilePathObjectFilePath { file_id })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let MessageDeltaContentTextAnnotationsFilePathObjectFilePath { file_id } = self;
        _S { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    #[doc = "The ID of the file that was generated."]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextAnnotationsFilePathObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `file_path`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextAnnotationsFilePathObjectType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentTextAnnotationsFilePathObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "file_path")]
            #[allow(dead_code)]
            file_path: Option<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: Option<u64>,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: Option<u64>,
        }
        let _D {
            index,
            text,
            file_path,
            start_index,
            end_index,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentTextAnnotationsFilePathObject {
            index,
            text,
            file_path,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFilePathObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `file_path`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextAnnotationsFilePathObjectType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentTextAnnotationsFilePathObjectType,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "file_path")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_path: &'a Option<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,
            #[serde(rename = "start_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            start_index: &'a Option<u64>,
            #[serde(rename = "end_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            end_index: &'a Option<u64>,
        }
        let MessageDeltaContentTextAnnotationsFilePathObject {
            index,
            text,
            file_path,
            start_index,
            end_index,
        } = self;
        _S {
            index,
            type_: &Default::default(),
            text,
            file_path,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFilePathObject {
    #[doc = "The index of the annotation in the text content part."]
    pub index: u64,
    #[doc = "The text in the message content that needs to be replaced."]
    #[builder(default)]
    pub text: Option<String>,
    #[builder(default)]
    pub file_path: Option<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,
    #[builder(default)]
    pub start_index: Option<u64>,
    #[builder(default)]
    pub end_index: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextObjectTextAnnotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileCitation(#[allow(dead_code)] MessageDeltaContentTextAnnotationsFileCitationObject),
            FilePath(#[allow(dead_code)] MessageDeltaContentTextAnnotationsFilePathObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileCitation(_v) => Self::FileCitation(_v),
            _D::FilePath(_v) => Self::FilePath(_v),
        })
    }
}
impl serde::Serialize for MessageDeltaContentTextObjectTextAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileCitation(
                #[allow(dead_code)] &'a MessageDeltaContentTextAnnotationsFileCitationObject,
            ),
            FilePath(#[allow(dead_code)] &'a MessageDeltaContentTextAnnotationsFilePathObject),
        }
        match self {
            Self::FileCitation(_v) => _S::FileCitation(_v).serialize(serializer),
            Self::FilePath(_v) => _S::FilePath(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum MessageDeltaContentTextObjectTextAnnotation {
    FileCitation(MessageDeltaContentTextAnnotationsFileCitationObject),
    FilePath(MessageDeltaContentTextAnnotationsFilePathObject),
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextObjectText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: Option<String>,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Option<Vec<MessageDeltaContentTextObjectTextAnnotation>>,
        }
        let _D {
            value, annotations, ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentTextObjectText { value, annotations })
    }
}
impl serde::Serialize for MessageDeltaContentTextObjectText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            value: &'a Option<String>,
            #[serde(rename = "annotations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            annotations: &'a Option<Vec<MessageDeltaContentTextObjectTextAnnotation>>,
        }
        let MessageDeltaContentTextObjectText { value, annotations } = self;
        _S { value, annotations }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextObjectText {
    #[doc = "The data that makes up the text."]
    #[builder(default)]
    pub value: Option<String>,
    #[builder(default)]
    pub annotations: Option<Vec<MessageDeltaContentTextObjectTextAnnotation>>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentTextObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<MessageDeltaContentTextObjectText>,
        }
        let _D { index, text, .. } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaContentTextObject { index, text })
    }
}
impl serde::Serialize for MessageDeltaContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentTextObjectType,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<MessageDeltaContentTextObjectText>,
        }
        let MessageDeltaContentTextObject { index, text } = self;
        _S {
            index,
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextObject {
    #[doc = "The index of the content part in the message."]
    pub index: u64,
    #[builder(default)]
    pub text: Option<MessageDeltaContentTextObjectText>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaObjectDeltaRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectDeltaRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectDeltaRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] MessageDeltaObjectDeltaRoleUser),
            Assistant(#[allow(dead_code)] MessageDeltaObjectDeltaRoleAssistant),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
        })
    }
}
impl serde::Serialize for MessageDeltaObjectDeltaRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectDeltaRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectDeltaRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a MessageDeltaObjectDeltaRoleUser),
            Assistant(#[allow(dead_code)] &'a MessageDeltaObjectDeltaRoleAssistant),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The entity that produced the message. One of `user` or `assistant`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageDeltaObjectDeltaRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaObjectDeltaContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ImageFile(#[allow(dead_code)] MessageDeltaContentImageFileObject),
            Text(#[allow(dead_code)] MessageDeltaContentTextObject),
            Refusal(#[allow(dead_code)] MessageDeltaContentRefusalObject),
            ImageUrl(#[allow(dead_code)] MessageDeltaContentImageUrlObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ImageFile(_v) => Self::ImageFile(_v),
            _D::Text(_v) => Self::Text(_v),
            _D::Refusal(_v) => Self::Refusal(_v),
            _D::ImageUrl(_v) => Self::ImageUrl(_v),
        })
    }
}
impl serde::Serialize for MessageDeltaObjectDeltaContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ImageFile(#[allow(dead_code)] &'a MessageDeltaContentImageFileObject),
            Text(#[allow(dead_code)] &'a MessageDeltaContentTextObject),
            Refusal(#[allow(dead_code)] &'a MessageDeltaContentRefusalObject),
            ImageUrl(#[allow(dead_code)] &'a MessageDeltaContentImageUrlObject),
        }
        match self {
            Self::ImageFile(_v) => _S::ImageFile(_v).serialize(serializer),
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
            Self::Refusal(_v) => _S::Refusal(_v).serialize(serializer),
            Self::ImageUrl(_v) => _S::ImageUrl(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum MessageDeltaObjectDeltaContent {
    ImageFile(MessageDeltaContentImageFileObject),
    Text(MessageDeltaContentTextObject),
    Refusal(MessageDeltaContentRefusalObject),
    ImageUrl(MessageDeltaContentImageUrlObject),
}
impl<'de> serde::Deserialize<'de> for MessageDeltaObjectDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<MessageDeltaObjectDeltaRole>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<MessageDeltaObjectDeltaContent>>,
        }
        let _D { role, content, .. } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaObjectDelta { role, content })
    }
}
impl serde::Serialize for MessageDeltaObjectDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<MessageDeltaObjectDeltaRole>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<MessageDeltaObjectDeltaContent>>,
        }
        let MessageDeltaObjectDelta { role, content } = self;
        _S { role, content }.serialize(serializer)
    }
}
#[doc = "The delta containing the fields that have changed on the Message."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaObjectDelta {
    #[doc = "The entity that produced the message. One of `user` or `assistant`."]
    #[builder(default)]
    pub role: Option<MessageDeltaObjectDeltaRole>,
    #[doc = "The content of the message in array of text and/or images."]
    #[builder(default)]
    pub content: Option<Vec<MessageDeltaObjectDeltaContent>>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.message.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectObject {
            #[default]
            #[serde(rename = "thread.message.delta")]
            ThreadMessageDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: MessageDeltaObjectObject,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: MessageDeltaObjectDelta,
        }
        let _D { id, delta, .. } = _D::deserialize(deserializer)?;
        Ok(MessageDeltaObject { id, delta })
    }
}
impl serde::Serialize for MessageDeltaObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.message.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectObject {
            #[default]
            #[serde(rename = "thread.message.delta")]
            ThreadMessageDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a MessageDeltaObjectObject,
            #[serde(rename = "delta")]
            delta: &'a MessageDeltaObjectDelta,
        }
        let MessageDeltaObject { id, delta } = self;
        _S {
            id,
            object: &Default::default(),
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a message delta i.e. any changed fields on a message during streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaObject {
    #[doc = "The identifier of the message, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The delta containing the fields that have changed on the Message."]
    #[builder(default)]
    pub delta: MessageDeltaObjectDelta,
}
impl<'de> serde::Deserialize<'de> for MessageObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] MessageObjectStatusInProgress),
            Incomplete(#[allow(dead_code)] MessageObjectStatusIncomplete),
            Completed(#[allow(dead_code)] MessageObjectStatusCompleted),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Incomplete(_) => Self::Incomplete,
            _D::Completed(_) => Self::Completed,
        })
    }
}
impl serde::Serialize for MessageObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a MessageObjectStatusInProgress),
            Incomplete(#[allow(dead_code)] &'a MessageObjectStatusIncomplete),
            Completed(#[allow(dead_code)] &'a MessageObjectStatusCompleted),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the message, which can be either `in_progress`, `incomplete`, or `completed`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "incomplete"]
    Incomplete,
    #[doc = "completed"]
    Completed,
}
impl<'de> serde::Deserialize<'de> for MessageObjectIncompleteDetailsReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonMaxTokens {
            #[default]
            #[serde(rename = "max_tokens")]
            MaxTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunCancelled {
            #[default]
            #[serde(rename = "run_cancelled")]
            RunCancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunExpired {
            #[default]
            #[serde(rename = "run_expired")]
            RunExpired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunFailed {
            #[default]
            #[serde(rename = "run_failed")]
            RunFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ContentFilter(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonContentFilter),
            MaxTokens(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonMaxTokens),
            RunCancelled(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonRunCancelled),
            RunExpired(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonRunExpired),
            RunFailed(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonRunFailed),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ContentFilter(_) => Self::ContentFilter,
            _D::MaxTokens(_) => Self::MaxTokens,
            _D::RunCancelled(_) => Self::RunCancelled,
            _D::RunExpired(_) => Self::RunExpired,
            _D::RunFailed(_) => Self::RunFailed,
        })
    }
}
impl serde::Serialize for MessageObjectIncompleteDetailsReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonMaxTokens {
            #[default]
            #[serde(rename = "max_tokens")]
            MaxTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunCancelled {
            #[default]
            #[serde(rename = "run_cancelled")]
            RunCancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunExpired {
            #[default]
            #[serde(rename = "run_expired")]
            RunExpired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunFailed {
            #[default]
            #[serde(rename = "run_failed")]
            RunFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ContentFilter(
                #[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonContentFilter,
            ),
            MaxTokens(#[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonMaxTokens),
            RunCancelled(#[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonRunCancelled),
            RunExpired(#[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonRunExpired),
            RunFailed(#[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonRunFailed),
        }
        match self {
            Self::ContentFilter => _S::ContentFilter(&Default::default()).serialize(serializer),
            Self::MaxTokens => _S::MaxTokens(&Default::default()).serialize(serializer),
            Self::RunCancelled => _S::RunCancelled(&Default::default()).serialize(serializer),
            Self::RunExpired => _S::RunExpired(&Default::default()).serialize(serializer),
            Self::RunFailed => _S::RunFailed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The reason the message is incomplete."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectIncompleteDetailsReason {
    #[doc = "content_filter"]
    ContentFilter,
    #[doc = "max_tokens"]
    MaxTokens,
    #[doc = "run_cancelled"]
    RunCancelled,
    #[doc = "run_expired"]
    RunExpired,
    #[doc = "run_failed"]
    RunFailed,
}
impl<'de> serde::Deserialize<'de> for MessageObjectIncompleteDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: MessageObjectIncompleteDetailsReason,
        }
        let _D { reason, .. } = _D::deserialize(deserializer)?;
        Ok(MessageObjectIncompleteDetails { reason })
    }
}
impl serde::Serialize for MessageObjectIncompleteDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "reason")]
            reason: &'a MessageObjectIncompleteDetailsReason,
        }
        let MessageObjectIncompleteDetails { reason } = self;
        _S { reason }.serialize(serializer)
    }
}
#[doc = "On an incomplete message, details about why the message is incomplete."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct MessageObjectIncompleteDetails {
    #[doc = "The reason the message is incomplete."]
    pub reason: MessageObjectIncompleteDetailsReason,
}
impl<'de> serde::Deserialize<'de> for MessageObjectRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] MessageObjectRoleUser),
            Assistant(#[allow(dead_code)] MessageObjectRoleAssistant),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
        })
    }
}
impl serde::Serialize for MessageObjectRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a MessageObjectRoleUser),
            Assistant(#[allow(dead_code)] &'a MessageObjectRoleAssistant),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The entity that produced the message. One of `user` or `assistant`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
}
impl<'de> serde::Deserialize<'de> for MessageObjectContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ImageFile(#[allow(dead_code)] MessageContentImageFileObject),
            ImageUrl(#[allow(dead_code)] MessageContentImageUrlObject),
            Text(#[allow(dead_code)] MessageContentTextObject),
            Refusal(#[allow(dead_code)] MessageContentRefusalObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ImageFile(_v) => Self::ImageFile(_v),
            _D::ImageUrl(_v) => Self::ImageUrl(_v),
            _D::Text(_v) => Self::Text(_v),
            _D::Refusal(_v) => Self::Refusal(_v),
        })
    }
}
impl serde::Serialize for MessageObjectContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ImageFile(#[allow(dead_code)] &'a MessageContentImageFileObject),
            ImageUrl(#[allow(dead_code)] &'a MessageContentImageUrlObject),
            Text(#[allow(dead_code)] &'a MessageContentTextObject),
            Refusal(#[allow(dead_code)] &'a MessageContentRefusalObject),
        }
        match self {
            Self::ImageFile(_v) => _S::ImageFile(_v).serialize(serializer),
            Self::ImageUrl(_v) => _S::ImageUrl(_v).serialize(serializer),
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
            Self::Refusal(_v) => _S::Refusal(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectContent {
    ImageFile(MessageContentImageFileObject),
    ImageUrl(MessageContentImageUrlObject),
    Text(MessageContentTextObject),
    Refusal(MessageContentRefusalObject),
}
impl<'de> serde::Deserialize<'de> for MessageObjectAttachmentsTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearchTypeOnly),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
        })
    }
}
impl serde::Serialize for MessageObjectAttachmentsTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearchTypeOnly),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectAttachmentsTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearchTypeOnly),
}
impl<'de> serde::Deserialize<'de> for MessageObjectAttachments {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<MessageObjectAttachmentsTool>>,
        }
        let _D { file_id, tools, .. } = _D::deserialize(deserializer)?;
        Ok(MessageObjectAttachments { file_id, tools })
    }
}
impl serde::Serialize for MessageObjectAttachments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<MessageObjectAttachmentsTool>>,
        }
        let MessageObjectAttachments { file_id, tools } = self;
        _S { file_id, tools }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageObjectAttachments {
    #[doc = "The ID of the file to attach to the message."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The tools to add this file to."]
    #[builder(default)]
    pub tools: Option<Vec<MessageObjectAttachmentsTool>>,
}
impl<'de> serde::Deserialize<'de> for MessageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.message`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectObject {
            #[default]
            #[serde(rename = "thread.message")]
            ThreadMessage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: MessageObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "thread_id")]
            #[allow(dead_code)]
            thread_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: MessageObjectStatus,
            #[serde(rename = "incomplete_details")]
            #[allow(dead_code)]
            incomplete_details: Option<MessageObjectIncompleteDetails>,
            #[serde(rename = "completed_at")]
            #[allow(dead_code)]
            completed_at: Option<u64>,
            #[serde(rename = "incomplete_at")]
            #[allow(dead_code)]
            incomplete_at: Option<u64>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: MessageObjectRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Vec<MessageObjectContent>,
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: Option<String>,
            #[serde(rename = "run_id")]
            #[allow(dead_code)]
            run_id: Option<String>,
            #[serde(rename = "attachments")]
            #[allow(dead_code)]
            attachments: Option<Vec<MessageObjectAttachments>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Metadata,
        }
        let _D {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(MessageObject {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        })
    }
}
impl serde::Serialize for MessageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.message`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectObject {
            #[default]
            #[serde(rename = "thread.message")]
            ThreadMessage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a MessageObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "status")]
            status: &'a MessageObjectStatus,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<MessageObjectIncompleteDetails>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<u64>,
            #[serde(rename = "incomplete_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_at: &'a Option<u64>,
            #[serde(rename = "role")]
            role: &'a MessageObjectRole,
            #[serde(rename = "content")]
            content: &'a Vec<MessageObjectContent>,
            #[serde(rename = "assistant_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            assistant_id: &'a Option<String>,
            #[serde(rename = "run_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            run_id: &'a Option<String>,
            #[serde(rename = "attachments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attachments: &'a Option<Vec<MessageObjectAttachments>>,
            #[serde(rename = "metadata")]
            metadata: &'a Metadata,
        }
        let MessageObject {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        } = self;
        _S {
            id,
            object: &Default::default(),
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a message within a [thread](https://platform.openai.com/docs/api-reference/threads)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the message was created."]
    pub created_at: u64,
    #[doc = "The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to."]
    pub thread_id: String,
    #[doc = "The status of the message, which can be either `in_progress`, `incomplete`, or `completed`."]
    pub status: MessageObjectStatus,
    #[doc = "On an incomplete message, details about why the message is incomplete."]
    #[builder(default)]
    pub incomplete_details: Option<MessageObjectIncompleteDetails>,
    #[doc = "The Unix timestamp (in seconds) for when the message was completed."]
    #[builder(default)]
    pub completed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the message was marked as incomplete."]
    #[builder(default)]
    pub incomplete_at: Option<u64>,
    #[doc = "The entity that produced the message. One of `user` or `assistant`."]
    pub role: MessageObjectRole,
    #[doc = "The content of the message in array of text and/or images."]
    pub content: Vec<MessageObjectContent>,
    #[doc = "If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message."]
    #[builder(default)]
    pub assistant_id: Option<String>,
    #[doc = "The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints."]
    #[builder(default)]
    pub run_id: Option<String>,
    #[doc = "A list of files attached to the message, and the tools they were added to."]
    #[builder(default)]
    pub attachments: Option<Vec<MessageObjectAttachments>>,
    pub metadata: Metadata,
}
impl<'de> serde::Deserialize<'de> for MessageRequestContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageRequestContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageRequestContentTextObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(MessageRequestContentTextObject { text })
    }
}
impl serde::Serialize for MessageRequestContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageRequestContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageRequestContentTextObjectType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let MessageRequestContentTextObject { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageRequestContentTextObject {
    #[doc = "Text content to be sent to the model"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageCreatedEvent {
            #[default]
            #[serde(rename = "thread.message.created")]
            ThreadMessageCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageCreatedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(MessageStreamEventThreadMessageCreated { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageCreatedEvent {
            #[default]
            #[serde(rename = "thread.message.created")]
            ThreadMessageCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageCreatedEvent,
            #[serde(rename = "data")]
            data: &'a MessageObject,
        }
        let MessageStreamEventThreadMessageCreated { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is created."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageCreated {
    pub data: MessageObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageInProgress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageInProgressEvent {
            #[default]
            #[serde(rename = "thread.message.in_progress")]
            ThreadMessageInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageInProgressEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(MessageStreamEventThreadMessageInProgress { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageInProgress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageInProgressEvent {
            #[default]
            #[serde(rename = "thread.message.in_progress")]
            ThreadMessageInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageInProgressEvent,
            #[serde(rename = "data")]
            data: &'a MessageObject,
        }
        let MessageStreamEventThreadMessageInProgress { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) moves to an `in_progress` state."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageInProgress {
    pub data: MessageObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageDeltaEvent {
            #[default]
            #[serde(rename = "thread.message.delta")]
            ThreadMessageDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageDeltaEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageDeltaObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(MessageStreamEventThreadMessageDelta { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageDeltaEvent {
            #[default]
            #[serde(rename = "thread.message.delta")]
            ThreadMessageDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageDeltaEvent,
            #[serde(rename = "data")]
            data: &'a MessageDeltaObject,
        }
        let MessageStreamEventThreadMessageDelta { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when parts of a [Message](https://platform.openai.com/docs/api-reference/messages/object) are being streamed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageDelta {
    pub data: MessageDeltaObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageCompleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageCompletedEvent {
            #[default]
            #[serde(rename = "thread.message.completed")]
            ThreadMessageCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageCompletedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(MessageStreamEventThreadMessageCompleted { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageCompletedEvent {
            #[default]
            #[serde(rename = "thread.message.completed")]
            ThreadMessageCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageCompletedEvent,
            #[serde(rename = "data")]
            data: &'a MessageObject,
        }
        let MessageStreamEventThreadMessageCompleted { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageCompleted {
    pub data: MessageObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageIncomplete {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageIncompleteEvent {
            #[default]
            #[serde(rename = "thread.message.incomplete")]
            ThreadMessageIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageIncompleteEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(MessageStreamEventThreadMessageIncomplete { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageIncomplete {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageIncompleteEvent {
            #[default]
            #[serde(rename = "thread.message.incomplete")]
            ThreadMessageIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageIncompleteEvent,
            #[serde(rename = "data")]
            data: &'a MessageObject,
        }
        let MessageStreamEventThreadMessageIncomplete { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) ends before it is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageIncomplete {
    pub data: MessageObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ThreadMessageCreated(#[allow(dead_code)] MessageStreamEventThreadMessageCreated),
            ThreadMessageInProgress(#[allow(dead_code)] MessageStreamEventThreadMessageInProgress),
            ThreadMessageDelta(#[allow(dead_code)] MessageStreamEventThreadMessageDelta),
            ThreadMessageCompleted(#[allow(dead_code)] MessageStreamEventThreadMessageCompleted),
            ThreadMessageIncomplete(#[allow(dead_code)] MessageStreamEventThreadMessageIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ThreadMessageCreated(_v) => Self::ThreadMessageCreated(_v),
            _D::ThreadMessageInProgress(_v) => Self::ThreadMessageInProgress(_v),
            _D::ThreadMessageDelta(_v) => Self::ThreadMessageDelta(_v),
            _D::ThreadMessageCompleted(_v) => Self::ThreadMessageCompleted(_v),
            _D::ThreadMessageIncomplete(_v) => Self::ThreadMessageIncomplete(_v),
        })
    }
}
impl serde::Serialize for MessageStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ThreadMessageCreated(#[allow(dead_code)] &'a MessageStreamEventThreadMessageCreated),
            ThreadMessageInProgress(
                #[allow(dead_code)] &'a MessageStreamEventThreadMessageInProgress,
            ),
            ThreadMessageDelta(#[allow(dead_code)] &'a MessageStreamEventThreadMessageDelta),
            ThreadMessageCompleted(
                #[allow(dead_code)] &'a MessageStreamEventThreadMessageCompleted,
            ),
            ThreadMessageIncomplete(
                #[allow(dead_code)] &'a MessageStreamEventThreadMessageIncomplete,
            ),
        }
        match self {
            Self::ThreadMessageCreated(_v) => _S::ThreadMessageCreated(_v).serialize(serializer),
            Self::ThreadMessageInProgress(_v) => {
                _S::ThreadMessageInProgress(_v).serialize(serializer)
            }
            Self::ThreadMessageDelta(_v) => _S::ThreadMessageDelta(_v).serialize(serializer),
            Self::ThreadMessageCompleted(_v) => {
                _S::ThreadMessageCompleted(_v).serialize(serializer)
            }
            Self::ThreadMessageIncomplete(_v) => {
                _S::ThreadMessageIncomplete(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum MessageStreamEvent {
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is created."]
    ThreadMessageCreated(MessageStreamEventThreadMessageCreated),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) moves to an `in_progress` state."]
    ThreadMessageInProgress(MessageStreamEventThreadMessageInProgress),
    #[doc = "Occurs when parts of a [Message](https://platform.openai.com/docs/api-reference/messages/object) are being streamed."]
    ThreadMessageDelta(MessageStreamEventThreadMessageDelta),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is completed."]
    ThreadMessageCompleted(MessageStreamEventThreadMessageCompleted),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) ends before it is completed."]
    ThreadMessageIncomplete(MessageStreamEventThreadMessageIncomplete),
}
#[doc = "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. \n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"]
pub type Metadata = Vec<String>;
impl<'de> serde::Deserialize<'de> for Model {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"model\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelObject {
            #[default]
            #[serde(rename = "model")]
            Model,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ModelObject,
            #[serde(rename = "owned_by")]
            #[allow(dead_code)]
            owned_by: String,
        }
        let _D {
            id,
            created,
            owned_by,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Model {
            id,
            created,
            owned_by,
        })
    }
}
impl serde::Serialize for Model {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"model\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelObject {
            #[default]
            #[serde(rename = "model")]
            Model,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "object")]
            object: &'a ModelObject,
            #[serde(rename = "owned_by")]
            owned_by: &'a String,
        }
        let Model {
            id,
            created,
            owned_by,
        } = self;
        _S {
            id,
            created,
            object: &Default::default(),
            owned_by,
        }
        .serialize(serializer)
    }
}
#[doc = "Describes an OpenAI model offering that can be used with the API."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Model {
    #[doc = "The model identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) when the model was created."]
    pub created: u64,
    #[doc = "The organization that owns the model."]
    pub owned_by: String,
}
impl<'de> serde::Deserialize<'de> for ModelIds {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ModelIdsShared(#[allow(dead_code)] ModelIdsShared),
            ModelIdsResponses(#[allow(dead_code)] ModelIdsResponses),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ModelIdsShared(_v) => Self::ModelIdsShared(_v),
            _D::ModelIdsResponses(_v) => Self::ModelIdsResponses(_v),
        })
    }
}
impl serde::Serialize for ModelIds {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ModelIdsShared(#[allow(dead_code)] &'a ModelIdsShared),
            ModelIdsResponses(#[allow(dead_code)] &'a ModelIdsResponses),
        }
        match self {
            Self::ModelIdsShared(_v) => _S::ModelIdsShared(_v).serialize(serializer),
            Self::ModelIdsResponses(_v) => _S::ModelIdsResponses(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIds {
    ModelIdsShared(ModelIdsShared),
    ModelIdsResponses(ModelIdsResponses),
}
impl<'de> serde::Deserialize<'de> for ModelIdsResponses {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO1Pro {
            #[default]
            #[serde(rename = "o1-pro")]
            O1Pro,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO1Pro2025_03_19 {
            #[default]
            #[serde(rename = "o1-pro-2025-03-19")]
            O1Pro2025_03_19,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesComputerUsePreview {
            #[default]
            #[serde(rename = "computer-use-preview")]
            ComputerUsePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesComputerUsePreview2025_03_11 {
            #[default]
            #[serde(rename = "computer-use-preview-2025-03-11")]
            ComputerUsePreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ModelIdsShared(#[allow(dead_code)] ModelIdsShared),
            O1Pro(#[allow(dead_code)] ModelIdsResponsesO1Pro),
            O1Pro2025_03_19(#[allow(dead_code)] ModelIdsResponsesO1Pro2025_03_19),
            ComputerUsePreview(#[allow(dead_code)] ModelIdsResponsesComputerUsePreview),
            ComputerUsePreview2025_03_11(
                #[allow(dead_code)] ModelIdsResponsesComputerUsePreview2025_03_11,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ModelIdsShared(_v) => Self::ModelIdsShared(_v),
            _D::O1Pro(_) => Self::O1Pro,
            _D::O1Pro2025_03_19(_) => Self::O1Pro2025_03_19,
            _D::ComputerUsePreview(_) => Self::ComputerUsePreview,
            _D::ComputerUsePreview2025_03_11(_) => Self::ComputerUsePreview2025_03_11,
        })
    }
}
impl serde::Serialize for ModelIdsResponses {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO1Pro {
            #[default]
            #[serde(rename = "o1-pro")]
            O1Pro,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO1Pro2025_03_19 {
            #[default]
            #[serde(rename = "o1-pro-2025-03-19")]
            O1Pro2025_03_19,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesComputerUsePreview {
            #[default]
            #[serde(rename = "computer-use-preview")]
            ComputerUsePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesComputerUsePreview2025_03_11 {
            #[default]
            #[serde(rename = "computer-use-preview-2025-03-11")]
            ComputerUsePreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ModelIdsShared(#[allow(dead_code)] &'a ModelIdsShared),
            O1Pro(#[allow(dead_code)] &'a ModelIdsResponsesO1Pro),
            O1Pro2025_03_19(#[allow(dead_code)] &'a ModelIdsResponsesO1Pro2025_03_19),
            ComputerUsePreview(#[allow(dead_code)] &'a ModelIdsResponsesComputerUsePreview),
            ComputerUsePreview2025_03_11(
                #[allow(dead_code)] &'a ModelIdsResponsesComputerUsePreview2025_03_11,
            ),
        }
        match self {
            Self::ModelIdsShared(_v) => _S::ModelIdsShared(_v).serialize(serializer),
            Self::O1Pro => _S::O1Pro(&Default::default()).serialize(serializer),
            Self::O1Pro2025_03_19 => _S::O1Pro2025_03_19(&Default::default()).serialize(serializer),
            Self::ComputerUsePreview => {
                _S::ComputerUsePreview(&Default::default()).serialize(serializer)
            }
            Self::ComputerUsePreview2025_03_11 => {
                _S::ComputerUsePreview2025_03_11(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIdsResponses {
    ModelIdsShared(ModelIdsShared),
    #[doc = "o1-pro"]
    O1Pro,
    #[doc = "o1-pro-2025-03-19"]
    O1Pro2025_03_19,
    #[doc = "computer-use-preview"]
    ComputerUsePreview,
    #[doc = "computer-use-preview-2025-03-11"]
    ComputerUsePreview2025_03_11,
}
impl<'de> serde::Deserialize<'de> for ModelIdsShared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1 {
            #[default]
            #[serde(rename = "gpt-4.1")]
            Gpt4_1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1Mini {
            #[default]
            #[serde(rename = "gpt-4.1-mini")]
            Gpt4_1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1Nano {
            #[default]
            #[serde(rename = "gpt-4.1-nano")]
            Gpt4_1Nano,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1_2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-2025-04-14")]
            Gpt4_1_2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1Mini2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-mini-2025-04-14")]
            Gpt4_1Mini2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1Nano2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-nano-2025-04-14")]
            Gpt4_1Nano2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO4Mini {
            #[default]
            #[serde(rename = "o4-mini")]
            O4Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO4Mini2025_04_16 {
            #[default]
            #[serde(rename = "o4-mini-2025-04-16")]
            O4Mini2025_04_16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO3 {
            #[default]
            #[serde(rename = "o3")]
            O3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO3_2025_04_16 {
            #[default]
            #[serde(rename = "o3-2025-04-16")]
            O3_2025_04_16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO3Mini {
            #[default]
            #[serde(rename = "o3-mini")]
            O3Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO3Mini2025_01_31 {
            #[default]
            #[serde(rename = "o3-mini-2025-01-31")]
            O3Mini2025_01_31,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1 {
            #[default]
            #[serde(rename = "o1")]
            O1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1_2024_12_17 {
            #[default]
            #[serde(rename = "o1-2024-12-17")]
            O1_2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1Preview {
            #[default]
            #[serde(rename = "o1-preview")]
            O1Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1Preview2024_09_12 {
            #[default]
            #[serde(rename = "o1-preview-2024-09-12")]
            O1Preview2024_09_12,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1Mini {
            #[default]
            #[serde(rename = "o1-mini")]
            O1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1Mini2024_09_12 {
            #[default]
            #[serde(rename = "o1-mini-2024-09-12")]
            O1Mini2024_09_12,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4o {
            #[default]
            #[serde(rename = "gpt-4o")]
            Gpt4o,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4o2024_11_20 {
            #[default]
            #[serde(rename = "gpt-4o-2024-11-20")]
            Gpt4o2024_11_20,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4o2024_08_06 {
            #[default]
            #[serde(rename = "gpt-4o-2024-08-06")]
            Gpt4o2024_08_06,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4o2024_05_13 {
            #[default]
            #[serde(rename = "gpt-4o-2024-05-13")]
            Gpt4o2024_05_13,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oAudioPreview {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview")]
            Gpt4oAudioPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oAudioPreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2024-10-01")]
            Gpt4oAudioPreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oAudioPreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2024-12-17")]
            Gpt4oAudioPreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMiniAudioPreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-audio-preview")]
            Gpt4oMiniAudioPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMiniAudioPreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-audio-preview-2024-12-17")]
            Gpt4oMiniAudioPreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oSearchPreview {
            #[default]
            #[serde(rename = "gpt-4o-search-preview")]
            Gpt4oSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMiniSearchPreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-search-preview")]
            Gpt4oMiniSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "gpt-4o-search-preview-2025-03-11")]
            Gpt4oSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMiniSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "gpt-4o-mini-search-preview-2025-03-11")]
            Gpt4oMiniSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedChatgpt4oLatest {
            #[default]
            #[serde(rename = "chatgpt-4o-latest")]
            Chatgpt4oLatest,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMini {
            #[default]
            #[serde(rename = "gpt-4o-mini")]
            Gpt4oMini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMini2024_07_18 {
            #[default]
            #[serde(rename = "gpt-4o-mini-2024-07-18")]
            Gpt4oMini2024_07_18,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4Turbo {
            #[default]
            #[serde(rename = "gpt-4-turbo")]
            Gpt4Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4Turbo2024_04_09 {
            #[default]
            #[serde(rename = "gpt-4-turbo-2024-04-09")]
            Gpt4Turbo2024_04_09,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_0125Preview {
            #[default]
            #[serde(rename = "gpt-4-0125-preview")]
            Gpt4_0125Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4TurboPreview {
            #[default]
            #[serde(rename = "gpt-4-turbo-preview")]
            Gpt4TurboPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1106Preview {
            #[default]
            #[serde(rename = "gpt-4-1106-preview")]
            Gpt4_1106Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4VisionPreview {
            #[default]
            #[serde(rename = "gpt-4-vision-preview")]
            Gpt4VisionPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4 {
            #[default]
            #[serde(rename = "gpt-4")]
            Gpt4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_0314 {
            #[default]
            #[serde(rename = "gpt-4-0314")]
            Gpt4_0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_0613 {
            #[default]
            #[serde(rename = "gpt-4-0613")]
            Gpt4_0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_32k {
            #[default]
            #[serde(rename = "gpt-4-32k")]
            Gpt4_32k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_32k0314 {
            #[default]
            #[serde(rename = "gpt-4-32k-0314")]
            Gpt4_32k0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_32k0613 {
            #[default]
            #[serde(rename = "gpt-4-32k-0613")]
            Gpt4_32k0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo {
            #[default]
            #[serde(rename = "gpt-3.5-turbo")]
            Gpt3_5Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo16k {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k")]
            Gpt3_5Turbo16k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo0301 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0301")]
            Gpt3_5Turbo0301,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0613")]
            Gpt3_5Turbo0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo1106 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-1106")]
            Gpt3_5Turbo1106,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo0125 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0125")]
            Gpt3_5Turbo0125,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo16k0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k-0613")]
            Gpt3_5Turbo16k0613,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Gpt4_1(#[allow(dead_code)] ModelIdsSharedGpt4_1),
            Gpt4_1Mini(#[allow(dead_code)] ModelIdsSharedGpt4_1Mini),
            Gpt4_1Nano(#[allow(dead_code)] ModelIdsSharedGpt4_1Nano),
            Gpt4_1_2025_04_14(#[allow(dead_code)] ModelIdsSharedGpt4_1_2025_04_14),
            Gpt4_1Mini2025_04_14(#[allow(dead_code)] ModelIdsSharedGpt4_1Mini2025_04_14),
            Gpt4_1Nano2025_04_14(#[allow(dead_code)] ModelIdsSharedGpt4_1Nano2025_04_14),
            O4Mini(#[allow(dead_code)] ModelIdsSharedO4Mini),
            O4Mini2025_04_16(#[allow(dead_code)] ModelIdsSharedO4Mini2025_04_16),
            O3(#[allow(dead_code)] ModelIdsSharedO3),
            O3_2025_04_16(#[allow(dead_code)] ModelIdsSharedO3_2025_04_16),
            O3Mini(#[allow(dead_code)] ModelIdsSharedO3Mini),
            O3Mini2025_01_31(#[allow(dead_code)] ModelIdsSharedO3Mini2025_01_31),
            O1(#[allow(dead_code)] ModelIdsSharedO1),
            O1_2024_12_17(#[allow(dead_code)] ModelIdsSharedO1_2024_12_17),
            O1Preview(#[allow(dead_code)] ModelIdsSharedO1Preview),
            O1Preview2024_09_12(#[allow(dead_code)] ModelIdsSharedO1Preview2024_09_12),
            O1Mini(#[allow(dead_code)] ModelIdsSharedO1Mini),
            O1Mini2024_09_12(#[allow(dead_code)] ModelIdsSharedO1Mini2024_09_12),
            Gpt4o(#[allow(dead_code)] ModelIdsSharedGpt4o),
            Gpt4o2024_11_20(#[allow(dead_code)] ModelIdsSharedGpt4o2024_11_20),
            Gpt4o2024_08_06(#[allow(dead_code)] ModelIdsSharedGpt4o2024_08_06),
            Gpt4o2024_05_13(#[allow(dead_code)] ModelIdsSharedGpt4o2024_05_13),
            Gpt4oAudioPreview(#[allow(dead_code)] ModelIdsSharedGpt4oAudioPreview),
            Gpt4oAudioPreview2024_10_01(
                #[allow(dead_code)] ModelIdsSharedGpt4oAudioPreview2024_10_01,
            ),
            Gpt4oAudioPreview2024_12_17(
                #[allow(dead_code)] ModelIdsSharedGpt4oAudioPreview2024_12_17,
            ),
            Gpt4oMiniAudioPreview(#[allow(dead_code)] ModelIdsSharedGpt4oMiniAudioPreview),
            Gpt4oMiniAudioPreview2024_12_17(
                #[allow(dead_code)] ModelIdsSharedGpt4oMiniAudioPreview2024_12_17,
            ),
            Gpt4oSearchPreview(#[allow(dead_code)] ModelIdsSharedGpt4oSearchPreview),
            Gpt4oMiniSearchPreview(#[allow(dead_code)] ModelIdsSharedGpt4oMiniSearchPreview),
            Gpt4oSearchPreview2025_03_11(
                #[allow(dead_code)] ModelIdsSharedGpt4oSearchPreview2025_03_11,
            ),
            Gpt4oMiniSearchPreview2025_03_11(
                #[allow(dead_code)] ModelIdsSharedGpt4oMiniSearchPreview2025_03_11,
            ),
            Chatgpt4oLatest(#[allow(dead_code)] ModelIdsSharedChatgpt4oLatest),
            Gpt4oMini(#[allow(dead_code)] ModelIdsSharedGpt4oMini),
            Gpt4oMini2024_07_18(#[allow(dead_code)] ModelIdsSharedGpt4oMini2024_07_18),
            Gpt4Turbo(#[allow(dead_code)] ModelIdsSharedGpt4Turbo),
            Gpt4Turbo2024_04_09(#[allow(dead_code)] ModelIdsSharedGpt4Turbo2024_04_09),
            Gpt4_0125Preview(#[allow(dead_code)] ModelIdsSharedGpt4_0125Preview),
            Gpt4TurboPreview(#[allow(dead_code)] ModelIdsSharedGpt4TurboPreview),
            Gpt4_1106Preview(#[allow(dead_code)] ModelIdsSharedGpt4_1106Preview),
            Gpt4VisionPreview(#[allow(dead_code)] ModelIdsSharedGpt4VisionPreview),
            Gpt4(#[allow(dead_code)] ModelIdsSharedGpt4),
            Gpt4_0314(#[allow(dead_code)] ModelIdsSharedGpt4_0314),
            Gpt4_0613(#[allow(dead_code)] ModelIdsSharedGpt4_0613),
            Gpt4_32k(#[allow(dead_code)] ModelIdsSharedGpt4_32k),
            Gpt4_32k0314(#[allow(dead_code)] ModelIdsSharedGpt4_32k0314),
            Gpt4_32k0613(#[allow(dead_code)] ModelIdsSharedGpt4_32k0613),
            Gpt3_5Turbo(#[allow(dead_code)] ModelIdsSharedGpt3_5Turbo),
            Gpt3_5Turbo16k(#[allow(dead_code)] ModelIdsSharedGpt3_5Turbo16k),
            Gpt3_5Turbo0301(#[allow(dead_code)] ModelIdsSharedGpt3_5Turbo0301),
            Gpt3_5Turbo0613(#[allow(dead_code)] ModelIdsSharedGpt3_5Turbo0613),
            Gpt3_5Turbo1106(#[allow(dead_code)] ModelIdsSharedGpt3_5Turbo1106),
            Gpt3_5Turbo0125(#[allow(dead_code)] ModelIdsSharedGpt3_5Turbo0125),
            Gpt3_5Turbo16k0613(#[allow(dead_code)] ModelIdsSharedGpt3_5Turbo16k0613),
            Other(#[allow(dead_code)] String),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Gpt4_1(_) => Self::Gpt4_1,
            _D::Gpt4_1Mini(_) => Self::Gpt4_1Mini,
            _D::Gpt4_1Nano(_) => Self::Gpt4_1Nano,
            _D::Gpt4_1_2025_04_14(_) => Self::Gpt4_1_2025_04_14,
            _D::Gpt4_1Mini2025_04_14(_) => Self::Gpt4_1Mini2025_04_14,
            _D::Gpt4_1Nano2025_04_14(_) => Self::Gpt4_1Nano2025_04_14,
            _D::O4Mini(_) => Self::O4Mini,
            _D::O4Mini2025_04_16(_) => Self::O4Mini2025_04_16,
            _D::O3(_) => Self::O3,
            _D::O3_2025_04_16(_) => Self::O3_2025_04_16,
            _D::O3Mini(_) => Self::O3Mini,
            _D::O3Mini2025_01_31(_) => Self::O3Mini2025_01_31,
            _D::O1(_) => Self::O1,
            _D::O1_2024_12_17(_) => Self::O1_2024_12_17,
            _D::O1Preview(_) => Self::O1Preview,
            _D::O1Preview2024_09_12(_) => Self::O1Preview2024_09_12,
            _D::O1Mini(_) => Self::O1Mini,
            _D::O1Mini2024_09_12(_) => Self::O1Mini2024_09_12,
            _D::Gpt4o(_) => Self::Gpt4o,
            _D::Gpt4o2024_11_20(_) => Self::Gpt4o2024_11_20,
            _D::Gpt4o2024_08_06(_) => Self::Gpt4o2024_08_06,
            _D::Gpt4o2024_05_13(_) => Self::Gpt4o2024_05_13,
            _D::Gpt4oAudioPreview(_) => Self::Gpt4oAudioPreview,
            _D::Gpt4oAudioPreview2024_10_01(_) => Self::Gpt4oAudioPreview2024_10_01,
            _D::Gpt4oAudioPreview2024_12_17(_) => Self::Gpt4oAudioPreview2024_12_17,
            _D::Gpt4oMiniAudioPreview(_) => Self::Gpt4oMiniAudioPreview,
            _D::Gpt4oMiniAudioPreview2024_12_17(_) => Self::Gpt4oMiniAudioPreview2024_12_17,
            _D::Gpt4oSearchPreview(_) => Self::Gpt4oSearchPreview,
            _D::Gpt4oMiniSearchPreview(_) => Self::Gpt4oMiniSearchPreview,
            _D::Gpt4oSearchPreview2025_03_11(_) => Self::Gpt4oSearchPreview2025_03_11,
            _D::Gpt4oMiniSearchPreview2025_03_11(_) => Self::Gpt4oMiniSearchPreview2025_03_11,
            _D::Chatgpt4oLatest(_) => Self::Chatgpt4oLatest,
            _D::Gpt4oMini(_) => Self::Gpt4oMini,
            _D::Gpt4oMini2024_07_18(_) => Self::Gpt4oMini2024_07_18,
            _D::Gpt4Turbo(_) => Self::Gpt4Turbo,
            _D::Gpt4Turbo2024_04_09(_) => Self::Gpt4Turbo2024_04_09,
            _D::Gpt4_0125Preview(_) => Self::Gpt4_0125Preview,
            _D::Gpt4TurboPreview(_) => Self::Gpt4TurboPreview,
            _D::Gpt4_1106Preview(_) => Self::Gpt4_1106Preview,
            _D::Gpt4VisionPreview(_) => Self::Gpt4VisionPreview,
            _D::Gpt4(_) => Self::Gpt4,
            _D::Gpt4_0314(_) => Self::Gpt4_0314,
            _D::Gpt4_0613(_) => Self::Gpt4_0613,
            _D::Gpt4_32k(_) => Self::Gpt4_32k,
            _D::Gpt4_32k0314(_) => Self::Gpt4_32k0314,
            _D::Gpt4_32k0613(_) => Self::Gpt4_32k0613,
            _D::Gpt3_5Turbo(_) => Self::Gpt3_5Turbo,
            _D::Gpt3_5Turbo16k(_) => Self::Gpt3_5Turbo16k,
            _D::Gpt3_5Turbo0301(_) => Self::Gpt3_5Turbo0301,
            _D::Gpt3_5Turbo0613(_) => Self::Gpt3_5Turbo0613,
            _D::Gpt3_5Turbo1106(_) => Self::Gpt3_5Turbo1106,
            _D::Gpt3_5Turbo0125(_) => Self::Gpt3_5Turbo0125,
            _D::Gpt3_5Turbo16k0613(_) => Self::Gpt3_5Turbo16k0613,
            _D::Other(_v) => Self::Other(_v),
        })
    }
}
impl serde::Serialize for ModelIdsShared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1 {
            #[default]
            #[serde(rename = "gpt-4.1")]
            Gpt4_1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1Mini {
            #[default]
            #[serde(rename = "gpt-4.1-mini")]
            Gpt4_1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1Nano {
            #[default]
            #[serde(rename = "gpt-4.1-nano")]
            Gpt4_1Nano,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1_2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-2025-04-14")]
            Gpt4_1_2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1Mini2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-mini-2025-04-14")]
            Gpt4_1Mini2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1Nano2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-nano-2025-04-14")]
            Gpt4_1Nano2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO4Mini {
            #[default]
            #[serde(rename = "o4-mini")]
            O4Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO4Mini2025_04_16 {
            #[default]
            #[serde(rename = "o4-mini-2025-04-16")]
            O4Mini2025_04_16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO3 {
            #[default]
            #[serde(rename = "o3")]
            O3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO3_2025_04_16 {
            #[default]
            #[serde(rename = "o3-2025-04-16")]
            O3_2025_04_16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO3Mini {
            #[default]
            #[serde(rename = "o3-mini")]
            O3Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO3Mini2025_01_31 {
            #[default]
            #[serde(rename = "o3-mini-2025-01-31")]
            O3Mini2025_01_31,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1 {
            #[default]
            #[serde(rename = "o1")]
            O1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1_2024_12_17 {
            #[default]
            #[serde(rename = "o1-2024-12-17")]
            O1_2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1Preview {
            #[default]
            #[serde(rename = "o1-preview")]
            O1Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1Preview2024_09_12 {
            #[default]
            #[serde(rename = "o1-preview-2024-09-12")]
            O1Preview2024_09_12,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1Mini {
            #[default]
            #[serde(rename = "o1-mini")]
            O1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedO1Mini2024_09_12 {
            #[default]
            #[serde(rename = "o1-mini-2024-09-12")]
            O1Mini2024_09_12,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4o {
            #[default]
            #[serde(rename = "gpt-4o")]
            Gpt4o,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4o2024_11_20 {
            #[default]
            #[serde(rename = "gpt-4o-2024-11-20")]
            Gpt4o2024_11_20,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4o2024_08_06 {
            #[default]
            #[serde(rename = "gpt-4o-2024-08-06")]
            Gpt4o2024_08_06,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4o2024_05_13 {
            #[default]
            #[serde(rename = "gpt-4o-2024-05-13")]
            Gpt4o2024_05_13,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oAudioPreview {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview")]
            Gpt4oAudioPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oAudioPreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2024-10-01")]
            Gpt4oAudioPreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oAudioPreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2024-12-17")]
            Gpt4oAudioPreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMiniAudioPreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-audio-preview")]
            Gpt4oMiniAudioPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMiniAudioPreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-audio-preview-2024-12-17")]
            Gpt4oMiniAudioPreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oSearchPreview {
            #[default]
            #[serde(rename = "gpt-4o-search-preview")]
            Gpt4oSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMiniSearchPreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-search-preview")]
            Gpt4oMiniSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "gpt-4o-search-preview-2025-03-11")]
            Gpt4oSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMiniSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "gpt-4o-mini-search-preview-2025-03-11")]
            Gpt4oMiniSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedChatgpt4oLatest {
            #[default]
            #[serde(rename = "chatgpt-4o-latest")]
            Chatgpt4oLatest,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMini {
            #[default]
            #[serde(rename = "gpt-4o-mini")]
            Gpt4oMini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4oMini2024_07_18 {
            #[default]
            #[serde(rename = "gpt-4o-mini-2024-07-18")]
            Gpt4oMini2024_07_18,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4Turbo {
            #[default]
            #[serde(rename = "gpt-4-turbo")]
            Gpt4Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4Turbo2024_04_09 {
            #[default]
            #[serde(rename = "gpt-4-turbo-2024-04-09")]
            Gpt4Turbo2024_04_09,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_0125Preview {
            #[default]
            #[serde(rename = "gpt-4-0125-preview")]
            Gpt4_0125Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4TurboPreview {
            #[default]
            #[serde(rename = "gpt-4-turbo-preview")]
            Gpt4TurboPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_1106Preview {
            #[default]
            #[serde(rename = "gpt-4-1106-preview")]
            Gpt4_1106Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4VisionPreview {
            #[default]
            #[serde(rename = "gpt-4-vision-preview")]
            Gpt4VisionPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4 {
            #[default]
            #[serde(rename = "gpt-4")]
            Gpt4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_0314 {
            #[default]
            #[serde(rename = "gpt-4-0314")]
            Gpt4_0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_0613 {
            #[default]
            #[serde(rename = "gpt-4-0613")]
            Gpt4_0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_32k {
            #[default]
            #[serde(rename = "gpt-4-32k")]
            Gpt4_32k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_32k0314 {
            #[default]
            #[serde(rename = "gpt-4-32k-0314")]
            Gpt4_32k0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt4_32k0613 {
            #[default]
            #[serde(rename = "gpt-4-32k-0613")]
            Gpt4_32k0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo {
            #[default]
            #[serde(rename = "gpt-3.5-turbo")]
            Gpt3_5Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo16k {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k")]
            Gpt3_5Turbo16k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo0301 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0301")]
            Gpt3_5Turbo0301,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0613")]
            Gpt3_5Turbo0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo1106 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-1106")]
            Gpt3_5Turbo1106,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo0125 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0125")]
            Gpt3_5Turbo0125,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsSharedGpt3_5Turbo16k0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k-0613")]
            Gpt3_5Turbo16k0613,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Gpt4_1(#[allow(dead_code)] &'a ModelIdsSharedGpt4_1),
            Gpt4_1Mini(#[allow(dead_code)] &'a ModelIdsSharedGpt4_1Mini),
            Gpt4_1Nano(#[allow(dead_code)] &'a ModelIdsSharedGpt4_1Nano),
            Gpt4_1_2025_04_14(#[allow(dead_code)] &'a ModelIdsSharedGpt4_1_2025_04_14),
            Gpt4_1Mini2025_04_14(#[allow(dead_code)] &'a ModelIdsSharedGpt4_1Mini2025_04_14),
            Gpt4_1Nano2025_04_14(#[allow(dead_code)] &'a ModelIdsSharedGpt4_1Nano2025_04_14),
            O4Mini(#[allow(dead_code)] &'a ModelIdsSharedO4Mini),
            O4Mini2025_04_16(#[allow(dead_code)] &'a ModelIdsSharedO4Mini2025_04_16),
            O3(#[allow(dead_code)] &'a ModelIdsSharedO3),
            O3_2025_04_16(#[allow(dead_code)] &'a ModelIdsSharedO3_2025_04_16),
            O3Mini(#[allow(dead_code)] &'a ModelIdsSharedO3Mini),
            O3Mini2025_01_31(#[allow(dead_code)] &'a ModelIdsSharedO3Mini2025_01_31),
            O1(#[allow(dead_code)] &'a ModelIdsSharedO1),
            O1_2024_12_17(#[allow(dead_code)] &'a ModelIdsSharedO1_2024_12_17),
            O1Preview(#[allow(dead_code)] &'a ModelIdsSharedO1Preview),
            O1Preview2024_09_12(#[allow(dead_code)] &'a ModelIdsSharedO1Preview2024_09_12),
            O1Mini(#[allow(dead_code)] &'a ModelIdsSharedO1Mini),
            O1Mini2024_09_12(#[allow(dead_code)] &'a ModelIdsSharedO1Mini2024_09_12),
            Gpt4o(#[allow(dead_code)] &'a ModelIdsSharedGpt4o),
            Gpt4o2024_11_20(#[allow(dead_code)] &'a ModelIdsSharedGpt4o2024_11_20),
            Gpt4o2024_08_06(#[allow(dead_code)] &'a ModelIdsSharedGpt4o2024_08_06),
            Gpt4o2024_05_13(#[allow(dead_code)] &'a ModelIdsSharedGpt4o2024_05_13),
            Gpt4oAudioPreview(#[allow(dead_code)] &'a ModelIdsSharedGpt4oAudioPreview),
            Gpt4oAudioPreview2024_10_01(
                #[allow(dead_code)] &'a ModelIdsSharedGpt4oAudioPreview2024_10_01,
            ),
            Gpt4oAudioPreview2024_12_17(
                #[allow(dead_code)] &'a ModelIdsSharedGpt4oAudioPreview2024_12_17,
            ),
            Gpt4oMiniAudioPreview(#[allow(dead_code)] &'a ModelIdsSharedGpt4oMiniAudioPreview),
            Gpt4oMiniAudioPreview2024_12_17(
                #[allow(dead_code)] &'a ModelIdsSharedGpt4oMiniAudioPreview2024_12_17,
            ),
            Gpt4oSearchPreview(#[allow(dead_code)] &'a ModelIdsSharedGpt4oSearchPreview),
            Gpt4oMiniSearchPreview(#[allow(dead_code)] &'a ModelIdsSharedGpt4oMiniSearchPreview),
            Gpt4oSearchPreview2025_03_11(
                #[allow(dead_code)] &'a ModelIdsSharedGpt4oSearchPreview2025_03_11,
            ),
            Gpt4oMiniSearchPreview2025_03_11(
                #[allow(dead_code)] &'a ModelIdsSharedGpt4oMiniSearchPreview2025_03_11,
            ),
            Chatgpt4oLatest(#[allow(dead_code)] &'a ModelIdsSharedChatgpt4oLatest),
            Gpt4oMini(#[allow(dead_code)] &'a ModelIdsSharedGpt4oMini),
            Gpt4oMini2024_07_18(#[allow(dead_code)] &'a ModelIdsSharedGpt4oMini2024_07_18),
            Gpt4Turbo(#[allow(dead_code)] &'a ModelIdsSharedGpt4Turbo),
            Gpt4Turbo2024_04_09(#[allow(dead_code)] &'a ModelIdsSharedGpt4Turbo2024_04_09),
            Gpt4_0125Preview(#[allow(dead_code)] &'a ModelIdsSharedGpt4_0125Preview),
            Gpt4TurboPreview(#[allow(dead_code)] &'a ModelIdsSharedGpt4TurboPreview),
            Gpt4_1106Preview(#[allow(dead_code)] &'a ModelIdsSharedGpt4_1106Preview),
            Gpt4VisionPreview(#[allow(dead_code)] &'a ModelIdsSharedGpt4VisionPreview),
            Gpt4(#[allow(dead_code)] &'a ModelIdsSharedGpt4),
            Gpt4_0314(#[allow(dead_code)] &'a ModelIdsSharedGpt4_0314),
            Gpt4_0613(#[allow(dead_code)] &'a ModelIdsSharedGpt4_0613),
            Gpt4_32k(#[allow(dead_code)] &'a ModelIdsSharedGpt4_32k),
            Gpt4_32k0314(#[allow(dead_code)] &'a ModelIdsSharedGpt4_32k0314),
            Gpt4_32k0613(#[allow(dead_code)] &'a ModelIdsSharedGpt4_32k0613),
            Gpt3_5Turbo(#[allow(dead_code)] &'a ModelIdsSharedGpt3_5Turbo),
            Gpt3_5Turbo16k(#[allow(dead_code)] &'a ModelIdsSharedGpt3_5Turbo16k),
            Gpt3_5Turbo0301(#[allow(dead_code)] &'a ModelIdsSharedGpt3_5Turbo0301),
            Gpt3_5Turbo0613(#[allow(dead_code)] &'a ModelIdsSharedGpt3_5Turbo0613),
            Gpt3_5Turbo1106(#[allow(dead_code)] &'a ModelIdsSharedGpt3_5Turbo1106),
            Gpt3_5Turbo0125(#[allow(dead_code)] &'a ModelIdsSharedGpt3_5Turbo0125),
            Gpt3_5Turbo16k0613(#[allow(dead_code)] &'a ModelIdsSharedGpt3_5Turbo16k0613),
            Other(#[allow(dead_code)] &'a String),
        }
        match self {
            Self::Gpt4_1 => _S::Gpt4_1(&Default::default()).serialize(serializer),
            Self::Gpt4_1Mini => _S::Gpt4_1Mini(&Default::default()).serialize(serializer),
            Self::Gpt4_1Nano => _S::Gpt4_1Nano(&Default::default()).serialize(serializer),
            Self::Gpt4_1_2025_04_14 => {
                _S::Gpt4_1_2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1Mini2025_04_14 => {
                _S::Gpt4_1Mini2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1Nano2025_04_14 => {
                _S::Gpt4_1Nano2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::O4Mini => _S::O4Mini(&Default::default()).serialize(serializer),
            Self::O4Mini2025_04_16 => {
                _S::O4Mini2025_04_16(&Default::default()).serialize(serializer)
            }
            Self::O3 => _S::O3(&Default::default()).serialize(serializer),
            Self::O3_2025_04_16 => _S::O3_2025_04_16(&Default::default()).serialize(serializer),
            Self::O3Mini => _S::O3Mini(&Default::default()).serialize(serializer),
            Self::O3Mini2025_01_31 => {
                _S::O3Mini2025_01_31(&Default::default()).serialize(serializer)
            }
            Self::O1 => _S::O1(&Default::default()).serialize(serializer),
            Self::O1_2024_12_17 => _S::O1_2024_12_17(&Default::default()).serialize(serializer),
            Self::O1Preview => _S::O1Preview(&Default::default()).serialize(serializer),
            Self::O1Preview2024_09_12 => {
                _S::O1Preview2024_09_12(&Default::default()).serialize(serializer)
            }
            Self::O1Mini => _S::O1Mini(&Default::default()).serialize(serializer),
            Self::O1Mini2024_09_12 => {
                _S::O1Mini2024_09_12(&Default::default()).serialize(serializer)
            }
            Self::Gpt4o => _S::Gpt4o(&Default::default()).serialize(serializer),
            Self::Gpt4o2024_11_20 => _S::Gpt4o2024_11_20(&Default::default()).serialize(serializer),
            Self::Gpt4o2024_08_06 => _S::Gpt4o2024_08_06(&Default::default()).serialize(serializer),
            Self::Gpt4o2024_05_13 => _S::Gpt4o2024_05_13(&Default::default()).serialize(serializer),
            Self::Gpt4oAudioPreview => {
                _S::Gpt4oAudioPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oAudioPreview2024_10_01 => {
                _S::Gpt4oAudioPreview2024_10_01(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oAudioPreview2024_12_17 => {
                _S::Gpt4oAudioPreview2024_12_17(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniAudioPreview => {
                _S::Gpt4oMiniAudioPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniAudioPreview2024_12_17 => {
                _S::Gpt4oMiniAudioPreview2024_12_17(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oSearchPreview => {
                _S::Gpt4oSearchPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniSearchPreview => {
                _S::Gpt4oMiniSearchPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oSearchPreview2025_03_11 => {
                _S::Gpt4oSearchPreview2025_03_11(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniSearchPreview2025_03_11 => {
                _S::Gpt4oMiniSearchPreview2025_03_11(&Default::default()).serialize(serializer)
            }
            Self::Chatgpt4oLatest => _S::Chatgpt4oLatest(&Default::default()).serialize(serializer),
            Self::Gpt4oMini => _S::Gpt4oMini(&Default::default()).serialize(serializer),
            Self::Gpt4oMini2024_07_18 => {
                _S::Gpt4oMini2024_07_18(&Default::default()).serialize(serializer)
            }
            Self::Gpt4Turbo => _S::Gpt4Turbo(&Default::default()).serialize(serializer),
            Self::Gpt4Turbo2024_04_09 => {
                _S::Gpt4Turbo2024_04_09(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_0125Preview => {
                _S::Gpt4_0125Preview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4TurboPreview => {
                _S::Gpt4TurboPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1106Preview => {
                _S::Gpt4_1106Preview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4VisionPreview => {
                _S::Gpt4VisionPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4 => _S::Gpt4(&Default::default()).serialize(serializer),
            Self::Gpt4_0314 => _S::Gpt4_0314(&Default::default()).serialize(serializer),
            Self::Gpt4_0613 => _S::Gpt4_0613(&Default::default()).serialize(serializer),
            Self::Gpt4_32k => _S::Gpt4_32k(&Default::default()).serialize(serializer),
            Self::Gpt4_32k0314 => _S::Gpt4_32k0314(&Default::default()).serialize(serializer),
            Self::Gpt4_32k0613 => _S::Gpt4_32k0613(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo => _S::Gpt3_5Turbo(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo16k => _S::Gpt3_5Turbo16k(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo0301 => _S::Gpt3_5Turbo0301(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo0613 => _S::Gpt3_5Turbo0613(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo1106 => _S::Gpt3_5Turbo1106(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo0125 => _S::Gpt3_5Turbo0125(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo16k0613 => {
                _S::Gpt3_5Turbo16k0613(&Default::default()).serialize(serializer)
            }
            Self::Other(_v) => _S::Other(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIdsShared {
    #[doc = "gpt-4.1"]
    Gpt4_1,
    #[doc = "gpt-4.1-mini"]
    Gpt4_1Mini,
    #[doc = "gpt-4.1-nano"]
    Gpt4_1Nano,
    #[doc = "gpt-4.1-2025-04-14"]
    Gpt4_1_2025_04_14,
    #[doc = "gpt-4.1-mini-2025-04-14"]
    Gpt4_1Mini2025_04_14,
    #[doc = "gpt-4.1-nano-2025-04-14"]
    Gpt4_1Nano2025_04_14,
    #[doc = "o4-mini"]
    O4Mini,
    #[doc = "o4-mini-2025-04-16"]
    O4Mini2025_04_16,
    #[doc = "o3"]
    O3,
    #[doc = "o3-2025-04-16"]
    O3_2025_04_16,
    #[doc = "o3-mini"]
    O3Mini,
    #[doc = "o3-mini-2025-01-31"]
    O3Mini2025_01_31,
    #[doc = "o1"]
    O1,
    #[doc = "o1-2024-12-17"]
    O1_2024_12_17,
    #[doc = "o1-preview"]
    O1Preview,
    #[doc = "o1-preview-2024-09-12"]
    O1Preview2024_09_12,
    #[doc = "o1-mini"]
    O1Mini,
    #[doc = "o1-mini-2024-09-12"]
    O1Mini2024_09_12,
    #[doc = "gpt-4o"]
    Gpt4o,
    #[doc = "gpt-4o-2024-11-20"]
    Gpt4o2024_11_20,
    #[doc = "gpt-4o-2024-08-06"]
    Gpt4o2024_08_06,
    #[doc = "gpt-4o-2024-05-13"]
    Gpt4o2024_05_13,
    #[doc = "gpt-4o-audio-preview"]
    Gpt4oAudioPreview,
    #[doc = "gpt-4o-audio-preview-2024-10-01"]
    Gpt4oAudioPreview2024_10_01,
    #[doc = "gpt-4o-audio-preview-2024-12-17"]
    Gpt4oAudioPreview2024_12_17,
    #[doc = "gpt-4o-mini-audio-preview"]
    Gpt4oMiniAudioPreview,
    #[doc = "gpt-4o-mini-audio-preview-2024-12-17"]
    Gpt4oMiniAudioPreview2024_12_17,
    #[doc = "gpt-4o-search-preview"]
    Gpt4oSearchPreview,
    #[doc = "gpt-4o-mini-search-preview"]
    Gpt4oMiniSearchPreview,
    #[doc = "gpt-4o-search-preview-2025-03-11"]
    Gpt4oSearchPreview2025_03_11,
    #[doc = "gpt-4o-mini-search-preview-2025-03-11"]
    Gpt4oMiniSearchPreview2025_03_11,
    #[doc = "chatgpt-4o-latest"]
    Chatgpt4oLatest,
    #[doc = "gpt-4o-mini"]
    Gpt4oMini,
    #[doc = "gpt-4o-mini-2024-07-18"]
    Gpt4oMini2024_07_18,
    #[doc = "gpt-4-turbo"]
    Gpt4Turbo,
    #[doc = "gpt-4-turbo-2024-04-09"]
    Gpt4Turbo2024_04_09,
    #[doc = "gpt-4-0125-preview"]
    Gpt4_0125Preview,
    #[doc = "gpt-4-turbo-preview"]
    Gpt4TurboPreview,
    #[doc = "gpt-4-1106-preview"]
    Gpt4_1106Preview,
    #[doc = "gpt-4-vision-preview"]
    Gpt4VisionPreview,
    #[doc = "gpt-4"]
    Gpt4,
    #[doc = "gpt-4-0314"]
    Gpt4_0314,
    #[doc = "gpt-4-0613"]
    Gpt4_0613,
    #[doc = "gpt-4-32k"]
    Gpt4_32k,
    #[doc = "gpt-4-32k-0314"]
    Gpt4_32k0314,
    #[doc = "gpt-4-32k-0613"]
    Gpt4_32k0613,
    #[doc = "gpt-3.5-turbo"]
    Gpt3_5Turbo,
    #[doc = "gpt-3.5-turbo-16k"]
    Gpt3_5Turbo16k,
    #[doc = "gpt-3.5-turbo-0301"]
    Gpt3_5Turbo0301,
    #[doc = "gpt-3.5-turbo-0613"]
    Gpt3_5Turbo0613,
    #[doc = "gpt-3.5-turbo-1106"]
    Gpt3_5Turbo1106,
    #[doc = "gpt-3.5-turbo-0125"]
    Gpt3_5Turbo0125,
    #[doc = "gpt-3.5-turbo-16k-0613"]
    Gpt3_5Turbo16k0613,
    Other(String),
}
impl<'de> serde::Deserialize<'de> for ModelResponseProperties {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
            #[serde(rename = "service_tier")]
            #[allow(dead_code)]
            service_tier: Option<ServiceTier>,
        }
        let _D {
            metadata,
            temperature,
            top_p,
            user,
            service_tier,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ModelResponseProperties {
            metadata,
            temperature,
            top_p,
            user,
            service_tier,
        })
    }
}
impl serde::Serialize for ModelResponseProperties {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<ServiceTier>,
        }
        let ModelResponseProperties {
            metadata,
            temperature,
            top_p,
            user,
            service_tier,
        } = self;
        _S {
            metadata,
            temperature,
            top_p,
            user,
            service_tier,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModelResponseProperties {
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
    #[builder(default)]
    pub service_tier: Option<ServiceTier>,
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            AssistantSupportedModels(#[allow(dead_code)] AssistantSupportedModels),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::AssistantSupportedModels(_v) => Self::AssistantSupportedModels(_v),
        })
    }
}
impl serde::Serialize for ModifyAssistantRequestModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            AssistantSupportedModels(#[allow(dead_code)] &'a AssistantSupportedModels),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::AssistantSupportedModels(_v) => {
                _S::AssistantSupportedModels(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModifyAssistantRequestModel {
    String(String),
    AssistantSupportedModels(AssistantSupportedModels),
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearch),
            Function(#[allow(dead_code)] AssistantToolsFunction),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for ModifyAssistantRequestTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearch),
            Function(#[allow(dead_code)] &'a AssistantToolsFunction),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModifyAssistantRequestTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearch),
    Function(AssistantToolsFunction),
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let _D { file_ids, .. } = _D::deserialize(deserializer)?;
        Ok(ModifyAssistantRequestToolResourcesCodeInterpreter { file_ids })
    }
}
impl serde::Serialize for ModifyAssistantRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let ModifyAssistantRequestToolResourcesCodeInterpreter { file_ids } = self;
        _S { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequestToolResourcesCodeInterpreter {
    #[doc = "Overrides the list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let _D {
            vector_store_ids, ..
        } = _D::deserialize(deserializer)?;
        Ok(ModifyAssistantRequestToolResourcesFileSearch { vector_store_ids })
    }
}
impl serde::Serialize for ModifyAssistantRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let ModifyAssistantRequestToolResourcesFileSearch { vector_store_ids } = self;
        _S { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequestToolResourcesFileSearch {
    #[doc = "Overrides the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<ModifyAssistantRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<ModifyAssistantRequestToolResourcesFileSearch>,
        }
        let _D {
            code_interpreter,
            file_search,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ModifyAssistantRequestToolResources {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for ModifyAssistantRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<ModifyAssistantRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<ModifyAssistantRequestToolResourcesFileSearch>,
        }
        let ModifyAssistantRequestToolResources {
            code_interpreter,
            file_search,
        } = self;
        _S {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<ModifyAssistantRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<ModifyAssistantRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<ModifyAssistantRequestModel>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ModifyAssistantRequestTool>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<ModifyAssistantRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let _D {
            model,
            reasoning_effort,
            name,
            description,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ModifyAssistantRequest {
            model,
            reasoning_effort,
            name,
            description,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        })
    }
}
impl serde::Serialize for ModifyAssistantRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<ModifyAssistantRequestModel>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ModifyAssistantRequestTool>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<ModifyAssistantRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let ModifyAssistantRequest {
            model,
            reasoning_effort,
            name,
            description,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        } = self;
        _S {
            model,
            reasoning_effort,
            name,
            description,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](/docs/models) for descriptions of them.\n"]
    #[builder(default)]
    pub model: Option<ModifyAssistantRequestModel>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    #[builder(default)]
    pub tools: Option<Vec<ModifyAssistantRequestTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<ModifyAssistantRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for ModifyCertificateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { name, .. } = _D::deserialize(deserializer)?;
        Ok(ModifyCertificateRequest { name })
    }
}
impl serde::Serialize for ModifyCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ModifyCertificateRequest { name } = self;
        _S { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ModifyCertificateRequest {
    #[doc = "The updated name for the certificate"]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ModifyMessageRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D { metadata, .. } = _D::deserialize(deserializer)?;
        Ok(ModifyMessageRequest { metadata })
    }
}
impl serde::Serialize for ModifyMessageRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let ModifyMessageRequest { metadata } = self;
        _S { metadata }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyMessageRequest {
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for ModifyRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D { metadata, .. } = _D::deserialize(deserializer)?;
        Ok(ModifyRunRequest { metadata })
    }
}
impl serde::Serialize for ModifyRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let ModifyRunRequest { metadata } = self;
        _S { metadata }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyRunRequest {
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for ModifyThreadRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let _D { file_ids, .. } = _D::deserialize(deserializer)?;
        Ok(ModifyThreadRequestToolResourcesCodeInterpreter { file_ids })
    }
}
impl serde::Serialize for ModifyThreadRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let ModifyThreadRequestToolResourcesCodeInterpreter { file_ids } = self;
        _S { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequestToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ModifyThreadRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let _D {
            vector_store_ids, ..
        } = _D::deserialize(deserializer)?;
        Ok(ModifyThreadRequestToolResourcesFileSearch { vector_store_ids })
    }
}
impl serde::Serialize for ModifyThreadRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let ModifyThreadRequestToolResourcesFileSearch { vector_store_ids } = self;
        _S { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequestToolResourcesFileSearch {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ModifyThreadRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<ModifyThreadRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<ModifyThreadRequestToolResourcesFileSearch>,
        }
        let _D {
            code_interpreter,
            file_search,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ModifyThreadRequestToolResources {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for ModifyThreadRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<ModifyThreadRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<ModifyThreadRequestToolResourcesFileSearch>,
        }
        let ModifyThreadRequestToolResources {
            code_interpreter,
            file_search,
        } = self;
        _S {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<ModifyThreadRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<ModifyThreadRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for ModifyThreadRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<ModifyThreadRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            tool_resources,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ModifyThreadRequest {
            tool_resources,
            metadata,
        })
    }
}
impl serde::Serialize for ModifyThreadRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<ModifyThreadRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let ModifyThreadRequest {
            tool_resources,
            metadata,
        } = self;
        _S {
            tool_resources,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequest {
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<ModifyThreadRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for Move {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a move action, this property is \nalways set to `move`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MoveType {
            #[default]
            #[serde(rename = "move")]
            Move,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MoveType,
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
        }
        let _D { x, y, .. } = _D::deserialize(deserializer)?;
        Ok(Move { x, y })
    }
}
impl serde::Serialize for Move {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a move action, this property is \nalways set to `move`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MoveType {
            #[default]
            #[serde(rename = "move")]
            Move,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a MoveType,
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
        }
        let Move { x, y } = self;
        _S {
            type_: &Default::default(),
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[doc = "A mouse move action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct Move {
    #[doc = "The x-coordinate to move to.\n"]
    pub x: u64,
    #[doc = "The y-coordinate to move to.\n"]
    pub y: u64,
}
impl<'de> serde::Deserialize<'de> for OpenAiFilePurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeAssistantsOutput {
            #[default]
            #[serde(rename = "assistants_output")]
            AssistantsOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeBatchOutput {
            #[default]
            #[serde(rename = "batch_output")]
            BatchOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeFineTuneResults {
            #[default]
            #[serde(rename = "fine-tune-results")]
            FineTuneResults,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Assistants(#[allow(dead_code)] OpenAiFilePurposeAssistants),
            AssistantsOutput(#[allow(dead_code)] OpenAiFilePurposeAssistantsOutput),
            Batch(#[allow(dead_code)] OpenAiFilePurposeBatch),
            BatchOutput(#[allow(dead_code)] OpenAiFilePurposeBatchOutput),
            FineTune(#[allow(dead_code)] OpenAiFilePurposeFineTune),
            FineTuneResults(#[allow(dead_code)] OpenAiFilePurposeFineTuneResults),
            Vision(#[allow(dead_code)] OpenAiFilePurposeVision),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Assistants(_) => Self::Assistants,
            _D::AssistantsOutput(_) => Self::AssistantsOutput,
            _D::Batch(_) => Self::Batch,
            _D::BatchOutput(_) => Self::BatchOutput,
            _D::FineTune(_) => Self::FineTune,
            _D::FineTuneResults(_) => Self::FineTuneResults,
            _D::Vision(_) => Self::Vision,
        })
    }
}
impl serde::Serialize for OpenAiFilePurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeAssistantsOutput {
            #[default]
            #[serde(rename = "assistants_output")]
            AssistantsOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeBatchOutput {
            #[default]
            #[serde(rename = "batch_output")]
            BatchOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeFineTuneResults {
            #[default]
            #[serde(rename = "fine-tune-results")]
            FineTuneResults,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Assistants(#[allow(dead_code)] &'a OpenAiFilePurposeAssistants),
            AssistantsOutput(#[allow(dead_code)] &'a OpenAiFilePurposeAssistantsOutput),
            Batch(#[allow(dead_code)] &'a OpenAiFilePurposeBatch),
            BatchOutput(#[allow(dead_code)] &'a OpenAiFilePurposeBatchOutput),
            FineTune(#[allow(dead_code)] &'a OpenAiFilePurposeFineTune),
            FineTuneResults(#[allow(dead_code)] &'a OpenAiFilePurposeFineTuneResults),
            Vision(#[allow(dead_code)] &'a OpenAiFilePurposeVision),
        }
        match self {
            Self::Assistants => _S::Assistants(&Default::default()).serialize(serializer),
            Self::AssistantsOutput => {
                _S::AssistantsOutput(&Default::default()).serialize(serializer)
            }
            Self::Batch => _S::Batch(&Default::default()).serialize(serializer),
            Self::BatchOutput => _S::BatchOutput(&Default::default()).serialize(serializer),
            Self::FineTune => _S::FineTune(&Default::default()).serialize(serializer),
            Self::FineTuneResults => _S::FineTuneResults(&Default::default()).serialize(serializer),
            Self::Vision => _S::Vision(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum OpenAiFilePurpose {
    #[doc = "assistants"]
    Assistants,
    #[doc = "assistants_output"]
    AssistantsOutput,
    #[doc = "batch"]
    Batch,
    #[doc = "batch_output"]
    BatchOutput,
    #[doc = "fine-tune"]
    FineTune,
    #[doc = "fine-tune-results"]
    FineTuneResults,
    #[doc = "vision"]
    Vision,
}
impl<'de> serde::Deserialize<'de> for OpenAiFileStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusUploaded {
            #[default]
            #[serde(rename = "uploaded")]
            Uploaded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusProcessed {
            #[default]
            #[serde(rename = "processed")]
            Processed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusError {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Uploaded(#[allow(dead_code)] OpenAiFileStatusUploaded),
            Processed(#[allow(dead_code)] OpenAiFileStatusProcessed),
            Error(#[allow(dead_code)] OpenAiFileStatusError),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Uploaded(_) => Self::Uploaded,
            _D::Processed(_) => Self::Processed,
            _D::Error(_) => Self::Error,
        })
    }
}
impl serde::Serialize for OpenAiFileStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusUploaded {
            #[default]
            #[serde(rename = "uploaded")]
            Uploaded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusProcessed {
            #[default]
            #[serde(rename = "processed")]
            Processed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusError {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Uploaded(#[allow(dead_code)] &'a OpenAiFileStatusUploaded),
            Processed(#[allow(dead_code)] &'a OpenAiFileStatusProcessed),
            Error(#[allow(dead_code)] &'a OpenAiFileStatusError),
        }
        match self {
            Self::Uploaded => _S::Uploaded(&Default::default()).serialize(serializer),
            Self::Processed => _S::Processed(&Default::default()).serialize(serializer),
            Self::Error => _S::Error(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum OpenAiFileStatus {
    #[doc = "uploaded"]
    Uploaded,
    #[doc = "processed"]
    Processed,
    #[doc = "error"]
    Error,
}
impl<'de> serde::Deserialize<'de> for OpenAiFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileObject {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: u64,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: OpenAiFileObject,
            #[serde(rename = "purpose")]
            #[allow(dead_code)]
            purpose: OpenAiFilePurpose,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: OpenAiFileStatus,
            #[serde(rename = "status_details")]
            #[allow(dead_code)]
            status_details: Option<String>,
        }
        let _D {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(OpenAiFile {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
        })
    }
}
impl serde::Serialize for OpenAiFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileObject {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "bytes")]
            bytes: &'a u64,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "object")]
            object: &'a OpenAiFileObject,
            #[serde(rename = "purpose")]
            purpose: &'a OpenAiFilePurpose,
            #[serde(rename = "status")]
            status: &'a OpenAiFileStatus,
            #[serde(rename = "status_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status_details: &'a Option<String>,
        }
        let OpenAiFile {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
        } = self;
        _S {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            object: &Default::default(),
            purpose,
            status,
            status_details,
        }
        .serialize(serializer)
    }
}
#[doc = "The `File` object represents a document that has been uploaded to OpenAI."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OpenAiFile {
    #[doc = "The file identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The size of the file, in bytes."]
    pub bytes: u64,
    #[doc = "The Unix timestamp (in seconds) for when the file was created."]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) for when the file will expire."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The name of the file."]
    pub filename: String,
    #[doc = "The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`."]
    pub purpose: OpenAiFilePurpose,
    #[doc = "Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`."]
    pub status: OpenAiFileStatus,
    #[doc = "Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`."]
    #[builder(default)]
    pub status_details: Option<String>,
}
impl<'de> serde::Deserialize<'de> for OtherChunkingStrategyResponseParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `other`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OtherChunkingStrategyResponseParamType {
            #[default]
            #[serde(rename = "other")]
            Other,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: OtherChunkingStrategyResponseParamType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(OtherChunkingStrategyResponseParam {})
    }
}
impl serde::Serialize for OtherChunkingStrategyResponseParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `other`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OtherChunkingStrategyResponseParamType {
            #[default]
            #[serde(rename = "other")]
            Other,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a OtherChunkingStrategyResponseParamType,
        }
        let OtherChunkingStrategyResponseParam {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct OtherChunkingStrategyResponseParam {}
impl<'de> serde::Deserialize<'de> for OutputAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the output audio. Always `output_audio`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputAudioType {
            #[default]
            #[serde(rename = "output_audio")]
            OutputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: OutputAudioType,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: String,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: String,
        }
        let _D {
            data, transcript, ..
        } = _D::deserialize(deserializer)?;
        Ok(OutputAudio { data, transcript })
    }
}
impl serde::Serialize for OutputAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the output audio. Always `output_audio`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputAudioType {
            #[default]
            #[serde(rename = "output_audio")]
            OutputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a OutputAudioType,
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "transcript")]
            transcript: &'a String,
        }
        let OutputAudio { data, transcript } = self;
        _S {
            type_: &Default::default(),
            data,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "An audio output from the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputAudio {
    #[doc = "Base64-encoded audio data from the model.\n"]
    pub data: String,
    #[doc = "The transcript of the audio data from the model.\n"]
    pub transcript: String,
}
impl<'de> serde::Deserialize<'de> for OutputContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            OutputText(#[allow(dead_code)] OutputTextContent),
            Refusal(#[allow(dead_code)] RefusalContent),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::OutputText(_v) => Self::OutputText(_v),
            _D::Refusal(_v) => Self::Refusal(_v),
        })
    }
}
impl serde::Serialize for OutputContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            OutputText(#[allow(dead_code)] &'a OutputTextContent),
            Refusal(#[allow(dead_code)] &'a RefusalContent),
        }
        match self {
            Self::OutputText(_v) => _S::OutputText(_v).serialize(serializer),
            Self::Refusal(_v) => _S::Refusal(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum OutputContent {
    OutputText(OutputTextContent),
    Refusal(RefusalContent),
}
impl<'de> serde::Deserialize<'de> for OutputItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Message(#[allow(dead_code)] OutputMessage),
            FileSearchCall(#[allow(dead_code)] FileSearchToolCall),
            FunctionCall(#[allow(dead_code)] FunctionToolCall),
            WebSearchCall(#[allow(dead_code)] WebSearchToolCall),
            ComputerCall(#[allow(dead_code)] ComputerToolCall),
            Reasoning(#[allow(dead_code)] ReasoningItem),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Message(_v) => Self::Message(_v),
            _D::FileSearchCall(_v) => Self::FileSearchCall(_v),
            _D::FunctionCall(_v) => Self::FunctionCall(_v),
            _D::WebSearchCall(_v) => Self::WebSearchCall(_v),
            _D::ComputerCall(_v) => Self::ComputerCall(_v),
            _D::Reasoning(_v) => Self::Reasoning(_v),
        })
    }
}
impl serde::Serialize for OutputItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Message(#[allow(dead_code)] &'a OutputMessage),
            FileSearchCall(#[allow(dead_code)] &'a FileSearchToolCall),
            FunctionCall(#[allow(dead_code)] &'a FunctionToolCall),
            WebSearchCall(#[allow(dead_code)] &'a WebSearchToolCall),
            ComputerCall(#[allow(dead_code)] &'a ComputerToolCall),
            Reasoning(#[allow(dead_code)] &'a ReasoningItem),
        }
        match self {
            Self::Message(_v) => _S::Message(_v).serialize(serializer),
            Self::FileSearchCall(_v) => _S::FileSearchCall(_v).serialize(serializer),
            Self::FunctionCall(_v) => _S::FunctionCall(_v).serialize(serializer),
            Self::WebSearchCall(_v) => _S::WebSearchCall(_v).serialize(serializer),
            Self::ComputerCall(_v) => _S::ComputerCall(_v).serialize(serializer),
            Self::Reasoning(_v) => _S::Reasoning(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum OutputItem {
    Message(OutputMessage),
    FileSearchCall(FileSearchToolCall),
    FunctionCall(FunctionToolCall),
    WebSearchCall(WebSearchToolCall),
    ComputerCall(ComputerToolCall),
    Reasoning(ReasoningItem),
}
impl<'de> serde::Deserialize<'de> for OutputMessageStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] OutputMessageStatusInProgress),
            Completed(#[allow(dead_code)] OutputMessageStatusCompleted),
            Incomplete(#[allow(dead_code)] OutputMessageStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for OutputMessageStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a OutputMessageStatusInProgress),
            Completed(#[allow(dead_code)] &'a OutputMessageStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a OutputMessageStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum OutputMessageStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for OutputMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the output message. Always `message`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageType {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[doc = "The role of the output message. Always `assistant`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: OutputMessageType,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: OutputMessageRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Vec<OutputContent>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: OutputMessageStatus,
        }
        let _D {
            id,
            content,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(OutputMessage {
            id,
            content,
            status,
        })
    }
}
impl serde::Serialize for OutputMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the output message. Always `message`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageType {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[doc = "The role of the output message. Always `assistant`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a OutputMessageType,
            #[serde(rename = "role")]
            role: &'a OutputMessageRole,
            #[serde(rename = "content")]
            content: &'a Vec<OutputContent>,
            #[serde(rename = "status")]
            status: &'a OutputMessageStatus,
        }
        let OutputMessage {
            id,
            content,
            status,
        } = self;
        _S {
            id,
            type_: &Default::default(),
            role: &Default::default(),
            content,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "An output message from the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputMessage {
    #[doc = "The unique ID of the output message.\n"]
    pub id: String,
    #[doc = "The content of the output message.\n"]
    pub content: Vec<OutputContent>,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    pub status: OutputMessageStatus,
}
#[doc = "Whether to enable [parallel function calling](/docs/guides/function-calling#configuring-parallel-function-calling) during tool use."]
pub type ParallelToolCalls = bool;
impl<'de> serde::Deserialize<'de> for PredictionContentContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestMessageContentPartText>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for PredictionContentContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestMessageContentPartText>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The content that should be matched when generating a model response.\nIf generated tokens would match this content, the entire model response\ncan be returned much more quickly.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum PredictionContentContent {
    #[doc = "The content used for a Predicted Output. This is often the\ntext of a file you are regenerating with minor changes.\n"]
    String(String),
    #[doc = "An array of content parts with a defined type. Supported options differ based on the [model](/docs/models) being used to generate the response. Can contain text inputs."]
    Array(Vec<ChatCompletionRequestMessageContentPartText>),
}
impl<'de> serde::Deserialize<'de> for PredictionContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the predicted content you want to provide. This type is\ncurrently always `content`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum PredictionContentType {
            #[default]
            #[serde(rename = "content")]
            Content,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: PredictionContentType,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: PredictionContentContent,
        }
        let _D { content, .. } = _D::deserialize(deserializer)?;
        Ok(PredictionContent { content })
    }
}
impl serde::Serialize for PredictionContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the predicted content you want to provide. This type is\ncurrently always `content`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum PredictionContentType {
            #[default]
            #[serde(rename = "content")]
            Content,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a PredictionContentType,
            #[serde(rename = "content")]
            content: &'a PredictionContentContent,
        }
        let PredictionContent { content } = self;
        _S {
            type_: &Default::default(),
            content,
        }
        .serialize(serializer)
    }
}
#[doc = "Static predicted output content, such as the content of a text file that is\nbeing regenerated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct PredictionContent {
    #[doc = "The content that should be matched when generating a model response.\nIf generated tokens would match this content, the entire model response\ncan be returned much more quickly.\n"]
    pub content: PredictionContentContent,
}
impl<'de> serde::Deserialize<'de> for ProjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectStatusActive {
            #[default]
            #[serde(rename = "active")]
            Active,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectStatusArchived {
            #[default]
            #[serde(rename = "archived")]
            Archived,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Active(#[allow(dead_code)] ProjectStatusActive),
            Archived(#[allow(dead_code)] ProjectStatusArchived),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Active(_) => Self::Active,
            _D::Archived(_) => Self::Archived,
        })
    }
}
impl serde::Serialize for ProjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectStatusActive {
            #[default]
            #[serde(rename = "active")]
            Active,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectStatusArchived {
            #[default]
            #[serde(rename = "archived")]
            Archived,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Active(#[allow(dead_code)] &'a ProjectStatusActive),
            Archived(#[allow(dead_code)] &'a ProjectStatusArchived),
        }
        match self {
            Self::Active => _S::Active(&Default::default()).serialize(serializer),
            Self::Archived => _S::Archived(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`active` or `archived`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectStatus {
    #[doc = "active"]
    Active,
    #[doc = "archived"]
    Archived,
}
impl<'de> serde::Deserialize<'de> for Project {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectObject {
            #[default]
            #[serde(rename = "organization.project")]
            OrganizationProject,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectObject,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "archived_at")]
            #[allow(dead_code)]
            archived_at: Option<u64>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: ProjectStatus,
        }
        let _D {
            id,
            name,
            created_at,
            archived_at,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Project {
            id,
            name,
            created_at,
            archived_at,
            status,
        })
    }
}
impl serde::Serialize for Project {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectObject {
            #[default]
            #[serde(rename = "organization.project")]
            OrganizationProject,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a ProjectObject,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "archived_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            archived_at: &'a Option<u64>,
            #[serde(rename = "status")]
            status: &'a ProjectStatus,
        }
        let Project {
            id,
            name,
            created_at,
            archived_at,
            status,
        } = self;
        _S {
            id,
            object: &Default::default(),
            name,
            created_at,
            archived_at,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Project {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the project. This appears in reporting."]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the project was created."]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the project was archived or `null`."]
    #[builder(default)]
    pub archived_at: Option<u64>,
    #[doc = "`active` or `archived`"]
    pub status: ProjectStatus,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyOwnerType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyOwnerTypeUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyOwnerTypeServiceAccount {
            #[default]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] ProjectApiKeyOwnerTypeUser),
            ServiceAccount(#[allow(dead_code)] ProjectApiKeyOwnerTypeServiceAccount),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::ServiceAccount(_) => Self::ServiceAccount,
        })
    }
}
impl serde::Serialize for ProjectApiKeyOwnerType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyOwnerTypeUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyOwnerTypeServiceAccount {
            #[default]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a ProjectApiKeyOwnerTypeUser),
            ServiceAccount(#[allow(dead_code)] &'a ProjectApiKeyOwnerTypeServiceAccount),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::ServiceAccount => _S::ServiceAccount(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`user` or `service_account`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectApiKeyOwnerType {
    #[doc = "user"]
    User,
    #[doc = "service_account"]
    ServiceAccount,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyOwner {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<ProjectApiKeyOwnerType>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<ProjectUser>,
            #[serde(rename = "service_account")]
            #[allow(dead_code)]
            service_account: Option<ProjectServiceAccount>,
        }
        let _D {
            type_,
            user,
            service_account,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectApiKeyOwner {
            type_,
            user,
            service_account,
        })
    }
}
impl serde::Serialize for ProjectApiKeyOwner {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<ProjectApiKeyOwnerType>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<ProjectUser>,
            #[serde(rename = "service_account")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account: &'a Option<ProjectServiceAccount>,
        }
        let ProjectApiKeyOwner {
            type_,
            user,
            service_account,
        } = self;
        _S {
            type_,
            user,
            service_account,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ProjectApiKeyOwner {
    #[doc = "`user` or `service_account`"]
    #[builder(default)]
    pub type_: Option<ProjectApiKeyOwnerType>,
    #[builder(default)]
    pub user: Option<ProjectUser>,
    #[builder(default)]
    pub service_account: Option<ProjectServiceAccount>,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project.api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyObject {
            #[default]
            #[serde(rename = "organization.project.api_key")]
            OrganizationProjectApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectApiKeyObject,
            #[serde(rename = "redacted_value")]
            #[allow(dead_code)]
            redacted_value: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "last_used_at")]
            #[allow(dead_code)]
            last_used_at: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "owner")]
            #[allow(dead_code)]
            owner: ProjectApiKeyOwner,
        }
        let _D {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectApiKey {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        })
    }
}
impl serde::Serialize for ProjectApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project.api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyObject {
            #[default]
            #[serde(rename = "organization.project.api_key")]
            OrganizationProjectApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectApiKeyObject,
            #[serde(rename = "redacted_value")]
            redacted_value: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "last_used_at")]
            last_used_at: &'a u64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "owner")]
            owner: &'a ProjectApiKeyOwner,
        }
        let ProjectApiKey {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        } = self;
        _S {
            object: &Default::default(),
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual API key in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKey {
    #[doc = "The redacted value of the API key"]
    pub redacted_value: String,
    #[doc = "The name of the API key"]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the API key was created"]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the API key was last used."]
    pub last_used_at: u64,
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[builder(default)]
    pub owner: ProjectApiKeyOwner,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.api_key.deleted")]
            OrganizationProjectApiKeyDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectApiKeyDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(ProjectApiKeyDeleteResponse { id, deleted })
    }
}
impl serde::Serialize for ProjectApiKeyDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.api_key.deleted")]
            OrganizationProjectApiKeyDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectApiKeyDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let ProjectApiKeyDeleteResponse { id, deleted } = self;
        _S {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKeyDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectApiKeyListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ProjectApiKey>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectApiKeyListResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectApiKeyListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectApiKeyListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<ProjectApiKey>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ProjectApiKeyListResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKeyListResponse {
    pub data: Vec<ProjectApiKey>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { name, .. } = _D::deserialize(deserializer)?;
        Ok(ProjectCreateRequest { name })
    }
}
impl serde::Serialize for ProjectCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ProjectCreateRequest { name } = self;
        _S { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectCreateRequest {
    #[doc = "The friendly name of the project, this name appears in reports."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ProjectListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Project>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectListResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<Project>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ProjectListResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectListResponse {
    pub data: Vec<Project>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectRateLimit {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `project.rate_limit`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectRateLimitObject {
            #[default]
            #[serde(rename = "project.rate_limit")]
            ProjectRateLimit,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectRateLimitObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "max_requests_per_1_minute")]
            #[allow(dead_code)]
            max_requests_per_1_minute: u64,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[allow(dead_code)]
            max_tokens_per_1_minute: u64,
            #[serde(rename = "max_images_per_1_minute")]
            #[allow(dead_code)]
            max_images_per_1_minute: Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[allow(dead_code)]
            max_audio_megabytes_per_1_minute: Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[allow(dead_code)]
            max_requests_per_1_day: Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[allow(dead_code)]
            batch_1_day_max_input_tokens: Option<u64>,
        }
        let _D {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectRateLimit {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        })
    }
}
impl serde::Serialize for ProjectRateLimit {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `project.rate_limit`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectRateLimitObject {
            #[default]
            #[serde(rename = "project.rate_limit")]
            ProjectRateLimit,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectRateLimitObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "max_requests_per_1_minute")]
            max_requests_per_1_minute: &'a u64,
            #[serde(rename = "max_tokens_per_1_minute")]
            max_tokens_per_1_minute: &'a u64,
            #[serde(rename = "max_images_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_images_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_audio_megabytes_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_day: &'a Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_1_day_max_input_tokens: &'a Option<u64>,
        }
        let ProjectRateLimit {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        } = self;
        _S {
            object: &Default::default(),
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a project rate limit config."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimit {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The model this rate limit applies to."]
    pub model: String,
    #[doc = "The maximum requests per minute."]
    pub max_requests_per_1_minute: u64,
    #[doc = "The maximum tokens per minute."]
    pub max_tokens_per_1_minute: u64,
    #[doc = "The maximum images per minute. Only present for relevant models."]
    #[builder(default)]
    pub max_images_per_1_minute: Option<u64>,
    #[doc = "The maximum audio megabytes per minute. Only present for relevant models."]
    #[builder(default)]
    pub max_audio_megabytes_per_1_minute: Option<u64>,
    #[doc = "The maximum requests per day. Only present for relevant models."]
    #[builder(default)]
    pub max_requests_per_1_day: Option<u64>,
    #[doc = "The maximum batch input tokens per day. Only present for relevant models."]
    #[builder(default)]
    pub batch_1_day_max_input_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for ProjectRateLimitListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectRateLimitListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectRateLimitListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ProjectRateLimit>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectRateLimitListResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectRateLimitListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectRateLimitListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectRateLimitListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<ProjectRateLimit>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ProjectRateLimitListResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimitListResponse {
    pub data: Vec<ProjectRateLimit>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectRateLimitUpdateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "max_requests_per_1_minute")]
            #[allow(dead_code)]
            max_requests_per_1_minute: Option<u64>,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[allow(dead_code)]
            max_tokens_per_1_minute: Option<u64>,
            #[serde(rename = "max_images_per_1_minute")]
            #[allow(dead_code)]
            max_images_per_1_minute: Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[allow(dead_code)]
            max_audio_megabytes_per_1_minute: Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[allow(dead_code)]
            max_requests_per_1_day: Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[allow(dead_code)]
            batch_1_day_max_input_tokens: Option<u64>,
        }
        let _D {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectRateLimitUpdateRequest {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        })
    }
}
impl serde::Serialize for ProjectRateLimitUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "max_requests_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tokens_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_images_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_images_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_audio_megabytes_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_day: &'a Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_1_day_max_input_tokens: &'a Option<u64>,
        }
        let ProjectRateLimitUpdateRequest {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        } = self;
        _S {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimitUpdateRequest {
    #[doc = "The maximum requests per minute."]
    #[builder(default)]
    pub max_requests_per_1_minute: Option<u64>,
    #[doc = "The maximum tokens per minute."]
    #[builder(default)]
    pub max_tokens_per_1_minute: Option<u64>,
    #[doc = "The maximum images per minute. Only relevant for certain models."]
    #[builder(default)]
    pub max_images_per_1_minute: Option<u64>,
    #[doc = "The maximum audio megabytes per minute. Only relevant for certain models."]
    #[builder(default)]
    pub max_audio_megabytes_per_1_minute: Option<u64>,
    #[doc = "The maximum requests per day. Only relevant for certain models."]
    #[builder(default)]
    pub max_requests_per_1_day: Option<u64>,
    #[doc = "The maximum batch input tokens per day. Only relevant for certain models."]
    #[builder(default)]
    pub batch_1_day_max_input_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Owner(#[allow(dead_code)] ProjectServiceAccountRoleOwner),
            Member(#[allow(dead_code)] ProjectServiceAccountRoleMember),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Owner(_) => Self::Owner,
            _D::Member(_) => Self::Member,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Owner(#[allow(dead_code)] &'a ProjectServiceAccountRoleOwner),
            Member(#[allow(dead_code)] &'a ProjectServiceAccountRoleMember),
        }
        match self {
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
            Self::Member => _S::Member(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `member`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectServiceAccountRole {
    #[doc = "owner"]
    Owner,
    #[doc = "member"]
    Member,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project.service_account`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountObject {
            #[default]
            #[serde(rename = "organization.project.service_account")]
            OrganizationProjectServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectServiceAccountRole,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
        }
        let _D {
            id,
            name,
            role,
            created_at,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectServiceAccount {
            id,
            name,
            role,
            created_at,
        })
    }
}
impl serde::Serialize for ProjectServiceAccount {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project.service_account`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountObject {
            #[default]
            #[serde(rename = "organization.project.service_account")]
            OrganizationProjectServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "role")]
            role: &'a ProjectServiceAccountRole,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
        }
        let ProjectServiceAccount {
            id,
            name,
            role,
            created_at,
        } = self;
        _S {
            object: &Default::default(),
            id,
            name,
            role,
            created_at,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual service account in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccount {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the service account"]
    pub name: String,
    #[doc = "`owner` or `member`"]
    pub role: ProjectServiceAccountRole,
    #[doc = "The Unix timestamp (in seconds) of when the service account was created"]
    pub created_at: u64,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project.service_account.api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountApiKeyObject {
            #[default]
            #[serde(rename = "organization.project.service_account.api_key")]
            OrganizationProjectServiceAccountApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountApiKeyObject,
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D {
            value,
            name,
            created_at,
            id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectServiceAccountApiKey {
            value,
            name,
            created_at,
            id,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project.service_account.api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountApiKeyObject {
            #[default]
            #[serde(rename = "organization.project.service_account.api_key")]
            OrganizationProjectServiceAccountApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountApiKeyObject,
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let ProjectServiceAccountApiKey {
            value,
            name,
            created_at,
            id,
        } = self;
        _S {
            object: &Default::default(),
            value,
            name,
            created_at,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountApiKey {
    pub value: String,
    pub name: String,
    pub created_at: u64,
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { name, .. } = _D::deserialize(deserializer)?;
        Ok(ProjectServiceAccountCreateRequest { name })
    }
}
impl serde::Serialize for ProjectServiceAccountCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ProjectServiceAccountCreateRequest { name } = self;
        _S { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountCreateRequest {
    #[doc = "The name of the service account being created."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountCreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountCreateResponseObject {
            #[default]
            #[serde(rename = "organization.project.service_account")]
            OrganizationProjectServiceAccount,
        }
        #[doc = "Service accounts can only have one role of type `member`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountCreateResponseRole {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountCreateResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectServiceAccountCreateResponseRole,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "api_key")]
            #[allow(dead_code)]
            api_key: ProjectServiceAccountApiKey,
        }
        let _D {
            id,
            name,
            created_at,
            api_key,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectServiceAccountCreateResponse {
            id,
            name,
            created_at,
            api_key,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountCreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountCreateResponseObject {
            #[default]
            #[serde(rename = "organization.project.service_account")]
            OrganizationProjectServiceAccount,
        }
        #[doc = "Service accounts can only have one role of type `member`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountCreateResponseRole {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountCreateResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "role")]
            role: &'a ProjectServiceAccountCreateResponseRole,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "api_key")]
            api_key: &'a ProjectServiceAccountApiKey,
        }
        let ProjectServiceAccountCreateResponse {
            id,
            name,
            created_at,
            api_key,
        } = self;
        _S {
            object: &Default::default(),
            id,
            name,
            role: &Default::default(),
            created_at,
            api_key,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountCreateResponse {
    pub id: String,
    pub name: String,
    pub created_at: u64,
    pub api_key: ProjectServiceAccountApiKey,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.service_account.deleted")]
            OrganizationProjectServiceAccountDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(ProjectServiceAccountDeleteResponse { id, deleted })
    }
}
impl serde::Serialize for ProjectServiceAccountDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.service_account.deleted")]
            OrganizationProjectServiceAccountDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let ProjectServiceAccountDeleteResponse { id, deleted } = self;
        _S {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ProjectServiceAccount>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectServiceAccountListResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<ProjectServiceAccount>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ProjectServiceAccountListResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountListResponse {
    pub data: Vec<ProjectServiceAccount>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectUpdateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { name, .. } = _D::deserialize(deserializer)?;
        Ok(ProjectUpdateRequest { name })
    }
}
impl serde::Serialize for ProjectUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ProjectUpdateRequest { name } = self;
        _S { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUpdateRequest {
    #[doc = "The updated name of the project, this name appears in reports."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ProjectUserRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Owner(#[allow(dead_code)] ProjectUserRoleOwner),
            Member(#[allow(dead_code)] ProjectUserRoleMember),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Owner(_) => Self::Owner,
            _D::Member(_) => Self::Member,
        })
    }
}
impl serde::Serialize for ProjectUserRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Owner(#[allow(dead_code)] &'a ProjectUserRoleOwner),
            Member(#[allow(dead_code)] &'a ProjectUserRoleMember),
        }
        match self {
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
            Self::Member => _S::Member(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `member`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectUserRole {
    #[doc = "owner"]
    Owner,
    #[doc = "member"]
    Member,
}
impl<'de> serde::Deserialize<'de> for ProjectUser {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project.user`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserObject {
            #[default]
            #[serde(rename = "organization.project.user")]
            OrganizationProjectUser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectUserObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectUserRole,
            #[serde(rename = "added_at")]
            #[allow(dead_code)]
            added_at: u64,
        }
        let _D {
            id,
            name,
            email,
            role,
            added_at,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectUser {
            id,
            name,
            email,
            role,
            added_at,
        })
    }
}
impl serde::Serialize for ProjectUser {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project.user`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserObject {
            #[default]
            #[serde(rename = "organization.project.user")]
            OrganizationProjectUser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectUserObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a ProjectUserRole,
            #[serde(rename = "added_at")]
            added_at: &'a u64,
        }
        let ProjectUser {
            id,
            name,
            email,
            role,
            added_at,
        } = self;
        _S {
            object: &Default::default(),
            id,
            name,
            email,
            role,
            added_at,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual user in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUser {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the user"]
    pub name: String,
    #[doc = "The email address of the user"]
    pub email: String,
    #[doc = "`owner` or `member`"]
    pub role: ProjectUserRole,
    #[doc = "The Unix timestamp (in seconds) of when the project was added."]
    pub added_at: u64,
}
impl<'de> serde::Deserialize<'de> for ProjectUserCreateRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserCreateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserCreateRequestRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Owner(#[allow(dead_code)] ProjectUserCreateRequestRoleOwner),
            Member(#[allow(dead_code)] ProjectUserCreateRequestRoleMember),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Owner(_) => Self::Owner,
            _D::Member(_) => Self::Member,
        })
    }
}
impl serde::Serialize for ProjectUserCreateRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserCreateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserCreateRequestRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Owner(#[allow(dead_code)] &'a ProjectUserCreateRequestRoleOwner),
            Member(#[allow(dead_code)] &'a ProjectUserCreateRequestRoleMember),
        }
        match self {
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
            Self::Member => _S::Member(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `member`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectUserCreateRequestRole {
    #[doc = "owner"]
    Owner,
    #[doc = "member"]
    Member,
}
impl<'de> serde::Deserialize<'de> for ProjectUserCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectUserCreateRequestRole,
        }
        let _D { user_id, role, .. } = _D::deserialize(deserializer)?;
        Ok(ProjectUserCreateRequest { user_id, role })
    }
}
impl serde::Serialize for ProjectUserCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "user_id")]
            user_id: &'a String,
            #[serde(rename = "role")]
            role: &'a ProjectUserCreateRequestRole,
        }
        let ProjectUserCreateRequest { user_id, role } = self;
        _S { user_id, role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUserCreateRequest {
    #[doc = "The ID of the user."]
    pub user_id: String,
    #[doc = "`owner` or `member`"]
    pub role: ProjectUserCreateRequestRole,
}
impl<'de> serde::Deserialize<'de> for ProjectUserDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.user.deleted")]
            OrganizationProjectUserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectUserDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(ProjectUserDeleteResponse { id, deleted })
    }
}
impl serde::Serialize for ProjectUserDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.user.deleted")]
            OrganizationProjectUserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectUserDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let ProjectUserDeleteResponse { id, deleted } = self;
        _S {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUserDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectUserListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ProjectUser>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ProjectUserListResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectUserListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<ProjectUser>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let ProjectUserListResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUserListResponse {
    pub object: String,
    pub data: Vec<ProjectUser>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectUserUpdateRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserUpdateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserUpdateRequestRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Owner(#[allow(dead_code)] ProjectUserUpdateRequestRoleOwner),
            Member(#[allow(dead_code)] ProjectUserUpdateRequestRoleMember),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Owner(_) => Self::Owner,
            _D::Member(_) => Self::Member,
        })
    }
}
impl serde::Serialize for ProjectUserUpdateRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserUpdateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserUpdateRequestRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Owner(#[allow(dead_code)] &'a ProjectUserUpdateRequestRoleOwner),
            Member(#[allow(dead_code)] &'a ProjectUserUpdateRequestRoleMember),
        }
        match self {
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
            Self::Member => _S::Member(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `member`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectUserUpdateRequestRole {
    #[doc = "owner"]
    Owner,
    #[doc = "member"]
    Member,
}
impl<'de> serde::Deserialize<'de> for ProjectUserUpdateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectUserUpdateRequestRole,
        }
        let _D { role, .. } = _D::deserialize(deserializer)?;
        Ok(ProjectUserUpdateRequest { role })
    }
}
impl serde::Serialize for ProjectUserUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a ProjectUserUpdateRequestRole,
        }
        let ProjectUserUpdateRequest { role } = self;
        _S { role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ProjectUserUpdateRequest {
    #[doc = "`owner` or `member`"]
    pub role: ProjectUserUpdateRequestRole,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ConversationItemCreate(#[allow(dead_code)] RealtimeClientEventConversationItemCreate),
            ConversationItemDelete(#[allow(dead_code)] RealtimeClientEventConversationItemDelete),
            ConversationItemRetrieve(
                #[allow(dead_code)] RealtimeClientEventConversationItemRetrieve,
            ),
            ConversationItemTruncate(
                #[allow(dead_code)] RealtimeClientEventConversationItemTruncate,
            ),
            InputAudioBufferAppend(#[allow(dead_code)] RealtimeClientEventInputAudioBufferAppend),
            InputAudioBufferClear(#[allow(dead_code)] RealtimeClientEventInputAudioBufferClear),
            OutputAudioBufferClear(#[allow(dead_code)] RealtimeClientEventOutputAudioBufferClear),
            InputAudioBufferCommit(#[allow(dead_code)] RealtimeClientEventInputAudioBufferCommit),
            ResponseCancel(#[allow(dead_code)] RealtimeClientEventResponseCancel),
            ResponseCreate(#[allow(dead_code)] RealtimeClientEventResponseCreate),
            SessionUpdate(#[allow(dead_code)] RealtimeClientEventSessionUpdate),
            TranscriptionSessionUpdate(
                #[allow(dead_code)] RealtimeClientEventTranscriptionSessionUpdate,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ConversationItemCreate(_v) => Self::ConversationItemCreate(_v),
            _D::ConversationItemDelete(_v) => Self::ConversationItemDelete(_v),
            _D::ConversationItemRetrieve(_v) => Self::ConversationItemRetrieve(_v),
            _D::ConversationItemTruncate(_v) => Self::ConversationItemTruncate(_v),
            _D::InputAudioBufferAppend(_v) => Self::InputAudioBufferAppend(_v),
            _D::InputAudioBufferClear(_v) => Self::InputAudioBufferClear(_v),
            _D::OutputAudioBufferClear(_v) => Self::OutputAudioBufferClear(_v),
            _D::InputAudioBufferCommit(_v) => Self::InputAudioBufferCommit(_v),
            _D::ResponseCancel(_v) => Self::ResponseCancel(_v),
            _D::ResponseCreate(_v) => Self::ResponseCreate(_v),
            _D::SessionUpdate(_v) => Self::SessionUpdate(_v),
            _D::TranscriptionSessionUpdate(_v) => Self::TranscriptionSessionUpdate(_v),
        })
    }
}
impl serde::Serialize for RealtimeClientEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ConversationItemCreate(
                #[allow(dead_code)] &'a RealtimeClientEventConversationItemCreate,
            ),
            ConversationItemDelete(
                #[allow(dead_code)] &'a RealtimeClientEventConversationItemDelete,
            ),
            ConversationItemRetrieve(
                #[allow(dead_code)] &'a RealtimeClientEventConversationItemRetrieve,
            ),
            ConversationItemTruncate(
                #[allow(dead_code)] &'a RealtimeClientEventConversationItemTruncate,
            ),
            InputAudioBufferAppend(
                #[allow(dead_code)] &'a RealtimeClientEventInputAudioBufferAppend,
            ),
            InputAudioBufferClear(#[allow(dead_code)] &'a RealtimeClientEventInputAudioBufferClear),
            OutputAudioBufferClear(
                #[allow(dead_code)] &'a RealtimeClientEventOutputAudioBufferClear,
            ),
            InputAudioBufferCommit(
                #[allow(dead_code)] &'a RealtimeClientEventInputAudioBufferCommit,
            ),
            ResponseCancel(#[allow(dead_code)] &'a RealtimeClientEventResponseCancel),
            ResponseCreate(#[allow(dead_code)] &'a RealtimeClientEventResponseCreate),
            SessionUpdate(#[allow(dead_code)] &'a RealtimeClientEventSessionUpdate),
            TranscriptionSessionUpdate(
                #[allow(dead_code)] &'a RealtimeClientEventTranscriptionSessionUpdate,
            ),
        }
        match self {
            Self::ConversationItemCreate(_v) => {
                _S::ConversationItemCreate(_v).serialize(serializer)
            }
            Self::ConversationItemDelete(_v) => {
                _S::ConversationItemDelete(_v).serialize(serializer)
            }
            Self::ConversationItemRetrieve(_v) => {
                _S::ConversationItemRetrieve(_v).serialize(serializer)
            }
            Self::ConversationItemTruncate(_v) => {
                _S::ConversationItemTruncate(_v).serialize(serializer)
            }
            Self::InputAudioBufferAppend(_v) => {
                _S::InputAudioBufferAppend(_v).serialize(serializer)
            }
            Self::InputAudioBufferClear(_v) => _S::InputAudioBufferClear(_v).serialize(serializer),
            Self::OutputAudioBufferClear(_v) => {
                _S::OutputAudioBufferClear(_v).serialize(serializer)
            }
            Self::InputAudioBufferCommit(_v) => {
                _S::InputAudioBufferCommit(_v).serialize(serializer)
            }
            Self::ResponseCancel(_v) => _S::ResponseCancel(_v).serialize(serializer),
            Self::ResponseCreate(_v) => _S::ResponseCreate(_v).serialize(serializer),
            Self::SessionUpdate(_v) => _S::SessionUpdate(_v).serialize(serializer),
            Self::TranscriptionSessionUpdate(_v) => {
                _S::TranscriptionSessionUpdate(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "A realtime client event.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeClientEvent {
    ConversationItemCreate(RealtimeClientEventConversationItemCreate),
    ConversationItemDelete(RealtimeClientEventConversationItemDelete),
    ConversationItemRetrieve(RealtimeClientEventConversationItemRetrieve),
    ConversationItemTruncate(RealtimeClientEventConversationItemTruncate),
    InputAudioBufferAppend(RealtimeClientEventInputAudioBufferAppend),
    InputAudioBufferClear(RealtimeClientEventInputAudioBufferClear),
    OutputAudioBufferClear(RealtimeClientEventOutputAudioBufferClear),
    InputAudioBufferCommit(RealtimeClientEventInputAudioBufferCommit),
    ResponseCancel(RealtimeClientEventResponseCancel),
    ResponseCreate(RealtimeClientEventResponseCreate),
    SessionUpdate(RealtimeClientEventSessionUpdate),
    TranscriptionSessionUpdate(RealtimeClientEventTranscriptionSessionUpdate),
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemCreate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.create`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemCreateType {
            #[default]
            #[serde(rename = "conversation.item.create")]
            ConversationItemCreate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventConversationItemCreateType,
            #[serde(rename = "previous_item_id")]
            #[allow(dead_code)]
            previous_item_id: Option<String>,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let _D {
            event_id,
            previous_item_id,
            item,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventConversationItemCreate {
            event_id,
            previous_item_id,
            item,
        })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemCreate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.create`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemCreateType {
            #[default]
            #[serde(rename = "conversation.item.create")]
            ConversationItemCreate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventConversationItemCreateType,
            #[serde(rename = "previous_item_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            previous_item_id: &'a Option<String>,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let RealtimeClientEventConversationItemCreate {
            event_id,
            previous_item_id,
            item,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            previous_item_id,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Add a new Item to the Conversation's context, including messages, function \ncalls, and function call responses. This event can be used both to populate a \n\"history\" of the conversation and to add new items mid-stream, but has the \ncurrent limitation that it cannot populate assistant audio messages.\n\nIf successful, the server will respond with a `conversation.item.created` \nevent, otherwise an `error` event will be sent.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemCreate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the preceding item after which the new item will be inserted. \nIf not set, the new item will be appended to the end of the conversation.\nIf set to `root`, the new item will be added to the beginning of the conversation.\nIf set to an existing ID, it allows an item to be inserted mid-conversation. If the\nID cannot be found, an error will be returned and the item will not be added.\n"]
    #[builder(default)]
    pub previous_item_id: Option<String>,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemDelete {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.delete`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemDeleteType {
            #[default]
            #[serde(rename = "conversation.item.delete")]
            ConversationItemDelete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventConversationItemDeleteType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            event_id, item_id, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventConversationItemDelete { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemDelete {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.delete`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemDeleteType {
            #[default]
            #[serde(rename = "conversation.item.delete")]
            ConversationItemDelete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventConversationItemDeleteType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let RealtimeClientEventConversationItemDelete { event_id, item_id } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event when you want to remove any item from the conversation \nhistory. The server will respond with a `conversation.item.deleted` event, \nunless the item does not exist in the conversation history, in which case the \nserver will respond with an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemDelete {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the item to delete."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemRetrieve {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.retrieve`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemRetrieveType {
            #[default]
            #[serde(rename = "conversation.item.retrieve")]
            ConversationItemRetrieve,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventConversationItemRetrieveType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            event_id, item_id, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventConversationItemRetrieve { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemRetrieve {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.retrieve`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemRetrieveType {
            #[default]
            #[serde(rename = "conversation.item.retrieve")]
            ConversationItemRetrieve,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventConversationItemRetrieveType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let RealtimeClientEventConversationItemRetrieve { event_id, item_id } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event when you want to retrieve the server's representation of a specific item in the conversation history. This is useful, for example, to inspect user audio after noise cancellation and VAD.\nThe server will respond with a `conversation.item.retrieved` event, \nunless the item does not exist in the conversation history, in which case the \nserver will respond with an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemRetrieve {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the item to retrieve."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemTruncate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.truncate`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemTruncateType {
            #[default]
            #[serde(rename = "conversation.item.truncate")]
            ConversationItemTruncate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventConversationItemTruncateType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "audio_end_ms")]
            #[allow(dead_code)]
            audio_end_ms: u64,
        }
        let _D {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventConversationItemTruncate {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemTruncate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.truncate`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemTruncateType {
            #[default]
            #[serde(rename = "conversation.item.truncate")]
            ConversationItemTruncate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventConversationItemTruncateType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a u64,
        }
        let RealtimeClientEventConversationItemTruncate {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            audio_end_ms,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to truncate a previous assistant messages audio. The server \nwill produce audio faster than realtime, so this event is useful when the user \ninterrupts to truncate audio that has already been sent to the client but not \nyet played. This will synchronize the server's understanding of the audio with \nthe client's playback.\n\nTruncating audio will delete the server-side text transcript to ensure there \nis not text in the context that hasn't been heard by the user.\n\nIf successful, the server will respond with a `conversation.item.truncated` \nevent. \n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemTruncate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the assistant message item to truncate. Only assistant message \nitems can be truncated.\n"]
    pub item_id: String,
    #[doc = "The index of the content part to truncate. Set this to 0."]
    pub content_index: u64,
    #[doc = "Inclusive duration up to which audio is truncated, in milliseconds. If \nthe audio_end_ms is greater than the actual audio duration, the server \nwill respond with an error.\n"]
    pub audio_end_ms: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferAppend {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.append`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferAppendType {
            #[default]
            #[serde(rename = "input_audio_buffer.append")]
            InputAudioBufferAppend,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventInputAudioBufferAppendType,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: String,
        }
        let _D {
            event_id, audio, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventInputAudioBufferAppend { event_id, audio })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferAppend {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.append`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferAppendType {
            #[default]
            #[serde(rename = "input_audio_buffer.append")]
            InputAudioBufferAppend,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventInputAudioBufferAppendType,
            #[serde(rename = "audio")]
            audio: &'a String,
        }
        let RealtimeClientEventInputAudioBufferAppend { event_id, audio } = self;
        _S {
            event_id,
            type_: &Default::default(),
            audio,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to append audio bytes to the input audio buffer. The audio \nbuffer is temporary storage you can write to and later commit. In Server VAD \nmode, the audio buffer is used to detect speech and the server will decide \nwhen to commit. When Server VAD is disabled, you must commit the audio buffer\nmanually.\n\nThe client may choose how much audio to place in each event up to a maximum \nof 15 MiB, for example streaming smaller chunks from the client may allow the \nVAD to be more responsive. Unlike made other client events, the server will \nnot send a confirmation response to this event.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferAppend {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "Base64-encoded audio bytes. This must be in the format specified by the \n`input_audio_format` field in the session configuration.\n"]
    pub audio: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferClear {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.clear`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferClearType {
            #[default]
            #[serde(rename = "input_audio_buffer.clear")]
            InputAudioBufferClear,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventInputAudioBufferClearType,
        }
        let _D { event_id, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventInputAudioBufferClear { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferClear {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.clear`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferClearType {
            #[default]
            #[serde(rename = "input_audio_buffer.clear")]
            InputAudioBufferClear,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventInputAudioBufferClearType,
        }
        let RealtimeClientEventInputAudioBufferClear { event_id } = self;
        _S {
            event_id,
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to clear the audio bytes in the buffer. The server will \nrespond with an `input_audio_buffer.cleared` event.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferClear {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferCommit {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.commit`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferCommitType {
            #[default]
            #[serde(rename = "input_audio_buffer.commit")]
            InputAudioBufferCommit,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventInputAudioBufferCommitType,
        }
        let _D { event_id, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventInputAudioBufferCommit { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferCommit {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.commit`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferCommitType {
            #[default]
            #[serde(rename = "input_audio_buffer.commit")]
            InputAudioBufferCommit,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventInputAudioBufferCommitType,
        }
        let RealtimeClientEventInputAudioBufferCommit { event_id } = self;
        _S {
            event_id,
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to commit the user input audio buffer, which will create a \nnew user message item in the conversation. This event will produce an error \nif the input audio buffer is empty. When in Server VAD mode, the client does \nnot need to send this event, the server will commit the audio buffer \nautomatically.\n\nCommitting the input audio buffer will trigger input audio transcription \n(if enabled in session configuration), but it will not create a response \nfrom the model. The server will respond with an `input_audio_buffer.committed` \nevent.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferCommit {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventOutputAudioBufferClear {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `output_audio_buffer.clear`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventOutputAudioBufferClearType {
            #[default]
            #[serde(rename = "output_audio_buffer.clear")]
            OutputAudioBufferClear,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventOutputAudioBufferClearType,
        }
        let _D { event_id, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventOutputAudioBufferClear { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventOutputAudioBufferClear {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `output_audio_buffer.clear`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventOutputAudioBufferClearType {
            #[default]
            #[serde(rename = "output_audio_buffer.clear")]
            OutputAudioBufferClear,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventOutputAudioBufferClearType,
        }
        let RealtimeClientEventOutputAudioBufferClear { event_id } = self;
        _S {
            event_id,
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "**WebRTC Only:** Emit to cut off the current audio response. This will trigger the server to\nstop generating audio and emit a `output_audio_buffer.cleared` event. This \nevent should be preceded by a `response.cancel` client event to stop the \ngeneration of the current response.\n[Learn more](/docs/guides/realtime-model-capabilities#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventOutputAudioBufferClear {
    #[doc = "The unique ID of the client event used for error handling."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventResponseCancel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.cancel`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventResponseCancelType {
            #[default]
            #[serde(rename = "response.cancel")]
            ResponseCancel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventResponseCancelType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: Option<String>,
        }
        let _D {
            event_id,
            response_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventResponseCancel {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeClientEventResponseCancel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.cancel`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventResponseCancelType {
            #[default]
            #[serde(rename = "response.cancel")]
            ResponseCancel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventResponseCancelType,
            #[serde(rename = "response_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_id: &'a Option<String>,
        }
        let RealtimeClientEventResponseCancel {
            event_id,
            response_id,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to cancel an in-progress response. The server will respond \nwith a `response.cancelled` event or an error if there is no response to \ncancel.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventResponseCancel {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "A specific response ID to cancel - if not provided, will cancel an \nin-progress response in the default conversation.\n"]
    #[builder(default)]
    pub response_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventResponseCreate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.create`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventResponseCreateType {
            #[default]
            #[serde(rename = "response.create")]
            ResponseCreate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventResponseCreateType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Option<RealtimeResponseCreateParams>,
        }
        let _D {
            event_id, response, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventResponseCreate { event_id, response })
    }
}
impl serde::Serialize for RealtimeClientEventResponseCreate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.create`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventResponseCreateType {
            #[default]
            #[serde(rename = "response.create")]
            ResponseCreate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventResponseCreateType,
            #[serde(rename = "response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response: &'a Option<RealtimeResponseCreateParams>,
        }
        let RealtimeClientEventResponseCreate { event_id, response } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "This event instructs the server to create a Response, which means triggering \nmodel inference. When in Server VAD mode, the server will create Responses \nautomatically.\n\nA Response will include at least one Item, and may have two, in which case \nthe second will be a function call. These Items will be appended to the \nconversation history.\n\nThe server will respond with a `response.created` event, events for Items \nand content created, and finally a `response.done` event to indicate the \nResponse is complete.\n\nThe `response.create` event includes inference configuration like \n`instructions`, and `temperature`. These fields will override the Session's \nconfiguration for this Response only.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventResponseCreate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub response: Option<RealtimeResponseCreateParams>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventSessionUpdate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `session.update`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventSessionUpdateType {
            #[default]
            #[serde(rename = "session.update")]
            SessionUpdate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventSessionUpdateType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeSessionCreateRequest,
        }
        let _D {
            event_id, session, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventSessionUpdate { event_id, session })
    }
}
impl serde::Serialize for RealtimeClientEventSessionUpdate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `session.update`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventSessionUpdateType {
            #[default]
            #[serde(rename = "session.update")]
            SessionUpdate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventSessionUpdateType,
            #[serde(rename = "session")]
            session: &'a RealtimeSessionCreateRequest,
        }
        let RealtimeClientEventSessionUpdate { event_id, session } = self;
        _S {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to update the sessions default configuration.\nThe client may send this event at any time to update any field,\nexcept for `voice`. However, note that once a session has been\ninitialized with a particular `model`, it cant be changed to\nanother model using `session.update`.\n\nWhen the server receives a `session.update`, it will respond\nwith a `session.updated` event showing the full, effective configuration.\nOnly the fields that are present are updated. To clear a field like\n`instructions`, pass an empty string.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventSessionUpdate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub session: RealtimeSessionCreateRequest,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventTranscriptionSessionUpdate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `transcription_session.update`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventTranscriptionSessionUpdateType {
            #[default]
            #[serde(rename = "transcription_session.update")]
            TranscriptionSessionUpdate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventTranscriptionSessionUpdateType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeTranscriptionSessionCreateRequest,
        }
        let _D {
            event_id, session, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeClientEventTranscriptionSessionUpdate { event_id, session })
    }
}
impl serde::Serialize for RealtimeClientEventTranscriptionSessionUpdate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `transcription_session.update`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventTranscriptionSessionUpdateType {
            #[default]
            #[serde(rename = "transcription_session.update")]
            TranscriptionSessionUpdate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventTranscriptionSessionUpdateType,
            #[serde(rename = "session")]
            session: &'a RealtimeTranscriptionSessionCreateRequest,
        }
        let RealtimeClientEventTranscriptionSessionUpdate { event_id, session } = self;
        _S {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to update a transcription session.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventTranscriptionSessionUpdate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub session: RealtimeTranscriptionSessionCreateRequest,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeFunctionCallOutput {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Message(#[allow(dead_code)] RealtimeConversationItemTypeMessage),
            FunctionCall(#[allow(dead_code)] RealtimeConversationItemTypeFunctionCall),
            FunctionCallOutput(#[allow(dead_code)] RealtimeConversationItemTypeFunctionCallOutput),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Message(_) => Self::Message,
            _D::FunctionCall(_) => Self::FunctionCall,
            _D::FunctionCallOutput(_) => Self::FunctionCallOutput,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeFunctionCallOutput {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Message(#[allow(dead_code)] &'a RealtimeConversationItemTypeMessage),
            FunctionCall(#[allow(dead_code)] &'a RealtimeConversationItemTypeFunctionCall),
            FunctionCallOutput(
                #[allow(dead_code)] &'a RealtimeConversationItemTypeFunctionCallOutput,
            ),
        }
        match self {
            Self::Message => _S::Message(&Default::default()).serialize(serializer),
            Self::FunctionCall => _S::FunctionCall(&Default::default()).serialize(serializer),
            Self::FunctionCallOutput => {
                _S::FunctionCallOutput(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of the item (`message`, `function_call`, `function_call_output`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemType {
    #[doc = "message"]
    Message,
    #[doc = "function_call"]
    FunctionCall,
    #[doc = "function_call_output"]
    FunctionCallOutput,
}
#[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeConversationItemObject {
    #[default]
    #[serde(rename = "realtime.item")]
    RealtimeItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Completed(#[allow(dead_code)] RealtimeConversationItemStatusCompleted),
            Incomplete(#[allow(dead_code)] RealtimeConversationItemStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Completed(#[allow(dead_code)] &'a RealtimeConversationItemStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a RealtimeConversationItemStatusIncomplete),
        }
        match self {
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the item (`completed`, `incomplete`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemStatus {
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] RealtimeConversationItemRoleUser),
            Assistant(#[allow(dead_code)] RealtimeConversationItemRoleAssistant),
            System(#[allow(dead_code)] RealtimeConversationItemRoleSystem),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
            _D::System(_) => Self::System,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a RealtimeConversationItemRoleUser),
            Assistant(#[allow(dead_code)] &'a RealtimeConversationItemRoleAssistant),
            System(#[allow(dead_code)] &'a RealtimeConversationItemRoleSystem),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
            Self::System => _S::System(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "system"]
    System,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemContentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeInputAudio {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeInputText {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InputAudio(#[allow(dead_code)] RealtimeConversationItemContentTypeInputAudio),
            InputText(#[allow(dead_code)] RealtimeConversationItemContentTypeInputText),
            ItemReference(#[allow(dead_code)] RealtimeConversationItemContentTypeItemReference),
            Text(#[allow(dead_code)] RealtimeConversationItemContentTypeText),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InputAudio(_) => Self::InputAudio,
            _D::InputText(_) => Self::InputText,
            _D::ItemReference(_) => Self::ItemReference,
            _D::Text(_) => Self::Text,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemContentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeInputAudio {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeInputText {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InputAudio(#[allow(dead_code)] &'a RealtimeConversationItemContentTypeInputAudio),
            InputText(#[allow(dead_code)] &'a RealtimeConversationItemContentTypeInputText),
            ItemReference(#[allow(dead_code)] &'a RealtimeConversationItemContentTypeItemReference),
            Text(#[allow(dead_code)] &'a RealtimeConversationItemContentTypeText),
        }
        match self {
            Self::InputAudio => _S::InputAudio(&Default::default()).serialize(serializer),
            Self::InputText => _S::InputText(&Default::default()).serialize(serializer),
            Self::ItemReference => _S::ItemReference(&Default::default()).serialize(serializer),
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemContentType {
    #[doc = "input_audio"]
    InputAudio,
    #[doc = "input_text"]
    InputText,
    #[doc = "item_reference"]
    ItemReference,
    #[doc = "text"]
    Text,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeConversationItemContentType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<String>,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: Option<String>,
        }
        let _D {
            type_,
            text,
            id,
            audio,
            transcript,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeConversationItemContent {
            type_,
            text,
            id,
            audio,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeConversationItemContentType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<String>,
            #[serde(rename = "transcript")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transcript: &'a Option<String>,
        }
        let RealtimeConversationItemContent {
            type_,
            text,
            id,
            audio,
            transcript,
        } = self;
        _S {
            type_,
            text,
            id,
            audio,
            transcript,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItemContent {
    #[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeConversationItemContentType>,
    #[doc = "The text content, used for `input_text` and `text` content types.\n"]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "ID of a previous conversation item to reference (for `item_reference`\ncontent types in `response.create` events). These can reference both\nclient and server created items.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "Base64-encoded audio bytes, used for `input_audio` content type.\n"]
    #[builder(default)]
    pub audio: Option<String>,
    #[doc = "The transcript of the audio, used for `input_audio` content type.\n"]
    #[builder(default)]
    pub transcript: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeConversationItemType>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<RealtimeConversationItemObject>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<RealtimeConversationItemStatus>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<RealtimeConversationItemRole>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<RealtimeConversationItemContent>>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let _D {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeConversationItem {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        })
    }
}
impl serde::Serialize for RealtimeConversationItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeConversationItemType>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<RealtimeConversationItemObject>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<RealtimeConversationItemStatus>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<RealtimeConversationItemRole>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<RealtimeConversationItemContent>>,
            #[serde(rename = "call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            call_id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let RealtimeConversationItem {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        } = self;
        _S {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        }
        .serialize(serializer)
    }
}
#[doc = "The item to add to the conversation."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItem {
    #[doc = "The unique ID of the item, this can be generated by the client to help \nmanage server-side context, but is not required because the server will \ngenerate one if not provided.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the item (`message`, `function_call`, `function_call_output`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeConversationItemType>,
    #[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
    #[builder(default)]
    pub object: Option<RealtimeConversationItemObject>,
    #[doc = "The status of the item (`completed`, `incomplete`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
    #[builder(default)]
    pub status: Option<RealtimeConversationItemStatus>,
    #[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
    #[builder(default)]
    pub role: Option<RealtimeConversationItemRole>,
    #[doc = "The content of the message, applicable for `message` items. \n- Message items of role `system` support only `input_text` content\n- Message items of role `user` support `input_text` and `input_audio` \n  content\n- Message items of role `assistant` support `text` content.\n"]
    #[builder(default)]
    pub content: Option<Vec<RealtimeConversationItemContent>>,
    #[doc = "The ID of the function call (for `function_call` and \n`function_call_output` items). If passed on a `function_call_output` \nitem, the server will check that a `function_call` item with the same \nID exists in the conversation history.\n"]
    #[builder(default)]
    pub call_id: Option<String>,
    #[doc = "The name of the function being called (for `function_call` items).\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments of the function call (for `function_call` items).\n"]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The output of the function call (for `function_call_output` items).\n"]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReferenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeFunctionCallOutput {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Message(#[allow(dead_code)] RealtimeConversationItemWithReferenceTypeMessage),
            FunctionCall(#[allow(dead_code)] RealtimeConversationItemWithReferenceTypeFunctionCall),
            FunctionCallOutput(
                #[allow(dead_code)] RealtimeConversationItemWithReferenceTypeFunctionCallOutput,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Message(_) => Self::Message,
            _D::FunctionCall(_) => Self::FunctionCall,
            _D::FunctionCallOutput(_) => Self::FunctionCallOutput,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemWithReferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeFunctionCallOutput {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Message(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceTypeMessage),
            FunctionCall(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceTypeFunctionCall,
            ),
            FunctionCallOutput(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceTypeFunctionCallOutput,
            ),
        }
        match self {
            Self::Message => _S::Message(&Default::default()).serialize(serializer),
            Self::FunctionCall => _S::FunctionCall(&Default::default()).serialize(serializer),
            Self::FunctionCallOutput => {
                _S::FunctionCallOutput(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of the item (`message`, `function_call`, `function_call_output`, `item_reference`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemWithReferenceType {
    #[doc = "message"]
    Message,
    #[doc = "function_call"]
    FunctionCall,
    #[doc = "function_call_output"]
    FunctionCallOutput,
}
#[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeConversationItemWithReferenceObject {
    #[default]
    #[serde(rename = "realtime.item")]
    RealtimeItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReferenceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Completed(#[allow(dead_code)] RealtimeConversationItemWithReferenceStatusCompleted),
            Incomplete(#[allow(dead_code)] RealtimeConversationItemWithReferenceStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemWithReferenceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Completed(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceStatusCompleted),
            Incomplete(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceStatusIncomplete,
            ),
        }
        match self {
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the item (`completed`, `incomplete`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemWithReferenceStatus {
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReferenceRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            User(#[allow(dead_code)] RealtimeConversationItemWithReferenceRoleUser),
            Assistant(#[allow(dead_code)] RealtimeConversationItemWithReferenceRoleAssistant),
            System(#[allow(dead_code)] RealtimeConversationItemWithReferenceRoleSystem),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::User(_) => Self::User,
            _D::Assistant(_) => Self::Assistant,
            _D::System(_) => Self::System,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemWithReferenceRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            User(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceRoleUser),
            Assistant(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceRoleAssistant),
            System(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceRoleSystem),
        }
        match self {
            Self::User => _S::User(&Default::default()).serialize(serializer),
            Self::Assistant => _S::Assistant(&Default::default()).serialize(serializer),
            Self::System => _S::System(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemWithReferenceRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "system"]
    System,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReferenceContentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceContentTypeInputAudio {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceContentTypeInputText {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceContentTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceContentTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InputAudio(
                #[allow(dead_code)] RealtimeConversationItemWithReferenceContentTypeInputAudio,
            ),
            InputText(
                #[allow(dead_code)] RealtimeConversationItemWithReferenceContentTypeInputText,
            ),
            ItemReference(
                #[allow(dead_code)] RealtimeConversationItemWithReferenceContentTypeItemReference,
            ),
            Text(#[allow(dead_code)] RealtimeConversationItemWithReferenceContentTypeText),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InputAudio(_) => Self::InputAudio,
            _D::InputText(_) => Self::InputText,
            _D::ItemReference(_) => Self::ItemReference,
            _D::Text(_) => Self::Text,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemWithReferenceContentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceContentTypeInputAudio {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceContentTypeInputText {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceContentTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceContentTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InputAudio(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceContentTypeInputAudio,
            ),
            InputText(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceContentTypeInputText,
            ),
            ItemReference(
                #[allow(dead_code)]
                &'a RealtimeConversationItemWithReferenceContentTypeItemReference,
            ),
            Text(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceContentTypeText),
        }
        match self {
            Self::InputAudio => _S::InputAudio(&Default::default()).serialize(serializer),
            Self::InputText => _S::InputText(&Default::default()).serialize(serializer),
            Self::ItemReference => _S::ItemReference(&Default::default()).serialize(serializer),
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemWithReferenceContentType {
    #[doc = "input_audio"]
    InputAudio,
    #[doc = "input_text"]
    InputText,
    #[doc = "item_reference"]
    ItemReference,
    #[doc = "text"]
    Text,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReferenceContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeConversationItemWithReferenceContentType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<String>,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: Option<String>,
        }
        let _D {
            type_,
            text,
            id,
            audio,
            transcript,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeConversationItemWithReferenceContent {
            type_,
            text,
            id,
            audio,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemWithReferenceContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeConversationItemWithReferenceContentType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<String>,
            #[serde(rename = "transcript")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transcript: &'a Option<String>,
        }
        let RealtimeConversationItemWithReferenceContent {
            type_,
            text,
            id,
            audio,
            transcript,
        } = self;
        _S {
            type_,
            text,
            id,
            audio,
            transcript,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItemWithReferenceContent {
    #[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeConversationItemWithReferenceContentType>,
    #[doc = "The text content, used for `input_text` and `text` content types.\n"]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "ID of a previous conversation item to reference (for `item_reference`\ncontent types in `response.create` events). These can reference both\nclient and server created items.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "Base64-encoded audio bytes, used for `input_audio` content type.\n"]
    #[builder(default)]
    pub audio: Option<String>,
    #[doc = "The transcript of the audio, used for `input_audio` content type.\n"]
    #[builder(default)]
    pub transcript: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeConversationItemWithReferenceType>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<RealtimeConversationItemWithReferenceObject>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<RealtimeConversationItemWithReferenceStatus>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<RealtimeConversationItemWithReferenceRole>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<RealtimeConversationItemWithReferenceContent>>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let _D {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeConversationItemWithReference {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemWithReference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeConversationItemWithReferenceType>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<RealtimeConversationItemWithReferenceObject>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<RealtimeConversationItemWithReferenceStatus>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<RealtimeConversationItemWithReferenceRole>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<RealtimeConversationItemWithReferenceContent>>,
            #[serde(rename = "call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            call_id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let RealtimeConversationItemWithReference {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        } = self;
        _S {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        }
        .serialize(serializer)
    }
}
#[doc = "The item to add to the conversation."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItemWithReference {
    #[doc = "For an item of type (`message` | `function_call` | `function_call_output`)\nthis field allows the client to assign the unique ID of the item. It is\nnot required because the server will generate one if not provided.\n\nFor an item of type `item_reference`, this field is required and is a\nreference to any item that has previously existed in the conversation.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the item (`message`, `function_call`, `function_call_output`, `item_reference`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeConversationItemWithReferenceType>,
    #[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
    #[builder(default)]
    pub object: Option<RealtimeConversationItemWithReferenceObject>,
    #[doc = "The status of the item (`completed`, `incomplete`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
    #[builder(default)]
    pub status: Option<RealtimeConversationItemWithReferenceStatus>,
    #[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
    #[builder(default)]
    pub role: Option<RealtimeConversationItemWithReferenceRole>,
    #[doc = "The content of the message, applicable for `message` items. \n- Message items of role `system` support only `input_text` content\n- Message items of role `user` support `input_text` and `input_audio` \n  content\n- Message items of role `assistant` support `text` content.\n"]
    #[builder(default)]
    pub content: Option<Vec<RealtimeConversationItemWithReferenceContent>>,
    #[doc = "The ID of the function call (for `function_call` and \n`function_call_output` items). If passed on a `function_call_output` \nitem, the server will check that a `function_call` item with the same \nID exists in the conversation history.\n"]
    #[builder(default)]
    pub call_id: Option<String>,
    #[doc = "The name of the function being called (for `function_call` items).\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments of the function call (for `function_call` items).\n"]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The output of the function call (for `function_call_output` items).\n"]
    #[builder(default)]
    pub output: Option<String>,
}
#[doc = "The object type, must be `realtime.response`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeResponseObject {
    #[default]
    #[serde(rename = "realtime.response")]
    RealtimeResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Completed(#[allow(dead_code)] RealtimeResponseStatusCompleted),
            Cancelled(#[allow(dead_code)] RealtimeResponseStatusCancelled),
            Failed(#[allow(dead_code)] RealtimeResponseStatusFailed),
            Incomplete(#[allow(dead_code)] RealtimeResponseStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Completed(_) => Self::Completed,
            _D::Cancelled(_) => Self::Cancelled,
            _D::Failed(_) => Self::Failed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for RealtimeResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Completed(#[allow(dead_code)] &'a RealtimeResponseStatusCompleted),
            Cancelled(#[allow(dead_code)] &'a RealtimeResponseStatusCancelled),
            Failed(#[allow(dead_code)] &'a RealtimeResponseStatusFailed),
            Incomplete(#[allow(dead_code)] &'a RealtimeResponseStatusIncomplete),
        }
        match self {
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The final status of the response (`completed`, `cancelled`, `failed`, or \n`incomplete`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseStatus {
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatusDetailsType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Completed(#[allow(dead_code)] RealtimeResponseStatusDetailsTypeCompleted),
            Cancelled(#[allow(dead_code)] RealtimeResponseStatusDetailsTypeCancelled),
            Failed(#[allow(dead_code)] RealtimeResponseStatusDetailsTypeFailed),
            Incomplete(#[allow(dead_code)] RealtimeResponseStatusDetailsTypeIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Completed(_) => Self::Completed,
            _D::Cancelled(_) => Self::Cancelled,
            _D::Failed(_) => Self::Failed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for RealtimeResponseStatusDetailsType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Completed(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsTypeCompleted),
            Cancelled(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsTypeCancelled),
            Failed(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsTypeFailed),
            Incomplete(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsTypeIncomplete),
        }
        match self {
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of error that caused the response to fail, corresponding \nwith the `status` field (`completed`, `cancelled`, `incomplete`, \n`failed`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseStatusDetailsType {
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatusDetailsReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonTurnDetected {
            #[default]
            #[serde(rename = "turn_detected")]
            TurnDetected,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonClientCancelled {
            #[default]
            #[serde(rename = "client_cancelled")]
            ClientCancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonMaxOutputTokens {
            #[default]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            TurnDetected(#[allow(dead_code)] RealtimeResponseStatusDetailsReasonTurnDetected),
            ClientCancelled(#[allow(dead_code)] RealtimeResponseStatusDetailsReasonClientCancelled),
            MaxOutputTokens(#[allow(dead_code)] RealtimeResponseStatusDetailsReasonMaxOutputTokens),
            ContentFilter(#[allow(dead_code)] RealtimeResponseStatusDetailsReasonContentFilter),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::TurnDetected(_) => Self::TurnDetected,
            _D::ClientCancelled(_) => Self::ClientCancelled,
            _D::MaxOutputTokens(_) => Self::MaxOutputTokens,
            _D::ContentFilter(_) => Self::ContentFilter,
        })
    }
}
impl serde::Serialize for RealtimeResponseStatusDetailsReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonTurnDetected {
            #[default]
            #[serde(rename = "turn_detected")]
            TurnDetected,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonClientCancelled {
            #[default]
            #[serde(rename = "client_cancelled")]
            ClientCancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonMaxOutputTokens {
            #[default]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            TurnDetected(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsReasonTurnDetected),
            ClientCancelled(
                #[allow(dead_code)] &'a RealtimeResponseStatusDetailsReasonClientCancelled,
            ),
            MaxOutputTokens(
                #[allow(dead_code)] &'a RealtimeResponseStatusDetailsReasonMaxOutputTokens,
            ),
            ContentFilter(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsReasonContentFilter),
        }
        match self {
            Self::TurnDetected => _S::TurnDetected(&Default::default()).serialize(serializer),
            Self::ClientCancelled => _S::ClientCancelled(&Default::default()).serialize(serializer),
            Self::MaxOutputTokens => _S::MaxOutputTokens(&Default::default()).serialize(serializer),
            Self::ContentFilter => _S::ContentFilter(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The reason the Response did not complete. For a `cancelled` Response, \none of `turn_detected` (the server VAD detected a new start of speech) \nor `client_cancelled` (the client sent a cancel event). For an \n`incomplete` Response, one of `max_output_tokens` or `content_filter` \n(the server-side safety filter activated and cut off the response).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseStatusDetailsReason {
    #[doc = "turn_detected"]
    TurnDetected,
    #[doc = "client_cancelled"]
    ClientCancelled,
    #[doc = "max_output_tokens"]
    MaxOutputTokens,
    #[doc = "content_filter"]
    ContentFilter,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatusDetailsError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
        }
        let _D { type_, code, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeResponseStatusDetailsError { type_, code })
    }
}
impl serde::Serialize for RealtimeResponseStatusDetailsError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
        }
        let RealtimeResponseStatusDetailsError { type_, code } = self;
        _S { type_, code }.serialize(serializer)
    }
}
#[doc = "A description of the error that caused the response to fail, \npopulated when the `status` is `failed`.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseStatusDetailsError {
    #[doc = "The type of error."]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "Error code, if any."]
    #[builder(default)]
    pub code: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatusDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeResponseStatusDetailsType>,
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: Option<RealtimeResponseStatusDetailsReason>,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<RealtimeResponseStatusDetailsError>,
        }
        let _D {
            type_,
            reason,
            error,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeResponseStatusDetails {
            type_,
            reason,
            error,
        })
    }
}
impl serde::Serialize for RealtimeResponseStatusDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeResponseStatusDetailsType>,
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<RealtimeResponseStatusDetailsReason>,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<RealtimeResponseStatusDetailsError>,
        }
        let RealtimeResponseStatusDetails {
            type_,
            reason,
            error,
        } = self;
        _S {
            type_,
            reason,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "Additional details about the status."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseStatusDetails {
    #[doc = "The type of error that caused the response to fail, corresponding \nwith the `status` field (`completed`, `cancelled`, `incomplete`, \n`failed`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeResponseStatusDetailsType>,
    #[doc = "The reason the Response did not complete. For a `cancelled` Response, \none of `turn_detected` (the server VAD detected a new start of speech) \nor `client_cancelled` (the client sent a cancel event). For an \n`incomplete` Response, one of `max_output_tokens` or `content_filter` \n(the server-side safety filter activated and cut off the response).\n"]
    #[builder(default)]
    pub reason: Option<RealtimeResponseStatusDetailsReason>,
    #[doc = "A description of the error that caused the response to fail, \npopulated when the `status` is `failed`.\n"]
    #[builder(default)]
    pub error: Option<RealtimeResponseStatusDetailsError>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseUsageInputTokenDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: Option<u64>,
            #[serde(rename = "text_tokens")]
            #[allow(dead_code)]
            text_tokens: Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[allow(dead_code)]
            audio_tokens: Option<u64>,
        }
        let _D {
            cached_tokens,
            text_tokens,
            audio_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeResponseUsageInputTokenDetails {
            cached_tokens,
            text_tokens,
            audio_tokens,
        })
    }
}
impl serde::Serialize for RealtimeResponseUsageInputTokenDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "cached_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cached_tokens: &'a Option<u64>,
            #[serde(rename = "text_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text_tokens: &'a Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio_tokens: &'a Option<u64>,
        }
        let RealtimeResponseUsageInputTokenDetails {
            cached_tokens,
            text_tokens,
            audio_tokens,
        } = self;
        _S {
            cached_tokens,
            text_tokens,
            audio_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Details about the input tokens used in the Response."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseUsageInputTokenDetails {
    #[doc = "The number of cached tokens used in the Response."]
    #[builder(default)]
    pub cached_tokens: Option<u64>,
    #[doc = "The number of text tokens used in the Response."]
    #[builder(default)]
    pub text_tokens: Option<u64>,
    #[doc = "The number of audio tokens used in the Response."]
    #[builder(default)]
    pub audio_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseUsageOutputTokenDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "text_tokens")]
            #[allow(dead_code)]
            text_tokens: Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[allow(dead_code)]
            audio_tokens: Option<u64>,
        }
        let _D {
            text_tokens,
            audio_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeResponseUsageOutputTokenDetails {
            text_tokens,
            audio_tokens,
        })
    }
}
impl serde::Serialize for RealtimeResponseUsageOutputTokenDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "text_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text_tokens: &'a Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio_tokens: &'a Option<u64>,
        }
        let RealtimeResponseUsageOutputTokenDetails {
            text_tokens,
            audio_tokens,
        } = self;
        _S {
            text_tokens,
            audio_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Details about the output tokens used in the Response."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseUsageOutputTokenDetails {
    #[doc = "The number of text tokens used in the Response."]
    #[builder(default)]
    pub text_tokens: Option<u64>,
    #[doc = "The number of audio tokens used in the Response."]
    #[builder(default)]
    pub audio_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: Option<u64>,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: Option<u64>,
            #[serde(rename = "output_tokens")]
            #[allow(dead_code)]
            output_tokens: Option<u64>,
            #[serde(rename = "input_token_details")]
            #[allow(dead_code)]
            input_token_details: Option<RealtimeResponseUsageInputTokenDetails>,
            #[serde(rename = "output_token_details")]
            #[allow(dead_code)]
            output_token_details: Option<RealtimeResponseUsageOutputTokenDetails>,
        }
        let _D {
            total_tokens,
            input_tokens,
            output_tokens,
            input_token_details,
            output_token_details,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeResponseUsage {
            total_tokens,
            input_tokens,
            output_tokens,
            input_token_details,
            output_token_details,
        })
    }
}
impl serde::Serialize for RealtimeResponseUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "total_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            total_tokens: &'a Option<u64>,
            #[serde(rename = "input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_tokens: &'a Option<u64>,
            #[serde(rename = "output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_tokens: &'a Option<u64>,
            #[serde(rename = "input_token_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_token_details: &'a Option<RealtimeResponseUsageInputTokenDetails>,
            #[serde(rename = "output_token_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_token_details: &'a Option<RealtimeResponseUsageOutputTokenDetails>,
        }
        let RealtimeResponseUsage {
            total_tokens,
            input_tokens,
            output_tokens,
            input_token_details,
            output_token_details,
        } = self;
        _S {
            total_tokens,
            input_tokens,
            output_tokens,
            input_token_details,
            output_token_details,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics for the Response, this will correspond to billing. A \nRealtime API session will maintain a conversation context and append new \nItems to the Conversation, thus output from previous turns (text and \naudio tokens) will become the input for later turns.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseUsage {
    #[doc = "The total number of tokens in the Response including input and output \ntext and audio tokens.\n"]
    #[builder(default)]
    pub total_tokens: Option<u64>,
    #[doc = "The number of input tokens used in the Response, including text and \naudio tokens.\n"]
    #[builder(default)]
    pub input_tokens: Option<u64>,
    #[doc = "The number of output tokens sent in the Response, including text and \naudio tokens.\n"]
    #[builder(default)]
    pub output_tokens: Option<u64>,
    #[doc = "Details about the input tokens used in the Response."]
    #[builder(default)]
    pub input_token_details: Option<RealtimeResponseUsageInputTokenDetails>,
    #[doc = "Details about the output tokens used in the Response."]
    #[builder(default)]
    pub output_token_details: Option<RealtimeResponseUsageOutputTokenDetails>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] RealtimeResponseModalityText),
            Audio(#[allow(dead_code)] RealtimeResponseModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeResponseModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a RealtimeResponseModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeResponseModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseOutputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Pcm16(#[allow(dead_code)] RealtimeResponseOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeResponseOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeResponseOutputAudioFormatG711Alaw),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Pcm16(_) => Self::Pcm16,
            _D::G711Ulaw(_) => Self::G711Ulaw,
            _D::G711Alaw(_) => Self::G711Alaw,
        })
    }
}
impl serde::Serialize for RealtimeResponseOutputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeResponseOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeResponseOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeResponseOutputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => _S::Pcm16(&Default::default()).serialize(serializer),
            Self::G711Ulaw => _S::G711Ulaw(&Default::default()).serialize(serializer),
            Self::G711Alaw => _S::G711Alaw(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseOutputAudioFormat {
    #[doc = "pcm16"]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseMaxOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseMaxOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Integer(#[allow(dead_code)] u64),
            Inf(#[allow(dead_code)] RealtimeResponseMaxOutputTokensInf),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Integer(_v) => Self::Integer(_v),
            _D::Inf(_) => Self::Inf,
        })
    }
}
impl serde::Serialize for RealtimeResponseMaxOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseMaxOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeResponseMaxOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
            Self::Inf => _S::Inf(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls, that was used in this response.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseMaxOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<RealtimeResponseObject>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<RealtimeResponseStatus>,
            #[serde(rename = "status_details")]
            #[allow(dead_code)]
            status_details: Option<RealtimeResponseStatusDetails>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<Vec<RealtimeConversationItem>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<RealtimeResponseUsage>,
            #[serde(rename = "conversation_id")]
            #[allow(dead_code)]
            conversation_id: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeResponseModality>>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<RealtimeResponseOutputAudioFormat>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_output_tokens")]
            #[allow(dead_code)]
            max_output_tokens: Option<RealtimeResponseMaxOutputTokens>,
        }
        let _D {
            id,
            object,
            status,
            status_details,
            output,
            metadata,
            usage,
            conversation_id,
            voice,
            modalities,
            output_audio_format,
            temperature,
            max_output_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeResponse {
            id,
            object,
            status,
            status_details,
            output,
            metadata,
            usage,
            conversation_id,
            voice,
            modalities,
            output_audio_format,
            temperature,
            max_output_tokens,
        })
    }
}
impl serde::Serialize for RealtimeResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<RealtimeResponseObject>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<RealtimeResponseStatus>,
            #[serde(rename = "status_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status_details: &'a Option<RealtimeResponseStatusDetails>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<Vec<RealtimeConversationItem>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<RealtimeResponseUsage>,
            #[serde(rename = "conversation_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            conversation_id: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeResponseModality>>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<RealtimeResponseOutputAudioFormat>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_output_tokens: &'a Option<RealtimeResponseMaxOutputTokens>,
        }
        let RealtimeResponse {
            id,
            object,
            status,
            status_details,
            output,
            metadata,
            usage,
            conversation_id,
            voice,
            modalities,
            output_audio_format,
            temperature,
            max_output_tokens,
        } = self;
        _S {
            id,
            object,
            status,
            status_details,
            output,
            metadata,
            usage,
            conversation_id,
            voice,
            modalities,
            output_audio_format,
            temperature,
            max_output_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "The response resource."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponse {
    #[doc = "The unique ID of the response."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The object type, must be `realtime.response`."]
    #[builder(default)]
    pub object: Option<RealtimeResponseObject>,
    #[doc = "The final status of the response (`completed`, `cancelled`, `failed`, or \n`incomplete`).\n"]
    #[builder(default)]
    pub status: Option<RealtimeResponseStatus>,
    #[doc = "Additional details about the status."]
    #[builder(default)]
    pub status_details: Option<RealtimeResponseStatusDetails>,
    #[doc = "The list of output items generated by the response."]
    #[builder(default)]
    pub output: Option<Vec<RealtimeConversationItem>>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "Usage statistics for the Response, this will correspond to billing. A \nRealtime API session will maintain a conversation context and append new \nItems to the Conversation, thus output from previous turns (text and \naudio tokens) will become the input for later turns.\n"]
    #[builder(default)]
    pub usage: Option<RealtimeResponseUsage>,
    #[doc = "Which conversation the response is added to, determined by the `conversation`\nfield in the `response.create` event. If `auto`, the response will be added to\nthe default conversation and the value of `conversation_id` will be an id like\n`conv_1234`. If `none`, the response will not be added to any conversation and\nthe value of `conversation_id` will be `null`. If responses are being triggered\nby server VAD, the response will be added to the default conversation, thus\nthe `conversation_id` will be an id like `conv_1234`.\n"]
    #[builder(default)]
    pub conversation_id: Option<String>,
    #[doc = "The voice the model used to respond.\nCurrent voice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`,\n`onyx`, `nova`, `sage`, `shimmer`, and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The set of modalities the model used to respond. If there are multiple modalities,\nthe model will pick one, for example if `modalities` is `[\"text\", \"audio\"]`, the model\ncould be responding in either text or audio.\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeResponseModality>>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub output_audio_format: Option<RealtimeResponseOutputAudioFormat>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls, that was used in this response.\n"]
    #[builder(default)]
    pub max_output_tokens: Option<RealtimeResponseMaxOutputTokens>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] RealtimeResponseCreateParamsModalityText),
            Audio(#[allow(dead_code)] RealtimeResponseCreateParamsModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a RealtimeResponseCreateParamsModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeResponseCreateParamsModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsOutputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Pcm16(#[allow(dead_code)] RealtimeResponseCreateParamsOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeResponseCreateParamsOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeResponseCreateParamsOutputAudioFormatG711Alaw),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Pcm16(_) => Self::Pcm16,
            _D::G711Ulaw(_) => Self::G711Ulaw,
            _D::G711Alaw(_) => Self::G711Alaw,
        })
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsOutputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeResponseCreateParamsOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeResponseCreateParamsOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeResponseCreateParamsOutputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => _S::Pcm16(&Default::default()).serialize(serializer),
            Self::G711Ulaw => _S::G711Ulaw(&Default::default()).serialize(serializer),
            Self::G711Alaw => _S::G711Alaw(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsOutputAudioFormat {
    #[doc = "pcm16"]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
#[doc = "The type of the tool, i.e. `function`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeResponseCreateParamsToolType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeResponseCreateParamsToolType>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let _D {
            type_,
            name,
            description,
            parameters,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeResponseCreateParamsTool {
            type_,
            name,
            description,
            parameters,
        })
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeResponseCreateParamsToolType>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeResponseCreateParamsTool {
            type_,
            name,
            description,
            parameters,
        } = self;
        _S {
            type_,
            name,
            description,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseCreateParamsTool {
    #[doc = "The type of the tool, i.e. `function`."]
    #[builder(default)]
    pub type_: Option<RealtimeResponseCreateParamsToolType>,
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "Parameters of the function in JSON Schema."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsMaxResponseOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Integer(#[allow(dead_code)] u64),
            Inf(#[allow(dead_code)] RealtimeResponseCreateParamsMaxResponseOutputTokensInf),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Integer(_v) => Self::Integer(_v),
            _D::Inf(_) => Self::Inf,
        })
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsMaxResponseOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeResponseCreateParamsMaxResponseOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
            Self::Inf => _S::Inf(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsMaxResponseOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsConversation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsConversationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsConversationNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] RealtimeResponseCreateParamsConversationAuto),
            None(#[allow(dead_code)] RealtimeResponseCreateParamsConversationNone),
            Other(#[allow(dead_code)] String),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::None(_) => Self::None,
            _D::Other(_v) => Self::Other(_v),
        })
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsConversation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsConversationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsConversationNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a RealtimeResponseCreateParamsConversationAuto),
            None(#[allow(dead_code)] &'a RealtimeResponseCreateParamsConversationNone),
            Other(#[allow(dead_code)] &'a String),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::None => _S::None(&Default::default()).serialize(serializer),
            Self::Other(_v) => _S::Other(_v).serialize(serializer),
        }
    }
}
#[doc = "Controls which conversation the response is added to. Currently supports\n`auto` and `none`, with `auto` as the default value. The `auto` value\nmeans that the contents of the response will be added to the default\nconversation. Set this to `none` to create an out-of-band response which \nwill not add items to default conversation.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsConversation {
    #[doc = "auto"]
    Auto,
    #[doc = "none"]
    None,
    Other(String),
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeResponseCreateParamsModality>>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<RealtimeResponseCreateParamsOutputAudioFormat>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<RealtimeResponseCreateParamsTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[allow(dead_code)]
            max_response_output_tokens: Option<RealtimeResponseCreateParamsMaxResponseOutputTokens>,
            #[serde(rename = "conversation")]
            #[allow(dead_code)]
            conversation: Option<RealtimeResponseCreateParamsConversation>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Option<Vec<RealtimeConversationItemWithReference>>,
        }
        let _D {
            modalities,
            instructions,
            voice,
            output_audio_format,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            conversation,
            metadata,
            input,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeResponseCreateParams {
            modalities,
            instructions,
            voice,
            output_audio_format,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            conversation,
            metadata,
            input,
        })
    }
}
impl serde::Serialize for RealtimeResponseCreateParams {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeResponseCreateParamsModality>>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<RealtimeResponseCreateParamsOutputAudioFormat>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<RealtimeResponseCreateParamsTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_response_output_tokens:
                &'a Option<RealtimeResponseCreateParamsMaxResponseOutputTokens>,
            #[serde(rename = "conversation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            conversation: &'a Option<RealtimeResponseCreateParamsConversation>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "input")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input: &'a Option<Vec<RealtimeConversationItemWithReference>>,
        }
        let RealtimeResponseCreateParams {
            modalities,
            instructions,
            voice,
            output_audio_format,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            conversation,
            metadata,
            input,
        } = self;
        _S {
            modalities,
            instructions,
            voice,
            output_audio_format,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            conversation,
            metadata,
            input,
        }
        .serialize(serializer)
    }
}
#[doc = "Create a new Realtime response with these parameters"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseCreateParams {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeResponseCreateParamsModality>>,
    #[doc = "The default system instructions (i.e. system message) prepended to model \ncalls. This field allows the client to guide the model on desired \nresponses. The model can be instructed on response content and format, \n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good \nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion \ninto your voice\", \"laugh frequently\"). The instructions are not guaranteed \nto be followed by the model, but they provide guidance to the model on the \ndesired behavior.\n\nNote that the server sets default instructions which will be used if this \nfield is not set and are visible in the `session.created` event at the \nstart of the session.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the \nsession once the model has responded with audio at least once. Current \nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`,\n`onyx`, `nova`, `sage`, `shimmer`, and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub output_audio_format: Option<RealtimeResponseCreateParamsOutputAudioFormat>,
    #[doc = "Tools (functions) available to the model."]
    #[builder(default)]
    pub tools: Option<Vec<RealtimeResponseCreateParamsTool>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or \nspecify a function, like `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}`.\n"]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[builder(default)]
    pub max_response_output_tokens: Option<RealtimeResponseCreateParamsMaxResponseOutputTokens>,
    #[doc = "Controls which conversation the response is added to. Currently supports\n`auto` and `none`, with `auto` as the default value. The `auto` value\nmeans that the contents of the response will be added to the default\nconversation. Set this to `none` to create an out-of-band response which \nwill not add items to default conversation.\n"]
    #[builder(default)]
    pub conversation: Option<RealtimeResponseCreateParamsConversation>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "Input items to include in the prompt for the model. Using this field\ncreates a new context for this Response instead of using the default\nconversation. An empty array `[]` will clear the context for this Response.\nNote that this can include references to items from the default conversation.\n"]
    #[builder(default)]
    pub input: Option<Vec<RealtimeConversationItemWithReference>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ConversationCreated(#[allow(dead_code)] RealtimeServerEventConversationCreated),
            ConversationItemCreated(#[allow(dead_code)] RealtimeServerEventConversationItemCreated),
            ConversationItemDeleted(#[allow(dead_code)] RealtimeServerEventConversationItemDeleted),
            ConversationItemInputAudioTranscriptionCompleted(
                #[allow(dead_code)]
                RealtimeServerEventConversationItemInputAudioTranscriptionCompleted,
            ),
            ConversationItemInputAudioTranscriptionDelta(
                #[allow(dead_code)] RealtimeServerEventConversationItemInputAudioTranscriptionDelta,
            ),
            ConversationItemInputAudioTranscriptionFailed(
                #[allow(dead_code)]
                RealtimeServerEventConversationItemInputAudioTranscriptionFailed,
            ),
            ConversationItemRetrieved(
                #[allow(dead_code)] RealtimeServerEventConversationItemRetrieved,
            ),
            ConversationItemTruncated(
                #[allow(dead_code)] RealtimeServerEventConversationItemTruncated,
            ),
            Error(#[allow(dead_code)] RealtimeServerEventError),
            InputAudioBufferCleared(#[allow(dead_code)] RealtimeServerEventInputAudioBufferCleared),
            InputAudioBufferCommitted(
                #[allow(dead_code)] RealtimeServerEventInputAudioBufferCommitted,
            ),
            InputAudioBufferSpeechStarted(
                #[allow(dead_code)] RealtimeServerEventInputAudioBufferSpeechStarted,
            ),
            InputAudioBufferSpeechStopped(
                #[allow(dead_code)] RealtimeServerEventInputAudioBufferSpeechStopped,
            ),
            RateLimitsUpdated(#[allow(dead_code)] RealtimeServerEventRateLimitsUpdated),
            ResponseAudioDelta(#[allow(dead_code)] RealtimeServerEventResponseAudioDelta),
            ResponseAudioDone(#[allow(dead_code)] RealtimeServerEventResponseAudioDone),
            ResponseAudioTranscriptDelta(
                #[allow(dead_code)] RealtimeServerEventResponseAudioTranscriptDelta,
            ),
            ResponseAudioTranscriptDone(
                #[allow(dead_code)] RealtimeServerEventResponseAudioTranscriptDone,
            ),
            ResponseContentPartAdded(
                #[allow(dead_code)] RealtimeServerEventResponseContentPartAdded,
            ),
            ResponseContentPartDone(#[allow(dead_code)] RealtimeServerEventResponseContentPartDone),
            ResponseCreated(#[allow(dead_code)] RealtimeServerEventResponseCreated),
            ResponseDone(#[allow(dead_code)] RealtimeServerEventResponseDone),
            ResponseFunctionCallArgumentsDelta(
                #[allow(dead_code)] RealtimeServerEventResponseFunctionCallArgumentsDelta,
            ),
            ResponseFunctionCallArgumentsDone(
                #[allow(dead_code)] RealtimeServerEventResponseFunctionCallArgumentsDone,
            ),
            ResponseOutputItemAdded(#[allow(dead_code)] RealtimeServerEventResponseOutputItemAdded),
            ResponseOutputItemDone(#[allow(dead_code)] RealtimeServerEventResponseOutputItemDone),
            ResponseTextDelta(#[allow(dead_code)] RealtimeServerEventResponseTextDelta),
            ResponseTextDone(#[allow(dead_code)] RealtimeServerEventResponseTextDone),
            SessionCreated(#[allow(dead_code)] RealtimeServerEventSessionCreated),
            SessionUpdated(#[allow(dead_code)] RealtimeServerEventSessionUpdated),
            TranscriptionSessionUpdated(
                #[allow(dead_code)] RealtimeServerEventTranscriptionSessionUpdated,
            ),
            OutputAudioBufferStarted(
                #[allow(dead_code)] RealtimeServerEventOutputAudioBufferStarted,
            ),
            OutputAudioBufferStopped(
                #[allow(dead_code)] RealtimeServerEventOutputAudioBufferStopped,
            ),
            OutputAudioBufferCleared(
                #[allow(dead_code)] RealtimeServerEventOutputAudioBufferCleared,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ConversationCreated(_v) => Self::ConversationCreated(_v),
            _D::ConversationItemCreated(_v) => Self::ConversationItemCreated(_v),
            _D::ConversationItemDeleted(_v) => Self::ConversationItemDeleted(_v),
            _D::ConversationItemInputAudioTranscriptionCompleted(_v) => {
                Self::ConversationItemInputAudioTranscriptionCompleted(_v)
            }
            _D::ConversationItemInputAudioTranscriptionDelta(_v) => {
                Self::ConversationItemInputAudioTranscriptionDelta(_v)
            }
            _D::ConversationItemInputAudioTranscriptionFailed(_v) => {
                Self::ConversationItemInputAudioTranscriptionFailed(_v)
            }
            _D::ConversationItemRetrieved(_v) => Self::ConversationItemRetrieved(_v),
            _D::ConversationItemTruncated(_v) => Self::ConversationItemTruncated(_v),
            _D::Error(_v) => Self::Error(_v),
            _D::InputAudioBufferCleared(_v) => Self::InputAudioBufferCleared(_v),
            _D::InputAudioBufferCommitted(_v) => Self::InputAudioBufferCommitted(_v),
            _D::InputAudioBufferSpeechStarted(_v) => Self::InputAudioBufferSpeechStarted(_v),
            _D::InputAudioBufferSpeechStopped(_v) => Self::InputAudioBufferSpeechStopped(_v),
            _D::RateLimitsUpdated(_v) => Self::RateLimitsUpdated(_v),
            _D::ResponseAudioDelta(_v) => Self::ResponseAudioDelta(_v),
            _D::ResponseAudioDone(_v) => Self::ResponseAudioDone(_v),
            _D::ResponseAudioTranscriptDelta(_v) => Self::ResponseAudioTranscriptDelta(_v),
            _D::ResponseAudioTranscriptDone(_v) => Self::ResponseAudioTranscriptDone(_v),
            _D::ResponseContentPartAdded(_v) => Self::ResponseContentPartAdded(_v),
            _D::ResponseContentPartDone(_v) => Self::ResponseContentPartDone(_v),
            _D::ResponseCreated(_v) => Self::ResponseCreated(_v),
            _D::ResponseDone(_v) => Self::ResponseDone(_v),
            _D::ResponseFunctionCallArgumentsDelta(_v) => {
                Self::ResponseFunctionCallArgumentsDelta(_v)
            }
            _D::ResponseFunctionCallArgumentsDone(_v) => {
                Self::ResponseFunctionCallArgumentsDone(_v)
            }
            _D::ResponseOutputItemAdded(_v) => Self::ResponseOutputItemAdded(_v),
            _D::ResponseOutputItemDone(_v) => Self::ResponseOutputItemDone(_v),
            _D::ResponseTextDelta(_v) => Self::ResponseTextDelta(_v),
            _D::ResponseTextDone(_v) => Self::ResponseTextDone(_v),
            _D::SessionCreated(_v) => Self::SessionCreated(_v),
            _D::SessionUpdated(_v) => Self::SessionUpdated(_v),
            _D::TranscriptionSessionUpdated(_v) => Self::TranscriptionSessionUpdated(_v),
            _D::OutputAudioBufferStarted(_v) => Self::OutputAudioBufferStarted(_v),
            _D::OutputAudioBufferStopped(_v) => Self::OutputAudioBufferStopped(_v),
            _D::OutputAudioBufferCleared(_v) => Self::OutputAudioBufferCleared(_v),
        })
    }
}
impl serde::Serialize for RealtimeServerEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ConversationCreated(#[allow(dead_code)] &'a RealtimeServerEventConversationCreated),
            ConversationItemCreated(
                #[allow(dead_code)] &'a RealtimeServerEventConversationItemCreated,
            ),
            ConversationItemDeleted(
                #[allow(dead_code)] &'a RealtimeServerEventConversationItemDeleted,
            ),
            ConversationItemInputAudioTranscriptionCompleted(
                #[allow(dead_code)]
                &'a RealtimeServerEventConversationItemInputAudioTranscriptionCompleted,
            ),
            ConversationItemInputAudioTranscriptionDelta(
                #[allow(dead_code)]
                &'a RealtimeServerEventConversationItemInputAudioTranscriptionDelta,
            ),
            ConversationItemInputAudioTranscriptionFailed(
                #[allow(dead_code)]
                &'a RealtimeServerEventConversationItemInputAudioTranscriptionFailed,
            ),
            ConversationItemRetrieved(
                #[allow(dead_code)] &'a RealtimeServerEventConversationItemRetrieved,
            ),
            ConversationItemTruncated(
                #[allow(dead_code)] &'a RealtimeServerEventConversationItemTruncated,
            ),
            Error(#[allow(dead_code)] &'a RealtimeServerEventError),
            InputAudioBufferCleared(
                #[allow(dead_code)] &'a RealtimeServerEventInputAudioBufferCleared,
            ),
            InputAudioBufferCommitted(
                #[allow(dead_code)] &'a RealtimeServerEventInputAudioBufferCommitted,
            ),
            InputAudioBufferSpeechStarted(
                #[allow(dead_code)] &'a RealtimeServerEventInputAudioBufferSpeechStarted,
            ),
            InputAudioBufferSpeechStopped(
                #[allow(dead_code)] &'a RealtimeServerEventInputAudioBufferSpeechStopped,
            ),
            RateLimitsUpdated(#[allow(dead_code)] &'a RealtimeServerEventRateLimitsUpdated),
            ResponseAudioDelta(#[allow(dead_code)] &'a RealtimeServerEventResponseAudioDelta),
            ResponseAudioDone(#[allow(dead_code)] &'a RealtimeServerEventResponseAudioDone),
            ResponseAudioTranscriptDelta(
                #[allow(dead_code)] &'a RealtimeServerEventResponseAudioTranscriptDelta,
            ),
            ResponseAudioTranscriptDone(
                #[allow(dead_code)] &'a RealtimeServerEventResponseAudioTranscriptDone,
            ),
            ResponseContentPartAdded(
                #[allow(dead_code)] &'a RealtimeServerEventResponseContentPartAdded,
            ),
            ResponseContentPartDone(
                #[allow(dead_code)] &'a RealtimeServerEventResponseContentPartDone,
            ),
            ResponseCreated(#[allow(dead_code)] &'a RealtimeServerEventResponseCreated),
            ResponseDone(#[allow(dead_code)] &'a RealtimeServerEventResponseDone),
            ResponseFunctionCallArgumentsDelta(
                #[allow(dead_code)] &'a RealtimeServerEventResponseFunctionCallArgumentsDelta,
            ),
            ResponseFunctionCallArgumentsDone(
                #[allow(dead_code)] &'a RealtimeServerEventResponseFunctionCallArgumentsDone,
            ),
            ResponseOutputItemAdded(
                #[allow(dead_code)] &'a RealtimeServerEventResponseOutputItemAdded,
            ),
            ResponseOutputItemDone(
                #[allow(dead_code)] &'a RealtimeServerEventResponseOutputItemDone,
            ),
            ResponseTextDelta(#[allow(dead_code)] &'a RealtimeServerEventResponseTextDelta),
            ResponseTextDone(#[allow(dead_code)] &'a RealtimeServerEventResponseTextDone),
            SessionCreated(#[allow(dead_code)] &'a RealtimeServerEventSessionCreated),
            SessionUpdated(#[allow(dead_code)] &'a RealtimeServerEventSessionUpdated),
            TranscriptionSessionUpdated(
                #[allow(dead_code)] &'a RealtimeServerEventTranscriptionSessionUpdated,
            ),
            OutputAudioBufferStarted(
                #[allow(dead_code)] &'a RealtimeServerEventOutputAudioBufferStarted,
            ),
            OutputAudioBufferStopped(
                #[allow(dead_code)] &'a RealtimeServerEventOutputAudioBufferStopped,
            ),
            OutputAudioBufferCleared(
                #[allow(dead_code)] &'a RealtimeServerEventOutputAudioBufferCleared,
            ),
        }
        match self {
            Self::ConversationCreated(_v) => _S::ConversationCreated(_v).serialize(serializer),
            Self::ConversationItemCreated(_v) => {
                _S::ConversationItemCreated(_v).serialize(serializer)
            }
            Self::ConversationItemDeleted(_v) => {
                _S::ConversationItemDeleted(_v).serialize(serializer)
            }
            Self::ConversationItemInputAudioTranscriptionCompleted(_v) => {
                _S::ConversationItemInputAudioTranscriptionCompleted(_v).serialize(serializer)
            }
            Self::ConversationItemInputAudioTranscriptionDelta(_v) => {
                _S::ConversationItemInputAudioTranscriptionDelta(_v).serialize(serializer)
            }
            Self::ConversationItemInputAudioTranscriptionFailed(_v) => {
                _S::ConversationItemInputAudioTranscriptionFailed(_v).serialize(serializer)
            }
            Self::ConversationItemRetrieved(_v) => {
                _S::ConversationItemRetrieved(_v).serialize(serializer)
            }
            Self::ConversationItemTruncated(_v) => {
                _S::ConversationItemTruncated(_v).serialize(serializer)
            }
            Self::Error(_v) => _S::Error(_v).serialize(serializer),
            Self::InputAudioBufferCleared(_v) => {
                _S::InputAudioBufferCleared(_v).serialize(serializer)
            }
            Self::InputAudioBufferCommitted(_v) => {
                _S::InputAudioBufferCommitted(_v).serialize(serializer)
            }
            Self::InputAudioBufferSpeechStarted(_v) => {
                _S::InputAudioBufferSpeechStarted(_v).serialize(serializer)
            }
            Self::InputAudioBufferSpeechStopped(_v) => {
                _S::InputAudioBufferSpeechStopped(_v).serialize(serializer)
            }
            Self::RateLimitsUpdated(_v) => _S::RateLimitsUpdated(_v).serialize(serializer),
            Self::ResponseAudioDelta(_v) => _S::ResponseAudioDelta(_v).serialize(serializer),
            Self::ResponseAudioDone(_v) => _S::ResponseAudioDone(_v).serialize(serializer),
            Self::ResponseAudioTranscriptDelta(_v) => {
                _S::ResponseAudioTranscriptDelta(_v).serialize(serializer)
            }
            Self::ResponseAudioTranscriptDone(_v) => {
                _S::ResponseAudioTranscriptDone(_v).serialize(serializer)
            }
            Self::ResponseContentPartAdded(_v) => {
                _S::ResponseContentPartAdded(_v).serialize(serializer)
            }
            Self::ResponseContentPartDone(_v) => {
                _S::ResponseContentPartDone(_v).serialize(serializer)
            }
            Self::ResponseCreated(_v) => _S::ResponseCreated(_v).serialize(serializer),
            Self::ResponseDone(_v) => _S::ResponseDone(_v).serialize(serializer),
            Self::ResponseFunctionCallArgumentsDelta(_v) => {
                _S::ResponseFunctionCallArgumentsDelta(_v).serialize(serializer)
            }
            Self::ResponseFunctionCallArgumentsDone(_v) => {
                _S::ResponseFunctionCallArgumentsDone(_v).serialize(serializer)
            }
            Self::ResponseOutputItemAdded(_v) => {
                _S::ResponseOutputItemAdded(_v).serialize(serializer)
            }
            Self::ResponseOutputItemDone(_v) => {
                _S::ResponseOutputItemDone(_v).serialize(serializer)
            }
            Self::ResponseTextDelta(_v) => _S::ResponseTextDelta(_v).serialize(serializer),
            Self::ResponseTextDone(_v) => _S::ResponseTextDone(_v).serialize(serializer),
            Self::SessionCreated(_v) => _S::SessionCreated(_v).serialize(serializer),
            Self::SessionUpdated(_v) => _S::SessionUpdated(_v).serialize(serializer),
            Self::TranscriptionSessionUpdated(_v) => {
                _S::TranscriptionSessionUpdated(_v).serialize(serializer)
            }
            Self::OutputAudioBufferStarted(_v) => {
                _S::OutputAudioBufferStarted(_v).serialize(serializer)
            }
            Self::OutputAudioBufferStopped(_v) => {
                _S::OutputAudioBufferStopped(_v).serialize(serializer)
            }
            Self::OutputAudioBufferCleared(_v) => {
                _S::OutputAudioBufferCleared(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "A realtime server event.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEvent {
    ConversationCreated(RealtimeServerEventConversationCreated),
    ConversationItemCreated(RealtimeServerEventConversationItemCreated),
    ConversationItemDeleted(RealtimeServerEventConversationItemDeleted),
    ConversationItemInputAudioTranscriptionCompleted(
        RealtimeServerEventConversationItemInputAudioTranscriptionCompleted,
    ),
    ConversationItemInputAudioTranscriptionDelta(
        RealtimeServerEventConversationItemInputAudioTranscriptionDelta,
    ),
    ConversationItemInputAudioTranscriptionFailed(
        RealtimeServerEventConversationItemInputAudioTranscriptionFailed,
    ),
    ConversationItemRetrieved(RealtimeServerEventConversationItemRetrieved),
    ConversationItemTruncated(RealtimeServerEventConversationItemTruncated),
    Error(RealtimeServerEventError),
    InputAudioBufferCleared(RealtimeServerEventInputAudioBufferCleared),
    InputAudioBufferCommitted(RealtimeServerEventInputAudioBufferCommitted),
    InputAudioBufferSpeechStarted(RealtimeServerEventInputAudioBufferSpeechStarted),
    InputAudioBufferSpeechStopped(RealtimeServerEventInputAudioBufferSpeechStopped),
    RateLimitsUpdated(RealtimeServerEventRateLimitsUpdated),
    ResponseAudioDelta(RealtimeServerEventResponseAudioDelta),
    ResponseAudioDone(RealtimeServerEventResponseAudioDone),
    ResponseAudioTranscriptDelta(RealtimeServerEventResponseAudioTranscriptDelta),
    ResponseAudioTranscriptDone(RealtimeServerEventResponseAudioTranscriptDone),
    ResponseContentPartAdded(RealtimeServerEventResponseContentPartAdded),
    ResponseContentPartDone(RealtimeServerEventResponseContentPartDone),
    ResponseCreated(RealtimeServerEventResponseCreated),
    ResponseDone(RealtimeServerEventResponseDone),
    ResponseFunctionCallArgumentsDelta(RealtimeServerEventResponseFunctionCallArgumentsDelta),
    ResponseFunctionCallArgumentsDone(RealtimeServerEventResponseFunctionCallArgumentsDone),
    ResponseOutputItemAdded(RealtimeServerEventResponseOutputItemAdded),
    ResponseOutputItemDone(RealtimeServerEventResponseOutputItemDone),
    ResponseTextDelta(RealtimeServerEventResponseTextDelta),
    ResponseTextDone(RealtimeServerEventResponseTextDone),
    SessionCreated(RealtimeServerEventSessionCreated),
    SessionUpdated(RealtimeServerEventSessionUpdated),
    TranscriptionSessionUpdated(RealtimeServerEventTranscriptionSessionUpdated),
    OutputAudioBufferStarted(RealtimeServerEventOutputAudioBufferStarted),
    OutputAudioBufferStopped(RealtimeServerEventOutputAudioBufferStopped),
    OutputAudioBufferCleared(RealtimeServerEventOutputAudioBufferCleared),
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationCreatedConversation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<String>,
        }
        let _D { id, object, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventConversationCreatedConversation { id, object })
    }
}
impl serde::Serialize for RealtimeServerEventConversationCreatedConversation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<String>,
        }
        let RealtimeServerEventConversationCreatedConversation { id, object } = self;
        _S { id, object }.serialize(serializer)
    }
}
#[doc = "The conversation resource."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationCreatedConversation {
    #[doc = "The unique ID of the conversation."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The object type, must be `realtime.conversation`."]
    #[builder(default)]
    pub object: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationCreatedType {
            #[default]
            #[serde(rename = "conversation.created")]
            ConversationCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationCreatedType,
            #[serde(rename = "conversation")]
            #[allow(dead_code)]
            conversation: RealtimeServerEventConversationCreatedConversation,
        }
        let _D {
            event_id,
            conversation,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventConversationCreated {
            event_id,
            conversation,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationCreatedType {
            #[default]
            #[serde(rename = "conversation.created")]
            ConversationCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationCreatedType,
            #[serde(rename = "conversation")]
            conversation: &'a RealtimeServerEventConversationCreatedConversation,
        }
        let RealtimeServerEventConversationCreated {
            event_id,
            conversation,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            conversation,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a conversation is created. Emitted right after session creation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The conversation resource."]
    #[builder(default)]
    pub conversation: RealtimeServerEventConversationCreatedConversation,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemCreatedType {
            #[default]
            #[serde(rename = "conversation.item.created")]
            ConversationItemCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemCreatedType,
            #[serde(rename = "previous_item_id")]
            #[allow(dead_code)]
            previous_item_id: String,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let _D {
            event_id,
            previous_item_id,
            item,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventConversationItemCreated {
            event_id,
            previous_item_id,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemCreatedType {
            #[default]
            #[serde(rename = "conversation.item.created")]
            ConversationItemCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemCreatedType,
            #[serde(rename = "previous_item_id")]
            previous_item_id: &'a String,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let RealtimeServerEventConversationItemCreated {
            event_id,
            previous_item_id,
            item,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            previous_item_id,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a conversation item is created. There are several scenarios that produce this event:\n  - The server is generating a Response, which if successful will produce \n    either one or two Items, which will be of type `message` \n    (role `assistant`) or type `function_call`.\n  - The input audio buffer has been committed, either by the client or the \n    server (in `server_vad` mode). The server will take the content of the \n    input audio buffer and add it to a new user message Item.\n  - The client has sent a `conversation.item.create` event to add a new Item \n    to the Conversation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the preceding item in the Conversation context, allows the \nclient to understand the order of the conversation.\n"]
    pub previous_item_id: String,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.deleted`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemDeletedType {
            #[default]
            #[serde(rename = "conversation.item.deleted")]
            ConversationItemDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemDeletedType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            event_id, item_id, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventConversationItemDeleted { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.deleted`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemDeletedType {
            #[default]
            #[serde(rename = "conversation.item.deleted")]
            ConversationItemDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemDeletedType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let RealtimeServerEventConversationItemDeleted { event_id, item_id } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an item in the conversation is deleted by the client with a \n`conversation.item.delete` event. This event is used to synchronize the \nserver's understanding of the conversation history with the client's view.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemDeleted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the item that was deleted."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionCompletedType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.completed")]
            ConversationItemInputAudioTranscriptionCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemInputAudioTranscriptionCompletedType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: String,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<LogProbProperties>>,
        }
        let _D {
            event_id,
            item_id,
            content_index,
            transcript,
            logprobs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
                event_id,
                item_id,
                content_index,
                transcript,
                logprobs,
            },
        )
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionCompletedType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.completed")]
            ConversationItemInputAudioTranscriptionCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemInputAudioTranscriptionCompletedType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "transcript")]
            transcript: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<LogProbProperties>>,
        }
        let RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
            event_id,
            item_id,
            content_index,
            transcript,
            logprobs,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            transcript,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "This event is the output of audio transcription for user audio written to the \nuser audio buffer. Transcription begins when the input audio buffer is \ncommitted by the client or server (in `server_vad` mode). Transcription runs \nasynchronously with Response creation, so this event may come before or after \nthe Response events.\n\nRealtime API models accept audio natively, and thus input transcription is a \nseparate process run on a separate ASR (Automatic Speech Recognition) model, \ncurrently always `whisper-1`. Thus the transcript may diverge somewhat from \nthe model's interpretation, and should be treated as a rough guide.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the user message item containing the audio."]
    pub item_id: String,
    #[doc = "The index of the content part containing the audio."]
    pub content_index: u64,
    #[doc = "The transcribed text."]
    pub transcript: String,
    #[doc = "The log probabilities of the transcription."]
    #[builder(default)]
    pub logprobs: Option<Vec<LogProbProperties>>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionDelta
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.input_audio_transcription.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionDeltaType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.delta")]
            ConversationItemInputAudioTranscriptionDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemInputAudioTranscriptionDeltaType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: Option<u64>,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: Option<String>,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<LogProbProperties>>,
        }
        let _D {
            event_id,
            item_id,
            content_index,
            delta,
            logprobs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
                event_id,
                item_id,
                content_index,
                delta,
                logprobs,
            },
        )
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.input_audio_transcription.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionDeltaType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.delta")]
            ConversationItemInputAudioTranscriptionDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemInputAudioTranscriptionDeltaType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content_index: &'a Option<u64>,
            #[serde(rename = "delta")]
            #[serde(skip_serializing_if = "Option::is_none")]
            delta: &'a Option<String>,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<LogProbProperties>>,
        }
        let RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
            event_id,
            item_id,
            content_index,
            delta,
            logprobs,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            delta,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the text value of an input audio transcription content part is updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the content part in the item's content array."]
    #[builder(default)]
    pub content_index: Option<u64>,
    #[doc = "The text delta."]
    #[builder(default)]
    pub delta: Option<String>,
    #[doc = "The log probabilities of the transcription."]
    #[builder(default)]
    pub logprobs: Option<Vec<LogProbProperties>>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionFailedError
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: Option<String>,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
        }
        let _D {
            type_,
            code,
            message,
            param,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
                type_,
                code,
                message,
                param,
            },
        )
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message: &'a Option<String>,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
        }
        let RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
            type_,
            code,
            message,
            param,
        } = self;
        _S {
            type_,
            code,
            message,
            param,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the transcription error."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    #[doc = "The type of error."]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "Error code, if any."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable error message."]
    #[builder(default)]
    pub message: Option<String>,
    #[doc = "Parameter related to the error, if any."]
    #[builder(default)]
    pub param: Option<String>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionFailed
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.failed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionFailedType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.failed")]
            ConversationItemInputAudioTranscriptionFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemInputAudioTranscriptionFailedType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: RealtimeServerEventConversationItemInputAudioTranscriptionFailedError,
        }
        let _D {
            event_id,
            item_id,
            content_index,
            error,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
                event_id,
                item_id,
                content_index,
                error,
            },
        )
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.failed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionFailedType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.failed")]
            ConversationItemInputAudioTranscriptionFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemInputAudioTranscriptionFailedType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "error")]
            error: &'a RealtimeServerEventConversationItemInputAudioTranscriptionFailedError,
        }
        let RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
            event_id,
            item_id,
            content_index,
            error,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when input audio transcription is configured, and a transcription \nrequest for a user message failed. These events are separate from other \n`error` events so that the client can identify the related Item.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the user message item."]
    pub item_id: String,
    #[doc = "The index of the content part containing the audio."]
    pub content_index: u64,
    #[doc = "Details of the transcription error."]
    #[builder(default)]
    pub error: RealtimeServerEventConversationItemInputAudioTranscriptionFailedError,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemRetrieved {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.retrieved`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemRetrievedType {
            #[default]
            #[serde(rename = "conversation.item.retrieved")]
            ConversationItemRetrieved,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemRetrievedType,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let _D { event_id, item, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventConversationItemRetrieved { event_id, item })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemRetrieved {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.retrieved`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemRetrievedType {
            #[default]
            #[serde(rename = "conversation.item.retrieved")]
            ConversationItemRetrieved,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemRetrievedType,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let RealtimeServerEventConversationItemRetrieved { event_id, item } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a conversation item is retrieved with `conversation.item.retrieve`.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemRetrieved {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemTruncated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.truncated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemTruncatedType {
            #[default]
            #[serde(rename = "conversation.item.truncated")]
            ConversationItemTruncated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemTruncatedType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "audio_end_ms")]
            #[allow(dead_code)]
            audio_end_ms: u64,
        }
        let _D {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventConversationItemTruncated {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemTruncated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.truncated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemTruncatedType {
            #[default]
            #[serde(rename = "conversation.item.truncated")]
            ConversationItemTruncated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemTruncatedType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a u64,
        }
        let RealtimeServerEventConversationItemTruncated {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            audio_end_ms,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an earlier assistant audio message item is truncated by the \nclient with a `conversation.item.truncate` event. This event is used to \nsynchronize the server's understanding of the audio with the client's playback.\n\nThis action will truncate the audio and remove the server-side text transcript \nto ensure there is no text in the context that hasn't been heard by the user.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemTruncated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the assistant message item that was truncated."]
    pub item_id: String,
    #[doc = "The index of the content part that was truncated."]
    pub content_index: u64,
    #[doc = "The duration up to which the audio was truncated, in milliseconds.\n"]
    pub audio_end_ms: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventErrorError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: String,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
        }
        let _D {
            type_,
            code,
            message,
            param,
            event_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventErrorError {
            type_,
            code,
            message,
            param,
            event_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventErrorError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a String,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
        }
        let RealtimeServerEventErrorError {
            type_,
            code,
            message,
            param,
            event_id,
        } = self;
        _S {
            type_,
            code,
            message,
            param,
            event_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the error."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventErrorError {
    #[doc = "The type of error (e.g., \"invalid_request_error\", \"server_error\").\n"]
    pub type_: String,
    #[doc = "Error code, if any."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable error message."]
    pub message: String,
    #[doc = "Parameter related to the error, if any."]
    #[builder(default)]
    pub param: Option<String>,
    #[doc = "The event_id of the client event that caused the error, if applicable.\n"]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `error`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventErrorType {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventErrorType,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: RealtimeServerEventErrorError,
        }
        let _D {
            event_id, error, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventError { event_id, error })
    }
}
impl serde::Serialize for RealtimeServerEventError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `error`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventErrorType {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventErrorType,
            #[serde(rename = "error")]
            error: &'a RealtimeServerEventErrorError,
        }
        let RealtimeServerEventError { event_id, error } = self;
        _S {
            event_id,
            type_: &Default::default(),
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an error occurs, which could be a client problem or a server \nproblem. Most errors are recoverable and the session will stay open, we \nrecommend to implementors to monitor and log error messages by default.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventError {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Details of the error."]
    pub error: RealtimeServerEventErrorError,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferCleared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.cleared`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferClearedType {
            #[default]
            #[serde(rename = "input_audio_buffer.cleared")]
            InputAudioBufferCleared,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventInputAudioBufferClearedType,
        }
        let _D { event_id, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventInputAudioBufferCleared { event_id })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferCleared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.cleared`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferClearedType {
            #[default]
            #[serde(rename = "input_audio_buffer.cleared")]
            InputAudioBufferCleared,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventInputAudioBufferClearedType,
        }
        let RealtimeServerEventInputAudioBufferCleared { event_id } = self;
        _S {
            event_id,
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the input audio buffer is cleared by the client with a \n`input_audio_buffer.clear` event.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferCleared {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferCommitted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.committed`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferCommittedType {
            #[default]
            #[serde(rename = "input_audio_buffer.committed")]
            InputAudioBufferCommitted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventInputAudioBufferCommittedType,
            #[serde(rename = "previous_item_id")]
            #[allow(dead_code)]
            previous_item_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            event_id,
            previous_item_id,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventInputAudioBufferCommitted {
            event_id,
            previous_item_id,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferCommitted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.committed`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferCommittedType {
            #[default]
            #[serde(rename = "input_audio_buffer.committed")]
            InputAudioBufferCommitted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventInputAudioBufferCommittedType,
            #[serde(rename = "previous_item_id")]
            previous_item_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let RealtimeServerEventInputAudioBufferCommitted {
            event_id,
            previous_item_id,
            item_id,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            previous_item_id,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an input audio buffer is committed, either by the client or \nautomatically in server VAD mode. The `item_id` property is the ID of the user\nmessage item that will be created, thus a `conversation.item.created` event \nwill also be sent to the client.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferCommitted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the preceding item after which the new item will be inserted.\n"]
    pub previous_item_id: String,
    #[doc = "The ID of the user message item that will be created."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferSpeechStarted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.speech_started`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferSpeechStartedType {
            #[default]
            #[serde(rename = "input_audio_buffer.speech_started")]
            InputAudioBufferSpeechStarted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventInputAudioBufferSpeechStartedType,
            #[serde(rename = "audio_start_ms")]
            #[allow(dead_code)]
            audio_start_ms: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            event_id,
            audio_start_ms,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventInputAudioBufferSpeechStarted {
            event_id,
            audio_start_ms,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferSpeechStarted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.speech_started`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferSpeechStartedType {
            #[default]
            #[serde(rename = "input_audio_buffer.speech_started")]
            InputAudioBufferSpeechStarted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventInputAudioBufferSpeechStartedType,
            #[serde(rename = "audio_start_ms")]
            audio_start_ms: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let RealtimeServerEventInputAudioBufferSpeechStarted {
            event_id,
            audio_start_ms,
            item_id,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            audio_start_ms,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Sent by the server when in `server_vad` mode to indicate that speech has been \ndetected in the audio buffer. This can happen any time audio is added to the \nbuffer (unless speech is already detected). The client may want to use this \nevent to interrupt audio playback or provide visual feedback to the user. \n\nThe client should expect to receive a `input_audio_buffer.speech_stopped` event \nwhen speech stops. The `item_id` property is the ID of the user message item \nthat will be created when speech stops and will also be included in the \n`input_audio_buffer.speech_stopped` event (unless the client manually commits \nthe audio buffer during VAD activation).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferSpeechStarted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Milliseconds from the start of all audio written to the buffer during the \nsession when speech was first detected. This will correspond to the \nbeginning of audio sent to the model, and thus includes the \n`prefix_padding_ms` configured in the Session.\n"]
    pub audio_start_ms: u64,
    #[doc = "The ID of the user message item that will be created when speech stops.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferSpeechStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.speech_stopped`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferSpeechStoppedType {
            #[default]
            #[serde(rename = "input_audio_buffer.speech_stopped")]
            InputAudioBufferSpeechStopped,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventInputAudioBufferSpeechStoppedType,
            #[serde(rename = "audio_end_ms")]
            #[allow(dead_code)]
            audio_end_ms: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            event_id,
            audio_end_ms,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventInputAudioBufferSpeechStopped {
            event_id,
            audio_end_ms,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferSpeechStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.speech_stopped`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferSpeechStoppedType {
            #[default]
            #[serde(rename = "input_audio_buffer.speech_stopped")]
            InputAudioBufferSpeechStopped,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventInputAudioBufferSpeechStoppedType,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let RealtimeServerEventInputAudioBufferSpeechStopped {
            event_id,
            audio_end_ms,
            item_id,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            audio_end_ms,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned in `server_vad` mode when the server detects the end of speech in \nthe audio buffer. The server will also send an `conversation.item.created` \nevent with the user message item that is created from the audio buffer.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferSpeechStopped {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Milliseconds since the session started when speech stopped. This will \ncorrespond to the end of audio sent to the model, and thus includes the \n`min_silence_duration_ms` configured in the Session.\n"]
    pub audio_end_ms: u64,
    #[doc = "The ID of the user message item that will be created."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferCleared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `output_audio_buffer.cleared`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferClearedType {
            #[default]
            #[serde(rename = "output_audio_buffer.cleared")]
            OutputAudioBufferCleared,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventOutputAudioBufferClearedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
        }
        let _D {
            event_id,
            response_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventOutputAudioBufferCleared {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferCleared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `output_audio_buffer.cleared`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferClearedType {
            #[default]
            #[serde(rename = "output_audio_buffer.cleared")]
            OutputAudioBufferCleared,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventOutputAudioBufferClearedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let RealtimeServerEventOutputAudioBufferCleared {
            event_id,
            response_id,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[doc = "**WebRTC Only:** Emitted when the output audio buffer is cleared. This happens either in VAD\nmode when the user has interrupted (`input_audio_buffer.speech_started`),\nor when the client has emitted the `output_audio_buffer.clear` event to manually\ncut off the current audio response.\n[Learn more](/docs/guides/realtime-model-capabilities#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferCleared {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferStarted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `output_audio_buffer.started`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferStartedType {
            #[default]
            #[serde(rename = "output_audio_buffer.started")]
            OutputAudioBufferStarted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventOutputAudioBufferStartedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
        }
        let _D {
            event_id,
            response_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventOutputAudioBufferStarted {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferStarted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `output_audio_buffer.started`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferStartedType {
            #[default]
            #[serde(rename = "output_audio_buffer.started")]
            OutputAudioBufferStarted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventOutputAudioBufferStartedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let RealtimeServerEventOutputAudioBufferStarted {
            event_id,
            response_id,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[doc = "**WebRTC Only:** Emitted when the server begins streaming audio to the client. This event is\nemitted after an audio content part has been added (`response.content_part.added`)\nto the response.\n[Learn more](/docs/guides/realtime-model-capabilities#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferStarted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `output_audio_buffer.stopped`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferStoppedType {
            #[default]
            #[serde(rename = "output_audio_buffer.stopped")]
            OutputAudioBufferStopped,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventOutputAudioBufferStoppedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
        }
        let _D {
            event_id,
            response_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventOutputAudioBufferStopped {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `output_audio_buffer.stopped`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferStoppedType {
            #[default]
            #[serde(rename = "output_audio_buffer.stopped")]
            OutputAudioBufferStopped,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventOutputAudioBufferStoppedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let RealtimeServerEventOutputAudioBufferStopped {
            event_id,
            response_id,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[doc = "**WebRTC Only:** Emitted when the output audio buffer has been completely drained on the server,\nand no more audio is forthcoming. This event is emitted after the full response\ndata has been sent to the client (`response.done`).\n[Learn more](/docs/guides/realtime-model-capabilities#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferStopped {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventRateLimitsUpdatedRateLimitsName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsNameRequests {
            #[default]
            #[serde(rename = "requests")]
            Requests,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsNameTokens {
            #[default]
            #[serde(rename = "tokens")]
            Tokens,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Requests(
                #[allow(dead_code)] RealtimeServerEventRateLimitsUpdatedRateLimitsNameRequests,
            ),
            Tokens(#[allow(dead_code)] RealtimeServerEventRateLimitsUpdatedRateLimitsNameTokens),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Requests(_) => Self::Requests,
            _D::Tokens(_) => Self::Tokens,
        })
    }
}
impl serde::Serialize for RealtimeServerEventRateLimitsUpdatedRateLimitsName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsNameRequests {
            #[default]
            #[serde(rename = "requests")]
            Requests,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsNameTokens {
            #[default]
            #[serde(rename = "tokens")]
            Tokens,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Requests(
                #[allow(dead_code)] &'a RealtimeServerEventRateLimitsUpdatedRateLimitsNameRequests,
            ),
            Tokens(
                #[allow(dead_code)] &'a RealtimeServerEventRateLimitsUpdatedRateLimitsNameTokens,
            ),
        }
        match self {
            Self::Requests => _S::Requests(&Default::default()).serialize(serializer),
            Self::Tokens => _S::Tokens(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The name of the rate limit (`requests`, `tokens`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEventRateLimitsUpdatedRateLimitsName {
    #[doc = "requests"]
    Requests,
    #[doc = "tokens"]
    Tokens,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventRateLimitsUpdatedRateLimits {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<RealtimeServerEventRateLimitsUpdatedRateLimitsName>,
            #[serde(rename = "limit")]
            #[allow(dead_code)]
            limit: Option<u64>,
            #[serde(rename = "remaining")]
            #[allow(dead_code)]
            remaining: Option<u64>,
            #[serde(rename = "reset_seconds")]
            #[allow(dead_code)]
            reset_seconds: Option<f64>,
        }
        let _D {
            name,
            limit,
            remaining,
            reset_seconds,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventRateLimitsUpdatedRateLimits {
            name,
            limit,
            remaining,
            reset_seconds,
        })
    }
}
impl serde::Serialize for RealtimeServerEventRateLimitsUpdatedRateLimits {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<RealtimeServerEventRateLimitsUpdatedRateLimitsName>,
            #[serde(rename = "limit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            limit: &'a Option<u64>,
            #[serde(rename = "remaining")]
            #[serde(skip_serializing_if = "Option::is_none")]
            remaining: &'a Option<u64>,
            #[serde(rename = "reset_seconds")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reset_seconds: &'a Option<f64>,
        }
        let RealtimeServerEventRateLimitsUpdatedRateLimits {
            name,
            limit,
            remaining,
            reset_seconds,
        } = self;
        _S {
            name,
            limit,
            remaining,
            reset_seconds,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventRateLimitsUpdatedRateLimits {
    #[doc = "The name of the rate limit (`requests`, `tokens`).\n"]
    #[builder(default)]
    pub name: Option<RealtimeServerEventRateLimitsUpdatedRateLimitsName>,
    #[doc = "The maximum allowed value for the rate limit."]
    #[builder(default)]
    pub limit: Option<u64>,
    #[doc = "The remaining value before the limit is reached."]
    #[builder(default)]
    pub remaining: Option<u64>,
    #[doc = "Seconds until the rate limit resets."]
    #[builder(default)]
    pub reset_seconds: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventRateLimitsUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `rate_limits.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedType {
            #[default]
            #[serde(rename = "rate_limits.updated")]
            RateLimitsUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventRateLimitsUpdatedType,
            #[serde(rename = "rate_limits")]
            #[allow(dead_code)]
            rate_limits: Vec<RealtimeServerEventRateLimitsUpdatedRateLimits>,
        }
        let _D {
            event_id,
            rate_limits,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventRateLimitsUpdated {
            event_id,
            rate_limits,
        })
    }
}
impl serde::Serialize for RealtimeServerEventRateLimitsUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `rate_limits.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedType {
            #[default]
            #[serde(rename = "rate_limits.updated")]
            RateLimitsUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventRateLimitsUpdatedType,
            #[serde(rename = "rate_limits")]
            rate_limits: &'a Vec<RealtimeServerEventRateLimitsUpdatedRateLimits>,
        }
        let RealtimeServerEventRateLimitsUpdated {
            event_id,
            rate_limits,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            rate_limits,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted at the beginning of a Response to indicate the updated rate limits. \nWhen a Response is created some tokens will be \"reserved\" for the output \ntokens, the rate limits shown here reflect that reservation, which is then \nadjusted accordingly once the Response is completed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventRateLimitsUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "List of rate limit information."]
    pub rate_limits: Vec<RealtimeServerEventRateLimitsUpdatedRateLimits>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.audio.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioDeltaType {
            #[default]
            #[serde(rename = "response.audio.delta")]
            ResponseAudioDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseAudioDeltaType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseAudioDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.audio.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioDeltaType {
            #[default]
            #[serde(rename = "response.audio.delta")]
            ResponseAudioDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseAudioDeltaType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let RealtimeServerEventResponseAudioDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated audio is updated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "Base64-encoded audio data delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.audio.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioDoneType {
            #[default]
            #[serde(rename = "response.audio.done")]
            ResponseAudioDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseAudioDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseAudioDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.audio.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioDoneType {
            #[default]
            #[serde(rename = "response.audio.done")]
            ResponseAudioDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseAudioDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
        }
        let RealtimeServerEventResponseAudioDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated audio is done. Also emitted when a Response\nis interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioTranscriptDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.audio_transcript.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioTranscriptDeltaType {
            #[default]
            #[serde(rename = "response.audio_transcript.delta")]
            ResponseAudioTranscriptDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseAudioTranscriptDeltaType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseAudioTranscriptDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioTranscriptDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.audio_transcript.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioTranscriptDeltaType {
            #[default]
            #[serde(rename = "response.audio_transcript.delta")]
            ResponseAudioTranscriptDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseAudioTranscriptDeltaType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let RealtimeServerEventResponseAudioTranscriptDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated transcription of audio output is updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioTranscriptDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The transcript delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioTranscriptDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.audio_transcript.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioTranscriptDoneType {
            #[default]
            #[serde(rename = "response.audio_transcript.done")]
            ResponseAudioTranscriptDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseAudioTranscriptDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: String,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseAudioTranscriptDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioTranscriptDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.audio_transcript.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioTranscriptDoneType {
            #[default]
            #[serde(rename = "response.audio_transcript.done")]
            ResponseAudioTranscriptDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseAudioTranscriptDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "transcript")]
            transcript: &'a String,
        }
        let RealtimeServerEventResponseAudioTranscriptDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated transcription of audio output is done\nstreaming. Also emitted when a Response is interrupted, incomplete, or\ncancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioTranscriptDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The final transcript of the audio."]
    pub transcript: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartAddedPartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedPartTypeAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedPartTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Audio(#[allow(dead_code)] RealtimeServerEventResponseContentPartAddedPartTypeAudio),
            Text(#[allow(dead_code)] RealtimeServerEventResponseContentPartAddedPartTypeText),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Audio(_) => Self::Audio,
            _D::Text(_) => Self::Text,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartAddedPartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedPartTypeAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedPartTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Audio(#[allow(dead_code)] &'a RealtimeServerEventResponseContentPartAddedPartTypeAudio),
            Text(#[allow(dead_code)] &'a RealtimeServerEventResponseContentPartAddedPartTypeText),
        }
        match self {
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The content type (\"text\", \"audio\")."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEventResponseContentPartAddedPartType {
    #[doc = "audio"]
    Audio,
    #[doc = "text"]
    Text,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartAddedPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeServerEventResponseContentPartAddedPartType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<String>,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: Option<String>,
        }
        let _D {
            type_,
            text,
            audio,
            transcript,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseContentPartAddedPart {
            type_,
            text,
            audio,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartAddedPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeServerEventResponseContentPartAddedPartType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<String>,
            #[serde(rename = "transcript")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transcript: &'a Option<String>,
        }
        let RealtimeServerEventResponseContentPartAddedPart {
            type_,
            text,
            audio,
            transcript,
        } = self;
        _S {
            type_,
            text,
            audio,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "The content part that was added."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartAddedPart {
    #[doc = "The content type (\"text\", \"audio\")."]
    #[builder(default)]
    pub type_: Option<RealtimeServerEventResponseContentPartAddedPartType>,
    #[doc = "The text content (if type is \"text\")."]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "Base64-encoded audio data (if type is \"audio\")."]
    #[builder(default)]
    pub audio: Option<String>,
    #[doc = "The transcript of the audio (if type is \"audio\")."]
    #[builder(default)]
    pub transcript: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartAdded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.content_part.added`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedType {
            #[default]
            #[serde(rename = "response.content_part.added")]
            ResponseContentPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseContentPartAddedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: RealtimeServerEventResponseContentPartAddedPart,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseContentPartAdded {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartAdded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.content_part.added`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedType {
            #[default]
            #[serde(rename = "response.content_part.added")]
            ResponseContentPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseContentPartAddedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a RealtimeServerEventResponseContentPartAddedPart,
        }
        let RealtimeServerEventResponseContentPartAdded {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a new content part is added to an assistant message item during\nresponse generation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartAdded {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item to which the content part was added."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The content part that was added."]
    #[builder(default)]
    pub part: RealtimeServerEventResponseContentPartAddedPart,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartDonePartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDonePartTypeAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDonePartTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Audio(#[allow(dead_code)] RealtimeServerEventResponseContentPartDonePartTypeAudio),
            Text(#[allow(dead_code)] RealtimeServerEventResponseContentPartDonePartTypeText),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Audio(_) => Self::Audio,
            _D::Text(_) => Self::Text,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartDonePartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDonePartTypeAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDonePartTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Audio(#[allow(dead_code)] &'a RealtimeServerEventResponseContentPartDonePartTypeAudio),
            Text(#[allow(dead_code)] &'a RealtimeServerEventResponseContentPartDonePartTypeText),
        }
        match self {
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The content type (\"text\", \"audio\")."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEventResponseContentPartDonePartType {
    #[doc = "audio"]
    Audio,
    #[doc = "text"]
    Text,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartDonePart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeServerEventResponseContentPartDonePartType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<String>,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: Option<String>,
        }
        let _D {
            type_,
            text,
            audio,
            transcript,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseContentPartDonePart {
            type_,
            text,
            audio,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartDonePart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeServerEventResponseContentPartDonePartType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<String>,
            #[serde(rename = "transcript")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transcript: &'a Option<String>,
        }
        let RealtimeServerEventResponseContentPartDonePart {
            type_,
            text,
            audio,
            transcript,
        } = self;
        _S {
            type_,
            text,
            audio,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "The content part that is done."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartDonePart {
    #[doc = "The content type (\"text\", \"audio\")."]
    #[builder(default)]
    pub type_: Option<RealtimeServerEventResponseContentPartDonePartType>,
    #[doc = "The text content (if type is \"text\")."]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "Base64-encoded audio data (if type is \"audio\")."]
    #[builder(default)]
    pub audio: Option<String>,
    #[doc = "The transcript of the audio (if type is \"audio\")."]
    #[builder(default)]
    pub transcript: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.content_part.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDoneType {
            #[default]
            #[serde(rename = "response.content_part.done")]
            ResponseContentPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseContentPartDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: RealtimeServerEventResponseContentPartDonePart,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseContentPartDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.content_part.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDoneType {
            #[default]
            #[serde(rename = "response.content_part.done")]
            ResponseContentPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseContentPartDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a RealtimeServerEventResponseContentPartDonePart,
        }
        let RealtimeServerEventResponseContentPartDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a content part is done streaming in an assistant message item.\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The content part that is done."]
    #[builder(default)]
    pub part: RealtimeServerEventResponseContentPartDonePart,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseCreatedType {
            #[default]
            #[serde(rename = "response.created")]
            ResponseCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseCreatedType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: RealtimeResponse,
        }
        let _D {
            event_id, response, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseCreated { event_id, response })
    }
}
impl serde::Serialize for RealtimeServerEventResponseCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseCreatedType {
            #[default]
            #[serde(rename = "response.created")]
            ResponseCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseCreatedType,
            #[serde(rename = "response")]
            response: &'a RealtimeResponse,
        }
        let RealtimeServerEventResponseCreated { event_id, response } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a new Response is created. The first event of response creation,\nwhere the response is in an initial state of `in_progress`.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub response: RealtimeResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseDoneType {
            #[default]
            #[serde(rename = "response.done")]
            ResponseDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseDoneType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: RealtimeResponse,
        }
        let _D {
            event_id, response, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseDone { event_id, response })
    }
}
impl serde::Serialize for RealtimeServerEventResponseDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseDoneType {
            #[default]
            #[serde(rename = "response.done")]
            ResponseDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseDoneType,
            #[serde(rename = "response")]
            response: &'a RealtimeResponse,
        }
        let RealtimeServerEventResponseDone { event_id, response } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a Response is done streaming. Always emitted, no matter the \nfinal state. The Response object included in the `response.done` event will \ninclude all output Items in the Response but will omit the raw audio data.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub response: RealtimeResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseFunctionCallArgumentsDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.function_call_arguments.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseFunctionCallArgumentsDeltaType {
            #[default]
            #[serde(rename = "response.function_call_arguments.delta")]
            ResponseFunctionCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseFunctionCallArgumentsDeltaType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseFunctionCallArgumentsDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseFunctionCallArgumentsDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.function_call_arguments.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseFunctionCallArgumentsDeltaType {
            #[default]
            #[serde(rename = "response.function_call_arguments.delta")]
            ResponseFunctionCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseFunctionCallArgumentsDeltaType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let RealtimeServerEventResponseFunctionCallArgumentsDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated function call arguments are updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseFunctionCallArgumentsDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the function call item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The ID of the function call."]
    pub call_id: String,
    #[doc = "The arguments delta as a JSON string."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseFunctionCallArgumentsDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.function_call_arguments.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseFunctionCallArgumentsDoneType {
            #[default]
            #[serde(rename = "response.function_call_arguments.done")]
            ResponseFunctionCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseFunctionCallArgumentsDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseFunctionCallArgumentsDone {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseFunctionCallArgumentsDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.function_call_arguments.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseFunctionCallArgumentsDoneType {
            #[default]
            #[serde(rename = "response.function_call_arguments.done")]
            ResponseFunctionCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseFunctionCallArgumentsDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let RealtimeServerEventResponseFunctionCallArgumentsDone {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated function call arguments are done streaming.\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseFunctionCallArgumentsDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the function call item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The ID of the function call."]
    pub call_id: String,
    #[doc = "The final arguments as a JSON string."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseOutputItemAdded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.output_item.added`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseOutputItemAddedType {
            #[default]
            #[serde(rename = "response.output_item.added")]
            ResponseOutputItemAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseOutputItemAddedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let _D {
            event_id,
            response_id,
            output_index,
            item,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseOutputItemAdded {
            event_id,
            response_id,
            output_index,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseOutputItemAdded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.output_item.added`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseOutputItemAddedType {
            #[default]
            #[serde(rename = "response.output_item.added")]
            ResponseOutputItemAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseOutputItemAddedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let RealtimeServerEventResponseOutputItemAdded {
            event_id,
            response_id,
            output_index,
            item,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            output_index,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a new Item is created during Response generation."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseOutputItemAdded {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the Response to which the item belongs."]
    pub response_id: String,
    #[doc = "The index of the output item in the Response."]
    pub output_index: u64,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseOutputItemDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.output_item.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseOutputItemDoneType {
            #[default]
            #[serde(rename = "response.output_item.done")]
            ResponseOutputItemDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseOutputItemDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let _D {
            event_id,
            response_id,
            output_index,
            item,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseOutputItemDone {
            event_id,
            response_id,
            output_index,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseOutputItemDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.output_item.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseOutputItemDoneType {
            #[default]
            #[serde(rename = "response.output_item.done")]
            ResponseOutputItemDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseOutputItemDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let RealtimeServerEventResponseOutputItemDone {
            event_id,
            response_id,
            output_index,
            item,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            output_index,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an Item is done streaming. Also emitted when a Response is \ninterrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseOutputItemDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the Response to which the item belongs."]
    pub response_id: String,
    #[doc = "The index of the output item in the Response."]
    pub output_index: u64,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseTextDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.text.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseTextDeltaType {
            #[default]
            #[serde(rename = "response.text.delta")]
            ResponseTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseTextDeltaType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseTextDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseTextDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.text.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseTextDeltaType {
            #[default]
            #[serde(rename = "response.text.delta")]
            ResponseTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseTextDeltaType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let RealtimeServerEventResponseTextDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the text value of a \"text\" content part is updated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseTextDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The text delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseTextDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.text.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseTextDoneType {
            #[default]
            #[serde(rename = "response.text.done")]
            ResponseTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseTextDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventResponseTextDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseTextDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.text.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseTextDoneType {
            #[default]
            #[serde(rename = "response.text.done")]
            ResponseTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseTextDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let RealtimeServerEventResponseTextDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        } = self;
        _S {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the text value of a \"text\" content part is done streaming. Also\nemitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseTextDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The final text content."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventSessionCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `session.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventSessionCreatedType {
            #[default]
            #[serde(rename = "session.created")]
            SessionCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventSessionCreatedType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeSession,
        }
        let _D {
            event_id, session, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventSessionCreated { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventSessionCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `session.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventSessionCreatedType {
            #[default]
            #[serde(rename = "session.created")]
            SessionCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventSessionCreatedType,
            #[serde(rename = "session")]
            session: &'a RealtimeSession,
        }
        let RealtimeServerEventSessionCreated { event_id, session } = self;
        _S {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a Session is created. Emitted automatically when a new \nconnection is established as the first server event. This event will contain \nthe default Session configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventSessionCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub session: RealtimeSession,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventSessionUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `session.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventSessionUpdatedType {
            #[default]
            #[serde(rename = "session.updated")]
            SessionUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventSessionUpdatedType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeSession,
        }
        let _D {
            event_id, session, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventSessionUpdated { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventSessionUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `session.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventSessionUpdatedType {
            #[default]
            #[serde(rename = "session.updated")]
            SessionUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventSessionUpdatedType,
            #[serde(rename = "session")]
            session: &'a RealtimeSession,
        }
        let RealtimeServerEventSessionUpdated { event_id, session } = self;
        _S {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a session is updated with a `session.update` event, unless \nthere is an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventSessionUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub session: RealtimeSession,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventTranscriptionSessionUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `transcription_session.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventTranscriptionSessionUpdatedType {
            #[default]
            #[serde(rename = "transcription_session.updated")]
            TranscriptionSessionUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventTranscriptionSessionUpdatedType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeTranscriptionSessionCreateResponse,
        }
        let _D {
            event_id, session, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeServerEventTranscriptionSessionUpdated { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventTranscriptionSessionUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `transcription_session.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventTranscriptionSessionUpdatedType {
            #[default]
            #[serde(rename = "transcription_session.updated")]
            TranscriptionSessionUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventTranscriptionSessionUpdatedType,
            #[serde(rename = "session")]
            session: &'a RealtimeTranscriptionSessionCreateResponse,
        }
        let RealtimeServerEventTranscriptionSessionUpdated { event_id, session } = self;
        _S {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a transcription session is updated with a `transcription_session.update` event, unless \nthere is an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventTranscriptionSessionUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    pub session: RealtimeTranscriptionSessionCreateResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] RealtimeSessionModalityText),
            Audio(#[allow(dead_code)] RealtimeSessionModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeSessionModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a RealtimeSessionModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeSessionModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview")]
            Gpt4oRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
            Gpt4oRealtimePreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
            Gpt4oRealtimePreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oMiniRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview")]
            Gpt4oMiniRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oMiniRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
            Gpt4oMiniRealtimePreview2024_12_17,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Gpt4oRealtimePreview(#[allow(dead_code)] RealtimeSessionModelGpt4oRealtimePreview),
            Gpt4oRealtimePreview2024_10_01(
                #[allow(dead_code)] RealtimeSessionModelGpt4oRealtimePreview2024_10_01,
            ),
            Gpt4oRealtimePreview2024_12_17(
                #[allow(dead_code)] RealtimeSessionModelGpt4oRealtimePreview2024_12_17,
            ),
            Gpt4oMiniRealtimePreview(
                #[allow(dead_code)] RealtimeSessionModelGpt4oMiniRealtimePreview,
            ),
            Gpt4oMiniRealtimePreview2024_12_17(
                #[allow(dead_code)] RealtimeSessionModelGpt4oMiniRealtimePreview2024_12_17,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Gpt4oRealtimePreview(_) => Self::Gpt4oRealtimePreview,
            _D::Gpt4oRealtimePreview2024_10_01(_) => Self::Gpt4oRealtimePreview2024_10_01,
            _D::Gpt4oRealtimePreview2024_12_17(_) => Self::Gpt4oRealtimePreview2024_12_17,
            _D::Gpt4oMiniRealtimePreview(_) => Self::Gpt4oMiniRealtimePreview,
            _D::Gpt4oMiniRealtimePreview2024_12_17(_) => Self::Gpt4oMiniRealtimePreview2024_12_17,
        })
    }
}
impl serde::Serialize for RealtimeSessionModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview")]
            Gpt4oRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
            Gpt4oRealtimePreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
            Gpt4oRealtimePreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oMiniRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview")]
            Gpt4oMiniRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oMiniRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
            Gpt4oMiniRealtimePreview2024_12_17,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Gpt4oRealtimePreview(#[allow(dead_code)] &'a RealtimeSessionModelGpt4oRealtimePreview),
            Gpt4oRealtimePreview2024_10_01(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oRealtimePreview2024_10_01,
            ),
            Gpt4oRealtimePreview2024_12_17(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oRealtimePreview2024_12_17,
            ),
            Gpt4oMiniRealtimePreview(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oMiniRealtimePreview,
            ),
            Gpt4oMiniRealtimePreview2024_12_17(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oMiniRealtimePreview2024_12_17,
            ),
        }
        match self {
            Self::Gpt4oRealtimePreview => {
                _S::Gpt4oRealtimePreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2024_10_01 => {
                _S::Gpt4oRealtimePreview2024_10_01(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2024_12_17 => {
                _S::Gpt4oRealtimePreview2024_12_17(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniRealtimePreview => {
                _S::Gpt4oMiniRealtimePreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniRealtimePreview2024_12_17 => {
                _S::Gpt4oMiniRealtimePreview2024_12_17(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The Realtime model used for this session.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionModel {
    #[doc = "gpt-4o-realtime-preview"]
    Gpt4oRealtimePreview,
    #[doc = "gpt-4o-realtime-preview-2024-10-01"]
    Gpt4oRealtimePreview2024_10_01,
    #[doc = "gpt-4o-realtime-preview-2024-12-17"]
    Gpt4oRealtimePreview2024_12_17,
    #[doc = "gpt-4o-mini-realtime-preview"]
    Gpt4oMiniRealtimePreview,
    #[doc = "gpt-4o-mini-realtime-preview-2024-12-17"]
    Gpt4oMiniRealtimePreview2024_12_17,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionInputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Pcm16(#[allow(dead_code)] RealtimeSessionInputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeSessionInputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeSessionInputAudioFormatG711Alaw),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Pcm16(_) => Self::Pcm16,
            _D::G711Ulaw(_) => Self::G711Ulaw,
            _D::G711Alaw(_) => Self::G711Alaw,
        })
    }
}
impl serde::Serialize for RealtimeSessionInputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeSessionInputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeSessionInputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeSessionInputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => _S::Pcm16(&Default::default()).serialize(serializer),
            Self::G711Ulaw => _S::G711Ulaw(&Default::default()).serialize(serializer),
            Self::G711Alaw => _S::G711Alaw(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate, \nsingle channel (mono), and little-endian byte order.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionInputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionOutputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Pcm16(#[allow(dead_code)] RealtimeSessionOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeSessionOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeSessionOutputAudioFormatG711Alaw),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Pcm16(_) => Self::Pcm16,
            _D::G711Ulaw(_) => Self::G711Ulaw,
            _D::G711Alaw(_) => Self::G711Alaw,
        })
    }
}
impl serde::Serialize for RealtimeSessionOutputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeSessionOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeSessionOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeSessionOutputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => _S::Pcm16(&Default::default()).serialize(serializer),
            Self::G711Ulaw => _S::G711Ulaw(&Default::default()).serialize(serializer),
            Self::G711Alaw => _S::G711Alaw(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionOutputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionInputAudioTranscription {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
        }
        let _D {
            model,
            language,
            prompt,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionInputAudioTranscription {
            model,
            language,
            prompt,
        })
    }
}
impl serde::Serialize for RealtimeSessionInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
        }
        let RealtimeSessionInputAudioTranscription {
            model,
            language,
            prompt,
        } = self;
        _S {
            model,
            language,
            prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs  asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionInputAudioTranscription {
    #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"]
    #[builder(default)]
    pub prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTurnDetectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ServerVad(#[allow(dead_code)] RealtimeSessionTurnDetectionTypeServerVad),
            SemanticVad(#[allow(dead_code)] RealtimeSessionTurnDetectionTypeSemanticVad),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ServerVad(_) => Self::ServerVad,
            _D::SemanticVad(_) => Self::SemanticVad,
        })
    }
}
impl serde::Serialize for RealtimeSessionTurnDetectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ServerVad(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionTypeServerVad),
            SemanticVad(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionTypeSemanticVad),
        }
        match self {
            Self::ServerVad => _S::ServerVad(&Default::default()).serialize(serializer),
            Self::SemanticVad => _S::SemanticVad(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Type of turn detection.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionTurnDetectionType {
    #[doc = "server_vad"]
    #[default]
    ServerVad,
    #[doc = "semantic_vad"]
    SemanticVad,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTurnDetectionEagerness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Low(#[allow(dead_code)] RealtimeSessionTurnDetectionEagernessLow),
            Medium(#[allow(dead_code)] RealtimeSessionTurnDetectionEagernessMedium),
            High(#[allow(dead_code)] RealtimeSessionTurnDetectionEagernessHigh),
            Auto(#[allow(dead_code)] RealtimeSessionTurnDetectionEagernessAuto),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Low(_) => Self::Low,
            _D::Medium(_) => Self::Medium,
            _D::High(_) => Self::High,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for RealtimeSessionTurnDetectionEagerness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Low(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionEagernessLow),
            Medium(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionEagernessMedium),
            High(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionEagernessHigh),
            Auto(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionEagernessAuto),
        }
        match self {
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Medium => _S::Medium(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionTurnDetectionEagerness {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[allow(dead_code)]
            eagerness: Option<RealtimeSessionTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
            #[serde(rename = "create_response")]
            #[allow(dead_code)]
            create_response: Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[allow(dead_code)]
            interrupt_response: Option<bool>,
        }
        let _D {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        })
    }
}
impl serde::Serialize for RealtimeSessionTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[serde(skip_serializing_if = "Option::is_none")]
            eagerness: &'a Option<RealtimeSessionTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
            #[serde(rename = "create_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            create_response: &'a Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            interrupt_response: &'a Option<bool>,
        }
        let RealtimeSessionTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        } = self;
        _S {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionTurnDetection {
    #[doc = "Type of turn detection.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeSessionTurnDetectionType>,
    #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
    #[builder(default)]
    pub eagerness: Option<RealtimeSessionTurnDetectionEagerness>,
    #[doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
    #[doc = "Whether or not to automatically generate a response when a VAD stop event occurs.\n"]
    #[builder(default)]
    pub create_response: Option<bool>,
    #[doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs.\n"]
    #[builder(default)]
    pub interrupt_response: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionInputAudioNoiseReductionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            NearField(#[allow(dead_code)] RealtimeSessionInputAudioNoiseReductionTypeNearField),
            FarField(#[allow(dead_code)] RealtimeSessionInputAudioNoiseReductionTypeFarField),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::NearField(_) => Self::NearField,
            _D::FarField(_) => Self::FarField,
        })
    }
}
impl serde::Serialize for RealtimeSessionInputAudioNoiseReductionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            NearField(#[allow(dead_code)] &'a RealtimeSessionInputAudioNoiseReductionTypeNearField),
            FarField(#[allow(dead_code)] &'a RealtimeSessionInputAudioNoiseReductionTypeFarField),
        }
        match self {
            Self::NearField => _S::NearField(&Default::default()).serialize(serializer),
            Self::FarField => _S::FarField(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionInputAudioNoiseReductionType {
    #[doc = "near_field"]
    NearField,
    #[doc = "far_field"]
    FarField,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionInputAudioNoiseReduction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionInputAudioNoiseReductionType>,
        }
        let _D { type_, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionInputAudioNoiseReduction { type_ })
    }
}
impl serde::Serialize for RealtimeSessionInputAudioNoiseReduction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionInputAudioNoiseReductionType>,
        }
        let RealtimeSessionInputAudioNoiseReduction { type_ } = self;
        _S { type_ }.serialize(serializer)
    }
}
#[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionInputAudioNoiseReduction {
    #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeSessionInputAudioNoiseReductionType>,
}
#[doc = "The type of the tool, i.e. `function`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeSessionToolType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionToolType>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let _D {
            type_,
            name,
            description,
            parameters,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionTool {
            type_,
            name,
            description,
            parameters,
        })
    }
}
impl serde::Serialize for RealtimeSessionTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionToolType>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionTool {
            type_,
            name,
            description,
            parameters,
        } = self;
        _S {
            type_,
            name,
            description,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionTool {
    #[doc = "The type of the tool, i.e. `function`."]
    #[builder(default)]
    pub type_: Option<RealtimeSessionToolType>,
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "Parameters of the function in JSON Schema."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionMaxResponseOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Integer(#[allow(dead_code)] u64),
            Inf(#[allow(dead_code)] RealtimeSessionMaxResponseOutputTokensInf),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Integer(_v) => Self::Integer(_v),
            _D::Inf(_) => Self::Inf,
        })
    }
}
impl serde::Serialize for RealtimeSessionMaxResponseOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeSessionMaxResponseOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
            Self::Inf => _S::Inf(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionMaxResponseOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeSession {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeSessionModality>>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<RealtimeSessionModel>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<RealtimeSessionInputAudioFormat>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<RealtimeSessionOutputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription: Option<RealtimeSessionInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeSessionTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[allow(dead_code)]
            input_audio_noise_reduction: Option<RealtimeSessionInputAudioNoiseReduction>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<RealtimeSessionTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[allow(dead_code)]
            max_response_output_tokens: Option<RealtimeSessionMaxResponseOutputTokens>,
        }
        let _D {
            id,
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSession {
            id,
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        })
    }
}
impl serde::Serialize for RealtimeSession {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeSessionModality>>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<RealtimeSessionModel>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format: &'a Option<RealtimeSessionInputAudioFormat>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<RealtimeSessionOutputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription: &'a Option<RealtimeSessionInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeSessionTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_noise_reduction: &'a Option<RealtimeSessionInputAudioNoiseReduction>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<RealtimeSessionTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_response_output_tokens: &'a Option<RealtimeSessionMaxResponseOutputTokens>,
        }
        let RealtimeSession {
            id,
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        } = self;
        _S {
            id,
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Realtime session object configuration."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSession {
    #[doc = "Unique identifier for the session that looks like `sess_1234567890abcdef`.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeSessionModality>>,
    #[doc = "The Realtime model used for this session.\n"]
    #[builder(default)]
    pub model: Option<RealtimeSessionModel>,
    #[doc = "The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the desired behavior.\n\nNote that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the \nsession once the model has responded with audio at least once. Current \nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`, \n`shimmer` and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate, \nsingle channel (mono), and little-endian byte order.\n"]
    #[builder(default)]
    pub input_audio_format: Option<RealtimeSessionInputAudioFormat>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
    #[builder(default)]
    pub output_audio_format: Option<RealtimeSessionOutputAudioFormat>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs  asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[builder(default)]
    pub input_audio_transcription: Option<RealtimeSessionInputAudioTranscription>,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeSessionTurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[builder(default)]
    pub input_audio_noise_reduction: Option<RealtimeSessionInputAudioNoiseReduction>,
    #[doc = "Tools (functions) available to the model."]
    #[builder(default)]
    pub tools: Option<Vec<RealtimeSessionTool>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or \nspecify a function.\n"]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. For audio models a temperature of 0.8 is highly recommended for best performance.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[builder(default)]
    pub max_response_output_tokens: Option<RealtimeSessionMaxResponseOutputTokens>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] RealtimeSessionCreateRequestModalityText),
            Audio(#[allow(dead_code)] RealtimeSessionCreateRequestModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a RealtimeSessionCreateRequestModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeSessionCreateRequestModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview")]
            Gpt4oRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
            Gpt4oRealtimePreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
            Gpt4oRealtimePreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview")]
            Gpt4oMiniRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
            Gpt4oMiniRealtimePreview2024_12_17,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Gpt4oRealtimePreview(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oRealtimePreview,
            ),
            Gpt4oRealtimePreview2024_10_01(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_10_01,
            ),
            Gpt4oRealtimePreview2024_12_17(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_12_17,
            ),
            Gpt4oMiniRealtimePreview(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview,
            ),
            Gpt4oMiniRealtimePreview2024_12_17(
                #[allow(dead_code)]
                RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview2024_12_17,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Gpt4oRealtimePreview(_) => Self::Gpt4oRealtimePreview,
            _D::Gpt4oRealtimePreview2024_10_01(_) => Self::Gpt4oRealtimePreview2024_10_01,
            _D::Gpt4oRealtimePreview2024_12_17(_) => Self::Gpt4oRealtimePreview2024_12_17,
            _D::Gpt4oMiniRealtimePreview(_) => Self::Gpt4oMiniRealtimePreview,
            _D::Gpt4oMiniRealtimePreview2024_12_17(_) => Self::Gpt4oMiniRealtimePreview2024_12_17,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview")]
            Gpt4oRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
            Gpt4oRealtimePreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
            Gpt4oRealtimePreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview")]
            Gpt4oMiniRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
            Gpt4oMiniRealtimePreview2024_12_17,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Gpt4oRealtimePreview(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestModelGpt4oRealtimePreview,
            ),
            Gpt4oRealtimePreview2024_10_01(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_10_01,
            ),
            Gpt4oRealtimePreview2024_12_17(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_12_17,
            ),
            Gpt4oMiniRealtimePreview(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview,
            ),
            Gpt4oMiniRealtimePreview2024_12_17(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview2024_12_17,
            ),
        }
        match self {
            Self::Gpt4oRealtimePreview => {
                _S::Gpt4oRealtimePreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2024_10_01 => {
                _S::Gpt4oRealtimePreview2024_10_01(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2024_12_17 => {
                _S::Gpt4oRealtimePreview2024_12_17(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniRealtimePreview => {
                _S::Gpt4oMiniRealtimePreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniRealtimePreview2024_12_17 => {
                _S::Gpt4oMiniRealtimePreview2024_12_17(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The Realtime model used for this session.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestModel {
    #[doc = "gpt-4o-realtime-preview"]
    Gpt4oRealtimePreview,
    #[doc = "gpt-4o-realtime-preview-2024-10-01"]
    Gpt4oRealtimePreview2024_10_01,
    #[doc = "gpt-4o-realtime-preview-2024-12-17"]
    Gpt4oRealtimePreview2024_12_17,
    #[doc = "gpt-4o-mini-realtime-preview"]
    Gpt4oMiniRealtimePreview,
    #[doc = "gpt-4o-mini-realtime-preview-2024-12-17"]
    Gpt4oMiniRealtimePreview2024_12_17,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestInputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Pcm16(#[allow(dead_code)] RealtimeSessionCreateRequestInputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeSessionCreateRequestInputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeSessionCreateRequestInputAudioFormatG711Alaw),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Pcm16(_) => Self::Pcm16,
            _D::G711Ulaw(_) => Self::G711Ulaw,
            _D::G711Alaw(_) => Self::G711Alaw,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestInputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeSessionCreateRequestInputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeSessionCreateRequestInputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeSessionCreateRequestInputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => _S::Pcm16(&Default::default()).serialize(serializer),
            Self::G711Ulaw => _S::G711Ulaw(&Default::default()).serialize(serializer),
            Self::G711Alaw => _S::G711Alaw(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate, \nsingle channel (mono), and little-endian byte order.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestInputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestOutputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Pcm16(#[allow(dead_code)] RealtimeSessionCreateRequestOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeSessionCreateRequestOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeSessionCreateRequestOutputAudioFormatG711Alaw),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Pcm16(_) => Self::Pcm16,
            _D::G711Ulaw(_) => Self::G711Ulaw,
            _D::G711Alaw(_) => Self::G711Alaw,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestOutputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeSessionCreateRequestOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeSessionCreateRequestOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeSessionCreateRequestOutputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => _S::Pcm16(&Default::default()).serialize(serializer),
            Self::G711Ulaw => _S::G711Ulaw(&Default::default()).serialize(serializer),
            Self::G711Alaw => _S::G711Alaw(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestOutputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestInputAudioTranscription {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
        }
        let _D {
            model,
            language,
            prompt,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateRequestInputAudioTranscription {
            model,
            language,
            prompt,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
        }
        let RealtimeSessionCreateRequestInputAudioTranscription {
            model,
            language,
            prompt,
        } = self;
        _S {
            model,
            language,
            prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs  asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestInputAudioTranscription {
    #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"]
    #[builder(default)]
    pub prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTurnDetectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ServerVad(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionTypeServerVad),
            SemanticVad(
                #[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionTypeSemanticVad,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ServerVad(_) => Self::ServerVad,
            _D::SemanticVad(_) => Self::SemanticVad,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTurnDetectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ServerVad(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionTypeServerVad,
            ),
            SemanticVad(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionTypeSemanticVad,
            ),
        }
        match self {
            Self::ServerVad => _S::ServerVad(&Default::default()).serialize(serializer),
            Self::SemanticVad => _S::SemanticVad(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Type of turn detection.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestTurnDetectionType {
    #[doc = "server_vad"]
    #[default]
    ServerVad,
    #[doc = "semantic_vad"]
    SemanticVad,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTurnDetectionEagerness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Low(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionEagernessLow),
            Medium(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionEagernessMedium),
            High(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionEagernessHigh),
            Auto(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionEagernessAuto),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Low(_) => Self::Low,
            _D::Medium(_) => Self::Medium,
            _D::High(_) => Self::High,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTurnDetectionEagerness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Low(#[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionEagernessLow),
            Medium(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionEagernessMedium,
            ),
            High(#[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionEagernessHigh),
            Auto(#[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionEagernessAuto),
        }
        match self {
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Medium => _S::Medium(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestTurnDetectionEagerness {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionCreateRequestTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[allow(dead_code)]
            eagerness: Option<RealtimeSessionCreateRequestTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
            #[serde(rename = "create_response")]
            #[allow(dead_code)]
            create_response: Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[allow(dead_code)]
            interrupt_response: Option<bool>,
        }
        let _D {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateRequestTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionCreateRequestTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[serde(skip_serializing_if = "Option::is_none")]
            eagerness: &'a Option<RealtimeSessionCreateRequestTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
            #[serde(rename = "create_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            create_response: &'a Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            interrupt_response: &'a Option<bool>,
        }
        let RealtimeSessionCreateRequestTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        } = self;
        _S {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestTurnDetection {
    #[doc = "Type of turn detection.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeSessionCreateRequestTurnDetectionType>,
    #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
    #[builder(default)]
    pub eagerness: Option<RealtimeSessionCreateRequestTurnDetectionEagerness>,
    #[doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
    #[doc = "Whether or not to automatically generate a response when a VAD stop event occurs.\n"]
    #[builder(default)]
    pub create_response: Option<bool>,
    #[doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs.\n"]
    #[builder(default)]
    pub interrupt_response: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestInputAudioNoiseReductionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            NearField(
                #[allow(dead_code)]
                RealtimeSessionCreateRequestInputAudioNoiseReductionTypeNearField,
            ),
            FarField(
                #[allow(dead_code)]
                RealtimeSessionCreateRequestInputAudioNoiseReductionTypeFarField,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::NearField(_) => Self::NearField,
            _D::FarField(_) => Self::FarField,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestInputAudioNoiseReductionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            NearField(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestInputAudioNoiseReductionTypeNearField,
            ),
            FarField(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestInputAudioNoiseReductionTypeFarField,
            ),
        }
        match self {
            Self::NearField => _S::NearField(&Default::default()).serialize(serializer),
            Self::FarField => _S::FarField(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestInputAudioNoiseReductionType {
    #[doc = "near_field"]
    NearField,
    #[doc = "far_field"]
    FarField,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestInputAudioNoiseReduction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionCreateRequestInputAudioNoiseReductionType>,
        }
        let _D { type_, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateRequestInputAudioNoiseReduction { type_ })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestInputAudioNoiseReduction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionCreateRequestInputAudioNoiseReductionType>,
        }
        let RealtimeSessionCreateRequestInputAudioNoiseReduction { type_ } = self;
        _S { type_ }.serialize(serializer)
    }
}
#[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestInputAudioNoiseReduction {
    #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeSessionCreateRequestInputAudioNoiseReductionType>,
}
#[doc = "The type of the tool, i.e. `function`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeSessionCreateRequestToolType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionCreateRequestToolType>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let _D {
            type_,
            name,
            description,
            parameters,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateRequestTool {
            type_,
            name,
            description,
            parameters,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionCreateRequestToolType>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionCreateRequestTool {
            type_,
            name,
            description,
            parameters,
        } = self;
        _S {
            type_,
            name,
            description,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestTool {
    #[doc = "The type of the tool, i.e. `function`."]
    #[builder(default)]
    pub type_: Option<RealtimeSessionCreateRequestToolType>,
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "Parameters of the function in JSON Schema."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestMaxResponseOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Integer(#[allow(dead_code)] u64),
            Inf(#[allow(dead_code)] RealtimeSessionCreateRequestMaxResponseOutputTokensInf),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Integer(_v) => Self::Integer(_v),
            _D::Inf(_) => Self::Inf,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestMaxResponseOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeSessionCreateRequestMaxResponseOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
            Self::Inf => _S::Inf(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestMaxResponseOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeSessionCreateRequestModality>>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<RealtimeSessionCreateRequestModel>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<RealtimeSessionCreateRequestInputAudioFormat>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<RealtimeSessionCreateRequestOutputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription: Option<RealtimeSessionCreateRequestInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeSessionCreateRequestTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[allow(dead_code)]
            input_audio_noise_reduction:
                Option<RealtimeSessionCreateRequestInputAudioNoiseReduction>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<RealtimeSessionCreateRequestTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[allow(dead_code)]
            max_response_output_tokens: Option<RealtimeSessionCreateRequestMaxResponseOutputTokens>,
        }
        let _D {
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateRequest {
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeSessionCreateRequestModality>>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<RealtimeSessionCreateRequestModel>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format: &'a Option<RealtimeSessionCreateRequestInputAudioFormat>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<RealtimeSessionCreateRequestOutputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription:
                &'a Option<RealtimeSessionCreateRequestInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeSessionCreateRequestTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_noise_reduction:
                &'a Option<RealtimeSessionCreateRequestInputAudioNoiseReduction>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<RealtimeSessionCreateRequestTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_response_output_tokens:
                &'a Option<RealtimeSessionCreateRequestMaxResponseOutputTokens>,
        }
        let RealtimeSessionCreateRequest {
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        } = self;
        _S {
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Realtime session object configuration."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequest {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeSessionCreateRequestModality>>,
    #[doc = "The Realtime model used for this session.\n"]
    #[builder(default)]
    pub model: Option<RealtimeSessionCreateRequestModel>,
    #[doc = "The default system instructions (i.e. system message) prepended to model  calls. This field allows the client to guide the model on desired  responses. The model can be instructed on response content and format,  (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good  responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion  into your voice\", \"laugh frequently\"). The instructions are not guaranteed  to be followed by the model, but they provide guidance to the model on the desired behavior.\n\nNote that the server sets default instructions which will be used if this  field is not set and are visible in the `session.created` event at the  start of the session.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the \nsession once the model has responded with audio at least once. Current \nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`,\n`onyx`, `nova`, `sage`, `shimmer`, and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate, \nsingle channel (mono), and little-endian byte order.\n"]
    #[builder(default)]
    pub input_audio_format: Option<RealtimeSessionCreateRequestInputAudioFormat>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
    #[builder(default)]
    pub output_audio_format: Option<RealtimeSessionCreateRequestOutputAudioFormat>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs  asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[builder(default)]
    pub input_audio_transcription: Option<RealtimeSessionCreateRequestInputAudioTranscription>,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeSessionCreateRequestTurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[builder(default)]
    pub input_audio_noise_reduction: Option<RealtimeSessionCreateRequestInputAudioNoiseReduction>,
    #[doc = "Tools (functions) available to the model."]
    #[builder(default)]
    pub tools: Option<Vec<RealtimeSessionCreateRequestTool>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or \nspecify a function.\n"]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. For audio models a temperature of 0.8 is highly recommended for best performance.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[builder(default)]
    pub max_response_output_tokens: Option<RealtimeSessionCreateRequestMaxResponseOutputTokens>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseClientSecret {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: String,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
        }
        let _D {
            value, expires_at, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateResponseClientSecret { value, expires_at })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseClientSecret {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
        }
        let RealtimeSessionCreateResponseClientSecret { value, expires_at } = self;
        _S { value, expires_at }.serialize(serializer)
    }
}
#[doc = "Ephemeral key returned by the API."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseClientSecret {
    #[doc = "Ephemeral key usable in client environments to authenticate connections\nto the Realtime API. Use this in client-side environments rather than\na standard API token, which should only be used server-side.\n"]
    pub value: String,
    #[doc = "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"]
    pub expires_at: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] RealtimeSessionCreateResponseModalityText),
            Audio(#[allow(dead_code)] RealtimeSessionCreateResponseModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a RealtimeSessionCreateResponseModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeSessionCreateResponseModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateResponseModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseInputAudioTranscription {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let _D { model, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateResponseInputAudioTranscription { model })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let RealtimeSessionCreateResponseInputAudioTranscription { model } = self;
        _S { model }.serialize(serializer)
    }
}
#[doc = "Configuration for input audio transcription, defaults to off and can be \nset to `null` to turn off once on. Input audio transcription is not native \nto the model, since the model consumes audio directly. Transcription runs \nasynchronously through Whisper and should be treated as rough guidance \nrather than the representation understood by the model.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseInputAudioTranscription {
    #[doc = "The model to use for transcription, `whisper-1` is the only currently \nsupported model.\n"]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
        }
        let _D {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateResponseTurnDetection {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
        }
        let RealtimeSessionCreateResponseTurnDetection {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        } = self;
        _S {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseTurnDetection {
    #[doc = "Type of turn detection, only `server_vad` is currently supported.\n"]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
}
#[doc = "The type of the tool, i.e. `function`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeSessionCreateResponseToolType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionCreateResponseToolType>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let _D {
            type_,
            name,
            description,
            parameters,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateResponseTool {
            type_,
            name,
            description,
            parameters,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionCreateResponseToolType>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionCreateResponseTool {
            type_,
            name,
            description,
            parameters,
        } = self;
        _S {
            type_,
            name,
            description,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseTool {
    #[doc = "The type of the tool, i.e. `function`."]
    #[builder(default)]
    pub type_: Option<RealtimeSessionCreateResponseToolType>,
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "Parameters of the function in JSON Schema."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseMaxResponseOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Integer(#[allow(dead_code)] u64),
            Inf(#[allow(dead_code)] RealtimeSessionCreateResponseMaxResponseOutputTokensInf),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Integer(_v) => Self::Integer(_v),
            _D::Inf(_) => Self::Inf,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseMaxResponseOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeSessionCreateResponseMaxResponseOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => _S::Integer(_v).serialize(serializer),
            Self::Inf => _S::Inf(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateResponseMaxResponseOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "client_secret")]
            #[allow(dead_code)]
            client_secret: RealtimeSessionCreateResponseClientSecret,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeSessionCreateResponseModality>>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<String>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<String>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription: Option<RealtimeSessionCreateResponseInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeSessionCreateResponseTurnDetection>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<RealtimeSessionCreateResponseTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[allow(dead_code)]
            max_response_output_tokens:
                Option<RealtimeSessionCreateResponseMaxResponseOutputTokens>,
        }
        let _D {
            client_secret,
            modalities,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeSessionCreateResponse {
            client_secret,
            modalities,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "client_secret")]
            client_secret: &'a RealtimeSessionCreateResponseClientSecret,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeSessionCreateResponseModality>>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format: &'a Option<String>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<String>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription:
                &'a Option<RealtimeSessionCreateResponseInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeSessionCreateResponseTurnDetection>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<RealtimeSessionCreateResponseTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_response_output_tokens:
                &'a Option<RealtimeSessionCreateResponseMaxResponseOutputTokens>,
        }
        let RealtimeSessionCreateResponse {
            client_secret,
            modalities,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        } = self;
        _S {
            client_secret,
            modalities,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "A new Realtime session configuration, with an ephermeral key. Default TTL\nfor keys is one minute.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponse {
    #[doc = "Ephemeral key returned by the API."]
    pub client_secret: RealtimeSessionCreateResponseClientSecret,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeSessionCreateResponseModality>>,
    #[doc = "The default system instructions (i.e. system message) prepended to model \ncalls. This field allows the client to guide the model on desired \nresponses. The model can be instructed on response content and format, \n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good \nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion \ninto your voice\", \"laugh frequently\"). The instructions are not guaranteed \nto be followed by the model, but they provide guidance to the model on the \ndesired behavior.\n\nNote that the server sets default instructions which will be used if this \nfield is not set and are visible in the `session.created` event at the \nstart of the session.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the \nsession once the model has responded with audio at least once. Current \nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`, \n`shimmer` and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub input_audio_format: Option<String>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub output_audio_format: Option<String>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be \nset to `null` to turn off once on. Input audio transcription is not native \nto the model, since the model consumes audio directly. Transcription runs \nasynchronously through Whisper and should be treated as rough guidance \nrather than the representation understood by the model.\n"]
    #[builder(default)]
    pub input_audio_transcription: Option<RealtimeSessionCreateResponseInputAudioTranscription>,
    #[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeSessionCreateResponseTurnDetection>,
    #[doc = "Tools (functions) available to the model."]
    #[builder(default)]
    pub tools: Option<Vec<RealtimeSessionCreateResponseTool>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or \nspecify a function.\n"]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[builder(default)]
    pub max_response_output_tokens: Option<RealtimeSessionCreateResponseMaxResponseOutputTokens>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] RealtimeTranscriptionSessionCreateRequestModalityText),
            Audio(#[allow(dead_code)] RealtimeTranscriptionSessionCreateRequestModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a RealtimeTranscriptionSessionCreateRequestModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeTranscriptionSessionCreateRequestModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestInputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Pcm16(
                #[allow(dead_code)] RealtimeTranscriptionSessionCreateRequestInputAudioFormatPcm16,
            ),
            G711Ulaw(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Ulaw,
            ),
            G711Alaw(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Alaw,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Pcm16(_) => Self::Pcm16,
            _D::G711Ulaw(_) => Self::G711Ulaw,
            _D::G711Alaw(_) => Self::G711Alaw,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Pcm16(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioFormatPcm16,
            ),
            G711Ulaw(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Ulaw,
            ),
            G711Alaw(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Alaw,
            ),
        }
        match self {
            Self::Pcm16 => _S::Pcm16(&Default::default()).serialize(serializer),
            Self::G711Ulaw => _S::G711Ulaw(&Default::default()).serialize(serializer),
            Self::G711Alaw => _S::G711Alaw(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate, \nsingle channel (mono), and little-endian byte order.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestInputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oMiniTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelWhisper1 {
            #[default]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Gpt4oTranscribe (# [allow (dead_code)] RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oTranscribe) , Gpt4oMiniTranscribe (# [allow (dead_code)] RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oMiniTranscribe) , Whisper1 (# [allow (dead_code)] RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelWhisper1) }
        Ok(match _D::deserialize(deserializer)? {
            _D::Gpt4oTranscribe(_) => Self::Gpt4oTranscribe,
            _D::Gpt4oMiniTranscribe(_) => Self::Gpt4oMiniTranscribe,
            _D::Whisper1(_) => Self::Whisper1,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oMiniTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelWhisper1 {
            #[default]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Gpt4oTranscribe (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oTranscribe) , Gpt4oMiniTranscribe (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oMiniTranscribe) , Whisper1 (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelWhisper1) }
        match self {
            Self::Gpt4oTranscribe => _S::Gpt4oTranscribe(&Default::default()).serialize(serializer),
            Self::Gpt4oMiniTranscribe => {
                _S::Gpt4oMiniTranscribe(&Default::default()).serialize(serializer)
            }
            Self::Whisper1 => _S::Whisper1(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel {
    #[doc = "gpt-4o-transcribe"]
    Gpt4oTranscribe,
    #[doc = "gpt-4o-mini-transcribe"]
    Gpt4oMiniTranscribe,
    #[doc = "whisper-1"]
    Whisper1,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestInputAudioTranscription
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel>,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
        }
        let _D {
            model,
            language,
            prompt,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
                model,
                language,
                prompt,
            },
        )
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel>,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
        }
        let RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
            model,
            language,
            prompt,
        } = self;
        _S {
            model,
            language,
            prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for input audio transcription. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
    #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
    #[builder(default)]
    pub model: Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel>,
    #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"]
    #[builder(default)]
    pub prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestTurnDetectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ServerVad(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeServerVad,
            ),
            SemanticVad(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeSemanticVad,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ServerVad(_) => Self::ServerVad,
            _D::SemanticVad(_) => Self::SemanticVad,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestTurnDetectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ServerVad(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeServerVad,
            ),
            SemanticVad(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeSemanticVad,
            ),
        }
        match self {
            Self::ServerVad => _S::ServerVad(&Default::default()).serialize(serializer),
            Self::SemanticVad => _S::SemanticVad(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Type of turn detection.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestTurnDetectionType {
    #[doc = "server_vad"]
    #[default]
    ServerVad,
    #[doc = "semantic_vad"]
    SemanticVad,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Low(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessLow,
            ),
            Medium(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessMedium,
            ),
            High(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessHigh,
            ),
            Auto(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessAuto,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Low(_) => Self::Low,
            _D::Medium(_) => Self::Medium,
            _D::High(_) => Self::High,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Low(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessLow,
            ),
            Medium(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessMedium,
            ),
            High(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessHigh,
            ),
            Auto(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessAuto,
            ),
        }
        match self {
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Medium => _S::Medium(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[allow(dead_code)]
            eagerness: Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
            #[serde(rename = "create_response")]
            #[allow(dead_code)]
            create_response: Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[allow(dead_code)]
            interrupt_response: Option<bool>,
        }
        let _D {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeTranscriptionSessionCreateRequestTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[serde(skip_serializing_if = "Option::is_none")]
            eagerness: &'a Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
            #[serde(rename = "create_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            create_response: &'a Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            interrupt_response: &'a Option<bool>,
        }
        let RealtimeTranscriptionSessionCreateRequestTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        } = self;
        _S {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequestTurnDetection {
    #[doc = "Type of turn detection.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionType>,
    #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
    #[builder(default)]
    pub eagerness: Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness>,
    #[doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
    #[doc = "Whether or not to automatically generate a response when a VAD stop event occurs. Not available for transcription sessions.\n"]
    #[builder(default)]
    pub create_response: Option<bool>,
    #[doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs. Not available for transcription sessions.\n"]
    #[builder(default)]
    pub interrupt_response: Option<bool>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            NearField(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeNearField,
            ),
            FarField(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeFarField,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::NearField(_) => Self::NearField,
            _D::FarField(_) => Self::FarField,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            NearField(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeNearField,
            ),
            FarField(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeFarField,
            ),
        }
        match self {
            Self::NearField => _S::NearField(&Default::default()).serialize(serializer),
            Self::FarField => _S::FarField(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType {
    #[doc = "near_field"]
    NearField,
    #[doc = "far_field"]
    FarField,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType>,
        }
        let _D { type_, .. } = _D::deserialize(deserializer)?;
        Ok(RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction { type_ })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType>,
        }
        let RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction { type_ } = self;
        _S { type_ }.serialize(serializer)
    }
}
#[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction {
    #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeTranscriptionSessionCreateRequestModality>>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<RealtimeTranscriptionSessionCreateRequestInputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription:
                Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeTranscriptionSessionCreateRequestTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[allow(dead_code)]
            input_audio_noise_reduction:
                Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction>,
            #[serde(rename = "include")]
            #[allow(dead_code)]
            include: Option<Vec<String>>,
        }
        let _D {
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            include,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeTranscriptionSessionCreateRequest {
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            include,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeTranscriptionSessionCreateRequestModality>>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeTranscriptionSessionCreateRequestTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_noise_reduction:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction>,
            #[serde(rename = "include")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include: &'a Option<Vec<String>>,
        }
        let RealtimeTranscriptionSessionCreateRequest {
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            include,
        } = self;
        _S {
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            include,
        }
        .serialize(serializer)
    }
}
#[doc = "Realtime transcription session object configuration."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequest {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeTranscriptionSessionCreateRequestModality>>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate, \nsingle channel (mono), and little-endian byte order.\n"]
    #[builder(default)]
    pub input_audio_format: Option<RealtimeTranscriptionSessionCreateRequestInputAudioFormat>,
    #[doc = "Configuration for input audio transcription. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[builder(default)]
    pub input_audio_transcription:
        Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscription>,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeTranscriptionSessionCreateRequestTurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[builder(default)]
    pub input_audio_noise_reduction:
        Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction>,
    #[doc = "The set of items to include in the transcription. Current available items are:\n- `item.input_audio_transcription.logprobs`\n"]
    #[builder(default)]
    pub include: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateResponseClientSecret {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: String,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
        }
        let _D {
            value, expires_at, ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeTranscriptionSessionCreateResponseClientSecret { value, expires_at })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseClientSecret {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
        }
        let RealtimeTranscriptionSessionCreateResponseClientSecret { value, expires_at } = self;
        _S { value, expires_at }.serialize(serializer)
    }
}
#[doc = "Ephemeral key returned by the API. Only present when the session is\ncreated on the server via REST API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponseClientSecret {
    #[doc = "Ephemeral key usable in client environments to authenticate connections\nto the Realtime API. Use this in client-side environments rather than\na standard API token, which should only be used server-side.\n"]
    pub value: String,
    #[doc = "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"]
    pub expires_at: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateResponseModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] RealtimeTranscriptionSessionCreateResponseModalityText),
            Audio(#[allow(dead_code)] RealtimeTranscriptionSessionCreateResponseModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a RealtimeTranscriptionSessionCreateResponseModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeTranscriptionSessionCreateResponseModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateResponseModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oMiniTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelWhisper1 {
            #[default]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Gpt4oTranscribe (# [allow (dead_code)] RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oTranscribe) , Gpt4oMiniTranscribe (# [allow (dead_code)] RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oMiniTranscribe) , Whisper1 (# [allow (dead_code)] RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelWhisper1) }
        Ok(match _D::deserialize(deserializer)? {
            _D::Gpt4oTranscribe(_) => Self::Gpt4oTranscribe,
            _D::Gpt4oMiniTranscribe(_) => Self::Gpt4oMiniTranscribe,
            _D::Whisper1(_) => Self::Whisper1,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oMiniTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelWhisper1 {
            #[default]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Gpt4oTranscribe (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oTranscribe) , Gpt4oMiniTranscribe (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oMiniTranscribe) , Whisper1 (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelWhisper1) }
        match self {
            Self::Gpt4oTranscribe => _S::Gpt4oTranscribe(&Default::default()).serialize(serializer),
            Self::Gpt4oMiniTranscribe => {
                _S::Gpt4oMiniTranscribe(&Default::default()).serialize(serializer)
            }
            Self::Whisper1 => _S::Whisper1(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The model to use for transcription. Can be `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, or `whisper-1`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel {
    #[doc = "gpt-4o-transcribe"]
    Gpt4oTranscribe,
    #[doc = "gpt-4o-mini-transcribe"]
    Gpt4oMiniTranscribe,
    #[doc = "whisper-1"]
    Whisper1,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateResponseInputAudioTranscription
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel>,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
        }
        let _D {
            model,
            language,
            prompt,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(
            RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
                model,
                language,
                prompt,
            },
        )
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model:
                &'a Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel>,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
        }
        let RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
            model,
            language,
            prompt,
        } = self;
        _S {
            model,
            language,
            prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration of the transcription model.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
    #[doc = "The model to use for transcription. Can be `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, or `whisper-1`.\n"]
    #[builder(default)]
    pub model: Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel>,
    #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment. The [prompt](/docs/guides/speech-to-text#prompting) should match\nthe audio language.\n"]
    #[builder(default)]
    pub prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateResponseTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
        }
        let _D {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeTranscriptionSessionCreateResponseTurnDetection {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
        }
        let RealtimeTranscriptionSessionCreateResponseTurnDetection {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        } = self;
        _S {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponseTurnDetection {
    #[doc = "Type of turn detection, only `server_vad` is currently supported.\n"]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "client_secret")]
            #[allow(dead_code)]
            client_secret: RealtimeTranscriptionSessionCreateResponseClientSecret,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeTranscriptionSessionCreateResponseModality>>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<String>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription:
                Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeTranscriptionSessionCreateResponseTurnDetection>,
        }
        let _D {
            client_secret,
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RealtimeTranscriptionSessionCreateResponse {
            client_secret,
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "client_secret")]
            client_secret: &'a RealtimeTranscriptionSessionCreateResponseClientSecret,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeTranscriptionSessionCreateResponseModality>>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format: &'a Option<String>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription:
                &'a Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeTranscriptionSessionCreateResponseTurnDetection>,
        }
        let RealtimeTranscriptionSessionCreateResponse {
            client_secret,
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
        } = self;
        _S {
            client_secret,
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
        }
        .serialize(serializer)
    }
}
#[doc = "A new Realtime transcription session configuration.\n\nWhen a session is created on the server via REST API, the session object\nalso contains an ephemeral key. Default TTL for keys is one minute. This \nproperty is not present when a session is updated via the WebSocket API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponse {
    #[doc = "Ephemeral key returned by the API. Only present when the session is\ncreated on the server via REST API.\n"]
    pub client_secret: RealtimeTranscriptionSessionCreateResponseClientSecret,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeTranscriptionSessionCreateResponseModality>>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub input_audio_format: Option<String>,
    #[doc = "Configuration of the transcription model.\n"]
    #[builder(default)]
    pub input_audio_transcription:
        Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscription>,
    #[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeTranscriptionSessionCreateResponseTurnDetection>,
}
impl<'de> serde::Deserialize<'de> for ReasoningSummary {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryConcise {
            #[default]
            #[serde(rename = "concise")]
            Concise,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryDetailed {
            #[default]
            #[serde(rename = "detailed")]
            Detailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] ReasoningSummaryAuto),
            Concise(#[allow(dead_code)] ReasoningSummaryConcise),
            Detailed(#[allow(dead_code)] ReasoningSummaryDetailed),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Concise(_) => Self::Concise,
            _D::Detailed(_) => Self::Detailed,
        })
    }
}
impl serde::Serialize for ReasoningSummary {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryConcise {
            #[default]
            #[serde(rename = "concise")]
            Concise,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryDetailed {
            #[default]
            #[serde(rename = "detailed")]
            Detailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a ReasoningSummaryAuto),
            Concise(#[allow(dead_code)] &'a ReasoningSummaryConcise),
            Detailed(#[allow(dead_code)] &'a ReasoningSummaryDetailed),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Concise => _S::Concise(&Default::default()).serialize(serializer),
            Self::Detailed => _S::Detailed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ReasoningSummary {
    #[doc = "auto"]
    Auto,
    #[doc = "concise"]
    Concise,
    #[doc = "detailed"]
    Detailed,
}
impl<'de> serde::Deserialize<'de> for ReasoningGenerateSummary {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryConcise {
            #[default]
            #[serde(rename = "concise")]
            Concise,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryDetailed {
            #[default]
            #[serde(rename = "detailed")]
            Detailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] ReasoningGenerateSummaryAuto),
            Concise(#[allow(dead_code)] ReasoningGenerateSummaryConcise),
            Detailed(#[allow(dead_code)] ReasoningGenerateSummaryDetailed),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Concise(_) => Self::Concise,
            _D::Detailed(_) => Self::Detailed,
        })
    }
}
impl serde::Serialize for ReasoningGenerateSummary {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryConcise {
            #[default]
            #[serde(rename = "concise")]
            Concise,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryDetailed {
            #[default]
            #[serde(rename = "detailed")]
            Detailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a ReasoningGenerateSummaryAuto),
            Concise(#[allow(dead_code)] &'a ReasoningGenerateSummaryConcise),
            Detailed(#[allow(dead_code)] &'a ReasoningGenerateSummaryDetailed),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Concise => _S::Concise(&Default::default()).serialize(serializer),
            Self::Detailed => _S::Detailed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ReasoningGenerateSummary {
    #[doc = "auto"]
    Auto,
    #[doc = "concise"]
    Concise,
    #[doc = "detailed"]
    Detailed,
}
impl<'de> serde::Deserialize<'de> for Reasoning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "effort")]
            #[allow(dead_code)]
            effort: Option<ReasoningEffort>,
            #[serde(rename = "summary")]
            #[allow(dead_code)]
            summary: Option<ReasoningSummary>,
            #[serde(rename = "generate_summary")]
            #[allow(dead_code)]
            generate_summary: Option<ReasoningGenerateSummary>,
        }
        let _D {
            effort,
            summary,
            generate_summary,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Reasoning {
            effort,
            summary,
            generate_summary,
        })
    }
}
impl serde::Serialize for Reasoning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "summary")]
            #[serde(skip_serializing_if = "Option::is_none")]
            summary: &'a Option<ReasoningSummary>,
            #[serde(rename = "generate_summary")]
            #[serde(skip_serializing_if = "Option::is_none")]
            generate_summary: &'a Option<ReasoningGenerateSummary>,
        }
        let Reasoning {
            effort,
            summary,
            generate_summary,
        } = self;
        _S {
            effort,
            summary,
            generate_summary,
        }
        .serialize(serializer)
    }
}
#[doc = "**o-series models only**\n\nConfiguration options for \n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct Reasoning {
    #[builder(default)]
    pub effort: Option<ReasoningEffort>,
    #[doc = "A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
    #[builder(default)]
    pub summary: Option<ReasoningSummary>,
    #[doc = "**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
    #[builder(default)]
    pub generate_summary: Option<ReasoningGenerateSummary>,
}
impl<'de> serde::Deserialize<'de> for ReasoningEffort {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Low(#[allow(dead_code)] ReasoningEffortLow),
            Medium(#[allow(dead_code)] ReasoningEffortMedium),
            High(#[allow(dead_code)] ReasoningEffortHigh),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Low(_) => Self::Low,
            _D::Medium(_) => Self::Medium,
            _D::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for ReasoningEffort {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Low(#[allow(dead_code)] &'a ReasoningEffortLow),
            Medium(#[allow(dead_code)] &'a ReasoningEffortMedium),
            High(#[allow(dead_code)] &'a ReasoningEffortHigh),
        }
        match self {
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Medium => _S::Medium(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "**o-series models only** \n\nConstrains effort on reasoning for \n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\nCurrently supported values are `low`, `medium`, and `high`. Reducing\nreasoning effort can result in faster responses and fewer tokens used\non reasoning in a response.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ReasoningEffort {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    #[default]
    Medium,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for ReasoningItemSummary {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the object. Always `summary_text`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemSummaryType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ReasoningItemSummaryType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(ReasoningItemSummary { text })
    }
}
impl serde::Serialize for ReasoningItemSummary {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the object. Always `summary_text`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemSummaryType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ReasoningItemSummaryType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let ReasoningItemSummary { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ReasoningItemSummary {
    #[doc = "A short summary of the reasoning used by the model when generating\nthe response.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ReasoningItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] ReasoningItemStatusInProgress),
            Completed(#[allow(dead_code)] ReasoningItemStatusCompleted),
            Incomplete(#[allow(dead_code)] ReasoningItemStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for ReasoningItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a ReasoningItemStatusInProgress),
            Completed(#[allow(dead_code)] &'a ReasoningItemStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a ReasoningItemStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ReasoningItemStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ReasoningItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the object. Always `reasoning`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemType {
            #[default]
            #[serde(rename = "reasoning")]
            Reasoning,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ReasoningItemType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "summary")]
            #[allow(dead_code)]
            summary: Vec<ReasoningItemSummary>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<ReasoningItemStatus>,
        }
        let _D {
            id,
            summary,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ReasoningItem {
            id,
            summary,
            status,
        })
    }
}
impl serde::Serialize for ReasoningItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the object. Always `reasoning`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemType {
            #[default]
            #[serde(rename = "reasoning")]
            Reasoning,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ReasoningItemType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "summary")]
            summary: &'a Vec<ReasoningItemSummary>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<ReasoningItemStatus>,
        }
        let ReasoningItem {
            id,
            summary,
            status,
        } = self;
        _S {
            type_: &Default::default(),
            id,
            summary,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "A description of the chain of thought used by a reasoning model while generating\na response.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ReasoningItem {
    #[doc = "The unique identifier of the reasoning content.\n"]
    pub id: String,
    #[doc = "Reasoning text contents.\n"]
    pub summary: Vec<ReasoningItemSummary>,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<ReasoningItemStatus>,
}
impl<'de> serde::Deserialize<'de> for ResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Completed(#[allow(dead_code)] ResponseStatusCompleted),
            Failed(#[allow(dead_code)] ResponseStatusFailed),
            InProgress(#[allow(dead_code)] ResponseStatusInProgress),
            Incomplete(#[allow(dead_code)] ResponseStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Completed(_) => Self::Completed,
            _D::Failed(_) => Self::Failed,
            _D::InProgress(_) => Self::InProgress,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for ResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Completed(#[allow(dead_code)] &'a ResponseStatusCompleted),
            Failed(#[allow(dead_code)] &'a ResponseStatusFailed),
            InProgress(#[allow(dead_code)] &'a ResponseStatusInProgress),
            Incomplete(#[allow(dead_code)] &'a ResponseStatusIncomplete),
        }
        match self {
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the response generation. One of `completed`, `failed`, \n`in_progress`, or `incomplete`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseStatus {
    #[doc = "completed"]
    Completed,
    #[doc = "failed"]
    Failed,
    #[doc = "in_progress"]
    InProgress,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ResponseIncompleteDetailsReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteDetailsReasonMaxOutputTokens {
            #[default]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            MaxOutputTokens(#[allow(dead_code)] ResponseIncompleteDetailsReasonMaxOutputTokens),
            ContentFilter(#[allow(dead_code)] ResponseIncompleteDetailsReasonContentFilter),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::MaxOutputTokens(_) => Self::MaxOutputTokens,
            _D::ContentFilter(_) => Self::ContentFilter,
        })
    }
}
impl serde::Serialize for ResponseIncompleteDetailsReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteDetailsReasonMaxOutputTokens {
            #[default]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            MaxOutputTokens(#[allow(dead_code)] &'a ResponseIncompleteDetailsReasonMaxOutputTokens),
            ContentFilter(#[allow(dead_code)] &'a ResponseIncompleteDetailsReasonContentFilter),
        }
        match self {
            Self::MaxOutputTokens => _S::MaxOutputTokens(&Default::default()).serialize(serializer),
            Self::ContentFilter => _S::ContentFilter(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The reason why the response is incomplete."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseIncompleteDetailsReason {
    #[doc = "max_output_tokens"]
    MaxOutputTokens,
    #[doc = "content_filter"]
    ContentFilter,
}
impl<'de> serde::Deserialize<'de> for ResponseIncompleteDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: Option<ResponseIncompleteDetailsReason>,
        }
        let _D { reason, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseIncompleteDetails { reason })
    }
}
impl serde::Serialize for ResponseIncompleteDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<ResponseIncompleteDetailsReason>,
        }
        let ResponseIncompleteDetails { reason } = self;
        _S { reason }.serialize(serializer)
    }
}
#[doc = "Details about why the response is incomplete.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ResponseIncompleteDetails {
    #[doc = "The reason why the response is incomplete."]
    #[builder(default)]
    pub reason: Option<ResponseIncompleteDetailsReason>,
}
impl<'de> serde::Deserialize<'de> for Response {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type of this resource - always set to `response`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseObject {
            #[default]
            #[serde(rename = "response")]
            Response,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(flatten)]
            #[allow(dead_code)]
            model_response_properties: ModelResponseProperties,
            #[serde(flatten)]
            #[allow(dead_code)]
            response_properties: ResponseProperties,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ResponseObject,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<ResponseStatus>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: f64,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: ResponseError,
            #[serde(rename = "incomplete_details")]
            #[allow(dead_code)]
            incomplete_details: Option<ResponseIncompleteDetails>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Vec<OutputItem>,
            #[serde(rename = "output_text")]
            #[allow(dead_code)]
            output_text: Option<String>,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<ResponseUsage>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: bool,
        }
        let _D {
            model_response_properties,
            response_properties,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            output_text,
            usage,
            parallel_tool_calls,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Response {
            model_response_properties,
            response_properties,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            output_text,
            usage,
            parallel_tool_calls,
        })
    }
}
impl serde::Serialize for Response {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type of this resource - always set to `response`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseObject {
            #[default]
            #[serde(rename = "response")]
            Response,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(flatten)]
            model_response_properties: &'a ModelResponseProperties,
            #[serde(flatten)]
            response_properties: &'a ResponseProperties,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a ResponseObject,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<ResponseStatus>,
            #[serde(rename = "created_at")]
            created_at: &'a f64,
            #[serde(rename = "error")]
            error: &'a ResponseError,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<ResponseIncompleteDetails>,
            #[serde(rename = "output")]
            output: &'a Vec<OutputItem>,
            #[serde(rename = "output_text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_text: &'a Option<String>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<ResponseUsage>,
            #[serde(rename = "parallel_tool_calls")]
            parallel_tool_calls: &'a bool,
        }
        let Response {
            model_response_properties,
            response_properties,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            output_text,
            usage,
            parallel_tool_calls,
        } = self;
        _S {
            model_response_properties,
            response_properties,
            id,
            object: &Default::default(),
            status,
            created_at,
            error,
            incomplete_details,
            output,
            output_text,
            usage,
            parallel_tool_calls,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Response {
    #[builder(default)]
    pub model_response_properties: ModelResponseProperties,
    #[builder(default)]
    pub response_properties: ResponseProperties,
    #[doc = "Unique identifier for this Response.\n"]
    pub id: String,
    #[doc = "The status of the response generation. One of `completed`, `failed`, \n`in_progress`, or `incomplete`.\n"]
    #[builder(default)]
    pub status: Option<ResponseStatus>,
    #[doc = "Unix timestamp (in seconds) of when this Response was created.\n"]
    pub created_at: f64,
    pub error: ResponseError,
    #[doc = "Details about why the response is incomplete.\n"]
    #[builder(default)]
    pub incomplete_details: Option<ResponseIncompleteDetails>,
    #[doc = "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and \n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"]
    pub output: Vec<OutputItem>,
    #[doc = "SDK-only convenience property that contains the aggregated text output \nfrom all `output_text` items in the `output` array, if any are present. \nSupported in the Python and JavaScript SDKs.\n"]
    #[builder(default)]
    pub output_text: Option<String>,
    #[builder(default)]
    pub usage: Option<ResponseUsage>,
    #[doc = "Whether to allow the model to run tool calls in parallel.\n"]
    pub parallel_tool_calls: bool,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.audio.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioDeltaEventType {
            #[default]
            #[serde(rename = "response.audio.delta")]
            ResponseAudioDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseAudioDeltaEventType,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D { delta, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseAudioDeltaEvent { delta })
    }
}
impl serde::Serialize for ResponseAudioDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.audio.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioDeltaEventType {
            #[default]
            #[serde(rename = "response.audio.delta")]
            ResponseAudioDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseAudioDeltaEventType,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let ResponseAudioDeltaEvent { delta } = self;
        _S {
            type_: &Default::default(),
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a partial audio response."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseAudioDeltaEvent {
    #[doc = "A chunk of Base64 encoded response audio bytes.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.audio.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioDoneEventType {
            #[default]
            #[serde(rename = "response.audio.done")]
            ResponseAudioDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseAudioDoneEventType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(ResponseAudioDoneEvent {})
    }
}
impl serde::Serialize for ResponseAudioDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.audio.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioDoneEventType {
            #[default]
            #[serde(rename = "response.audio.done")]
            ResponseAudioDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseAudioDoneEventType,
        }
        let ResponseAudioDoneEvent {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the audio response is complete."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ResponseAudioDoneEvent {}
impl<'de> serde::Deserialize<'de> for ResponseAudioTranscriptDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.audio.transcript.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioTranscriptDeltaEventType {
            #[default]
            #[serde(rename = "response.audio.transcript.delta")]
            ResponseAudioTranscriptDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseAudioTranscriptDeltaEventType,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D { delta, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseAudioTranscriptDeltaEvent { delta })
    }
}
impl serde::Serialize for ResponseAudioTranscriptDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.audio.transcript.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioTranscriptDeltaEventType {
            #[default]
            #[serde(rename = "response.audio.transcript.delta")]
            ResponseAudioTranscriptDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseAudioTranscriptDeltaEventType,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let ResponseAudioTranscriptDeltaEvent { delta } = self;
        _S {
            type_: &Default::default(),
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a partial transcript of audio."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseAudioTranscriptDeltaEvent {
    #[doc = "The partial transcript of the audio response.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioTranscriptDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.audio.transcript.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioTranscriptDoneEventType {
            #[default]
            #[serde(rename = "response.audio.transcript.done")]
            ResponseAudioTranscriptDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseAudioTranscriptDoneEventType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(ResponseAudioTranscriptDoneEvent {})
    }
}
impl serde::Serialize for ResponseAudioTranscriptDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.audio.transcript.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioTranscriptDoneEventType {
            #[default]
            #[serde(rename = "response.audio.transcript.done")]
            ResponseAudioTranscriptDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseAudioTranscriptDoneEventType,
        }
        let ResponseAudioTranscriptDoneEvent {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the full audio transcript is completed."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ResponseAudioTranscriptDoneEvent {}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCodeDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.code.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCodeDeltaEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.code.delta")]
            ResponseCodeInterpreterCallCodeDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallCodeDeltaEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            output_index,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseCodeInterpreterCallCodeDeltaEvent {
            output_index,
            delta,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCodeDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.code.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCodeDeltaEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.code.delta")]
            ResponseCodeInterpreterCallCodeDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallCodeDeltaEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let ResponseCodeInterpreterCallCodeDeltaEvent {
            output_index,
            delta,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a partial code snippet is added by the code interpreter."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCodeDeltaEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    #[doc = "The partial code snippet added by the code interpreter.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCodeDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.code.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCodeDoneEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.code.done")]
            ResponseCodeInterpreterCallCodeDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallCodeDoneEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
        }
        let _D {
            output_index, code, ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseCodeInterpreterCallCodeDoneEvent { output_index, code })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCodeDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.code.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCodeDoneEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.code.done")]
            ResponseCodeInterpreterCallCodeDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallCodeDoneEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "code")]
            code: &'a String,
        }
        let ResponseCodeInterpreterCallCodeDoneEvent { output_index, code } = self;
        _S {
            type_: &Default::default(),
            output_index,
            code,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when code snippet output is finalized by the code interpreter."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCodeDoneEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    #[doc = "The final code snippet output by the code interpreter.\n"]
    pub code: String,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCompletedEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.completed")]
            ResponseCodeInterpreterCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallCompletedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "code_interpreter_call")]
            #[allow(dead_code)]
            code_interpreter_call: CodeInterpreterToolCall,
        }
        let _D {
            output_index,
            code_interpreter_call,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseCodeInterpreterCallCompletedEvent {
            output_index,
            code_interpreter_call,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCompletedEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.completed")]
            ResponseCodeInterpreterCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallCompletedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "code_interpreter_call")]
            code_interpreter_call: &'a CodeInterpreterToolCall,
        }
        let ResponseCodeInterpreterCallCompletedEvent {
            output_index,
            code_interpreter_call,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            code_interpreter_call,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the code interpreter call is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCompletedEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    pub code_interpreter_call: CodeInterpreterToolCall,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallInProgressEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.in_progress")]
            ResponseCodeInterpreterCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallInProgressEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "code_interpreter_call")]
            #[allow(dead_code)]
            code_interpreter_call: CodeInterpreterToolCall,
        }
        let _D {
            output_index,
            code_interpreter_call,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseCodeInterpreterCallInProgressEvent {
            output_index,
            code_interpreter_call,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallInProgressEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.in_progress")]
            ResponseCodeInterpreterCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallInProgressEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "code_interpreter_call")]
            code_interpreter_call: &'a CodeInterpreterToolCall,
        }
        let ResponseCodeInterpreterCallInProgressEvent {
            output_index,
            code_interpreter_call,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            code_interpreter_call,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a code interpreter call is in progress."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallInProgressEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    pub code_interpreter_call: CodeInterpreterToolCall,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallInterpretingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.interpreting`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallInterpretingEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.interpreting")]
            ResponseCodeInterpreterCallInterpreting,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallInterpretingEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "code_interpreter_call")]
            #[allow(dead_code)]
            code_interpreter_call: CodeInterpreterToolCall,
        }
        let _D {
            output_index,
            code_interpreter_call,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseCodeInterpreterCallInterpretingEvent {
            output_index,
            code_interpreter_call,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallInterpretingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.interpreting`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallInterpretingEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.interpreting")]
            ResponseCodeInterpreterCallInterpreting,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallInterpretingEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "code_interpreter_call")]
            code_interpreter_call: &'a CodeInterpreterToolCall,
        }
        let ResponseCodeInterpreterCallInterpretingEvent {
            output_index,
            code_interpreter_call,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            code_interpreter_call,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the code interpreter is actively interpreting the code snippet."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallInterpretingEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    pub code_interpreter_call: CodeInterpreterToolCall,
}
impl<'de> serde::Deserialize<'de> for ResponseCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCompletedEventType {
            #[default]
            #[serde(rename = "response.completed")]
            ResponseCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCompletedEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
        }
        let _D { response, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseCompletedEvent { response })
    }
}
impl serde::Serialize for ResponseCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCompletedEventType {
            #[default]
            #[serde(rename = "response.completed")]
            ResponseCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCompletedEventType,
            #[serde(rename = "response")]
            response: &'a Response,
        }
        let ResponseCompletedEvent { response } = self;
        _S {
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the model response is complete."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCompletedEvent {
    #[doc = "Properties of the completed response.\n"]
    pub response: Response,
}
impl<'de> serde::Deserialize<'de> for ResponseContentPartAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.content_part.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseContentPartAddedEventType {
            #[default]
            #[serde(rename = "response.content_part.added")]
            ResponseContentPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseContentPartAddedEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: OutputContent,
        }
        let _D {
            item_id,
            output_index,
            content_index,
            part,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseContentPartAddedEvent {
            item_id,
            output_index,
            content_index,
            part,
        })
    }
}
impl serde::Serialize for ResponseContentPartAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.content_part.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseContentPartAddedEventType {
            #[default]
            #[serde(rename = "response.content_part.added")]
            ResponseContentPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseContentPartAddedEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a OutputContent,
        }
        let ResponseContentPartAddedEvent {
            item_id,
            output_index,
            content_index,
            part,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a new content part is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseContentPartAddedEvent {
    #[doc = "The ID of the output item that the content part was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the content part was added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that was added.\n"]
    pub content_index: u64,
    #[doc = "The content part that was added.\n"]
    pub part: OutputContent,
}
impl<'de> serde::Deserialize<'de> for ResponseContentPartDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.content_part.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseContentPartDoneEventType {
            #[default]
            #[serde(rename = "response.content_part.done")]
            ResponseContentPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseContentPartDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: OutputContent,
        }
        let _D {
            item_id,
            output_index,
            content_index,
            part,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseContentPartDoneEvent {
            item_id,
            output_index,
            content_index,
            part,
        })
    }
}
impl serde::Serialize for ResponseContentPartDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.content_part.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseContentPartDoneEventType {
            #[default]
            #[serde(rename = "response.content_part.done")]
            ResponseContentPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseContentPartDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a OutputContent,
        }
        let ResponseContentPartDoneEvent {
            item_id,
            output_index,
            content_index,
            part,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a content part is done."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseContentPartDoneEvent {
    #[doc = "The ID of the output item that the content part was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the content part was added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that is done.\n"]
    pub content_index: u64,
    #[doc = "The content part that is done.\n"]
    pub part: OutputContent,
}
impl<'de> serde::Deserialize<'de> for ResponseCreatedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.created`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCreatedEventType {
            #[default]
            #[serde(rename = "response.created")]
            ResponseCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCreatedEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
        }
        let _D { response, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseCreatedEvent { response })
    }
}
impl serde::Serialize for ResponseCreatedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.created`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCreatedEventType {
            #[default]
            #[serde(rename = "response.created")]
            ResponseCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCreatedEventType,
            #[serde(rename = "response")]
            response: &'a Response,
        }
        let ResponseCreatedEvent { response } = self;
        _S {
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "An event that is emitted when a response is created.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCreatedEvent {
    #[doc = "The response that was created.\n"]
    pub response: Response,
}
impl<'de> serde::Deserialize<'de> for ResponseError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: ResponseErrorCode,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let _D { code, message, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseError { code, message })
    }
}
impl serde::Serialize for ResponseError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            code: &'a ResponseErrorCode,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let ResponseError { code, message } = self;
        _S { code, message }.serialize(serializer)
    }
}
#[doc = "An error object returned when the model fails to generate a Response.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseError {
    pub code: ResponseErrorCode,
    #[doc = "A human-readable description of the error.\n"]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for ResponseErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidPrompt {
            #[default]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeVectorStoreTimeout {
            #[default]
            #[serde(rename = "vector_store_timeout")]
            VectorStoreTimeout,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImage {
            #[default]
            #[serde(rename = "invalid_image")]
            InvalidImage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageFormat {
            #[default]
            #[serde(rename = "invalid_image_format")]
            InvalidImageFormat,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidBase64Image {
            #[default]
            #[serde(rename = "invalid_base64_image")]
            InvalidBase64Image,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageUrl {
            #[default]
            #[serde(rename = "invalid_image_url")]
            InvalidImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageTooLarge {
            #[default]
            #[serde(rename = "image_too_large")]
            ImageTooLarge,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageTooSmall {
            #[default]
            #[serde(rename = "image_too_small")]
            ImageTooSmall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageParseError {
            #[default]
            #[serde(rename = "image_parse_error")]
            ImageParseError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageContentPolicyViolation {
            #[default]
            #[serde(rename = "image_content_policy_violation")]
            ImageContentPolicyViolation,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageMode {
            #[default]
            #[serde(rename = "invalid_image_mode")]
            InvalidImageMode,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageFileTooLarge {
            #[default]
            #[serde(rename = "image_file_too_large")]
            ImageFileTooLarge,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeUnsupportedImageMediaType {
            #[default]
            #[serde(rename = "unsupported_image_media_type")]
            UnsupportedImageMediaType,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeEmptyImageFile {
            #[default]
            #[serde(rename = "empty_image_file")]
            EmptyImageFile,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeFailedToDownloadImage {
            #[default]
            #[serde(rename = "failed_to_download_image")]
            FailedToDownloadImage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageFileNotFound {
            #[default]
            #[serde(rename = "image_file_not_found")]
            ImageFileNotFound,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ServerError(#[allow(dead_code)] ResponseErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] ResponseErrorCodeRateLimitExceeded),
            InvalidPrompt(#[allow(dead_code)] ResponseErrorCodeInvalidPrompt),
            VectorStoreTimeout(#[allow(dead_code)] ResponseErrorCodeVectorStoreTimeout),
            InvalidImage(#[allow(dead_code)] ResponseErrorCodeInvalidImage),
            InvalidImageFormat(#[allow(dead_code)] ResponseErrorCodeInvalidImageFormat),
            InvalidBase64Image(#[allow(dead_code)] ResponseErrorCodeInvalidBase64Image),
            InvalidImageUrl(#[allow(dead_code)] ResponseErrorCodeInvalidImageUrl),
            ImageTooLarge(#[allow(dead_code)] ResponseErrorCodeImageTooLarge),
            ImageTooSmall(#[allow(dead_code)] ResponseErrorCodeImageTooSmall),
            ImageParseError(#[allow(dead_code)] ResponseErrorCodeImageParseError),
            ImageContentPolicyViolation(
                #[allow(dead_code)] ResponseErrorCodeImageContentPolicyViolation,
            ),
            InvalidImageMode(#[allow(dead_code)] ResponseErrorCodeInvalidImageMode),
            ImageFileTooLarge(#[allow(dead_code)] ResponseErrorCodeImageFileTooLarge),
            UnsupportedImageMediaType(
                #[allow(dead_code)] ResponseErrorCodeUnsupportedImageMediaType,
            ),
            EmptyImageFile(#[allow(dead_code)] ResponseErrorCodeEmptyImageFile),
            FailedToDownloadImage(#[allow(dead_code)] ResponseErrorCodeFailedToDownloadImage),
            ImageFileNotFound(#[allow(dead_code)] ResponseErrorCodeImageFileNotFound),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ServerError(_) => Self::ServerError,
            _D::RateLimitExceeded(_) => Self::RateLimitExceeded,
            _D::InvalidPrompt(_) => Self::InvalidPrompt,
            _D::VectorStoreTimeout(_) => Self::VectorStoreTimeout,
            _D::InvalidImage(_) => Self::InvalidImage,
            _D::InvalidImageFormat(_) => Self::InvalidImageFormat,
            _D::InvalidBase64Image(_) => Self::InvalidBase64Image,
            _D::InvalidImageUrl(_) => Self::InvalidImageUrl,
            _D::ImageTooLarge(_) => Self::ImageTooLarge,
            _D::ImageTooSmall(_) => Self::ImageTooSmall,
            _D::ImageParseError(_) => Self::ImageParseError,
            _D::ImageContentPolicyViolation(_) => Self::ImageContentPolicyViolation,
            _D::InvalidImageMode(_) => Self::InvalidImageMode,
            _D::ImageFileTooLarge(_) => Self::ImageFileTooLarge,
            _D::UnsupportedImageMediaType(_) => Self::UnsupportedImageMediaType,
            _D::EmptyImageFile(_) => Self::EmptyImageFile,
            _D::FailedToDownloadImage(_) => Self::FailedToDownloadImage,
            _D::ImageFileNotFound(_) => Self::ImageFileNotFound,
        })
    }
}
impl serde::Serialize for ResponseErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidPrompt {
            #[default]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeVectorStoreTimeout {
            #[default]
            #[serde(rename = "vector_store_timeout")]
            VectorStoreTimeout,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImage {
            #[default]
            #[serde(rename = "invalid_image")]
            InvalidImage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageFormat {
            #[default]
            #[serde(rename = "invalid_image_format")]
            InvalidImageFormat,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidBase64Image {
            #[default]
            #[serde(rename = "invalid_base64_image")]
            InvalidBase64Image,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageUrl {
            #[default]
            #[serde(rename = "invalid_image_url")]
            InvalidImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageTooLarge {
            #[default]
            #[serde(rename = "image_too_large")]
            ImageTooLarge,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageTooSmall {
            #[default]
            #[serde(rename = "image_too_small")]
            ImageTooSmall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageParseError {
            #[default]
            #[serde(rename = "image_parse_error")]
            ImageParseError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageContentPolicyViolation {
            #[default]
            #[serde(rename = "image_content_policy_violation")]
            ImageContentPolicyViolation,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageMode {
            #[default]
            #[serde(rename = "invalid_image_mode")]
            InvalidImageMode,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageFileTooLarge {
            #[default]
            #[serde(rename = "image_file_too_large")]
            ImageFileTooLarge,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeUnsupportedImageMediaType {
            #[default]
            #[serde(rename = "unsupported_image_media_type")]
            UnsupportedImageMediaType,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeEmptyImageFile {
            #[default]
            #[serde(rename = "empty_image_file")]
            EmptyImageFile,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeFailedToDownloadImage {
            #[default]
            #[serde(rename = "failed_to_download_image")]
            FailedToDownloadImage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageFileNotFound {
            #[default]
            #[serde(rename = "image_file_not_found")]
            ImageFileNotFound,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ServerError(#[allow(dead_code)] &'a ResponseErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] &'a ResponseErrorCodeRateLimitExceeded),
            InvalidPrompt(#[allow(dead_code)] &'a ResponseErrorCodeInvalidPrompt),
            VectorStoreTimeout(#[allow(dead_code)] &'a ResponseErrorCodeVectorStoreTimeout),
            InvalidImage(#[allow(dead_code)] &'a ResponseErrorCodeInvalidImage),
            InvalidImageFormat(#[allow(dead_code)] &'a ResponseErrorCodeInvalidImageFormat),
            InvalidBase64Image(#[allow(dead_code)] &'a ResponseErrorCodeInvalidBase64Image),
            InvalidImageUrl(#[allow(dead_code)] &'a ResponseErrorCodeInvalidImageUrl),
            ImageTooLarge(#[allow(dead_code)] &'a ResponseErrorCodeImageTooLarge),
            ImageTooSmall(#[allow(dead_code)] &'a ResponseErrorCodeImageTooSmall),
            ImageParseError(#[allow(dead_code)] &'a ResponseErrorCodeImageParseError),
            ImageContentPolicyViolation(
                #[allow(dead_code)] &'a ResponseErrorCodeImageContentPolicyViolation,
            ),
            InvalidImageMode(#[allow(dead_code)] &'a ResponseErrorCodeInvalidImageMode),
            ImageFileTooLarge(#[allow(dead_code)] &'a ResponseErrorCodeImageFileTooLarge),
            UnsupportedImageMediaType(
                #[allow(dead_code)] &'a ResponseErrorCodeUnsupportedImageMediaType,
            ),
            EmptyImageFile(#[allow(dead_code)] &'a ResponseErrorCodeEmptyImageFile),
            FailedToDownloadImage(#[allow(dead_code)] &'a ResponseErrorCodeFailedToDownloadImage),
            ImageFileNotFound(#[allow(dead_code)] &'a ResponseErrorCodeImageFileNotFound),
        }
        match self {
            Self::ServerError => _S::ServerError(&Default::default()).serialize(serializer),
            Self::RateLimitExceeded => {
                _S::RateLimitExceeded(&Default::default()).serialize(serializer)
            }
            Self::InvalidPrompt => _S::InvalidPrompt(&Default::default()).serialize(serializer),
            Self::VectorStoreTimeout => {
                _S::VectorStoreTimeout(&Default::default()).serialize(serializer)
            }
            Self::InvalidImage => _S::InvalidImage(&Default::default()).serialize(serializer),
            Self::InvalidImageFormat => {
                _S::InvalidImageFormat(&Default::default()).serialize(serializer)
            }
            Self::InvalidBase64Image => {
                _S::InvalidBase64Image(&Default::default()).serialize(serializer)
            }
            Self::InvalidImageUrl => _S::InvalidImageUrl(&Default::default()).serialize(serializer),
            Self::ImageTooLarge => _S::ImageTooLarge(&Default::default()).serialize(serializer),
            Self::ImageTooSmall => _S::ImageTooSmall(&Default::default()).serialize(serializer),
            Self::ImageParseError => _S::ImageParseError(&Default::default()).serialize(serializer),
            Self::ImageContentPolicyViolation => {
                _S::ImageContentPolicyViolation(&Default::default()).serialize(serializer)
            }
            Self::InvalidImageMode => {
                _S::InvalidImageMode(&Default::default()).serialize(serializer)
            }
            Self::ImageFileTooLarge => {
                _S::ImageFileTooLarge(&Default::default()).serialize(serializer)
            }
            Self::UnsupportedImageMediaType => {
                _S::UnsupportedImageMediaType(&Default::default()).serialize(serializer)
            }
            Self::EmptyImageFile => _S::EmptyImageFile(&Default::default()).serialize(serializer),
            Self::FailedToDownloadImage => {
                _S::FailedToDownloadImage(&Default::default()).serialize(serializer)
            }
            Self::ImageFileNotFound => {
                _S::ImageFileNotFound(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The error code for the response.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseErrorCode {
    #[doc = "server_error"]
    ServerError,
    #[doc = "rate_limit_exceeded"]
    RateLimitExceeded,
    #[doc = "invalid_prompt"]
    InvalidPrompt,
    #[doc = "vector_store_timeout"]
    VectorStoreTimeout,
    #[doc = "invalid_image"]
    InvalidImage,
    #[doc = "invalid_image_format"]
    InvalidImageFormat,
    #[doc = "invalid_base64_image"]
    InvalidBase64Image,
    #[doc = "invalid_image_url"]
    InvalidImageUrl,
    #[doc = "image_too_large"]
    ImageTooLarge,
    #[doc = "image_too_small"]
    ImageTooSmall,
    #[doc = "image_parse_error"]
    ImageParseError,
    #[doc = "image_content_policy_violation"]
    ImageContentPolicyViolation,
    #[doc = "invalid_image_mode"]
    InvalidImageMode,
    #[doc = "image_file_too_large"]
    ImageFileTooLarge,
    #[doc = "unsupported_image_media_type"]
    UnsupportedImageMediaType,
    #[doc = "empty_image_file"]
    EmptyImageFile,
    #[doc = "failed_to_download_image"]
    FailedToDownloadImage,
    #[doc = "image_file_not_found"]
    ImageFileNotFound,
}
impl<'de> serde::Deserialize<'de> for ResponseErrorEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `error`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorEventType {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseErrorEventType,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
        }
        let _D {
            code,
            message,
            param,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseErrorEvent {
            code,
            message,
            param,
        })
    }
}
impl serde::Serialize for ResponseErrorEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `error`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorEventType {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseErrorEventType,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
        }
        let ResponseErrorEvent {
            code,
            message,
            param,
        } = self;
        _S {
            type_: &Default::default(),
            code,
            message,
            param,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an error occurs."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseErrorEvent {
    #[doc = "The error code.\n"]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "The error message.\n"]
    pub message: String,
    #[doc = "The error parameter.\n"]
    #[builder(default)]
    pub param: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ResponseFailedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.failed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFailedEventType {
            #[default]
            #[serde(rename = "response.failed")]
            ResponseFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFailedEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
        }
        let _D { response, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseFailedEvent { response })
    }
}
impl serde::Serialize for ResponseFailedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.failed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFailedEventType {
            #[default]
            #[serde(rename = "response.failed")]
            ResponseFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFailedEventType,
            #[serde(rename = "response")]
            response: &'a Response,
        }
        let ResponseFailedEvent { response } = self;
        _S {
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "An event that is emitted when a response fails.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFailedEvent {
    #[doc = "The response that failed.\n"]
    pub response: Response,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.file_search_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallCompletedEventType {
            #[default]
            #[serde(rename = "response.file_search_call.completed")]
            ResponseFileSearchCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFileSearchCallCompletedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            output_index,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseFileSearchCallCompletedEvent {
            output_index,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.file_search_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallCompletedEventType {
            #[default]
            #[serde(rename = "response.file_search_call.completed")]
            ResponseFileSearchCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFileSearchCallCompletedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let ResponseFileSearchCallCompletedEvent {
            output_index,
            item_id,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a file search call is completed (results found)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallCompletedEvent {
    #[doc = "The index of the output item that the file search call is initiated.\n"]
    pub output_index: u64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.file_search_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallInProgressEventType {
            #[default]
            #[serde(rename = "response.file_search_call.in_progress")]
            ResponseFileSearchCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFileSearchCallInProgressEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            output_index,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseFileSearchCallInProgressEvent {
            output_index,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.file_search_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallInProgressEventType {
            #[default]
            #[serde(rename = "response.file_search_call.in_progress")]
            ResponseFileSearchCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFileSearchCallInProgressEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let ResponseFileSearchCallInProgressEvent {
            output_index,
            item_id,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a file search call is initiated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallInProgressEvent {
    #[doc = "The index of the output item that the file search call is initiated.\n"]
    pub output_index: u64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallSearchingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.file_search_call.searching`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallSearchingEventType {
            #[default]
            #[serde(rename = "response.file_search_call.searching")]
            ResponseFileSearchCallSearching,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFileSearchCallSearchingEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            output_index,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseFileSearchCallSearchingEvent {
            output_index,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallSearchingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.file_search_call.searching`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallSearchingEventType {
            #[default]
            #[serde(rename = "response.file_search_call.searching")]
            ResponseFileSearchCallSearching,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFileSearchCallSearchingEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let ResponseFileSearchCallSearchingEvent {
            output_index,
            item_id,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a file search is currently searching."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallSearchingEvent {
    #[doc = "The index of the output item that the file search call is searching.\n"]
    pub output_index: u64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseFormatJsonObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of response format being defined. Always `json_object`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatJsonObjectType {
            #[default]
            #[serde(rename = "json_object")]
            JsonObject,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFormatJsonObjectType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(ResponseFormatJsonObject {})
    }
}
impl serde::Serialize for ResponseFormatJsonObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of response format being defined. Always `json_object`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatJsonObjectType {
            #[default]
            #[serde(rename = "json_object")]
            JsonObject,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFormatJsonObjectType,
        }
        let ResponseFormatJsonObject {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "JSON object response format. An older method of generating JSON responses.\nUsing `json_schema` is recommended for models that support it. Note that the\nmodel will not generate JSON without a system or user message instructing it\nto do so.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ResponseFormatJsonObject {}
impl<'de> serde::Deserialize<'de> for ResponseFormatJsonSchemaJsonSchema {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: Option<ResponseFormatJsonSchemaSchema>,
            #[serde(rename = "strict")]
            #[allow(dead_code)]
            strict: Option<bool>,
        }
        let _D {
            description,
            name,
            schema,
            strict,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseFormatJsonSchemaJsonSchema {
            description,
            name,
            schema,
            strict,
        })
    }
}
impl serde::Serialize for ResponseFormatJsonSchemaJsonSchema {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "schema")]
            #[serde(skip_serializing_if = "Option::is_none")]
            schema: &'a Option<ResponseFormatJsonSchemaSchema>,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let ResponseFormatJsonSchemaJsonSchema {
            description,
            name,
            schema,
            strict,
        } = self;
        _S {
            description,
            name,
            schema,
            strict,
        }
        .serialize(serializer)
    }
}
#[doc = "Structured Outputs configuration options, including a JSON Schema.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatJsonSchemaJsonSchema {
    #[doc = "A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n"]
    pub name: String,
    #[builder(default)]
    pub schema: Option<ResponseFormatJsonSchemaSchema>,
    #[doc = "Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](/docs/guides/structured-outputs).\n"]
    #[builder(default)]
    pub strict: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ResponseFormatJsonSchema {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of response format being defined. Always `json_schema`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatJsonSchemaType {
            #[default]
            #[serde(rename = "json_schema")]
            JsonSchema,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFormatJsonSchemaType,
            #[serde(rename = "json_schema")]
            #[allow(dead_code)]
            json_schema: ResponseFormatJsonSchemaJsonSchema,
        }
        let _D { json_schema, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseFormatJsonSchema { json_schema })
    }
}
impl serde::Serialize for ResponseFormatJsonSchema {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of response format being defined. Always `json_schema`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatJsonSchemaType {
            #[default]
            #[serde(rename = "json_schema")]
            JsonSchema,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFormatJsonSchemaType,
            #[serde(rename = "json_schema")]
            json_schema: &'a ResponseFormatJsonSchemaJsonSchema,
        }
        let ResponseFormatJsonSchema { json_schema } = self;
        _S {
            type_: &Default::default(),
            json_schema,
        }
        .serialize(serializer)
    }
}
#[doc = "JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](/docs/guides/structured-outputs).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatJsonSchema {
    #[doc = "Structured Outputs configuration options, including a JSON Schema.\n"]
    pub json_schema: ResponseFormatJsonSchemaJsonSchema,
}
#[doc = "The schema for the response format, described as a JSON Schema object.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
pub type ResponseFormatJsonSchemaSchema = std::collections::HashMap<String, serde_json::Value>;
impl<'de> serde::Deserialize<'de> for ResponseFormatText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of response format being defined. Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatTextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFormatTextType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(ResponseFormatText {})
    }
}
impl serde::Serialize for ResponseFormatText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of response format being defined. Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatTextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFormatTextType,
        }
        let ResponseFormatText {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Default response format. Used to generate text responses.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ResponseFormatText {}
impl<'de> serde::Deserialize<'de> for ResponseFunctionCallArgumentsDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.function_call_arguments.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFunctionCallArgumentsDeltaEventType {
            #[default]
            #[serde(rename = "response.function_call_arguments.delta")]
            ResponseFunctionCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFunctionCallArgumentsDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            item_id,
            output_index,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseFunctionCallArgumentsDeltaEvent {
            item_id,
            output_index,
            delta,
        })
    }
}
impl serde::Serialize for ResponseFunctionCallArgumentsDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.function_call_arguments.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFunctionCallArgumentsDeltaEventType {
            #[default]
            #[serde(rename = "response.function_call_arguments.delta")]
            ResponseFunctionCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFunctionCallArgumentsDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let ResponseFunctionCallArgumentsDeltaEvent {
            item_id,
            output_index,
            delta,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a partial function-call arguments delta."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFunctionCallArgumentsDeltaEvent {
    #[doc = "The ID of the output item that the function-call arguments delta is added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the function-call arguments delta is added to.\n"]
    pub output_index: u64,
    #[doc = "The function-call arguments delta that is added.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseFunctionCallArgumentsDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFunctionCallArgumentsDoneEventType {
            #[default]
            #[serde(rename = "response.function_call_arguments.done")]
            ResponseFunctionCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFunctionCallArgumentsDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let _D {
            item_id,
            output_index,
            arguments,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseFunctionCallArgumentsDoneEvent {
            item_id,
            output_index,
            arguments,
        })
    }
}
impl serde::Serialize for ResponseFunctionCallArgumentsDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFunctionCallArgumentsDoneEventType {
            #[default]
            #[serde(rename = "response.function_call_arguments.done")]
            ResponseFunctionCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFunctionCallArgumentsDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let ResponseFunctionCallArgumentsDoneEvent {
            item_id,
            output_index,
            arguments,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            arguments,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when function-call arguments are finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFunctionCallArgumentsDoneEvent {
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item."]
    pub output_index: u64,
    #[doc = "The function-call arguments."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for ResponseInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseInProgressEventType {
            #[default]
            #[serde(rename = "response.in_progress")]
            ResponseInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseInProgressEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
        }
        let _D { response, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseInProgressEvent { response })
    }
}
impl serde::Serialize for ResponseInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseInProgressEventType {
            #[default]
            #[serde(rename = "response.in_progress")]
            ResponseInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseInProgressEventType,
            #[serde(rename = "response")]
            response: &'a Response,
        }
        let ResponseInProgressEvent { response } = self;
        _S {
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the response is in progress."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseInProgressEvent {
    #[doc = "The response that is in progress.\n"]
    pub response: Response,
}
impl<'de> serde::Deserialize<'de> for ResponseIncompleteEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.incomplete`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteEventType {
            #[default]
            #[serde(rename = "response.incomplete")]
            ResponseIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseIncompleteEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
        }
        let _D { response, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseIncompleteEvent { response })
    }
}
impl serde::Serialize for ResponseIncompleteEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.incomplete`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteEventType {
            #[default]
            #[serde(rename = "response.incomplete")]
            ResponseIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseIncompleteEventType,
            #[serde(rename = "response")]
            response: &'a Response,
        }
        let ResponseIncompleteEvent { response } = self;
        _S {
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "An event that is emitted when a response finishes as incomplete.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseIncompleteEvent {
    #[doc = "The response that was incomplete.\n"]
    pub response: Response,
}
impl<'de> serde::Deserialize<'de> for ResponseItemList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of object returned, must be `list`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseItemListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ResponseItemListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ItemResource>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
        }
        let _D {
            data,
            has_more,
            first_id,
            last_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseItemList {
            data,
            has_more,
            first_id,
            last_id,
        })
    }
}
impl serde::Serialize for ResponseItemList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of object returned, must be `list`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseItemListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a ResponseItemListObject,
            #[serde(rename = "data")]
            data: &'a Vec<ItemResource>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
        }
        let ResponseItemList {
            data,
            has_more,
            first_id,
            last_id,
        } = self;
        _S {
            object: &Default::default(),
            data,
            has_more,
            first_id,
            last_id,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of Response items."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseItemList {
    #[doc = "A list of items used to generate this response."]
    pub data: Vec<ItemResource>,
    #[doc = "Whether there are more items available."]
    pub has_more: bool,
    #[doc = "The ID of the first item in the list."]
    pub first_id: String,
    #[doc = "The ID of the last item in the list."]
    pub last_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] ResponseModalityText),
            Audio(#[allow(dead_code)] ResponseModalityAudio),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_) => Self::Text,
            _D::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for ResponseModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a ResponseModalityText),
            Audio(#[allow(dead_code)] &'a ResponseModalityAudio),
        }
        match self {
            Self::Text => _S::Text(&Default::default()).serialize(serializer),
            Self::Audio => _S::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
#[doc = "Output types that you would like the model to generate.\nMost models are capable of generating text, which is the default:\n\n`[\"text\"]`\n\nThe `gpt-4o-audio-preview` model can also be used to \n[generate audio](/docs/guides/audio). To request that this model generate \nboth text and audio responses, you can use:\n\n`[\"text\", \"audio\"]`\n"]
pub type ResponseModalities = Vec<ResponseModality>;
impl<'de> serde::Deserialize<'de> for ResponseOutputItemAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_item.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputItemAddedEventType {
            #[default]
            #[serde(rename = "response.output_item.added")]
            ResponseOutputItemAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseOutputItemAddedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: OutputItem,
        }
        let _D {
            output_index, item, ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseOutputItemAddedEvent { output_index, item })
    }
}
impl serde::Serialize for ResponseOutputItemAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_item.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputItemAddedEventType {
            #[default]
            #[serde(rename = "response.output_item.added")]
            ResponseOutputItemAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseOutputItemAddedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item")]
            item: &'a OutputItem,
        }
        let ResponseOutputItemAddedEvent { output_index, item } = self;
        _S {
            type_: &Default::default(),
            output_index,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a new output item is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseOutputItemAddedEvent {
    #[doc = "The index of the output item that was added.\n"]
    pub output_index: u64,
    #[doc = "The output item that was added.\n"]
    pub item: OutputItem,
}
impl<'de> serde::Deserialize<'de> for ResponseOutputItemDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_item.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputItemDoneEventType {
            #[default]
            #[serde(rename = "response.output_item.done")]
            ResponseOutputItemDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseOutputItemDoneEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: OutputItem,
        }
        let _D {
            output_index, item, ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseOutputItemDoneEvent { output_index, item })
    }
}
impl serde::Serialize for ResponseOutputItemDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_item.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputItemDoneEventType {
            #[default]
            #[serde(rename = "response.output_item.done")]
            ResponseOutputItemDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseOutputItemDoneEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item")]
            item: &'a OutputItem,
        }
        let ResponseOutputItemDoneEvent { output_index, item } = self;
        _S {
            type_: &Default::default(),
            output_index,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an output item is marked done."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseOutputItemDoneEvent {
    #[doc = "The index of the output item that was marked done.\n"]
    pub output_index: u64,
    #[doc = "The output item that was marked done.\n"]
    pub item: OutputItem,
}
impl<'de> serde::Deserialize<'de> for ResponsePropertiesText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: Option<TextResponseFormatConfiguration>,
        }
        let _D { format, .. } = _D::deserialize(deserializer)?;
        Ok(ResponsePropertiesText { format })
    }
}
impl serde::Serialize for ResponsePropertiesText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            format: &'a Option<TextResponseFormatConfiguration>,
        }
        let ResponsePropertiesText { format } = self;
        _S { format }.serialize(serializer)
    }
}
#[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](/docs/guides/text)\n- [Structured Outputs](/docs/guides/structured-outputs)\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ResponsePropertiesText {
    #[builder(default)]
    pub format: Option<TextResponseFormatConfiguration>,
}
impl<'de> serde::Deserialize<'de> for ResponsePropertiesToolChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ToolChoiceOptions(#[allow(dead_code)] ToolChoiceOptions),
            ToolChoiceTypes(#[allow(dead_code)] ToolChoiceTypes),
            ToolChoiceFunction(#[allow(dead_code)] ToolChoiceFunction),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ToolChoiceOptions(_v) => Self::ToolChoiceOptions(_v),
            _D::ToolChoiceTypes(_v) => Self::ToolChoiceTypes(_v),
            _D::ToolChoiceFunction(_v) => Self::ToolChoiceFunction(_v),
        })
    }
}
impl serde::Serialize for ResponsePropertiesToolChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ToolChoiceOptions(#[allow(dead_code)] &'a ToolChoiceOptions),
            ToolChoiceTypes(#[allow(dead_code)] &'a ToolChoiceTypes),
            ToolChoiceFunction(#[allow(dead_code)] &'a ToolChoiceFunction),
        }
        match self {
            Self::ToolChoiceOptions(_v) => _S::ToolChoiceOptions(_v).serialize(serializer),
            Self::ToolChoiceTypes(_v) => _S::ToolChoiceTypes(_v).serialize(serializer),
            Self::ToolChoiceFunction(_v) => _S::ToolChoiceFunction(_v).serialize(serializer),
        }
    }
}
#[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ResponsePropertiesToolChoice {
    ToolChoiceOptions(ToolChoiceOptions),
    ToolChoiceTypes(ToolChoiceTypes),
    ToolChoiceFunction(ToolChoiceFunction),
}
impl<'de> serde::Deserialize<'de> for ResponsePropertiesTruncation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponsePropertiesTruncationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponsePropertiesTruncationDisabled {
            #[default]
            #[serde(rename = "disabled")]
            Disabled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] ResponsePropertiesTruncationAuto),
            Disabled(#[allow(dead_code)] ResponsePropertiesTruncationDisabled),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Disabled(_) => Self::Disabled,
        })
    }
}
impl serde::Serialize for ResponsePropertiesTruncation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponsePropertiesTruncationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponsePropertiesTruncationDisabled {
            #[default]
            #[serde(rename = "disabled")]
            Disabled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a ResponsePropertiesTruncationAuto),
            Disabled(#[allow(dead_code)] &'a ResponsePropertiesTruncationDisabled),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Disabled => _S::Disabled(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the \n  response to fit the context window by dropping input items in the\n  middle of the conversation. \n- `disabled` (default): If a model response will exceed the context window \n  size for a model, the request will fail with a 400 error.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ResponsePropertiesTruncation {
    #[doc = "auto"]
    Auto,
    #[doc = "disabled"]
    #[default]
    Disabled,
}
impl<'de> serde::Deserialize<'de> for ResponseProperties {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "previous_response_id")]
            #[allow(dead_code)]
            previous_response_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<ModelIdsResponses>,
            #[serde(rename = "reasoning")]
            #[allow(dead_code)]
            reasoning: Option<Reasoning>,
            #[serde(rename = "max_output_tokens")]
            #[allow(dead_code)]
            max_output_tokens: Option<u64>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<ResponsePropertiesText>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<Tool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<ResponsePropertiesToolChoice>,
            #[serde(rename = "truncation")]
            #[allow(dead_code)]
            truncation: Option<ResponsePropertiesTruncation>,
        }
        let _D {
            previous_response_id,
            model,
            reasoning,
            max_output_tokens,
            instructions,
            text,
            tools,
            tool_choice,
            truncation,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseProperties {
            previous_response_id,
            model,
            reasoning,
            max_output_tokens,
            instructions,
            text,
            tools,
            tool_choice,
            truncation,
        })
    }
}
impl serde::Serialize for ResponseProperties {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "previous_response_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            previous_response_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<ModelIdsResponses>,
            #[serde(rename = "reasoning")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning: &'a Option<Reasoning>,
            #[serde(rename = "max_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_output_tokens: &'a Option<u64>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<ResponsePropertiesText>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<Tool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<ResponsePropertiesToolChoice>,
            #[serde(rename = "truncation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation: &'a Option<ResponsePropertiesTruncation>,
        }
        let ResponseProperties {
            previous_response_id,
            model,
            reasoning,
            max_output_tokens,
            instructions,
            text,
            tools,
            tool_choice,
            truncation,
        } = self;
        _S {
            previous_response_id,
            model,
            reasoning,
            max_output_tokens,
            instructions,
            text,
            tools,
            tool_choice,
            truncation,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ResponseProperties {
    #[doc = "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about \n[conversation state](/docs/guides/conversation-state).\n"]
    #[builder(default)]
    pub previous_response_id: Option<String>,
    #[doc = "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](/docs/models)\nto browse and compare available models.\n"]
    #[builder(default)]
    pub model: Option<ModelIdsResponses>,
    #[builder(default)]
    pub reasoning: Option<Reasoning>,
    #[doc = "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](/docs/guides/reasoning).\n"]
    #[builder(default)]
    pub max_output_tokens: Option<u64>,
    #[doc = "Inserts a system (or developer) message as the first item in the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](/docs/guides/text)\n- [Structured Outputs](/docs/guides/structured-outputs)\n"]
    #[builder(default)]
    pub text: Option<ResponsePropertiesText>,
    #[doc = "An array of tools the model may call while generating a response. You \ncan specify which tool to use by setting the `tool_choice` parameter.\n\nThe two categories of tools you can provide the model are:\n\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](/docs/guides/tools-web-search)\n  or [file search](/docs/guides/tools-file-search). Learn more about\n  [built-in tools](/docs/guides/tools).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code. Learn more about\n  [function calling](/docs/guides/function-calling).\n"]
    #[builder(default)]
    pub tools: Option<Vec<Tool>>,
    #[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
    #[builder(default)]
    pub tool_choice: Option<ResponsePropertiesToolChoice>,
    #[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the \n  response to fit the context window by dropping input items in the\n  middle of the conversation. \n- `disabled` (default): If a model response will exceed the context window \n  size for a model, the request will fail with a 400 error.\n"]
    #[builder(default)]
    pub truncation: Option<ResponsePropertiesTruncation>,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartAddedEventPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartAddedEventPartType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryPartAddedEventPartType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseReasoningSummaryPartAddedEventPart { text })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartAddedEventPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartAddedEventPartType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryPartAddedEventPartType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let ResponseReasoningSummaryPartAddedEventPart { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The summary part that was added.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartAddedEventPart {
    #[doc = "The text of the summary part."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_part.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartAddedEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_part.added")]
            ResponseReasoningSummaryPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryPartAddedEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: ResponseReasoningSummaryPartAddedEventPart,
        }
        let _D {
            item_id,
            output_index,
            summary_index,
            part,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseReasoningSummaryPartAddedEvent {
            item_id,
            output_index,
            summary_index,
            part,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_part.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartAddedEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_part.added")]
            ResponseReasoningSummaryPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryPartAddedEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a ResponseReasoningSummaryPartAddedEventPart,
        }
        let ResponseReasoningSummaryPartAddedEvent {
            item_id,
            output_index,
            summary_index,
            part,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a new reasoning summary part is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartAddedEvent {
    #[doc = "The ID of the item this summary part is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary part is associated with.\n"]
    pub output_index: u64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: u64,
    #[doc = "The summary part that was added.\n"]
    pub part: ResponseReasoningSummaryPartAddedEventPart,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartDoneEventPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartDoneEventPartType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryPartDoneEventPartType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseReasoningSummaryPartDoneEventPart { text })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartDoneEventPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartDoneEventPartType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryPartDoneEventPartType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let ResponseReasoningSummaryPartDoneEventPart { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The completed summary part.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartDoneEventPart {
    #[doc = "The text of the summary part."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_part.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_part.done")]
            ResponseReasoningSummaryPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryPartDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: ResponseReasoningSummaryPartDoneEventPart,
        }
        let _D {
            item_id,
            output_index,
            summary_index,
            part,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseReasoningSummaryPartDoneEvent {
            item_id,
            output_index,
            summary_index,
            part,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_part.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_part.done")]
            ResponseReasoningSummaryPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryPartDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a ResponseReasoningSummaryPartDoneEventPart,
        }
        let ResponseReasoningSummaryPartDoneEvent {
            item_id,
            output_index,
            summary_index,
            part,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a reasoning summary part is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartDoneEvent {
    #[doc = "The ID of the item this summary part is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary part is associated with.\n"]
    pub output_index: u64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: u64,
    #[doc = "The completed summary part.\n"]
    pub part: ResponseReasoningSummaryPartDoneEventPart,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryTextDeltaEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_text.delta")]
            ResponseReasoningSummaryTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryTextDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            item_id,
            output_index,
            summary_index,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseReasoningSummaryTextDeltaEvent {
            item_id,
            output_index,
            summary_index,
            delta,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryTextDeltaEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_text.delta")]
            ResponseReasoningSummaryTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryTextDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let ResponseReasoningSummaryTextDeltaEvent {
            item_id,
            output_index,
            summary_index,
            delta,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a delta is added to a reasoning summary text."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryTextDeltaEvent {
    #[doc = "The ID of the item this summary text delta is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary text delta is associated with.\n"]
    pub output_index: u64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: u64,
    #[doc = "The text delta that was added to the summary.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryTextDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_text.done")]
            ResponseReasoningSummaryTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryTextDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D {
            item_id,
            output_index,
            summary_index,
            text,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseReasoningSummaryTextDoneEvent {
            item_id,
            output_index,
            summary_index,
            text,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryTextDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_text.done")]
            ResponseReasoningSummaryTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryTextDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let ResponseReasoningSummaryTextDoneEvent {
            item_id,
            output_index,
            summary_index,
            text,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a reasoning summary text is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryTextDoneEvent {
    #[doc = "The ID of the item this summary text is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary text is associated with.\n"]
    pub output_index: u64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: u64,
    #[doc = "The full text of the completed reasoning summary.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ResponseRefusalDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.refusal.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseRefusalDeltaEventType {
            #[default]
            #[serde(rename = "response.refusal.delta")]
            ResponseRefusalDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseRefusalDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseRefusalDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for ResponseRefusalDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.refusal.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseRefusalDeltaEventType {
            #[default]
            #[serde(rename = "response.refusal.delta")]
            ResponseRefusalDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseRefusalDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let ResponseRefusalDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a partial refusal text."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseRefusalDeltaEvent {
    #[doc = "The ID of the output item that the refusal text is added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the refusal text is added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the refusal text is added to.\n"]
    pub content_index: u64,
    #[doc = "The refusal text that is added.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseRefusalDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.refusal.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseRefusalDoneEventType {
            #[default]
            #[serde(rename = "response.refusal.done")]
            ResponseRefusalDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseRefusalDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: String,
        }
        let _D {
            item_id,
            output_index,
            content_index,
            refusal,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseRefusalDoneEvent {
            item_id,
            output_index,
            content_index,
            refusal,
        })
    }
}
impl serde::Serialize for ResponseRefusalDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.refusal.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseRefusalDoneEventType {
            #[default]
            #[serde(rename = "response.refusal.done")]
            ResponseRefusalDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseRefusalDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let ResponseRefusalDoneEvent {
            item_id,
            output_index,
            content_index,
            refusal,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when refusal text is finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseRefusalDoneEvent {
    #[doc = "The ID of the output item that the refusal text is finalized.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the refusal text is finalized.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the refusal text is finalized.\n"]
    pub content_index: u64,
    #[doc = "The refusal text that is finalized.\n"]
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for ResponseStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ResponseAudioDelta(#[allow(dead_code)] ResponseAudioDeltaEvent),
            ResponseAudioDone(#[allow(dead_code)] ResponseAudioDoneEvent),
            ResponseAudioTranscriptDelta(#[allow(dead_code)] ResponseAudioTranscriptDeltaEvent),
            ResponseAudioTranscriptDone(#[allow(dead_code)] ResponseAudioTranscriptDoneEvent),
            ResponseCodeInterpreterCallCodeDelta(
                #[allow(dead_code)] ResponseCodeInterpreterCallCodeDeltaEvent,
            ),
            ResponseCodeInterpreterCallCodeDone(
                #[allow(dead_code)] ResponseCodeInterpreterCallCodeDoneEvent,
            ),
            ResponseCodeInterpreterCallCompleted(
                #[allow(dead_code)] ResponseCodeInterpreterCallCompletedEvent,
            ),
            ResponseCodeInterpreterCallInProgress(
                #[allow(dead_code)] ResponseCodeInterpreterCallInProgressEvent,
            ),
            ResponseCodeInterpreterCallInterpreting(
                #[allow(dead_code)] ResponseCodeInterpreterCallInterpretingEvent,
            ),
            ResponseCompleted(#[allow(dead_code)] ResponseCompletedEvent),
            ResponseContentPartAdded(#[allow(dead_code)] ResponseContentPartAddedEvent),
            ResponseContentPartDone(#[allow(dead_code)] ResponseContentPartDoneEvent),
            ResponseCreated(#[allow(dead_code)] ResponseCreatedEvent),
            Error(#[allow(dead_code)] ResponseErrorEvent),
            ResponseFileSearchCallCompleted(
                #[allow(dead_code)] ResponseFileSearchCallCompletedEvent,
            ),
            ResponseFileSearchCallInProgress(
                #[allow(dead_code)] ResponseFileSearchCallInProgressEvent,
            ),
            ResponseFileSearchCallSearching(
                #[allow(dead_code)] ResponseFileSearchCallSearchingEvent,
            ),
            ResponseFunctionCallArgumentsDelta(
                #[allow(dead_code)] ResponseFunctionCallArgumentsDeltaEvent,
            ),
            ResponseFunctionCallArgumentsDone(
                #[allow(dead_code)] ResponseFunctionCallArgumentsDoneEvent,
            ),
            ResponseInProgress(#[allow(dead_code)] ResponseInProgressEvent),
            ResponseFailed(#[allow(dead_code)] ResponseFailedEvent),
            ResponseIncomplete(#[allow(dead_code)] ResponseIncompleteEvent),
            ResponseOutputItemAdded(#[allow(dead_code)] ResponseOutputItemAddedEvent),
            ResponseOutputItemDone(#[allow(dead_code)] ResponseOutputItemDoneEvent),
            ResponseReasoningSummaryPartAdded(
                #[allow(dead_code)] ResponseReasoningSummaryPartAddedEvent,
            ),
            ResponseReasoningSummaryPartDone(
                #[allow(dead_code)] ResponseReasoningSummaryPartDoneEvent,
            ),
            ResponseReasoningSummaryTextDelta(
                #[allow(dead_code)] ResponseReasoningSummaryTextDeltaEvent,
            ),
            ResponseReasoningSummaryTextDone(
                #[allow(dead_code)] ResponseReasoningSummaryTextDoneEvent,
            ),
            ResponseRefusalDelta(#[allow(dead_code)] ResponseRefusalDeltaEvent),
            ResponseRefusalDone(#[allow(dead_code)] ResponseRefusalDoneEvent),
            ResponseOutputTextAnnotationAdded(#[allow(dead_code)] ResponseTextAnnotationDeltaEvent),
            ResponseOutputTextDelta(#[allow(dead_code)] ResponseTextDeltaEvent),
            ResponseOutputTextDone(#[allow(dead_code)] ResponseTextDoneEvent),
            ResponseWebSearchCallCompleted(#[allow(dead_code)] ResponseWebSearchCallCompletedEvent),
            ResponseWebSearchCallInProgress(
                #[allow(dead_code)] ResponseWebSearchCallInProgressEvent,
            ),
            ResponseWebSearchCallSearching(#[allow(dead_code)] ResponseWebSearchCallSearchingEvent),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ResponseAudioDelta(_v) => Self::ResponseAudioDelta(_v),
            _D::ResponseAudioDone(_v) => Self::ResponseAudioDone(_v),
            _D::ResponseAudioTranscriptDelta(_v) => Self::ResponseAudioTranscriptDelta(_v),
            _D::ResponseAudioTranscriptDone(_v) => Self::ResponseAudioTranscriptDone(_v),
            _D::ResponseCodeInterpreterCallCodeDelta(_v) => {
                Self::ResponseCodeInterpreterCallCodeDelta(_v)
            }
            _D::ResponseCodeInterpreterCallCodeDone(_v) => {
                Self::ResponseCodeInterpreterCallCodeDone(_v)
            }
            _D::ResponseCodeInterpreterCallCompleted(_v) => {
                Self::ResponseCodeInterpreterCallCompleted(_v)
            }
            _D::ResponseCodeInterpreterCallInProgress(_v) => {
                Self::ResponseCodeInterpreterCallInProgress(_v)
            }
            _D::ResponseCodeInterpreterCallInterpreting(_v) => {
                Self::ResponseCodeInterpreterCallInterpreting(_v)
            }
            _D::ResponseCompleted(_v) => Self::ResponseCompleted(_v),
            _D::ResponseContentPartAdded(_v) => Self::ResponseContentPartAdded(_v),
            _D::ResponseContentPartDone(_v) => Self::ResponseContentPartDone(_v),
            _D::ResponseCreated(_v) => Self::ResponseCreated(_v),
            _D::Error(_v) => Self::Error(_v),
            _D::ResponseFileSearchCallCompleted(_v) => Self::ResponseFileSearchCallCompleted(_v),
            _D::ResponseFileSearchCallInProgress(_v) => Self::ResponseFileSearchCallInProgress(_v),
            _D::ResponseFileSearchCallSearching(_v) => Self::ResponseFileSearchCallSearching(_v),
            _D::ResponseFunctionCallArgumentsDelta(_v) => {
                Self::ResponseFunctionCallArgumentsDelta(_v)
            }
            _D::ResponseFunctionCallArgumentsDone(_v) => {
                Self::ResponseFunctionCallArgumentsDone(_v)
            }
            _D::ResponseInProgress(_v) => Self::ResponseInProgress(_v),
            _D::ResponseFailed(_v) => Self::ResponseFailed(_v),
            _D::ResponseIncomplete(_v) => Self::ResponseIncomplete(_v),
            _D::ResponseOutputItemAdded(_v) => Self::ResponseOutputItemAdded(_v),
            _D::ResponseOutputItemDone(_v) => Self::ResponseOutputItemDone(_v),
            _D::ResponseReasoningSummaryPartAdded(_v) => {
                Self::ResponseReasoningSummaryPartAdded(_v)
            }
            _D::ResponseReasoningSummaryPartDone(_v) => Self::ResponseReasoningSummaryPartDone(_v),
            _D::ResponseReasoningSummaryTextDelta(_v) => {
                Self::ResponseReasoningSummaryTextDelta(_v)
            }
            _D::ResponseReasoningSummaryTextDone(_v) => Self::ResponseReasoningSummaryTextDone(_v),
            _D::ResponseRefusalDelta(_v) => Self::ResponseRefusalDelta(_v),
            _D::ResponseRefusalDone(_v) => Self::ResponseRefusalDone(_v),
            _D::ResponseOutputTextAnnotationAdded(_v) => {
                Self::ResponseOutputTextAnnotationAdded(_v)
            }
            _D::ResponseOutputTextDelta(_v) => Self::ResponseOutputTextDelta(_v),
            _D::ResponseOutputTextDone(_v) => Self::ResponseOutputTextDone(_v),
            _D::ResponseWebSearchCallCompleted(_v) => Self::ResponseWebSearchCallCompleted(_v),
            _D::ResponseWebSearchCallInProgress(_v) => Self::ResponseWebSearchCallInProgress(_v),
            _D::ResponseWebSearchCallSearching(_v) => Self::ResponseWebSearchCallSearching(_v),
        })
    }
}
impl serde::Serialize for ResponseStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ResponseAudioDelta(#[allow(dead_code)] &'a ResponseAudioDeltaEvent),
            ResponseAudioDone(#[allow(dead_code)] &'a ResponseAudioDoneEvent),
            ResponseAudioTranscriptDelta(#[allow(dead_code)] &'a ResponseAudioTranscriptDeltaEvent),
            ResponseAudioTranscriptDone(#[allow(dead_code)] &'a ResponseAudioTranscriptDoneEvent),
            ResponseCodeInterpreterCallCodeDelta(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallCodeDeltaEvent,
            ),
            ResponseCodeInterpreterCallCodeDone(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallCodeDoneEvent,
            ),
            ResponseCodeInterpreterCallCompleted(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallCompletedEvent,
            ),
            ResponseCodeInterpreterCallInProgress(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallInProgressEvent,
            ),
            ResponseCodeInterpreterCallInterpreting(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallInterpretingEvent,
            ),
            ResponseCompleted(#[allow(dead_code)] &'a ResponseCompletedEvent),
            ResponseContentPartAdded(#[allow(dead_code)] &'a ResponseContentPartAddedEvent),
            ResponseContentPartDone(#[allow(dead_code)] &'a ResponseContentPartDoneEvent),
            ResponseCreated(#[allow(dead_code)] &'a ResponseCreatedEvent),
            Error(#[allow(dead_code)] &'a ResponseErrorEvent),
            ResponseFileSearchCallCompleted(
                #[allow(dead_code)] &'a ResponseFileSearchCallCompletedEvent,
            ),
            ResponseFileSearchCallInProgress(
                #[allow(dead_code)] &'a ResponseFileSearchCallInProgressEvent,
            ),
            ResponseFileSearchCallSearching(
                #[allow(dead_code)] &'a ResponseFileSearchCallSearchingEvent,
            ),
            ResponseFunctionCallArgumentsDelta(
                #[allow(dead_code)] &'a ResponseFunctionCallArgumentsDeltaEvent,
            ),
            ResponseFunctionCallArgumentsDone(
                #[allow(dead_code)] &'a ResponseFunctionCallArgumentsDoneEvent,
            ),
            ResponseInProgress(#[allow(dead_code)] &'a ResponseInProgressEvent),
            ResponseFailed(#[allow(dead_code)] &'a ResponseFailedEvent),
            ResponseIncomplete(#[allow(dead_code)] &'a ResponseIncompleteEvent),
            ResponseOutputItemAdded(#[allow(dead_code)] &'a ResponseOutputItemAddedEvent),
            ResponseOutputItemDone(#[allow(dead_code)] &'a ResponseOutputItemDoneEvent),
            ResponseReasoningSummaryPartAdded(
                #[allow(dead_code)] &'a ResponseReasoningSummaryPartAddedEvent,
            ),
            ResponseReasoningSummaryPartDone(
                #[allow(dead_code)] &'a ResponseReasoningSummaryPartDoneEvent,
            ),
            ResponseReasoningSummaryTextDelta(
                #[allow(dead_code)] &'a ResponseReasoningSummaryTextDeltaEvent,
            ),
            ResponseReasoningSummaryTextDone(
                #[allow(dead_code)] &'a ResponseReasoningSummaryTextDoneEvent,
            ),
            ResponseRefusalDelta(#[allow(dead_code)] &'a ResponseRefusalDeltaEvent),
            ResponseRefusalDone(#[allow(dead_code)] &'a ResponseRefusalDoneEvent),
            ResponseOutputTextAnnotationAdded(
                #[allow(dead_code)] &'a ResponseTextAnnotationDeltaEvent,
            ),
            ResponseOutputTextDelta(#[allow(dead_code)] &'a ResponseTextDeltaEvent),
            ResponseOutputTextDone(#[allow(dead_code)] &'a ResponseTextDoneEvent),
            ResponseWebSearchCallCompleted(
                #[allow(dead_code)] &'a ResponseWebSearchCallCompletedEvent,
            ),
            ResponseWebSearchCallInProgress(
                #[allow(dead_code)] &'a ResponseWebSearchCallInProgressEvent,
            ),
            ResponseWebSearchCallSearching(
                #[allow(dead_code)] &'a ResponseWebSearchCallSearchingEvent,
            ),
        }
        match self {
            Self::ResponseAudioDelta(_v) => _S::ResponseAudioDelta(_v).serialize(serializer),
            Self::ResponseAudioDone(_v) => _S::ResponseAudioDone(_v).serialize(serializer),
            Self::ResponseAudioTranscriptDelta(_v) => {
                _S::ResponseAudioTranscriptDelta(_v).serialize(serializer)
            }
            Self::ResponseAudioTranscriptDone(_v) => {
                _S::ResponseAudioTranscriptDone(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallCodeDelta(_v) => {
                _S::ResponseCodeInterpreterCallCodeDelta(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallCodeDone(_v) => {
                _S::ResponseCodeInterpreterCallCodeDone(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallCompleted(_v) => {
                _S::ResponseCodeInterpreterCallCompleted(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallInProgress(_v) => {
                _S::ResponseCodeInterpreterCallInProgress(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallInterpreting(_v) => {
                _S::ResponseCodeInterpreterCallInterpreting(_v).serialize(serializer)
            }
            Self::ResponseCompleted(_v) => _S::ResponseCompleted(_v).serialize(serializer),
            Self::ResponseContentPartAdded(_v) => {
                _S::ResponseContentPartAdded(_v).serialize(serializer)
            }
            Self::ResponseContentPartDone(_v) => {
                _S::ResponseContentPartDone(_v).serialize(serializer)
            }
            Self::ResponseCreated(_v) => _S::ResponseCreated(_v).serialize(serializer),
            Self::Error(_v) => _S::Error(_v).serialize(serializer),
            Self::ResponseFileSearchCallCompleted(_v) => {
                _S::ResponseFileSearchCallCompleted(_v).serialize(serializer)
            }
            Self::ResponseFileSearchCallInProgress(_v) => {
                _S::ResponseFileSearchCallInProgress(_v).serialize(serializer)
            }
            Self::ResponseFileSearchCallSearching(_v) => {
                _S::ResponseFileSearchCallSearching(_v).serialize(serializer)
            }
            Self::ResponseFunctionCallArgumentsDelta(_v) => {
                _S::ResponseFunctionCallArgumentsDelta(_v).serialize(serializer)
            }
            Self::ResponseFunctionCallArgumentsDone(_v) => {
                _S::ResponseFunctionCallArgumentsDone(_v).serialize(serializer)
            }
            Self::ResponseInProgress(_v) => _S::ResponseInProgress(_v).serialize(serializer),
            Self::ResponseFailed(_v) => _S::ResponseFailed(_v).serialize(serializer),
            Self::ResponseIncomplete(_v) => _S::ResponseIncomplete(_v).serialize(serializer),
            Self::ResponseOutputItemAdded(_v) => {
                _S::ResponseOutputItemAdded(_v).serialize(serializer)
            }
            Self::ResponseOutputItemDone(_v) => {
                _S::ResponseOutputItemDone(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryPartAdded(_v) => {
                _S::ResponseReasoningSummaryPartAdded(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryPartDone(_v) => {
                _S::ResponseReasoningSummaryPartDone(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryTextDelta(_v) => {
                _S::ResponseReasoningSummaryTextDelta(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryTextDone(_v) => {
                _S::ResponseReasoningSummaryTextDone(_v).serialize(serializer)
            }
            Self::ResponseRefusalDelta(_v) => _S::ResponseRefusalDelta(_v).serialize(serializer),
            Self::ResponseRefusalDone(_v) => _S::ResponseRefusalDone(_v).serialize(serializer),
            Self::ResponseOutputTextAnnotationAdded(_v) => {
                _S::ResponseOutputTextAnnotationAdded(_v).serialize(serializer)
            }
            Self::ResponseOutputTextDelta(_v) => {
                _S::ResponseOutputTextDelta(_v).serialize(serializer)
            }
            Self::ResponseOutputTextDone(_v) => {
                _S::ResponseOutputTextDone(_v).serialize(serializer)
            }
            Self::ResponseWebSearchCallCompleted(_v) => {
                _S::ResponseWebSearchCallCompleted(_v).serialize(serializer)
            }
            Self::ResponseWebSearchCallInProgress(_v) => {
                _S::ResponseWebSearchCallInProgress(_v).serialize(serializer)
            }
            Self::ResponseWebSearchCallSearching(_v) => {
                _S::ResponseWebSearchCallSearching(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseStreamEvent {
    ResponseAudioDelta(ResponseAudioDeltaEvent),
    ResponseAudioDone(ResponseAudioDoneEvent),
    ResponseAudioTranscriptDelta(ResponseAudioTranscriptDeltaEvent),
    ResponseAudioTranscriptDone(ResponseAudioTranscriptDoneEvent),
    ResponseCodeInterpreterCallCodeDelta(ResponseCodeInterpreterCallCodeDeltaEvent),
    ResponseCodeInterpreterCallCodeDone(ResponseCodeInterpreterCallCodeDoneEvent),
    ResponseCodeInterpreterCallCompleted(ResponseCodeInterpreterCallCompletedEvent),
    ResponseCodeInterpreterCallInProgress(ResponseCodeInterpreterCallInProgressEvent),
    ResponseCodeInterpreterCallInterpreting(ResponseCodeInterpreterCallInterpretingEvent),
    ResponseCompleted(ResponseCompletedEvent),
    ResponseContentPartAdded(ResponseContentPartAddedEvent),
    ResponseContentPartDone(ResponseContentPartDoneEvent),
    ResponseCreated(ResponseCreatedEvent),
    Error(ResponseErrorEvent),
    ResponseFileSearchCallCompleted(ResponseFileSearchCallCompletedEvent),
    ResponseFileSearchCallInProgress(ResponseFileSearchCallInProgressEvent),
    ResponseFileSearchCallSearching(ResponseFileSearchCallSearchingEvent),
    ResponseFunctionCallArgumentsDelta(ResponseFunctionCallArgumentsDeltaEvent),
    ResponseFunctionCallArgumentsDone(ResponseFunctionCallArgumentsDoneEvent),
    ResponseInProgress(ResponseInProgressEvent),
    ResponseFailed(ResponseFailedEvent),
    ResponseIncomplete(ResponseIncompleteEvent),
    ResponseOutputItemAdded(ResponseOutputItemAddedEvent),
    ResponseOutputItemDone(ResponseOutputItemDoneEvent),
    ResponseReasoningSummaryPartAdded(ResponseReasoningSummaryPartAddedEvent),
    ResponseReasoningSummaryPartDone(ResponseReasoningSummaryPartDoneEvent),
    ResponseReasoningSummaryTextDelta(ResponseReasoningSummaryTextDeltaEvent),
    ResponseReasoningSummaryTextDone(ResponseReasoningSummaryTextDoneEvent),
    ResponseRefusalDelta(ResponseRefusalDeltaEvent),
    ResponseRefusalDone(ResponseRefusalDoneEvent),
    ResponseOutputTextAnnotationAdded(ResponseTextAnnotationDeltaEvent),
    ResponseOutputTextDelta(ResponseTextDeltaEvent),
    ResponseOutputTextDone(ResponseTextDoneEvent),
    ResponseWebSearchCallCompleted(ResponseWebSearchCallCompletedEvent),
    ResponseWebSearchCallInProgress(ResponseWebSearchCallInProgressEvent),
    ResponseWebSearchCallSearching(ResponseWebSearchCallSearchingEvent),
}
impl<'de> serde::Deserialize<'de> for ResponseTextAnnotationDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_text.annotation.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextAnnotationDeltaEventType {
            #[default]
            #[serde(rename = "response.output_text.annotation.added")]
            ResponseOutputTextAnnotationAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseTextAnnotationDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "annotation_index")]
            #[allow(dead_code)]
            annotation_index: u64,
            #[serde(rename = "annotation")]
            #[allow(dead_code)]
            annotation: Annotation,
        }
        let _D {
            item_id,
            output_index,
            content_index,
            annotation_index,
            annotation,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseTextAnnotationDeltaEvent {
            item_id,
            output_index,
            content_index,
            annotation_index,
            annotation,
        })
    }
}
impl serde::Serialize for ResponseTextAnnotationDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_text.annotation.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextAnnotationDeltaEventType {
            #[default]
            #[serde(rename = "response.output_text.annotation.added")]
            ResponseOutputTextAnnotationAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseTextAnnotationDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "annotation_index")]
            annotation_index: &'a u64,
            #[serde(rename = "annotation")]
            annotation: &'a Annotation,
        }
        let ResponseTextAnnotationDeltaEvent {
            item_id,
            output_index,
            content_index,
            annotation_index,
            annotation,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            annotation_index,
            annotation,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a text annotation is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseTextAnnotationDeltaEvent {
    #[doc = "The ID of the output item that the text annotation was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the text annotation was added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the text annotation was added to.\n"]
    pub content_index: u64,
    #[doc = "The index of the annotation that was added.\n"]
    pub annotation_index: u64,
    pub annotation: Annotation,
}
impl<'de> serde::Deserialize<'de> for ResponseTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextDeltaEventType {
            #[default]
            #[serde(rename = "response.output_text.delta")]
            ResponseOutputTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseTextDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let _D {
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseTextDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for ResponseTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextDeltaEventType {
            #[default]
            #[serde(rename = "response.output_text.delta")]
            ResponseOutputTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseTextDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let ResponseTextDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is an additional text delta."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseTextDeltaEvent {
    #[doc = "The ID of the output item that the text delta was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the text delta was added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the text delta was added to.\n"]
    pub content_index: u64,
    #[doc = "The text delta that was added.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextDoneEventType {
            #[default]
            #[serde(rename = "response.output_text.done")]
            ResponseOutputTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseTextDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D {
            item_id,
            output_index,
            content_index,
            text,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseTextDoneEvent {
            item_id,
            output_index,
            content_index,
            text,
        })
    }
}
impl serde::Serialize for ResponseTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextDoneEventType {
            #[default]
            #[serde(rename = "response.output_text.done")]
            ResponseOutputTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseTextDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let ResponseTextDoneEvent {
            item_id,
            output_index,
            content_index,
            text,
        } = self;
        _S {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when text content is finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseTextDoneEvent {
    #[doc = "The ID of the output item that the text content is finalized.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the text content is finalized.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the text content is finalized.\n"]
    pub content_index: u64,
    #[doc = "The text content that is finalized.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ResponseUsageInputTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: u64,
        }
        let _D { cached_tokens, .. } = _D::deserialize(deserializer)?;
        Ok(ResponseUsageInputTokensDetails { cached_tokens })
    }
}
impl serde::Serialize for ResponseUsageInputTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "cached_tokens")]
            cached_tokens: &'a u64,
        }
        let ResponseUsageInputTokensDetails { cached_tokens } = self;
        _S { cached_tokens }.serialize(serializer)
    }
}
#[doc = "A detailed breakdown of the input tokens."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseUsageInputTokensDetails {
    #[doc = "The number of tokens that were retrieved from the cache. \n[More on prompt caching](/docs/guides/prompt-caching).\n"]
    pub cached_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseUsageOutputTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "reasoning_tokens")]
            #[allow(dead_code)]
            reasoning_tokens: u64,
        }
        let _D {
            reasoning_tokens, ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseUsageOutputTokensDetails { reasoning_tokens })
    }
}
impl serde::Serialize for ResponseUsageOutputTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "reasoning_tokens")]
            reasoning_tokens: &'a u64,
        }
        let ResponseUsageOutputTokensDetails { reasoning_tokens } = self;
        _S { reasoning_tokens }.serialize(serializer)
    }
}
#[doc = "A detailed breakdown of the output tokens."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseUsageOutputTokensDetails {
    #[doc = "The number of reasoning tokens."]
    pub reasoning_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "input_tokens_details")]
            #[allow(dead_code)]
            input_tokens_details: ResponseUsageInputTokensDetails,
            #[serde(rename = "output_tokens")]
            #[allow(dead_code)]
            output_tokens: u64,
            #[serde(rename = "output_tokens_details")]
            #[allow(dead_code)]
            output_tokens_details: ResponseUsageOutputTokensDetails,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
        }
        let _D {
            input_tokens,
            input_tokens_details,
            output_tokens,
            output_tokens_details,
            total_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseUsage {
            input_tokens,
            input_tokens_details,
            output_tokens,
            output_tokens_details,
            total_tokens,
        })
    }
}
impl serde::Serialize for ResponseUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "input_tokens_details")]
            input_tokens_details: &'a ResponseUsageInputTokensDetails,
            #[serde(rename = "output_tokens")]
            output_tokens: &'a u64,
            #[serde(rename = "output_tokens_details")]
            output_tokens_details: &'a ResponseUsageOutputTokensDetails,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
        }
        let ResponseUsage {
            input_tokens,
            input_tokens_details,
            output_tokens,
            output_tokens_details,
            total_tokens,
        } = self;
        _S {
            input_tokens,
            input_tokens_details,
            output_tokens,
            output_tokens_details,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents token usage details including input tokens, output tokens,\na breakdown of output tokens, and the total tokens used.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseUsage {
    #[doc = "The number of input tokens."]
    pub input_tokens: u64,
    #[doc = "A detailed breakdown of the input tokens."]
    pub input_tokens_details: ResponseUsageInputTokensDetails,
    #[doc = "The number of output tokens."]
    pub output_tokens: u64,
    #[doc = "A detailed breakdown of the output tokens."]
    pub output_tokens_details: ResponseUsageOutputTokensDetails,
    #[doc = "The total number of tokens used."]
    pub total_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.web_search_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallCompletedEventType {
            #[default]
            #[serde(rename = "response.web_search_call.completed")]
            ResponseWebSearchCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseWebSearchCallCompletedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            output_index,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseWebSearchCallCompletedEvent {
            output_index,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.web_search_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallCompletedEventType {
            #[default]
            #[serde(rename = "response.web_search_call.completed")]
            ResponseWebSearchCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseWebSearchCallCompletedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let ResponseWebSearchCallCompletedEvent {
            output_index,
            item_id,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a web search call is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallCompletedEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: u64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.web_search_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallInProgressEventType {
            #[default]
            #[serde(rename = "response.web_search_call.in_progress")]
            ResponseWebSearchCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseWebSearchCallInProgressEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            output_index,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseWebSearchCallInProgressEvent {
            output_index,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.web_search_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallInProgressEventType {
            #[default]
            #[serde(rename = "response.web_search_call.in_progress")]
            ResponseWebSearchCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseWebSearchCallInProgressEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let ResponseWebSearchCallInProgressEvent {
            output_index,
            item_id,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a web search call is initiated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallInProgressEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: u64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallSearchingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.web_search_call.searching`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallSearchingEventType {
            #[default]
            #[serde(rename = "response.web_search_call.searching")]
            ResponseWebSearchCallSearching,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseWebSearchCallSearchingEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let _D {
            output_index,
            item_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ResponseWebSearchCallSearchingEvent {
            output_index,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallSearchingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.web_search_call.searching`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallSearchingEventType {
            #[default]
            #[serde(rename = "response.web_search_call.searching")]
            ResponseWebSearchCallSearching,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseWebSearchCallSearchingEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let ResponseWebSearchCallSearchingEvent {
            output_index,
            item_id,
        } = self;
        _S {
            type_: &Default::default(),
            output_index,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a web search call is executing."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallSearchingEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: u64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RunCompletionUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
        }
        let _D {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        })
    }
}
impl serde::Serialize for RunCompletionUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
        }
        let RunCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        } = self;
        _S {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.)."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct RunCompletionUsage {
    #[doc = "Number of completion tokens used over the course of the run."]
    pub completion_tokens: u64,
    #[doc = "Number of prompt tokens used over the course of the run."]
    pub prompt_tokens: u64,
    #[doc = "Total number of tokens used (prompt + completion)."]
    pub total_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for RunObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusRequiresAction {
            #[default]
            #[serde(rename = "requires_action")]
            RequiresAction,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusCancelling {
            #[default]
            #[serde(rename = "cancelling")]
            Cancelling,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Queued(#[allow(dead_code)] RunObjectStatusQueued),
            InProgress(#[allow(dead_code)] RunObjectStatusInProgress),
            RequiresAction(#[allow(dead_code)] RunObjectStatusRequiresAction),
            Cancelling(#[allow(dead_code)] RunObjectStatusCancelling),
            Cancelled(#[allow(dead_code)] RunObjectStatusCancelled),
            Failed(#[allow(dead_code)] RunObjectStatusFailed),
            Completed(#[allow(dead_code)] RunObjectStatusCompleted),
            Incomplete(#[allow(dead_code)] RunObjectStatusIncomplete),
            Expired(#[allow(dead_code)] RunObjectStatusExpired),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Queued(_) => Self::Queued,
            _D::InProgress(_) => Self::InProgress,
            _D::RequiresAction(_) => Self::RequiresAction,
            _D::Cancelling(_) => Self::Cancelling,
            _D::Cancelled(_) => Self::Cancelled,
            _D::Failed(_) => Self::Failed,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
            _D::Expired(_) => Self::Expired,
        })
    }
}
impl serde::Serialize for RunObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusRequiresAction {
            #[default]
            #[serde(rename = "requires_action")]
            RequiresAction,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusCancelling {
            #[default]
            #[serde(rename = "cancelling")]
            Cancelling,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Queued(#[allow(dead_code)] &'a RunObjectStatusQueued),
            InProgress(#[allow(dead_code)] &'a RunObjectStatusInProgress),
            RequiresAction(#[allow(dead_code)] &'a RunObjectStatusRequiresAction),
            Cancelling(#[allow(dead_code)] &'a RunObjectStatusCancelling),
            Cancelled(#[allow(dead_code)] &'a RunObjectStatusCancelled),
            Failed(#[allow(dead_code)] &'a RunObjectStatusFailed),
            Completed(#[allow(dead_code)] &'a RunObjectStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a RunObjectStatusIncomplete),
            Expired(#[allow(dead_code)] &'a RunObjectStatusExpired),
        }
        match self {
            Self::Queued => _S::Queued(&Default::default()).serialize(serializer),
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::RequiresAction => _S::RequiresAction(&Default::default()).serialize(serializer),
            Self::Cancelling => _S::Cancelling(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
            Self::Expired => _S::Expired(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunObjectStatus {
    #[doc = "queued"]
    Queued,
    #[doc = "in_progress"]
    InProgress,
    #[doc = "requires_action"]
    RequiresAction,
    #[doc = "cancelling"]
    Cancelling,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
    #[doc = "expired"]
    Expired,
}
impl<'de> serde::Deserialize<'de> for RunObjectRequiredActionSubmitToolOutputs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Vec<RunToolCallObject>,
        }
        let _D { tool_calls, .. } = _D::deserialize(deserializer)?;
        Ok(RunObjectRequiredActionSubmitToolOutputs { tool_calls })
    }
}
impl serde::Serialize for RunObjectRequiredActionSubmitToolOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "tool_calls")]
            tool_calls: &'a Vec<RunToolCallObject>,
        }
        let RunObjectRequiredActionSubmitToolOutputs { tool_calls } = self;
        _S { tool_calls }.serialize(serializer)
    }
}
#[doc = "Details on the tool outputs needed for this run to continue."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObjectRequiredActionSubmitToolOutputs {
    #[doc = "A list of the relevant tool calls."]
    pub tool_calls: Vec<RunToolCallObject>,
}
impl<'de> serde::Deserialize<'de> for RunObjectRequiredAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "For now, this is always `submit_tool_outputs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectRequiredActionType {
            #[default]
            #[serde(rename = "submit_tool_outputs")]
            SubmitToolOutputs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunObjectRequiredActionType,
            #[serde(rename = "submit_tool_outputs")]
            #[allow(dead_code)]
            submit_tool_outputs: RunObjectRequiredActionSubmitToolOutputs,
        }
        let _D {
            submit_tool_outputs,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunObjectRequiredAction {
            submit_tool_outputs,
        })
    }
}
impl serde::Serialize for RunObjectRequiredAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "For now, this is always `submit_tool_outputs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectRequiredActionType {
            #[default]
            #[serde(rename = "submit_tool_outputs")]
            SubmitToolOutputs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a RunObjectRequiredActionType,
            #[serde(rename = "submit_tool_outputs")]
            submit_tool_outputs: &'a RunObjectRequiredActionSubmitToolOutputs,
        }
        let RunObjectRequiredAction {
            submit_tool_outputs,
        } = self;
        _S {
            type_: &Default::default(),
            submit_tool_outputs,
        }
        .serialize(serializer)
    }
}
#[doc = "Details on the action required to continue the run. Will be `null` if no action is required."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObjectRequiredAction {
    #[doc = "Details on the tool outputs needed for this run to continue."]
    pub submit_tool_outputs: RunObjectRequiredActionSubmitToolOutputs,
}
impl<'de> serde::Deserialize<'de> for RunObjectLastErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeInvalidPrompt {
            #[default]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ServerError(#[allow(dead_code)] RunObjectLastErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] RunObjectLastErrorCodeRateLimitExceeded),
            InvalidPrompt(#[allow(dead_code)] RunObjectLastErrorCodeInvalidPrompt),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ServerError(_) => Self::ServerError,
            _D::RateLimitExceeded(_) => Self::RateLimitExceeded,
            _D::InvalidPrompt(_) => Self::InvalidPrompt,
        })
    }
}
impl serde::Serialize for RunObjectLastErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeInvalidPrompt {
            #[default]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ServerError(#[allow(dead_code)] &'a RunObjectLastErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] &'a RunObjectLastErrorCodeRateLimitExceeded),
            InvalidPrompt(#[allow(dead_code)] &'a RunObjectLastErrorCodeInvalidPrompt),
        }
        match self {
            Self::ServerError => _S::ServerError(&Default::default()).serialize(serializer),
            Self::RateLimitExceeded => {
                _S::RateLimitExceeded(&Default::default()).serialize(serializer)
            }
            Self::InvalidPrompt => _S::InvalidPrompt(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunObjectLastErrorCode {
    #[doc = "server_error"]
    ServerError,
    #[doc = "rate_limit_exceeded"]
    RateLimitExceeded,
    #[doc = "invalid_prompt"]
    InvalidPrompt,
}
impl<'de> serde::Deserialize<'de> for RunObjectLastError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: RunObjectLastErrorCode,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let _D { code, message, .. } = _D::deserialize(deserializer)?;
        Ok(RunObjectLastError { code, message })
    }
}
impl serde::Serialize for RunObjectLastError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            code: &'a RunObjectLastErrorCode,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let RunObjectLastError { code, message } = self;
        _S { code, message }.serialize(serializer)
    }
}
#[doc = "The last error associated with this run. Will be `null` if there are no errors."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObjectLastError {
    #[doc = "One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`."]
    pub code: RunObjectLastErrorCode,
    #[doc = "A human-readable description of the error."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for RunObjectIncompleteDetailsReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectIncompleteDetailsReasonMaxCompletionTokens {
            #[default]
            #[serde(rename = "max_completion_tokens")]
            MaxCompletionTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectIncompleteDetailsReasonMaxPromptTokens {
            #[default]
            #[serde(rename = "max_prompt_tokens")]
            MaxPromptTokens,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            MaxCompletionTokens(
                #[allow(dead_code)] RunObjectIncompleteDetailsReasonMaxCompletionTokens,
            ),
            MaxPromptTokens(#[allow(dead_code)] RunObjectIncompleteDetailsReasonMaxPromptTokens),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::MaxCompletionTokens(_) => Self::MaxCompletionTokens,
            _D::MaxPromptTokens(_) => Self::MaxPromptTokens,
        })
    }
}
impl serde::Serialize for RunObjectIncompleteDetailsReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectIncompleteDetailsReasonMaxCompletionTokens {
            #[default]
            #[serde(rename = "max_completion_tokens")]
            MaxCompletionTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectIncompleteDetailsReasonMaxPromptTokens {
            #[default]
            #[serde(rename = "max_prompt_tokens")]
            MaxPromptTokens,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            MaxCompletionTokens(
                #[allow(dead_code)] &'a RunObjectIncompleteDetailsReasonMaxCompletionTokens,
            ),
            MaxPromptTokens(
                #[allow(dead_code)] &'a RunObjectIncompleteDetailsReasonMaxPromptTokens,
            ),
        }
        match self {
            Self::MaxCompletionTokens => {
                _S::MaxCompletionTokens(&Default::default()).serialize(serializer)
            }
            Self::MaxPromptTokens => _S::MaxPromptTokens(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunObjectIncompleteDetailsReason {
    #[doc = "max_completion_tokens"]
    MaxCompletionTokens,
    #[doc = "max_prompt_tokens"]
    MaxPromptTokens,
}
impl<'de> serde::Deserialize<'de> for RunObjectIncompleteDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: Option<RunObjectIncompleteDetailsReason>,
        }
        let _D { reason, .. } = _D::deserialize(deserializer)?;
        Ok(RunObjectIncompleteDetails { reason })
    }
}
impl serde::Serialize for RunObjectIncompleteDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<RunObjectIncompleteDetailsReason>,
        }
        let RunObjectIncompleteDetails { reason } = self;
        _S { reason }.serialize(serializer)
    }
}
#[doc = "Details on why the run is incomplete. Will be `null` if the run is not incomplete."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RunObjectIncompleteDetails {
    #[doc = "The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run."]
    #[builder(default)]
    pub reason: Option<RunObjectIncompleteDetailsReason>,
}
impl<'de> serde::Deserialize<'de> for RunObjectTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearch),
            Function(#[allow(dead_code)] AssistantToolsFunction),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for RunObjectTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearch),
            Function(#[allow(dead_code)] &'a AssistantToolsFunction),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunObjectTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearch),
    Function(AssistantToolsFunction),
}
impl<'de> serde::Deserialize<'de> for RunObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.run`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectObject {
            #[default]
            #[serde(rename = "thread.run")]
            ThreadRun,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: RunObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "thread_id")]
            #[allow(dead_code)]
            thread_id: String,
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: RunObjectStatus,
            #[serde(rename = "required_action")]
            #[allow(dead_code)]
            required_action: Option<RunObjectRequiredAction>,
            #[serde(rename = "last_error")]
            #[allow(dead_code)]
            last_error: Option<RunObjectLastError>,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "started_at")]
            #[allow(dead_code)]
            started_at: Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[allow(dead_code)]
            cancelled_at: Option<u64>,
            #[serde(rename = "failed_at")]
            #[allow(dead_code)]
            failed_at: Option<u64>,
            #[serde(rename = "completed_at")]
            #[allow(dead_code)]
            completed_at: Option<u64>,
            #[serde(rename = "incomplete_details")]
            #[allow(dead_code)]
            incomplete_details: Option<RunObjectIncompleteDetails>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: String,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Vec<RunObjectTool>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Metadata,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: RunCompletionUsage,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "max_prompt_tokens")]
            #[allow(dead_code)]
            max_prompt_tokens: Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[allow(dead_code)]
            truncation_strategy: Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: ParallelToolCalls,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let _D {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunObject {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for RunObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.run`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectObject {
            #[default]
            #[serde(rename = "thread.run")]
            ThreadRun,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a RunObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "status")]
            status: &'a RunObjectStatus,
            #[serde(rename = "required_action")]
            #[serde(skip_serializing_if = "Option::is_none")]
            required_action: &'a Option<RunObjectRequiredAction>,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<RunObjectLastError>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "started_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            started_at: &'a Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<u64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<u64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<u64>,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<RunObjectIncompleteDetails>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "instructions")]
            instructions: &'a String,
            #[serde(rename = "tools")]
            tools: &'a Vec<RunObjectTool>,
            #[serde(rename = "metadata")]
            metadata: &'a Metadata,
            #[serde(rename = "usage")]
            usage: &'a RunCompletionUsage,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            parallel_tool_calls: &'a ParallelToolCalls,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let RunObject {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        _S {
            id,
            object: &Default::default(),
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an execution run on a [thread](https://platform.openai.com/docs/api-reference/threads)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the run was created."]
    pub created_at: u64,
    #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run."]
    pub thread_id: String,
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run."]
    pub assistant_id: String,
    #[doc = "The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`."]
    pub status: RunObjectStatus,
    #[doc = "Details on the action required to continue the run. Will be `null` if no action is required."]
    #[builder(default)]
    pub required_action: Option<RunObjectRequiredAction>,
    #[doc = "The last error associated with this run. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<RunObjectLastError>,
    #[doc = "The Unix timestamp (in seconds) for when the run will expire."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was started."]
    #[builder(default)]
    pub started_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run failed."]
    #[builder(default)]
    pub failed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was completed."]
    #[builder(default)]
    pub completed_at: Option<u64>,
    #[doc = "Details on why the run is incomplete. Will be `null` if the run is not incomplete."]
    #[builder(default)]
    pub incomplete_details: Option<RunObjectIncompleteDetails>,
    #[doc = "The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub model: String,
    #[doc = "The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub instructions: String,
    #[doc = "The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub tools: Vec<RunObjectTool>,
    pub metadata: Metadata,
    pub usage: RunCompletionUsage,
    #[doc = "The sampling temperature used for this run. If not set, defaults to 1."]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "The nucleus sampling value used for this run. If not set, defaults to 1."]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "The maximum number of prompt tokens specified to have been used over the course of the run.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<u64>,
    #[doc = "The maximum number of completion tokens specified to have been used over the course of the run.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[builder(default)]
    pub truncation_strategy: Option<TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<AssistantsApiToolChoiceOption>,
    pub parallel_tool_calls: ParallelToolCalls,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for RunStepCompletionUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
        }
        let _D {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        })
    }
}
impl serde::Serialize for RunStepCompletionUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
        }
        let RunStepCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        } = self;
        _S {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct RunStepCompletionUsage {
    #[doc = "Number of completion tokens used over the course of the run step."]
    pub completion_tokens: u64,
    #[doc = "Number of prompt tokens used over the course of the run step."]
    pub prompt_tokens: u64,
    #[doc = "Total number of tokens used (prompt + completion)."]
    pub total_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaObjectDeltaStepDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            MessageCreation(#[allow(dead_code)] RunStepDeltaStepDetailsMessageCreationObject),
            ToolCalls(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::MessageCreation(_v) => Self::MessageCreation(_v),
            _D::ToolCalls(_v) => Self::ToolCalls(_v),
        })
    }
}
impl serde::Serialize for RunStepDeltaObjectDeltaStepDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            MessageCreation(#[allow(dead_code)] &'a RunStepDeltaStepDetailsMessageCreationObject),
            ToolCalls(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsObject),
        }
        match self {
            Self::MessageCreation(_v) => _S::MessageCreation(_v).serialize(serializer),
            Self::ToolCalls(_v) => _S::ToolCalls(_v).serialize(serializer),
        }
    }
}
#[doc = "The details of the run step."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDeltaObjectDeltaStepDetails {
    MessageCreation(RunStepDeltaStepDetailsMessageCreationObject),
    ToolCalls(RunStepDeltaStepDetailsToolCallsObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaObjectDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "step_details")]
            #[allow(dead_code)]
            step_details: Option<RunStepDeltaObjectDeltaStepDetails>,
        }
        let _D { step_details, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaObjectDelta { step_details })
    }
}
impl serde::Serialize for RunStepDeltaObjectDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "step_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            step_details: &'a Option<RunStepDeltaObjectDeltaStepDetails>,
        }
        let RunStepDeltaObjectDelta { step_details } = self;
        _S { step_details }.serialize(serializer)
    }
}
#[doc = "The delta containing the fields that have changed on the run step."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaObjectDelta {
    #[doc = "The details of the run step."]
    #[builder(default)]
    pub step_details: Option<RunStepDeltaObjectDeltaStepDetails>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.run.step.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaObjectObject {
            #[default]
            #[serde(rename = "thread.run.step.delta")]
            ThreadRunStepDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: RunStepDeltaObjectObject,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: RunStepDeltaObjectDelta,
        }
        let _D { id, delta, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaObject { id, delta })
    }
}
impl serde::Serialize for RunStepDeltaObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.run.step.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaObjectObject {
            #[default]
            #[serde(rename = "thread.run.step.delta")]
            ThreadRunStepDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a RunStepDeltaObjectObject,
            #[serde(rename = "delta")]
            delta: &'a RunStepDeltaObjectDelta,
        }
        let RunStepDeltaObject { id, delta } = self;
        _S {
            id,
            object: &Default::default(),
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a run step delta i.e. any changed fields on a run step during streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaObject {
    #[doc = "The identifier of the run step, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The delta containing the fields that have changed on the run step."]
    #[builder(default)]
    pub delta: RunStepDeltaObjectDelta,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "message_id")]
            #[allow(dead_code)]
            message_id: Option<String>,
        }
        let _D { message_id, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsMessageCreationObjectMessageCreation { message_id })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "message_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message_id: &'a Option<String>,
        }
        let RunStepDeltaStepDetailsMessageCreationObjectMessageCreation { message_id } = self;
        _S { message_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    #[doc = "The ID of the message that was created by this run step."]
    #[builder(default)]
    pub message_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsMessageCreationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `message_creation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsMessageCreationObjectType {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsMessageCreationObjectType,
            #[serde(rename = "message_creation")]
            #[allow(dead_code)]
            message_creation: Option<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,
        }
        let _D {
            message_creation, ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsMessageCreationObject { message_creation })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsMessageCreationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `message_creation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsMessageCreationObjectType {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsMessageCreationObjectType,
            #[serde(rename = "message_creation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message_creation:
                &'a Option<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,
        }
        let RunStepDeltaStepDetailsMessageCreationObject { message_creation } = self;
        _S {
            type_: &Default::default(),
            message_creation,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the message creation by the run step."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsMessageCreationObject {
    #[builder(default)]
    pub message_creation: Option<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,
}
impl<'de> serde::Deserialize<'de>
    for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Logs(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject),
            Image(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsCodeOutputImageObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Logs(_v) => Self::Logs(_v),
            _D::Image(_v) => Self::Image(_v),
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Logs(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject),
            Image(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsCodeOutputImageObject),
        }
        match self {
            Self::Logs(_v) => _S::Logs(_v).serialize(serializer),
            Self::Image(_v) => _S::Image(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    Logs(RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject),
    Image(RunStepDeltaStepDetailsToolCallsCodeOutputImageObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Option<String>,
            #[serde(rename = "outputs")]
            #[allow(dead_code)]
            outputs: Option<Vec<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>>,
        }
        let _D { input, outputs, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter { input, outputs })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "input")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input: &'a Option<String>,
            #[serde(rename = "outputs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            outputs:
                &'a Option<Vec<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter { input, outputs } = self;
        _S { input, outputs }.serialize(serializer)
    }
}
#[doc = "The Code Interpreter tool call definition."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    #[doc = "The input to the Code Interpreter tool call."]
    #[builder(default)]
    pub input: Option<String>,
    #[doc = "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type."]
    #[builder(default)]
    pub outputs: Option<Vec<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeObjectType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsCodeObjectType,
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,
        }
        let _D {
            index,
            id,
            code_interpreter,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsCodeObject {
            index,
            id,
            code_interpreter,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeObjectType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsCodeObjectType,
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeObject {
            index,
            id,
            code_interpreter,
        } = self;
        _S {
            index,
            id,
            type_: &Default::default(),
            code_interpreter,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the Code Interpreter tool call the run step was involved in."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: u64,
    #[doc = "The ID of the tool call."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The Code Interpreter tool call definition."]
    #[builder(default)]
    pub code_interpreter: Option<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let _D { file_id, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage { file_id })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage { file_id } = self;
        _S { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    #[doc = "The [file](https://platform.openai.com/docs/api-reference/files) ID of the image."]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectType {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectType,
            #[serde(rename = "image")]
            #[allow(dead_code)]
            image: Option<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,
        }
        let _D { index, image, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsCodeOutputImageObject { index, image })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectType {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectType,
            #[serde(rename = "image")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image: &'a Option<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeOutputImageObject { index, image } = self;
        _S {
            index,
            type_: &Default::default(),
            image,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    #[doc = "The index of the output in the outputs array."]
    pub index: u64,
    #[builder(default)]
    pub image: Option<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectType,
            #[serde(rename = "logs")]
            #[allow(dead_code)]
            logs: Option<String>,
        }
        let _D { index, logs, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject { index, logs })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectType,
            #[serde(rename = "logs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logs: &'a Option<String>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject { index, logs } = self;
        _S {
            index,
            type_: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[doc = "Text output from the Code Interpreter tool call as part of a run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    #[doc = "The index of the output in the outputs array."]
    pub index: u64,
    #[doc = "The text output from the Code Interpreter tool call."]
    #[builder(default)]
    pub logs: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsFileSearchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsFileSearchObjectType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsFileSearchObjectType,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: std::collections::HashMap<String, serde_json::Value>,
        }
        let _D {
            index,
            id,
            file_search,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsFileSearchObject {
            index,
            id,
            file_search,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsFileSearchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsFileSearchObjectType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsFileSearchObjectType,
            #[serde(rename = "file_search")]
            file_search: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let RunStepDeltaStepDetailsToolCallsFileSearchObject {
            index,
            id,
            file_search,
        } = self;
        _S {
            index,
            id,
            type_: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsFileSearchObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: u64,
    #[doc = "The ID of the tool call object."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "For now, this is always going to be an empty object."]
    pub file_search: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let _D {
            name,
            arguments,
            output,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
        } = self;
        _S {
            name,
            arguments,
            output,
        }
        .serialize(serializer)
    }
}
#[doc = "The definition of the function that was called."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments passed to the function."]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet."]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsFunctionObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsFunctionObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsFunctionObjectType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: Option<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,
        }
        let _D {
            index,
            id,
            function,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsFunctionObject {
            index,
            id,
            function,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsFunctionObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsFunctionObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsFunctionObjectType,
            #[serde(rename = "function")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function: &'a Option<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,
        }
        let RunStepDeltaStepDetailsToolCallsFunctionObject {
            index,
            id,
            function,
        } = self;
        _S {
            index,
            id,
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: u64,
    #[doc = "The ID of the tool call object."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The definition of the function that was called."]
    #[builder(default)]
    pub function: Option<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsObjectToolCalls {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsCodeObject),
            FileSearch(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsFileSearchObject),
            Function(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsFunctionObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsObjectToolCalls {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsCodeObject),
            FileSearch(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsFileSearchObject),
            Function(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsFunctionObject),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDeltaStepDetailsToolCallsObjectToolCalls {
    CodeInterpreter(RunStepDeltaStepDetailsToolCallsCodeObject),
    FileSearch(RunStepDeltaStepDetailsToolCallsFileSearchObject),
    Function(RunStepDeltaStepDetailsToolCallsFunctionObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `tool_calls`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsObjectType {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsObjectType,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Option<Vec<RunStepDeltaStepDetailsToolCallsObjectToolCalls>>,
        }
        let _D { tool_calls, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDeltaStepDetailsToolCallsObject { tool_calls })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `tool_calls`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsObjectType {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsObjectType,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<Vec<RunStepDeltaStepDetailsToolCallsObjectToolCalls>>,
        }
        let RunStepDeltaStepDetailsToolCallsObject { tool_calls } = self;
        _S {
            type_: &Default::default(),
            tool_calls,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the tool call."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsObject {
    #[doc = "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.\n"]
    #[builder(default)]
    pub tool_calls: Option<Vec<RunStepDeltaStepDetailsToolCallsObjectToolCalls>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsMessageCreationObjectMessageCreation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "message_id")]
            #[allow(dead_code)]
            message_id: String,
        }
        let _D { message_id, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsMessageCreationObjectMessageCreation { message_id })
    }
}
impl serde::Serialize for RunStepDetailsMessageCreationObjectMessageCreation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "message_id")]
            message_id: &'a String,
        }
        let RunStepDetailsMessageCreationObjectMessageCreation { message_id } = self;
        _S { message_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsMessageCreationObjectMessageCreation {
    #[doc = "The ID of the message that was created by this run step."]
    pub message_id: String,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsMessageCreationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `message_creation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsMessageCreationObjectType {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsMessageCreationObjectType,
            #[serde(rename = "message_creation")]
            #[allow(dead_code)]
            message_creation: RunStepDetailsMessageCreationObjectMessageCreation,
        }
        let _D {
            message_creation, ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsMessageCreationObject { message_creation })
    }
}
impl serde::Serialize for RunStepDetailsMessageCreationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `message_creation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsMessageCreationObjectType {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsMessageCreationObjectType,
            #[serde(rename = "message_creation")]
            message_creation: &'a RunStepDetailsMessageCreationObjectMessageCreation,
        }
        let RunStepDetailsMessageCreationObject { message_creation } = self;
        _S {
            type_: &Default::default(),
            message_creation,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the message creation by the run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsMessageCreationObject {
    pub message_creation: RunStepDetailsMessageCreationObjectMessageCreation,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Logs(#[allow(dead_code)] RunStepDetailsToolCallsCodeOutputLogsObject),
            Image(#[allow(dead_code)] RunStepDetailsToolCallsCodeOutputImageObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Logs(_v) => Self::Logs(_v),
            _D::Image(_v) => Self::Image(_v),
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Logs(#[allow(dead_code)] &'a RunStepDetailsToolCallsCodeOutputLogsObject),
            Image(#[allow(dead_code)] &'a RunStepDetailsToolCallsCodeOutputImageObject),
        }
        match self {
            Self::Logs(_v) => _S::Logs(_v).serialize(serializer),
            Self::Image(_v) => _S::Image(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    Logs(RunStepDetailsToolCallsCodeOutputLogsObject),
    Image(RunStepDetailsToolCallsCodeOutputImageObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: String,
            #[serde(rename = "outputs")]
            #[allow(dead_code)]
            outputs: Vec<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>,
        }
        let _D { input, outputs, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsCodeObjectCodeInterpreter { input, outputs })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "outputs")]
            outputs: &'a Vec<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>,
        }
        let RunStepDetailsToolCallsCodeObjectCodeInterpreter { input, outputs } = self;
        _S { input, outputs }.serialize(serializer)
    }
}
#[doc = "The Code Interpreter tool call definition."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    #[doc = "The input to the Code Interpreter tool call."]
    pub input: String,
    #[doc = "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type."]
    pub outputs: Vec<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeObjectType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsCodeObjectType,
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: RunStepDetailsToolCallsCodeObjectCodeInterpreter,
        }
        let _D {
            id,
            code_interpreter,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsCodeObject {
            id,
            code_interpreter,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeObjectType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsCodeObjectType,
            #[serde(rename = "code_interpreter")]
            code_interpreter: &'a RunStepDetailsToolCallsCodeObjectCodeInterpreter,
        }
        let RunStepDetailsToolCallsCodeObject {
            id,
            code_interpreter,
        } = self;
        _S {
            id,
            type_: &Default::default(),
            code_interpreter,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the Code Interpreter tool call the run step was involved in."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeObject {
    #[doc = "The ID of the tool call."]
    pub id: String,
    #[doc = "The Code Interpreter tool call definition."]
    pub code_interpreter: RunStepDetailsToolCallsCodeObjectCodeInterpreter,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeOutputImageObjectImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
        }
        let _D { file_id, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsCodeOutputImageObjectImage { file_id })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeOutputImageObjectImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
        }
        let RunStepDetailsToolCallsCodeOutputImageObjectImage { file_id } = self;
        _S { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeOutputImageObjectImage {
    #[doc = "The [file](https://platform.openai.com/docs/api-reference/files) ID of the image."]
    pub file_id: String,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeOutputImageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeOutputImageObjectType {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsCodeOutputImageObjectType,
            #[serde(rename = "image")]
            #[allow(dead_code)]
            image: RunStepDetailsToolCallsCodeOutputImageObjectImage,
        }
        let _D { image, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsCodeOutputImageObject { image })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeOutputImageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeOutputImageObjectType {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsCodeOutputImageObjectType,
            #[serde(rename = "image")]
            image: &'a RunStepDetailsToolCallsCodeOutputImageObjectImage,
        }
        let RunStepDetailsToolCallsCodeOutputImageObject { image } = self;
        _S {
            type_: &Default::default(),
            image,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeOutputImageObject {
    pub image: RunStepDetailsToolCallsCodeOutputImageObjectImage,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeOutputLogsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeOutputLogsObjectType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsCodeOutputLogsObjectType,
            #[serde(rename = "logs")]
            #[allow(dead_code)]
            logs: String,
        }
        let _D { logs, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsCodeOutputLogsObject { logs })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeOutputLogsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeOutputLogsObjectType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsCodeOutputLogsObjectType,
            #[serde(rename = "logs")]
            logs: &'a String,
        }
        let RunStepDetailsToolCallsCodeOutputLogsObject { logs } = self;
        _S {
            type_: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[doc = "Text output from the Code Interpreter tool call as part of a run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeOutputLogsObject {
    #[doc = "The text output from the Code Interpreter tool call."]
    pub logs: String,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchObjectFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "ranking_options")]
            #[allow(dead_code)]
            ranking_options: Option<RunStepDetailsToolCallsFileSearchRankingOptionsObject>,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Option<Vec<RunStepDetailsToolCallsFileSearchResultObject>>,
        }
        let _D {
            ranking_options,
            results,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsFileSearchObjectFileSearch {
            ranking_options,
            results,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchObjectFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<RunStepDetailsToolCallsFileSearchRankingOptionsObject>,
            #[serde(rename = "results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            results: &'a Option<Vec<RunStepDetailsToolCallsFileSearchResultObject>>,
        }
        let RunStepDetailsToolCallsFileSearchObjectFileSearch {
            ranking_options,
            results,
        } = self;
        _S {
            ranking_options,
            results,
        }
        .serialize(serializer)
    }
}
#[doc = "For now, this is always going to be an empty object."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchObjectFileSearch {
    #[builder(default)]
    pub ranking_options: Option<RunStepDetailsToolCallsFileSearchRankingOptionsObject>,
    #[doc = "The results of the file search."]
    #[builder(default)]
    pub results: Option<Vec<RunStepDetailsToolCallsFileSearchResultObject>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsFileSearchObjectType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsFileSearchObjectType,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: RunStepDetailsToolCallsFileSearchObjectFileSearch,
        }
        let _D {
            id, file_search, ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsFileSearchObject { id, file_search })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsFileSearchObjectType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsFileSearchObjectType,
            #[serde(rename = "file_search")]
            file_search: &'a RunStepDetailsToolCallsFileSearchObjectFileSearch,
        }
        let RunStepDetailsToolCallsFileSearchObject { id, file_search } = self;
        _S {
            id,
            type_: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchObject {
    #[doc = "The ID of the tool call object."]
    pub id: String,
    #[doc = "For now, this is always going to be an empty object."]
    #[builder(default)]
    pub file_search: RunStepDetailsToolCallsFileSearchObjectFileSearch,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "ranker")]
            #[allow(dead_code)]
            ranker: FileSearchRanker,
            #[serde(rename = "score_threshold")]
            #[allow(dead_code)]
            score_threshold: f64,
        }
        let _D {
            ranker,
            score_threshold,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsFileSearchRankingOptionsObject {
            ranker,
            score_threshold,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "ranker")]
            ranker: &'a FileSearchRanker,
            #[serde(rename = "score_threshold")]
            score_threshold: &'a f64,
        }
        let RunStepDetailsToolCallsFileSearchRankingOptionsObject {
            ranker,
            score_threshold,
        } = self;
        _S {
            ranker,
            score_threshold,
        }
        .serialize(serializer)
    }
}
#[doc = "The ranking options for the file search."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    pub ranker: FileSearchRanker,
    #[doc = "The score threshold for the file search. All values must be a floating point number between 0 and 1."]
    pub score_threshold: f64,
}
#[doc = "The type of the content."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RunStepDetailsToolCallsFileSearchResultObjectContentType {
    #[default]
    #[serde(rename = "text")]
    Text,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchResultObjectContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RunStepDetailsToolCallsFileSearchResultObjectContentType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
        }
        let _D { type_, text, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsFileSearchResultObjectContent { type_, text })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchResultObjectContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RunStepDetailsToolCallsFileSearchResultObjectContentType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
        }
        let RunStepDetailsToolCallsFileSearchResultObjectContent { type_, text } = self;
        _S { type_, text }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchResultObjectContent {
    #[doc = "The type of the content."]
    #[builder(default)]
    pub type_: Option<RunStepDetailsToolCallsFileSearchResultObjectContentType>,
    #[doc = "The text content of the file."]
    #[builder(default)]
    pub text: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchResultObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "file_name")]
            #[allow(dead_code)]
            file_name: String,
            #[serde(rename = "score")]
            #[allow(dead_code)]
            score: f64,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<RunStepDetailsToolCallsFileSearchResultObjectContent>>,
        }
        let _D {
            file_id,
            file_name,
            score,
            content,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsFileSearchResultObject {
            file_id,
            file_name,
            score,
            content,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchResultObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "file_name")]
            file_name: &'a String,
            #[serde(rename = "score")]
            score: &'a f64,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<RunStepDetailsToolCallsFileSearchResultObjectContent>>,
        }
        let RunStepDetailsToolCallsFileSearchResultObject {
            file_id,
            file_name,
            score,
            content,
        } = self;
        _S {
            file_id,
            file_name,
            score,
            content,
        }
        .serialize(serializer)
    }
}
#[doc = "A result instance of the file search."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchResultObject {
    #[doc = "The ID of the file that result was found in."]
    pub file_id: String,
    #[doc = "The name of the file that result was found in."]
    pub file_name: String,
    #[doc = "The score of the result. All values must be a floating point number between 0 and 1."]
    pub score: f64,
    #[doc = "The content of the result that was found. The content is only included if requested via the include query parameter."]
    #[builder(default)]
    pub content: Option<Vec<RunStepDetailsToolCallsFileSearchResultObjectContent>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFunctionObjectFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let _D {
            name,
            arguments,
            output,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFunctionObjectFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let RunStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
        } = self;
        _S {
            name,
            arguments,
            output,
        }
        .serialize(serializer)
    }
}
#[doc = "The definition of the function that was called."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFunctionObjectFunction {
    #[doc = "The name of the function."]
    pub name: String,
    #[doc = "The arguments passed to the function."]
    pub arguments: String,
    #[doc = "The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet."]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFunctionObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsFunctionObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsFunctionObjectType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: RunStepDetailsToolCallsFunctionObjectFunction,
        }
        let _D { id, function, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsFunctionObject { id, function })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFunctionObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsFunctionObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsFunctionObjectType,
            #[serde(rename = "function")]
            function: &'a RunStepDetailsToolCallsFunctionObjectFunction,
        }
        let RunStepDetailsToolCallsFunctionObject { id, function } = self;
        _S {
            id,
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFunctionObject {
    #[doc = "The ID of the tool call object."]
    pub id: String,
    #[doc = "The definition of the function that was called."]
    pub function: RunStepDetailsToolCallsFunctionObjectFunction,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsObjectToolCalls {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            CodeInterpreter(#[allow(dead_code)] RunStepDetailsToolCallsCodeObject),
            FileSearch(#[allow(dead_code)] RunStepDetailsToolCallsFileSearchObject),
            Function(#[allow(dead_code)] RunStepDetailsToolCallsFunctionObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            _D::FileSearch(_v) => Self::FileSearch(_v),
            _D::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsObjectToolCalls {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a RunStepDetailsToolCallsCodeObject),
            FileSearch(#[allow(dead_code)] &'a RunStepDetailsToolCallsFileSearchObject),
            Function(#[allow(dead_code)] &'a RunStepDetailsToolCallsFunctionObject),
        }
        match self {
            Self::CodeInterpreter(_v) => _S::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => _S::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => _S::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDetailsToolCallsObjectToolCalls {
    CodeInterpreter(RunStepDetailsToolCallsCodeObject),
    FileSearch(RunStepDetailsToolCallsFileSearchObject),
    Function(RunStepDetailsToolCallsFunctionObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `tool_calls`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsObjectType {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsObjectType,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Vec<RunStepDetailsToolCallsObjectToolCalls>,
        }
        let _D { tool_calls, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepDetailsToolCallsObject { tool_calls })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `tool_calls`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsObjectType {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsObjectType,
            #[serde(rename = "tool_calls")]
            tool_calls: &'a Vec<RunStepDetailsToolCallsObjectToolCalls>,
        }
        let RunStepDetailsToolCallsObject { tool_calls } = self;
        _S {
            type_: &Default::default(),
            tool_calls,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsObject {
    #[doc = "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.\n"]
    pub tool_calls: Vec<RunStepDetailsToolCallsObjectToolCalls>,
}
impl<'de> serde::Deserialize<'de> for RunStepObjectType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectTypeMessageCreation {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectTypeToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            MessageCreation(#[allow(dead_code)] RunStepObjectTypeMessageCreation),
            ToolCalls(#[allow(dead_code)] RunStepObjectTypeToolCalls),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::MessageCreation(_) => Self::MessageCreation,
            _D::ToolCalls(_) => Self::ToolCalls,
        })
    }
}
impl serde::Serialize for RunStepObjectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectTypeMessageCreation {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectTypeToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            MessageCreation(#[allow(dead_code)] &'a RunStepObjectTypeMessageCreation),
            ToolCalls(#[allow(dead_code)] &'a RunStepObjectTypeToolCalls),
        }
        match self {
            Self::MessageCreation => _S::MessageCreation(&Default::default()).serialize(serializer),
            Self::ToolCalls => _S::ToolCalls(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of run step, which can be either `message_creation` or `tool_calls`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepObjectType {
    #[doc = "message_creation"]
    MessageCreation,
    #[doc = "tool_calls"]
    ToolCalls,
}
impl<'de> serde::Deserialize<'de> for RunStepObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] RunStepObjectStatusInProgress),
            Cancelled(#[allow(dead_code)] RunStepObjectStatusCancelled),
            Failed(#[allow(dead_code)] RunStepObjectStatusFailed),
            Completed(#[allow(dead_code)] RunStepObjectStatusCompleted),
            Expired(#[allow(dead_code)] RunStepObjectStatusExpired),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Cancelled(_) => Self::Cancelled,
            _D::Failed(_) => Self::Failed,
            _D::Completed(_) => Self::Completed,
            _D::Expired(_) => Self::Expired,
        })
    }
}
impl serde::Serialize for RunStepObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a RunStepObjectStatusInProgress),
            Cancelled(#[allow(dead_code)] &'a RunStepObjectStatusCancelled),
            Failed(#[allow(dead_code)] &'a RunStepObjectStatusFailed),
            Completed(#[allow(dead_code)] &'a RunStepObjectStatusCompleted),
            Expired(#[allow(dead_code)] &'a RunStepObjectStatusExpired),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Expired => _S::Expired(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepObjectStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
    #[doc = "completed"]
    Completed,
    #[doc = "expired"]
    Expired,
}
impl<'de> serde::Deserialize<'de> for RunStepObjectStepDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            MessageCreation(#[allow(dead_code)] RunStepDetailsMessageCreationObject),
            ToolCalls(#[allow(dead_code)] RunStepDetailsToolCallsObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::MessageCreation(_v) => Self::MessageCreation(_v),
            _D::ToolCalls(_v) => Self::ToolCalls(_v),
        })
    }
}
impl serde::Serialize for RunStepObjectStepDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            MessageCreation(#[allow(dead_code)] &'a RunStepDetailsMessageCreationObject),
            ToolCalls(#[allow(dead_code)] &'a RunStepDetailsToolCallsObject),
        }
        match self {
            Self::MessageCreation(_v) => _S::MessageCreation(_v).serialize(serializer),
            Self::ToolCalls(_v) => _S::ToolCalls(_v).serialize(serializer),
        }
    }
}
#[doc = "The details of the run step."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepObjectStepDetails {
    MessageCreation(RunStepDetailsMessageCreationObject),
    ToolCalls(RunStepDetailsToolCallsObject),
}
impl<'de> serde::Deserialize<'de> for RunStepObjectLastErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectLastErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ServerError(#[allow(dead_code)] RunStepObjectLastErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] RunStepObjectLastErrorCodeRateLimitExceeded),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ServerError(_) => Self::ServerError,
            _D::RateLimitExceeded(_) => Self::RateLimitExceeded,
        })
    }
}
impl serde::Serialize for RunStepObjectLastErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectLastErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ServerError(#[allow(dead_code)] &'a RunStepObjectLastErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] &'a RunStepObjectLastErrorCodeRateLimitExceeded),
        }
        match self {
            Self::ServerError => _S::ServerError(&Default::default()).serialize(serializer),
            Self::RateLimitExceeded => {
                _S::RateLimitExceeded(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "One of `server_error` or `rate_limit_exceeded`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepObjectLastErrorCode {
    #[doc = "server_error"]
    ServerError,
    #[doc = "rate_limit_exceeded"]
    RateLimitExceeded,
}
impl<'de> serde::Deserialize<'de> for RunStepObjectLastError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: RunStepObjectLastErrorCode,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let _D { code, message, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepObjectLastError { code, message })
    }
}
impl serde::Serialize for RunStepObjectLastError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            code: &'a RunStepObjectLastErrorCode,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let RunStepObjectLastError { code, message } = self;
        _S { code, message }.serialize(serializer)
    }
}
#[doc = "The last error associated with this run step. Will be `null` if there are no errors."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepObjectLastError {
    #[doc = "One of `server_error` or `rate_limit_exceeded`."]
    pub code: RunStepObjectLastErrorCode,
    #[doc = "A human-readable description of the error."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for RunStepObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.run.step`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectObject {
            #[default]
            #[serde(rename = "thread.run.step")]
            ThreadRunStep,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: RunStepObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "thread_id")]
            #[allow(dead_code)]
            thread_id: String,
            #[serde(rename = "run_id")]
            #[allow(dead_code)]
            run_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepObjectType,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: RunStepObjectStatus,
            #[serde(rename = "step_details")]
            #[allow(dead_code)]
            step_details: RunStepObjectStepDetails,
            #[serde(rename = "last_error")]
            #[allow(dead_code)]
            last_error: Option<RunStepObjectLastError>,
            #[serde(rename = "expired_at")]
            #[allow(dead_code)]
            expired_at: Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[allow(dead_code)]
            cancelled_at: Option<u64>,
            #[serde(rename = "failed_at")]
            #[allow(dead_code)]
            failed_at: Option<u64>,
            #[serde(rename = "completed_at")]
            #[allow(dead_code)]
            completed_at: Option<u64>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Metadata,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: RunStepCompletionUsage,
        }
        let _D {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            type_,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RunStepObject {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            type_,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        })
    }
}
impl serde::Serialize for RunStepObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.run.step`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectObject {
            #[default]
            #[serde(rename = "thread.run.step")]
            ThreadRunStep,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a RunStepObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "run_id")]
            run_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunStepObjectType,
            #[serde(rename = "status")]
            status: &'a RunStepObjectStatus,
            #[serde(rename = "step_details")]
            step_details: &'a RunStepObjectStepDetails,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<RunStepObjectLastError>,
            #[serde(rename = "expired_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expired_at: &'a Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<u64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<u64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<u64>,
            #[serde(rename = "metadata")]
            metadata: &'a Metadata,
            #[serde(rename = "usage")]
            usage: &'a RunStepCompletionUsage,
        }
        let RunStepObject {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            type_,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        } = self;
        _S {
            id,
            object: &Default::default(),
            created_at,
            assistant_id,
            thread_id,
            run_id,
            type_,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a step in execution of a run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepObject {
    #[doc = "The identifier of the run step, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the run step was created."]
    pub created_at: u64,
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step."]
    pub assistant_id: String,
    #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run."]
    pub thread_id: String,
    #[doc = "The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of."]
    pub run_id: String,
    #[doc = "The type of run step, which can be either `message_creation` or `tool_calls`."]
    pub type_: RunStepObjectType,
    #[doc = "The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`."]
    pub status: RunStepObjectStatus,
    #[doc = "The details of the run step."]
    pub step_details: RunStepObjectStepDetails,
    #[doc = "The last error associated with this run step. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<RunStepObjectLastError>,
    #[doc = "The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired."]
    #[builder(default)]
    pub expired_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step failed."]
    #[builder(default)]
    pub failed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step completed."]
    #[builder(default)]
    pub completed_at: Option<u64>,
    pub metadata: Metadata,
    pub usage: RunStepCompletionUsage,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCreatedEvent {
            #[default]
            #[serde(rename = "thread.run.step.created")]
            ThreadRunStepCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepCreatedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepStreamEventThreadRunStepCreated { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCreatedEvent {
            #[default]
            #[serde(rename = "thread.run.step.created")]
            ThreadRunStepCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepCreatedEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let RunStepStreamEventThreadRunStepCreated { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is created."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepCreated {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepInProgress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepInProgressEvent {
            #[default]
            #[serde(rename = "thread.run.step.in_progress")]
            ThreadRunStepInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepInProgressEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepStreamEventThreadRunStepInProgress { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepInProgress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepInProgressEvent {
            #[default]
            #[serde(rename = "thread.run.step.in_progress")]
            ThreadRunStepInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepInProgressEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let RunStepStreamEventThreadRunStepInProgress { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) moves to an `in_progress` state."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepInProgress {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepDeltaEvent {
            #[default]
            #[serde(rename = "thread.run.step.delta")]
            ThreadRunStepDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepDeltaEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepDeltaObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepStreamEventThreadRunStepDelta { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepDeltaEvent {
            #[default]
            #[serde(rename = "thread.run.step.delta")]
            ThreadRunStepDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepDeltaEvent,
            #[serde(rename = "data")]
            data: &'a RunStepDeltaObject,
        }
        let RunStepStreamEventThreadRunStepDelta { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when parts of a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) are being streamed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepDelta {
    pub data: RunStepDeltaObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepCompleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCompletedEvent {
            #[default]
            #[serde(rename = "thread.run.step.completed")]
            ThreadRunStepCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepCompletedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepStreamEventThreadRunStepCompleted { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCompletedEvent {
            #[default]
            #[serde(rename = "thread.run.step.completed")]
            ThreadRunStepCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepCompletedEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let RunStepStreamEventThreadRunStepCompleted { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepCompleted {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepFailedEvent {
            #[default]
            #[serde(rename = "thread.run.step.failed")]
            ThreadRunStepFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepFailedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepStreamEventThreadRunStepFailed { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepFailedEvent {
            #[default]
            #[serde(rename = "thread.run.step.failed")]
            ThreadRunStepFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepFailedEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let RunStepStreamEventThreadRunStepFailed { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) fails."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepFailed {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepCancelled {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCancelledEvent {
            #[default]
            #[serde(rename = "thread.run.step.cancelled")]
            ThreadRunStepCancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepCancelledEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepStreamEventThreadRunStepCancelled { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepCancelled {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCancelledEvent {
            #[default]
            #[serde(rename = "thread.run.step.cancelled")]
            ThreadRunStepCancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepCancelledEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let RunStepStreamEventThreadRunStepCancelled { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is cancelled."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepCancelled {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepExpired {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepExpiredEvent {
            #[default]
            #[serde(rename = "thread.run.step.expired")]
            ThreadRunStepExpired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepExpiredEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStepStreamEventThreadRunStepExpired { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepExpired {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepExpiredEvent {
            #[default]
            #[serde(rename = "thread.run.step.expired")]
            ThreadRunStepExpired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepExpiredEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let RunStepStreamEventThreadRunStepExpired { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) expires."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepExpired {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ThreadRunStepCreated(#[allow(dead_code)] RunStepStreamEventThreadRunStepCreated),
            ThreadRunStepInProgress(#[allow(dead_code)] RunStepStreamEventThreadRunStepInProgress),
            ThreadRunStepDelta(#[allow(dead_code)] RunStepStreamEventThreadRunStepDelta),
            ThreadRunStepCompleted(#[allow(dead_code)] RunStepStreamEventThreadRunStepCompleted),
            ThreadRunStepFailed(#[allow(dead_code)] RunStepStreamEventThreadRunStepFailed),
            ThreadRunStepCancelled(#[allow(dead_code)] RunStepStreamEventThreadRunStepCancelled),
            ThreadRunStepExpired(#[allow(dead_code)] RunStepStreamEventThreadRunStepExpired),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ThreadRunStepCreated(_v) => Self::ThreadRunStepCreated(_v),
            _D::ThreadRunStepInProgress(_v) => Self::ThreadRunStepInProgress(_v),
            _D::ThreadRunStepDelta(_v) => Self::ThreadRunStepDelta(_v),
            _D::ThreadRunStepCompleted(_v) => Self::ThreadRunStepCompleted(_v),
            _D::ThreadRunStepFailed(_v) => Self::ThreadRunStepFailed(_v),
            _D::ThreadRunStepCancelled(_v) => Self::ThreadRunStepCancelled(_v),
            _D::ThreadRunStepExpired(_v) => Self::ThreadRunStepExpired(_v),
        })
    }
}
impl serde::Serialize for RunStepStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ThreadRunStepCreated(#[allow(dead_code)] &'a RunStepStreamEventThreadRunStepCreated),
            ThreadRunStepInProgress(
                #[allow(dead_code)] &'a RunStepStreamEventThreadRunStepInProgress,
            ),
            ThreadRunStepDelta(#[allow(dead_code)] &'a RunStepStreamEventThreadRunStepDelta),
            ThreadRunStepCompleted(
                #[allow(dead_code)] &'a RunStepStreamEventThreadRunStepCompleted,
            ),
            ThreadRunStepFailed(#[allow(dead_code)] &'a RunStepStreamEventThreadRunStepFailed),
            ThreadRunStepCancelled(
                #[allow(dead_code)] &'a RunStepStreamEventThreadRunStepCancelled,
            ),
            ThreadRunStepExpired(#[allow(dead_code)] &'a RunStepStreamEventThreadRunStepExpired),
        }
        match self {
            Self::ThreadRunStepCreated(_v) => _S::ThreadRunStepCreated(_v).serialize(serializer),
            Self::ThreadRunStepInProgress(_v) => {
                _S::ThreadRunStepInProgress(_v).serialize(serializer)
            }
            Self::ThreadRunStepDelta(_v) => _S::ThreadRunStepDelta(_v).serialize(serializer),
            Self::ThreadRunStepCompleted(_v) => {
                _S::ThreadRunStepCompleted(_v).serialize(serializer)
            }
            Self::ThreadRunStepFailed(_v) => _S::ThreadRunStepFailed(_v).serialize(serializer),
            Self::ThreadRunStepCancelled(_v) => {
                _S::ThreadRunStepCancelled(_v).serialize(serializer)
            }
            Self::ThreadRunStepExpired(_v) => _S::ThreadRunStepExpired(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepStreamEvent {
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is created."]
    ThreadRunStepCreated(RunStepStreamEventThreadRunStepCreated),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) moves to an `in_progress` state."]
    ThreadRunStepInProgress(RunStepStreamEventThreadRunStepInProgress),
    #[doc = "Occurs when parts of a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) are being streamed."]
    ThreadRunStepDelta(RunStepStreamEventThreadRunStepDelta),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is completed."]
    ThreadRunStepCompleted(RunStepStreamEventThreadRunStepCompleted),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) fails."]
    ThreadRunStepFailed(RunStepStreamEventThreadRunStepFailed),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is cancelled."]
    ThreadRunStepCancelled(RunStepStreamEventThreadRunStepCancelled),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) expires."]
    ThreadRunStepExpired(RunStepStreamEventThreadRunStepExpired),
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCreatedEvent {
            #[default]
            #[serde(rename = "thread.run.created")]
            ThreadRunCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunCreatedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunCreated { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCreatedEvent {
            #[default]
            #[serde(rename = "thread.run.created")]
            ThreadRunCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunCreatedEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunCreated { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a new [run](https://platform.openai.com/docs/api-reference/runs/object) is created."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunCreated {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunQueued {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunQueuedEvent {
            #[default]
            #[serde(rename = "thread.run.queued")]
            ThreadRunQueued,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunQueuedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunQueued { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunQueued {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunQueuedEvent {
            #[default]
            #[serde(rename = "thread.run.queued")]
            ThreadRunQueued,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunQueuedEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunQueued { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `queued` status."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunQueued {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunInProgress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunInProgressEvent {
            #[default]
            #[serde(rename = "thread.run.in_progress")]
            ThreadRunInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunInProgressEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunInProgress { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunInProgress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunInProgressEvent {
            #[default]
            #[serde(rename = "thread.run.in_progress")]
            ThreadRunInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunInProgressEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunInProgress { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to an `in_progress` status."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunInProgress {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunRequiresAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunRequiresActionEvent {
            #[default]
            #[serde(rename = "thread.run.requires_action")]
            ThreadRunRequiresAction,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunRequiresActionEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunRequiresAction { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunRequiresAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunRequiresActionEvent {
            #[default]
            #[serde(rename = "thread.run.requires_action")]
            ThreadRunRequiresAction,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunRequiresActionEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunRequiresAction { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `requires_action` status."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunRequiresAction {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunCompleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCompletedEvent {
            #[default]
            #[serde(rename = "thread.run.completed")]
            ThreadRunCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunCompletedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunCompleted { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCompletedEvent {
            #[default]
            #[serde(rename = "thread.run.completed")]
            ThreadRunCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunCompletedEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunCompleted { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunCompleted {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunIncomplete {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunIncompleteEvent {
            #[default]
            #[serde(rename = "thread.run.incomplete")]
            ThreadRunIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunIncompleteEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunIncomplete { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunIncomplete {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunIncompleteEvent {
            #[default]
            #[serde(rename = "thread.run.incomplete")]
            ThreadRunIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunIncompleteEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunIncomplete { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) ends with status `incomplete`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunIncomplete {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunFailedEvent {
            #[default]
            #[serde(rename = "thread.run.failed")]
            ThreadRunFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunFailedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunFailed { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunFailedEvent {
            #[default]
            #[serde(rename = "thread.run.failed")]
            ThreadRunFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunFailedEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunFailed { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) fails."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunFailed {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunCancelling {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCancellingEvent {
            #[default]
            #[serde(rename = "thread.run.cancelling")]
            ThreadRunCancelling,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunCancellingEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunCancelling { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunCancelling {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCancellingEvent {
            #[default]
            #[serde(rename = "thread.run.cancelling")]
            ThreadRunCancelling,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunCancellingEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunCancelling { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `cancelling` status."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunCancelling {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunCancelled {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCancelledEvent {
            #[default]
            #[serde(rename = "thread.run.cancelled")]
            ThreadRunCancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunCancelledEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunCancelled { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunCancelled {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCancelledEvent {
            #[default]
            #[serde(rename = "thread.run.cancelled")]
            ThreadRunCancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunCancelledEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunCancelled { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is cancelled."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunCancelled {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunExpired {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunExpiredEvent {
            #[default]
            #[serde(rename = "thread.run.expired")]
            ThreadRunExpired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunExpiredEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let _D { data, .. } = _D::deserialize(deserializer)?;
        Ok(RunStreamEventThreadRunExpired { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunExpired {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunExpiredEvent {
            #[default]
            #[serde(rename = "thread.run.expired")]
            ThreadRunExpired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunExpiredEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let RunStreamEventThreadRunExpired { data } = self;
        _S {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) expires."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunExpired {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ThreadRunCreated(#[allow(dead_code)] RunStreamEventThreadRunCreated),
            ThreadRunQueued(#[allow(dead_code)] RunStreamEventThreadRunQueued),
            ThreadRunInProgress(#[allow(dead_code)] RunStreamEventThreadRunInProgress),
            ThreadRunRequiresAction(#[allow(dead_code)] RunStreamEventThreadRunRequiresAction),
            ThreadRunCompleted(#[allow(dead_code)] RunStreamEventThreadRunCompleted),
            ThreadRunIncomplete(#[allow(dead_code)] RunStreamEventThreadRunIncomplete),
            ThreadRunFailed(#[allow(dead_code)] RunStreamEventThreadRunFailed),
            ThreadRunCancelling(#[allow(dead_code)] RunStreamEventThreadRunCancelling),
            ThreadRunCancelled(#[allow(dead_code)] RunStreamEventThreadRunCancelled),
            ThreadRunExpired(#[allow(dead_code)] RunStreamEventThreadRunExpired),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ThreadRunCreated(_v) => Self::ThreadRunCreated(_v),
            _D::ThreadRunQueued(_v) => Self::ThreadRunQueued(_v),
            _D::ThreadRunInProgress(_v) => Self::ThreadRunInProgress(_v),
            _D::ThreadRunRequiresAction(_v) => Self::ThreadRunRequiresAction(_v),
            _D::ThreadRunCompleted(_v) => Self::ThreadRunCompleted(_v),
            _D::ThreadRunIncomplete(_v) => Self::ThreadRunIncomplete(_v),
            _D::ThreadRunFailed(_v) => Self::ThreadRunFailed(_v),
            _D::ThreadRunCancelling(_v) => Self::ThreadRunCancelling(_v),
            _D::ThreadRunCancelled(_v) => Self::ThreadRunCancelled(_v),
            _D::ThreadRunExpired(_v) => Self::ThreadRunExpired(_v),
        })
    }
}
impl serde::Serialize for RunStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ThreadRunCreated(#[allow(dead_code)] &'a RunStreamEventThreadRunCreated),
            ThreadRunQueued(#[allow(dead_code)] &'a RunStreamEventThreadRunQueued),
            ThreadRunInProgress(#[allow(dead_code)] &'a RunStreamEventThreadRunInProgress),
            ThreadRunRequiresAction(#[allow(dead_code)] &'a RunStreamEventThreadRunRequiresAction),
            ThreadRunCompleted(#[allow(dead_code)] &'a RunStreamEventThreadRunCompleted),
            ThreadRunIncomplete(#[allow(dead_code)] &'a RunStreamEventThreadRunIncomplete),
            ThreadRunFailed(#[allow(dead_code)] &'a RunStreamEventThreadRunFailed),
            ThreadRunCancelling(#[allow(dead_code)] &'a RunStreamEventThreadRunCancelling),
            ThreadRunCancelled(#[allow(dead_code)] &'a RunStreamEventThreadRunCancelled),
            ThreadRunExpired(#[allow(dead_code)] &'a RunStreamEventThreadRunExpired),
        }
        match self {
            Self::ThreadRunCreated(_v) => _S::ThreadRunCreated(_v).serialize(serializer),
            Self::ThreadRunQueued(_v) => _S::ThreadRunQueued(_v).serialize(serializer),
            Self::ThreadRunInProgress(_v) => _S::ThreadRunInProgress(_v).serialize(serializer),
            Self::ThreadRunRequiresAction(_v) => {
                _S::ThreadRunRequiresAction(_v).serialize(serializer)
            }
            Self::ThreadRunCompleted(_v) => _S::ThreadRunCompleted(_v).serialize(serializer),
            Self::ThreadRunIncomplete(_v) => _S::ThreadRunIncomplete(_v).serialize(serializer),
            Self::ThreadRunFailed(_v) => _S::ThreadRunFailed(_v).serialize(serializer),
            Self::ThreadRunCancelling(_v) => _S::ThreadRunCancelling(_v).serialize(serializer),
            Self::ThreadRunCancelled(_v) => _S::ThreadRunCancelled(_v).serialize(serializer),
            Self::ThreadRunExpired(_v) => _S::ThreadRunExpired(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStreamEvent {
    #[doc = "Occurs when a new [run](https://platform.openai.com/docs/api-reference/runs/object) is created."]
    ThreadRunCreated(RunStreamEventThreadRunCreated),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `queued` status."]
    ThreadRunQueued(RunStreamEventThreadRunQueued),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to an `in_progress` status."]
    ThreadRunInProgress(RunStreamEventThreadRunInProgress),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `requires_action` status."]
    ThreadRunRequiresAction(RunStreamEventThreadRunRequiresAction),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is completed."]
    ThreadRunCompleted(RunStreamEventThreadRunCompleted),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) ends with status `incomplete`."]
    ThreadRunIncomplete(RunStreamEventThreadRunIncomplete),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) fails."]
    ThreadRunFailed(RunStreamEventThreadRunFailed),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `cancelling` status."]
    ThreadRunCancelling(RunStreamEventThreadRunCancelling),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is cancelled."]
    ThreadRunCancelled(RunStreamEventThreadRunCancelled),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) expires."]
    ThreadRunExpired(RunStreamEventThreadRunExpired),
}
impl<'de> serde::Deserialize<'de> for RunToolCallObjectFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let _D {
            name, arguments, ..
        } = _D::deserialize(deserializer)?;
        Ok(RunToolCallObjectFunction { name, arguments })
    }
}
impl serde::Serialize for RunToolCallObjectFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let RunToolCallObjectFunction { name, arguments } = self;
        _S { name, arguments }.serialize(serializer)
    }
}
#[doc = "The function definition."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunToolCallObjectFunction {
    #[doc = "The name of the function."]
    pub name: String,
    #[doc = "The arguments that the model expects you to pass to the function."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for RunToolCallObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call the output is required for. For now, this is always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunToolCallObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunToolCallObjectType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: RunToolCallObjectFunction,
        }
        let _D { id, function, .. } = _D::deserialize(deserializer)?;
        Ok(RunToolCallObject { id, function })
    }
}
impl serde::Serialize for RunToolCallObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call the output is required for. For now, this is always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunToolCallObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunToolCallObjectType,
            #[serde(rename = "function")]
            function: &'a RunToolCallObjectFunction,
        }
        let RunToolCallObject { id, function } = self;
        _S {
            id,
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[doc = "Tool call objects"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunToolCallObject {
    #[doc = "The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint."]
    pub id: String,
    #[doc = "The function definition."]
    pub function: RunToolCallObjectFunction,
}
impl<'de> serde::Deserialize<'de> for Screenshot {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a screenshot action, this property is \nalways set to `screenshot`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ScreenshotType {
            #[default]
            #[serde(rename = "screenshot")]
            Screenshot,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ScreenshotType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(Screenshot {})
    }
}
impl serde::Serialize for Screenshot {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a screenshot action, this property is \nalways set to `screenshot`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ScreenshotType {
            #[default]
            #[serde(rename = "screenshot")]
            Screenshot,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ScreenshotType,
        }
        let Screenshot {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "A screenshot action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct Screenshot {}
impl<'de> serde::Deserialize<'de> for Scroll {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a scroll action, this property is \nalways set to `scroll`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ScrollType {
            #[default]
            #[serde(rename = "scroll")]
            Scroll,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ScrollType,
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
            #[serde(rename = "scroll_x")]
            #[allow(dead_code)]
            scroll_x: u64,
            #[serde(rename = "scroll_y")]
            #[allow(dead_code)]
            scroll_y: u64,
        }
        let _D {
            x,
            y,
            scroll_x,
            scroll_y,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Scroll {
            x,
            y,
            scroll_x,
            scroll_y,
        })
    }
}
impl serde::Serialize for Scroll {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a scroll action, this property is \nalways set to `scroll`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ScrollType {
            #[default]
            #[serde(rename = "scroll")]
            Scroll,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ScrollType,
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
            #[serde(rename = "scroll_x")]
            scroll_x: &'a u64,
            #[serde(rename = "scroll_y")]
            scroll_y: &'a u64,
        }
        let Scroll {
            x,
            y,
            scroll_x,
            scroll_y,
        } = self;
        _S {
            type_: &Default::default(),
            x,
            y,
            scroll_x,
            scroll_y,
        }
        .serialize(serializer)
    }
}
#[doc = "A scroll action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct Scroll {
    #[doc = "The x-coordinate where the scroll occurred.\n"]
    pub x: u64,
    #[doc = "The y-coordinate where the scroll occurred.\n"]
    pub y: u64,
    #[doc = "The horizontal scroll distance.\n"]
    pub scroll_x: u64,
    #[doc = "The vertical scroll distance.\n"]
    pub scroll_y: u64,
}
impl<'de> serde::Deserialize<'de> for ServiceTier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierDefault {
            #[default]
            #[serde(rename = "default")]
            Default,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierFlex {
            #[default]
            #[serde(rename = "flex")]
            Flex,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] ServiceTierAuto),
            Default(#[allow(dead_code)] ServiceTierDefault),
            Flex(#[allow(dead_code)] ServiceTierFlex),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Default(_) => Self::Default,
            _D::Flex(_) => Self::Flex,
        })
    }
}
impl serde::Serialize for ServiceTier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierDefault {
            #[default]
            #[serde(rename = "default")]
            Default,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierFlex {
            #[default]
            #[serde(rename = "flex")]
            Flex,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a ServiceTierAuto),
            Default(#[allow(dead_code)] &'a ServiceTierDefault),
            Flex(#[allow(dead_code)] &'a ServiceTierFlex),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Default => _S::Default(&Default::default()).serialize(serializer),
            Self::Flex => _S::Flex(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:\n  - If set to 'auto', and the Project is Scale tier enabled, the system\n    will utilize scale tier credits until they are exhausted.\n  - If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.\n  - If set to 'default', the request will be processed using the default service tier with a lower uptime SLA and no latency guarentee.\n  - If set to 'flex', the request will be processed with the Flex Processing service tier. [Learn more](/docs/guides/flex-processing).\n  - When not set, the default behavior is 'auto'.\n\n  When this parameter is set, the response body will include the `service_tier` utilized.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ServiceTier {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "default"]
    Default,
    #[doc = "flex"]
    Flex,
}
impl<'de> serde::Deserialize<'de> for StaticChunkingStrategy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let _D {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(StaticChunkingStrategy {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        })
    }
}
impl serde::Serialize for StaticChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let StaticChunkingStrategy {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        _S {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategy {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for StaticChunkingStrategyRequestParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum StaticChunkingStrategyRequestParamType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: StaticChunkingStrategyRequestParamType,
            #[serde(rename = "static")]
            #[allow(dead_code)]
            static_: StaticChunkingStrategy,
        }
        let _D { static_, .. } = _D::deserialize(deserializer)?;
        Ok(StaticChunkingStrategyRequestParam { static_ })
    }
}
impl serde::Serialize for StaticChunkingStrategyRequestParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum StaticChunkingStrategyRequestParamType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a StaticChunkingStrategyRequestParamType,
            #[serde(rename = "static")]
            static_: &'a StaticChunkingStrategy,
        }
        let StaticChunkingStrategyRequestParam { static_ } = self;
        _S {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[doc = "Customize your own chunking strategy by setting chunk size and chunk overlap."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategyRequestParam {
    pub static_: StaticChunkingStrategy,
}
impl<'de> serde::Deserialize<'de> for StaticChunkingStrategyResponseParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum StaticChunkingStrategyResponseParamType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: StaticChunkingStrategyResponseParamType,
            #[serde(rename = "static")]
            #[allow(dead_code)]
            static_: StaticChunkingStrategy,
        }
        let _D { static_, .. } = _D::deserialize(deserializer)?;
        Ok(StaticChunkingStrategyResponseParam { static_ })
    }
}
impl serde::Serialize for StaticChunkingStrategyResponseParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum StaticChunkingStrategyResponseParamType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a StaticChunkingStrategyResponseParamType,
            #[serde(rename = "static")]
            static_: &'a StaticChunkingStrategy,
        }
        let StaticChunkingStrategyResponseParam { static_ } = self;
        _S {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategyResponseParam {
    pub static_: StaticChunkingStrategy,
}
impl<'de> serde::Deserialize<'de> for StopConfiguration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<String>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for StopConfiguration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<String>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "Not supported with latest reasoning models `o3` and `o4-mini`.\n\nUp to 4 sequences where the API will stop generating further tokens. The\nreturned text will not contain the stop sequence.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum StopConfiguration {
    String(String),
    Array(Vec<String>),
}
impl<'de> serde::Deserialize<'de> for SubmitToolOutputsRunRequestToolOutputs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "tool_call_id")]
            #[allow(dead_code)]
            tool_call_id: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let _D {
            tool_call_id,
            output,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(SubmitToolOutputsRunRequestToolOutputs {
            tool_call_id,
            output,
        })
    }
}
impl serde::Serialize for SubmitToolOutputsRunRequestToolOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "tool_call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_call_id: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let SubmitToolOutputsRunRequestToolOutputs {
            tool_call_id,
            output,
        } = self;
        _S {
            tool_call_id,
            output,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct SubmitToolOutputsRunRequestToolOutputs {
    #[doc = "The ID of the tool call in the `required_action` object within the run object the output is being submitted for."]
    #[builder(default)]
    pub tool_call_id: Option<String>,
    #[doc = "The output of the tool call to be submitted to continue the run."]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for SubmitToolOutputsRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "tool_outputs")]
            #[allow(dead_code)]
            tool_outputs: Vec<SubmitToolOutputsRunRequestToolOutputs>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
        }
        let _D {
            tool_outputs,
            stream,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(SubmitToolOutputsRunRequest {
            tool_outputs,
            stream,
        })
    }
}
impl serde::Serialize for SubmitToolOutputsRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "tool_outputs")]
            tool_outputs: &'a Vec<SubmitToolOutputsRunRequestToolOutputs>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
        }
        let SubmitToolOutputsRunRequest {
            tool_outputs,
            stream,
        } = self;
        _S {
            tool_outputs,
            stream,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct SubmitToolOutputsRunRequest {
    #[doc = "A list of tools for which the outputs are being submitted."]
    pub tool_outputs: Vec<SubmitToolOutputsRunRequestToolOutputs>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for TextResponseFormatConfiguration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Text(#[allow(dead_code)] ResponseFormatText),
            JsonSchema(#[allow(dead_code)] TextResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] ResponseFormatJsonObject),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Text(_v) => Self::Text(_v),
            _D::JsonSchema(_v) => Self::JsonSchema(_v),
            _D::JsonObject(_v) => Self::JsonObject(_v),
        })
    }
}
impl serde::Serialize for TextResponseFormatConfiguration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Text(#[allow(dead_code)] &'a ResponseFormatText),
            JsonSchema(#[allow(dead_code)] &'a TextResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] &'a ResponseFormatJsonObject),
        }
        match self {
            Self::Text(_v) => _S::Text(_v).serialize(serializer),
            Self::JsonSchema(_v) => _S::JsonSchema(_v).serialize(serializer),
            Self::JsonObject(_v) => _S::JsonObject(_v).serialize(serializer),
        }
    }
}
#[doc = "An object specifying the format that the model must output.\n\nConfiguring `{ \"type\": \"json_schema\" }` enables Structured Outputs, \nwhich ensures the model will match your supplied JSON schema. Learn more in the \n[Structured Outputs guide](/docs/guides/structured-outputs).\n\nThe default format is `{ \"type\": \"text\" }` with no additional options.\n\n**Not recommended for gpt-4o and newer models:**\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum TextResponseFormatConfiguration {
    Text(ResponseFormatText),
    JsonSchema(TextResponseFormatJsonSchema),
    JsonObject(ResponseFormatJsonObject),
}
impl<'de> serde::Deserialize<'de> for TextResponseFormatJsonSchema {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of response format being defined. Always `json_schema`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TextResponseFormatJsonSchemaType {
            #[default]
            #[serde(rename = "json_schema")]
            JsonSchema,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TextResponseFormatJsonSchemaType,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: ResponseFormatJsonSchemaSchema,
            #[serde(rename = "strict")]
            #[allow(dead_code)]
            strict: Option<bool>,
        }
        let _D {
            description,
            name,
            schema,
            strict,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(TextResponseFormatJsonSchema {
            description,
            name,
            schema,
            strict,
        })
    }
}
impl serde::Serialize for TextResponseFormatJsonSchema {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of response format being defined. Always `json_schema`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TextResponseFormatJsonSchemaType {
            #[default]
            #[serde(rename = "json_schema")]
            JsonSchema,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a TextResponseFormatJsonSchemaType,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "schema")]
            schema: &'a ResponseFormatJsonSchemaSchema,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let TextResponseFormatJsonSchema {
            description,
            name,
            schema,
            strict,
        } = self;
        _S {
            type_: &Default::default(),
            description,
            name,
            schema,
            strict,
        }
        .serialize(serializer)
    }
}
#[doc = "JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](/docs/guides/structured-outputs).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TextResponseFormatJsonSchema {
    #[doc = "A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n"]
    pub name: String,
    pub schema: ResponseFormatJsonSchemaSchema,
    #[doc = "Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](/docs/guides/structured-outputs).\n"]
    #[builder(default)]
    pub strict: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ThreadObjectToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let _D { file_ids, .. } = _D::deserialize(deserializer)?;
        Ok(ThreadObjectToolResourcesCodeInterpreter { file_ids })
    }
}
impl serde::Serialize for ThreadObjectToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let ThreadObjectToolResourcesCodeInterpreter { file_ids } = self;
        _S { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ThreadObjectToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ThreadObjectToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let _D {
            vector_store_ids, ..
        } = _D::deserialize(deserializer)?;
        Ok(ThreadObjectToolResourcesFileSearch { vector_store_ids })
    }
}
impl serde::Serialize for ThreadObjectToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let ThreadObjectToolResourcesFileSearch { vector_store_ids } = self;
        _S { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ThreadObjectToolResourcesFileSearch {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ThreadObjectToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<ThreadObjectToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<ThreadObjectToolResourcesFileSearch>,
        }
        let _D {
            code_interpreter,
            file_search,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ThreadObjectToolResources {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for ThreadObjectToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<ThreadObjectToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<ThreadObjectToolResourcesFileSearch>,
        }
        let ThreadObjectToolResources {
            code_interpreter,
            file_search,
        } = self;
        _S {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ThreadObjectToolResources {
    #[builder(default)]
    pub code_interpreter: Option<ThreadObjectToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<ThreadObjectToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for ThreadObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ThreadObjectObject {
            #[default]
            #[serde(rename = "thread")]
            Thread,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ThreadObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<ThreadObjectToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Metadata,
        }
        let _D {
            id,
            created_at,
            tool_resources,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ThreadObject {
            id,
            created_at,
            tool_resources,
            metadata,
        })
    }
}
impl serde::Serialize for ThreadObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ThreadObjectObject {
            #[default]
            #[serde(rename = "thread")]
            Thread,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a ThreadObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<ThreadObjectToolResources>,
            #[serde(rename = "metadata")]
            metadata: &'a Metadata,
        }
        let ThreadObject {
            id,
            created_at,
            tool_resources,
            metadata,
        } = self;
        _S {
            id,
            object: &Default::default(),
            created_at,
            tool_resources,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ThreadObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the thread was created."]
    pub created_at: u64,
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<ThreadObjectToolResources>,
    pub metadata: Metadata,
}
impl<'de> serde::Deserialize<'de> for ThreadStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ThreadStreamEventEvent {
            #[default]
            #[serde(rename = "thread.created")]
            ThreadCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "enabled")]
            #[allow(dead_code)]
            enabled: Option<bool>,
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: ThreadStreamEventEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: ThreadObject,
        }
        let _D { enabled, data, .. } = _D::deserialize(deserializer)?;
        Ok(ThreadStreamEvent { enabled, data })
    }
}
impl serde::Serialize for ThreadStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ThreadStreamEventEvent {
            #[default]
            #[serde(rename = "thread.created")]
            ThreadCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "enabled")]
            #[serde(skip_serializing_if = "Option::is_none")]
            enabled: &'a Option<bool>,
            #[serde(rename = "event")]
            event: &'a ThreadStreamEventEvent,
            #[serde(rename = "data")]
            data: &'a ThreadObject,
        }
        let ThreadStreamEvent { enabled, data } = self;
        _S {
            enabled,
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a new [thread](https://platform.openai.com/docs/api-reference/threads/object) is created."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ThreadStreamEvent {
    #[doc = "Whether to enable input audio transcription."]
    #[builder(default)]
    pub enabled: Option<bool>,
    pub data: ThreadObject,
}
impl<'de> serde::Deserialize<'de> for ToggleCertificatesRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "certificate_ids")]
            #[allow(dead_code)]
            certificate_ids: Vec<String>,
        }
        let _D {
            certificate_ids, ..
        } = _D::deserialize(deserializer)?;
        Ok(ToggleCertificatesRequest { certificate_ids })
    }
}
impl serde::Serialize for ToggleCertificatesRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "certificate_ids")]
            certificate_ids: &'a Vec<String>,
        }
        let ToggleCertificatesRequest { certificate_ids } = self;
        _S { certificate_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ToggleCertificatesRequest {
    pub certificate_ids: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "For function calling, the type is always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceFunctionType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ToolChoiceFunctionType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let _D { name, .. } = _D::deserialize(deserializer)?;
        Ok(ToolChoiceFunction { name })
    }
}
impl serde::Serialize for ToolChoiceFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "For function calling, the type is always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceFunctionType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ToolChoiceFunctionType,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let ToolChoiceFunction { name } = self;
        _S {
            type_: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Use this option to force the model to call a specific function.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ToolChoiceFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            None(#[allow(dead_code)] ToolChoiceOptionsNone),
            Auto(#[allow(dead_code)] ToolChoiceOptionsAuto),
            Required(#[allow(dead_code)] ToolChoiceOptionsRequired),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::None(_) => Self::None,
            _D::Auto(_) => Self::Auto,
            _D::Required(_) => Self::Required,
        })
    }
}
impl serde::Serialize for ToolChoiceOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            None(#[allow(dead_code)] &'a ToolChoiceOptionsNone),
            Auto(#[allow(dead_code)] &'a ToolChoiceOptionsAuto),
            Required(#[allow(dead_code)] &'a ToolChoiceOptionsRequired),
        }
        match self {
            Self::None => _S::None(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Required => _S::Required(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Controls which (if any) tool is called by the model.\n\n`none` means the model will not call any tool and instead generates a message.\n\n`auto` means the model can pick between generating a message or calling one or\nmore tools.\n\n`required` means the model must call one or more tools.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ToolChoiceOptions {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    #[doc = "required"]
    Required,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceTypesType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeFileSearch {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeWebSearchPreview {
            #[default]
            #[serde(rename = "web_search_preview")]
            WebSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeComputerUsePreview {
            #[default]
            #[serde(rename = "computer_use_preview")]
            ComputerUsePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeWebSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "web_search_preview_2025_03_11")]
            WebSearchPreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileSearch(#[allow(dead_code)] ToolChoiceTypesTypeFileSearch),
            WebSearchPreview(#[allow(dead_code)] ToolChoiceTypesTypeWebSearchPreview),
            ComputerUsePreview(#[allow(dead_code)] ToolChoiceTypesTypeComputerUsePreview),
            WebSearchPreview2025_03_11(
                #[allow(dead_code)] ToolChoiceTypesTypeWebSearchPreview2025_03_11,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileSearch(_) => Self::FileSearch,
            _D::WebSearchPreview(_) => Self::WebSearchPreview,
            _D::ComputerUsePreview(_) => Self::ComputerUsePreview,
            _D::WebSearchPreview2025_03_11(_) => Self::WebSearchPreview2025_03_11,
        })
    }
}
impl serde::Serialize for ToolChoiceTypesType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeFileSearch {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeWebSearchPreview {
            #[default]
            #[serde(rename = "web_search_preview")]
            WebSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeComputerUsePreview {
            #[default]
            #[serde(rename = "computer_use_preview")]
            ComputerUsePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeWebSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "web_search_preview_2025_03_11")]
            WebSearchPreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileSearch(#[allow(dead_code)] &'a ToolChoiceTypesTypeFileSearch),
            WebSearchPreview(#[allow(dead_code)] &'a ToolChoiceTypesTypeWebSearchPreview),
            ComputerUsePreview(#[allow(dead_code)] &'a ToolChoiceTypesTypeComputerUsePreview),
            WebSearchPreview2025_03_11(
                #[allow(dead_code)] &'a ToolChoiceTypesTypeWebSearchPreview2025_03_11,
            ),
        }
        match self {
            Self::FileSearch => _S::FileSearch(&Default::default()).serialize(serializer),
            Self::WebSearchPreview => {
                _S::WebSearchPreview(&Default::default()).serialize(serializer)
            }
            Self::ComputerUsePreview => {
                _S::ComputerUsePreview(&Default::default()).serialize(serializer)
            }
            Self::WebSearchPreview2025_03_11 => {
                _S::WebSearchPreview2025_03_11(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of hosted tool the model should to use. Learn more about\n[built-in tools](/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ToolChoiceTypesType {
    #[doc = "file_search"]
    FileSearch,
    #[doc = "web_search_preview"]
    WebSearchPreview,
    #[doc = "computer_use_preview"]
    ComputerUsePreview,
    #[doc = "web_search_preview_2025_03_11"]
    WebSearchPreview2025_03_11,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ToolChoiceTypesType,
        }
        let _D { type_, .. } = _D::deserialize(deserializer)?;
        Ok(ToolChoiceTypes { type_ })
    }
}
impl serde::Serialize for ToolChoiceTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ToolChoiceTypesType,
        }
        let ToolChoiceTypes { type_ } = self;
        _S { type_ }.serialize(serializer)
    }
}
#[doc = "Indicates that the model should use a built-in tool to generate a response.\n[Learn more about built-in tools](/docs/guides/tools).\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ToolChoiceTypes {
    #[doc = "The type of hosted tool the model should to use. Learn more about\n[built-in tools](/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n"]
    pub type_: ToolChoiceTypesType,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDeltaEventLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: Option<String>,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: Option<f64>,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<serde_json::Value>>,
        }
        let _D {
            token,
            logprob,
            bytes,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(TranscriptTextDeltaEventLogprob {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for TranscriptTextDeltaEventLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token: &'a Option<String>,
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprob: &'a Option<f64>,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<serde_json::Value>>,
        }
        let TranscriptTextDeltaEventLogprob {
            token,
            logprob,
            bytes,
        } = self;
        _S {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDeltaEventLogprob {
    #[doc = "The token that was used to generate the log probability.\n"]
    #[builder(default)]
    pub token: Option<String>,
    #[doc = "The log probability of the token.\n"]
    #[builder(default)]
    pub logprob: Option<f64>,
    #[doc = "The bytes that were used to generate the log probability.\n"]
    #[builder(default)]
    pub bytes: Option<Vec<serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `transcript.text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TranscriptTextDeltaEventType {
            #[default]
            #[serde(rename = "transcript.text.delta")]
            TranscriptTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TranscriptTextDeltaEventType,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<TranscriptTextDeltaEventLogprob>>,
        }
        let _D {
            delta, logprobs, ..
        } = _D::deserialize(deserializer)?;
        Ok(TranscriptTextDeltaEvent { delta, logprobs })
    }
}
impl serde::Serialize for TranscriptTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `transcript.text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TranscriptTextDeltaEventType {
            #[default]
            #[serde(rename = "transcript.text.delta")]
            TranscriptTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a TranscriptTextDeltaEventType,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<TranscriptTextDeltaEventLogprob>>,
        }
        let TranscriptTextDeltaEvent { delta, logprobs } = self;
        _S {
            type_: &Default::default(),
            delta,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is an additional text delta. This is also the first event emitted when the transcription starts. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDeltaEvent {
    #[doc = "The text delta that was additionally transcribed.\n"]
    pub delta: String,
    #[doc = "The log probabilities of the delta. Only included if you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.\n"]
    #[builder(default)]
    pub logprobs: Option<Vec<TranscriptTextDeltaEventLogprob>>,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDoneEventLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: Option<String>,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: Option<f64>,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<serde_json::Value>>,
        }
        let _D {
            token,
            logprob,
            bytes,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(TranscriptTextDoneEventLogprob {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for TranscriptTextDoneEventLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token: &'a Option<String>,
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprob: &'a Option<f64>,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<serde_json::Value>>,
        }
        let TranscriptTextDoneEventLogprob {
            token,
            logprob,
            bytes,
        } = self;
        _S {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDoneEventLogprob {
    #[doc = "The token that was used to generate the log probability.\n"]
    #[builder(default)]
    pub token: Option<String>,
    #[doc = "The log probability of the token.\n"]
    #[builder(default)]
    pub logprob: Option<f64>,
    #[doc = "The bytes that were used to generate the log probability.\n"]
    #[builder(default)]
    pub bytes: Option<Vec<serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `transcript.text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TranscriptTextDoneEventType {
            #[default]
            #[serde(rename = "transcript.text.done")]
            TranscriptTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TranscriptTextDoneEventType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<TranscriptTextDoneEventLogprob>>,
        }
        let _D { text, logprobs, .. } = _D::deserialize(deserializer)?;
        Ok(TranscriptTextDoneEvent { text, logprobs })
    }
}
impl serde::Serialize for TranscriptTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `transcript.text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TranscriptTextDoneEventType {
            #[default]
            #[serde(rename = "transcript.text.done")]
            TranscriptTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a TranscriptTextDoneEventType,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<TranscriptTextDoneEventLogprob>>,
        }
        let TranscriptTextDoneEvent { text, logprobs } = self;
        _S {
            type_: &Default::default(),
            text,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the transcription is complete. Contains the complete transcription text. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDoneEvent {
    #[doc = "The text that was transcribed.\n"]
    pub text: String,
    #[doc = "The log probabilities of the individual tokens in the transcription. Only included if you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.\n"]
    #[builder(default)]
    pub logprobs: Option<Vec<TranscriptTextDoneEventLogprob>>,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum TranscriptionInclude {
    #[default]
    #[serde(rename = "logprobs")]
    Logprobs,
}
impl<'de> serde::Deserialize<'de> for TranscriptionSegment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: u64,
            #[serde(rename = "seek")]
            #[allow(dead_code)]
            seek: u64,
            #[serde(rename = "start")]
            #[allow(dead_code)]
            start: f64,
            #[serde(rename = "end")]
            #[allow(dead_code)]
            end: f64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "tokens")]
            #[allow(dead_code)]
            tokens: Vec<u64>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: f64,
            #[serde(rename = "avg_logprob")]
            #[allow(dead_code)]
            avg_logprob: f64,
            #[serde(rename = "compression_ratio")]
            #[allow(dead_code)]
            compression_ratio: f64,
            #[serde(rename = "no_speech_prob")]
            #[allow(dead_code)]
            no_speech_prob: f64,
        }
        let _D {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(TranscriptionSegment {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
        })
    }
}
impl serde::Serialize for TranscriptionSegment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a u64,
            #[serde(rename = "seek")]
            seek: &'a u64,
            #[serde(rename = "start")]
            start: &'a f64,
            #[serde(rename = "end")]
            end: &'a f64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "tokens")]
            tokens: &'a Vec<u64>,
            #[serde(rename = "temperature")]
            temperature: &'a f64,
            #[serde(rename = "avg_logprob")]
            avg_logprob: &'a f64,
            #[serde(rename = "compression_ratio")]
            compression_ratio: &'a f64,
            #[serde(rename = "no_speech_prob")]
            no_speech_prob: &'a f64,
        }
        let TranscriptionSegment {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
        } = self;
        _S {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptionSegment {
    #[doc = "Unique identifier of the segment."]
    pub id: u64,
    #[doc = "Seek offset of the segment."]
    pub seek: u64,
    #[doc = "Start time of the segment in seconds."]
    pub start: f64,
    #[doc = "End time of the segment in seconds."]
    pub end: f64,
    #[doc = "Text content of the segment."]
    pub text: String,
    #[doc = "Array of token IDs for the text content."]
    pub tokens: Vec<u64>,
    #[doc = "Temperature parameter used for generating the segment."]
    pub temperature: f64,
    #[doc = "Average logprob of the segment. If the value is lower than -1, consider the logprobs failed."]
    pub avg_logprob: f64,
    #[doc = "Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed."]
    pub compression_ratio: f64,
    #[doc = "Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent."]
    pub no_speech_prob: f64,
}
impl<'de> serde::Deserialize<'de> for TranscriptionWord {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "word")]
            #[allow(dead_code)]
            word: String,
            #[serde(rename = "start")]
            #[allow(dead_code)]
            start: f64,
            #[serde(rename = "end")]
            #[allow(dead_code)]
            end: f64,
        }
        let _D {
            word, start, end, ..
        } = _D::deserialize(deserializer)?;
        Ok(TranscriptionWord { word, start, end })
    }
}
impl serde::Serialize for TranscriptionWord {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "word")]
            word: &'a String,
            #[serde(rename = "start")]
            start: &'a f64,
            #[serde(rename = "end")]
            end: &'a f64,
        }
        let TranscriptionWord { word, start, end } = self;
        _S { word, start, end }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptionWord {
    #[doc = "The text content of the word."]
    pub word: String,
    #[doc = "Start time of the word in seconds."]
    pub start: f64,
    #[doc = "End time of the word in seconds."]
    pub end: f64,
}
impl<'de> serde::Deserialize<'de> for TruncationObjectType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TruncationObjectTypeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TruncationObjectTypeLastMessages {
            #[default]
            #[serde(rename = "last_messages")]
            LastMessages,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] TruncationObjectTypeAuto),
            LastMessages(#[allow(dead_code)] TruncationObjectTypeLastMessages),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::LastMessages(_) => Self::LastMessages,
        })
    }
}
impl serde::Serialize for TruncationObjectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TruncationObjectTypeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TruncationObjectTypeLastMessages {
            #[default]
            #[serde(rename = "last_messages")]
            LastMessages,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a TruncationObjectTypeAuto),
            LastMessages(#[allow(dead_code)] &'a TruncationObjectTypeLastMessages),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::LastMessages => _S::LastMessages(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum TruncationObjectType {
    #[doc = "auto"]
    Auto,
    #[doc = "last_messages"]
    LastMessages,
}
impl<'de> serde::Deserialize<'de> for TruncationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TruncationObjectType,
            #[serde(rename = "last_messages")]
            #[allow(dead_code)]
            last_messages: Option<u64>,
        }
        let _D {
            type_,
            last_messages,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(TruncationObject {
            type_,
            last_messages,
        })
    }
}
impl serde::Serialize for TruncationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a TruncationObjectType,
            #[serde(rename = "last_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_messages: &'a Option<u64>,
        }
        let TruncationObject {
            type_,
            last_messages,
        } = self;
        _S {
            type_,
            last_messages,
        }
        .serialize(serializer)
    }
}
#[doc = "Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct TruncationObject {
    #[doc = "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."]
    pub type_: TruncationObjectType,
    #[doc = "The number of most recent messages from the thread when constructing the context for the run."]
    #[builder(default)]
    pub last_messages: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for Type {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a type action, this property is \nalways set to `type`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TypeType {
            #[default]
            #[serde(rename = "type")]
            Type,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TypeType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(Type { text })
    }
}
impl serde::Serialize for Type {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a type action, this property is \nalways set to `type`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TypeType {
            #[default]
            #[serde(rename = "type")]
            Type,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a TypeType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Type { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "An action to type in text.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Type {
    #[doc = "The text to type.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for UpdateVectorStoreFileAttributesRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: VectorStoreFileAttributes,
        }
        let _D { attributes, .. } = _D::deserialize(deserializer)?;
        Ok(UpdateVectorStoreFileAttributesRequest { attributes })
    }
}
impl serde::Serialize for UpdateVectorStoreFileAttributesRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "attributes")]
            attributes: &'a VectorStoreFileAttributes,
        }
        let UpdateVectorStoreFileAttributesRequest { attributes } = self;
        _S { attributes }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UpdateVectorStoreFileAttributesRequest {
    pub attributes: VectorStoreFileAttributes,
}
impl<'de> serde::Deserialize<'de> for UpdateVectorStoreRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "expires_after")]
            #[allow(dead_code)]
            expires_after: Option<VectorStoreExpirationAfter>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let _D {
            name,
            expires_after,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UpdateVectorStoreRequest {
            name,
            expires_after,
            metadata,
        })
    }
}
impl serde::Serialize for UpdateVectorStoreRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<VectorStoreExpirationAfter>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let UpdateVectorStoreRequest {
            name,
            expires_after,
            metadata,
        } = self;
        _S {
            name,
            expires_after,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct UpdateVectorStoreRequest {
    #[doc = "The name of the vector store."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub expires_after: Option<VectorStoreExpirationAfter>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for UploadStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusPending {
            #[default]
            #[serde(rename = "pending")]
            Pending,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Pending(#[allow(dead_code)] UploadStatusPending),
            Completed(#[allow(dead_code)] UploadStatusCompleted),
            Cancelled(#[allow(dead_code)] UploadStatusCancelled),
            Expired(#[allow(dead_code)] UploadStatusExpired),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Pending(_) => Self::Pending,
            _D::Completed(_) => Self::Completed,
            _D::Cancelled(_) => Self::Cancelled,
            _D::Expired(_) => Self::Expired,
        })
    }
}
impl serde::Serialize for UploadStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusPending {
            #[default]
            #[serde(rename = "pending")]
            Pending,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Pending(#[allow(dead_code)] &'a UploadStatusPending),
            Completed(#[allow(dead_code)] &'a UploadStatusCompleted),
            Cancelled(#[allow(dead_code)] &'a UploadStatusCancelled),
            Expired(#[allow(dead_code)] &'a UploadStatusExpired),
        }
        match self {
            Self::Pending => _S::Pending(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
            Self::Expired => _S::Expired(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the Upload."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum UploadStatus {
    #[doc = "pending"]
    Pending,
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "expired"]
    Expired,
}
#[doc = "The object type, which is always \"upload\"."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum UploadObject {
    #[default]
    #[serde(rename = "upload")]
    Upload,
}
impl<'de> serde::Deserialize<'de> for Upload {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: String,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: u64,
            #[serde(rename = "purpose")]
            #[allow(dead_code)]
            purpose: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: UploadStatus,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<UploadObject>,
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Option<OpenAiFile>,
        }
        let _D {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            object,
            file,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(Upload {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            object,
            file,
        })
    }
}
impl serde::Serialize for Upload {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "bytes")]
            bytes: &'a u64,
            #[serde(rename = "purpose")]
            purpose: &'a String,
            #[serde(rename = "status")]
            status: &'a UploadStatus,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<UploadObject>,
            #[serde(rename = "file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file: &'a Option<OpenAiFile>,
        }
        let Upload {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            object,
            file,
        } = self;
        _S {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            object,
            file,
        }
        .serialize(serializer)
    }
}
#[doc = "The Upload object can accept byte chunks in the form of Parts.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Upload {
    #[doc = "The Upload unique identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the Upload was created."]
    pub created_at: u64,
    #[doc = "The name of the file to be uploaded."]
    pub filename: String,
    #[doc = "The intended number of bytes to be uploaded."]
    pub bytes: u64,
    #[doc = "The intended purpose of the file. [Please refer here](https://platform.openai.com/docs/api-reference/files/object#files/object-purpose) for acceptable values."]
    pub purpose: String,
    #[doc = "The status of the Upload."]
    pub status: UploadStatus,
    #[doc = "The Unix timestamp (in seconds) for when the Upload will expire."]
    pub expires_at: u64,
    #[doc = "The object type, which is always \"upload\"."]
    #[builder(default)]
    pub object: Option<UploadObject>,
    #[doc = "The ready File object after the Upload is completed."]
    #[builder(default)]
    pub file: Option<OpenAiFile>,
}
impl<'de> serde::Deserialize<'de> for UploadCertificateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: String,
        }
        let _D { name, content, .. } = _D::deserialize(deserializer)?;
        Ok(UploadCertificateRequest { name, content })
    }
}
impl serde::Serialize for UploadCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "content")]
            content: &'a String,
        }
        let UploadCertificateRequest { name, content } = self;
        _S { name, content }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UploadCertificateRequest {
    #[doc = "An optional name for the certificate"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The certificate content in PEM format"]
    pub content: String,
}
impl<'de> serde::Deserialize<'de> for UploadPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `upload.part`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadPartObject {
            #[default]
            #[serde(rename = "upload.part")]
            UploadPart,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "upload_id")]
            #[allow(dead_code)]
            upload_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UploadPartObject,
        }
        let _D {
            id,
            created_at,
            upload_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UploadPart {
            id,
            created_at,
            upload_id,
        })
    }
}
impl serde::Serialize for UploadPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `upload.part`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadPartObject {
            #[default]
            #[serde(rename = "upload.part")]
            UploadPart,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "upload_id")]
            upload_id: &'a String,
            #[serde(rename = "object")]
            object: &'a UploadPartObject,
        }
        let UploadPart {
            id,
            created_at,
            upload_id,
        } = self;
        _S {
            id,
            created_at,
            upload_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The upload Part represents a chunk of bytes we can add to an Upload object.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UploadPart {
    #[doc = "The upload Part unique identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the Part was created."]
    pub created_at: u64,
    #[doc = "The ID of the Upload object that this Part was added to."]
    pub upload_id: String,
}
impl<'de> serde::Deserialize<'de> for UsageAudioSpeechesResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageAudioSpeechesResultObject {
            #[default]
            #[serde(rename = "organization.usage.audio_speeches.result")]
            OrganizationUsageAudioSpeechesResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageAudioSpeechesResultObject,
            #[serde(rename = "characters")]
            #[allow(dead_code)]
            characters: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let _D {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageAudioSpeechesResult {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageAudioSpeechesResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageAudioSpeechesResultObject {
            #[default]
            #[serde(rename = "organization.usage.audio_speeches.result")]
            OrganizationUsageAudioSpeechesResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageAudioSpeechesResultObject,
            #[serde(rename = "characters")]
            characters: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let UsageAudioSpeechesResult {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        _S {
            object: &Default::default(),
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated audio speeches usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageAudioSpeechesResult {
    #[doc = "The number of characters processed."]
    pub characters: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageAudioTranscriptionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageAudioTranscriptionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.audio_transcriptions.result")]
            OrganizationUsageAudioTranscriptionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageAudioTranscriptionsResultObject,
            #[serde(rename = "seconds")]
            #[allow(dead_code)]
            seconds: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let _D {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageAudioTranscriptionsResult {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageAudioTranscriptionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageAudioTranscriptionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.audio_transcriptions.result")]
            OrganizationUsageAudioTranscriptionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageAudioTranscriptionsResultObject,
            #[serde(rename = "seconds")]
            seconds: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let UsageAudioTranscriptionsResult {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        _S {
            object: &Default::default(),
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated audio transcriptions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageAudioTranscriptionsResult {
    #[doc = "The number of seconds processed."]
    pub seconds: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageCodeInterpreterSessionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageCodeInterpreterSessionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.code_interpreter_sessions.result")]
            OrganizationUsageCodeInterpreterSessionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageCodeInterpreterSessionsResultObject,
            #[serde(rename = "num_sessions")]
            #[allow(dead_code)]
            num_sessions: Option<u64>,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
        }
        let _D {
            num_sessions,
            project_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageCodeInterpreterSessionsResult {
            num_sessions,
            project_id,
        })
    }
}
impl serde::Serialize for UsageCodeInterpreterSessionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageCodeInterpreterSessionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.code_interpreter_sessions.result")]
            OrganizationUsageCodeInterpreterSessionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageCodeInterpreterSessionsResultObject,
            #[serde(rename = "num_sessions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            num_sessions: &'a Option<u64>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
        }
        let UsageCodeInterpreterSessionsResult {
            num_sessions,
            project_id,
        } = self;
        _S {
            object: &Default::default(),
            num_sessions,
            project_id,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated code interpreter sessions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct UsageCodeInterpreterSessionsResult {
    #[doc = "The number of code interpreter sessions."]
    #[builder(default)]
    pub num_sessions: Option<u64>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageCompletionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageCompletionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.completions.result")]
            OrganizationUsageCompletionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageCompletionsResultObject,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "input_cached_tokens")]
            #[allow(dead_code)]
            input_cached_tokens: Option<u64>,
            #[serde(rename = "output_tokens")]
            #[allow(dead_code)]
            output_tokens: u64,
            #[serde(rename = "input_audio_tokens")]
            #[allow(dead_code)]
            input_audio_tokens: Option<u64>,
            #[serde(rename = "output_audio_tokens")]
            #[allow(dead_code)]
            output_audio_tokens: Option<u64>,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "batch")]
            #[allow(dead_code)]
            batch: Option<bool>,
        }
        let _D {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageCompletionsResult {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        })
    }
}
impl serde::Serialize for UsageCompletionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageCompletionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.completions.result")]
            OrganizationUsageCompletionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageCompletionsResultObject,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "input_cached_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_cached_tokens: &'a Option<u64>,
            #[serde(rename = "output_tokens")]
            output_tokens: &'a u64,
            #[serde(rename = "input_audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_tokens: &'a Option<u64>,
            #[serde(rename = "output_audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_tokens: &'a Option<u64>,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "batch")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch: &'a Option<bool>,
        }
        let UsageCompletionsResult {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        } = self;
        _S {
            object: &Default::default(),
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated completions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageCompletionsResult {
    #[doc = "The aggregated number of text input tokens used, including cached tokens. For customers subscribe to scale tier, this includes scale tier tokens."]
    pub input_tokens: u64,
    #[doc = "The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens."]
    #[builder(default)]
    pub input_cached_tokens: Option<u64>,
    #[doc = "The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens."]
    pub output_tokens: u64,
    #[doc = "The aggregated number of audio input tokens used, including cached tokens."]
    #[builder(default)]
    pub input_audio_tokens: Option<u64>,
    #[doc = "The aggregated number of audio output tokens used."]
    #[builder(default)]
    pub output_audio_tokens: Option<u64>,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "When `group_by=batch`, this field tells whether the grouped usage result is batch or not."]
    #[builder(default)]
    pub batch: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for UsageEmbeddingsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageEmbeddingsResultObject {
            #[default]
            #[serde(rename = "organization.usage.embeddings.result")]
            OrganizationUsageEmbeddingsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageEmbeddingsResultObject,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let _D {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageEmbeddingsResult {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageEmbeddingsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageEmbeddingsResultObject {
            #[default]
            #[serde(rename = "organization.usage.embeddings.result")]
            OrganizationUsageEmbeddingsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageEmbeddingsResultObject,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let UsageEmbeddingsResult {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        _S {
            object: &Default::default(),
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated embeddings usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageEmbeddingsResult {
    #[doc = "The aggregated number of input tokens used."]
    pub input_tokens: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageImagesResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageImagesResultObject {
            #[default]
            #[serde(rename = "organization.usage.images.result")]
            OrganizationUsageImagesResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageImagesResultObject,
            #[serde(rename = "images")]
            #[allow(dead_code)]
            images: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: Option<String>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<String>,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let _D {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageImagesResult {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageImagesResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageImagesResultObject {
            #[default]
            #[serde(rename = "organization.usage.images.result")]
            OrganizationUsageImagesResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageImagesResultObject,
            #[serde(rename = "images")]
            images: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "source")]
            #[serde(skip_serializing_if = "Option::is_none")]
            source: &'a Option<String>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<String>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let UsageImagesResult {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        _S {
            object: &Default::default(),
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated images usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageImagesResult {
    #[doc = "The number of images processed."]
    pub images: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=source`, this field provides the source of the grouped usage result, possible values are `image.generation`, `image.edit`, `image.variation`."]
    #[builder(default)]
    pub source: Option<String>,
    #[doc = "When `group_by=size`, this field provides the image size of the grouped usage result."]
    #[builder(default)]
    pub size: Option<String>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageModerationsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageModerationsResultObject {
            #[default]
            #[serde(rename = "organization.usage.moderations.result")]
            OrganizationUsageModerationsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageModerationsResultObject,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let _D {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageModerationsResult {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageModerationsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageModerationsResultObject {
            #[default]
            #[serde(rename = "organization.usage.moderations.result")]
            OrganizationUsageModerationsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageModerationsResultObject,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let UsageModerationsResult {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        _S {
            object: &Default::default(),
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated moderations usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageModerationsResult {
    #[doc = "The aggregated number of input tokens used."]
    pub input_tokens: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageResponseObject {
            #[default]
            #[serde(rename = "page")]
            Page,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<UsageTimeBucket>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "next_page")]
            #[allow(dead_code)]
            next_page: String,
        }
        let _D {
            data,
            has_more,
            next_page,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageResponse {
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for UsageResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageResponseObject {
            #[default]
            #[serde(rename = "page")]
            Page,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<UsageTimeBucket>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            next_page: &'a String,
        }
        let UsageResponse {
            data,
            has_more,
            next_page,
        } = self;
        _S {
            object: &Default::default(),
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageResponse {
    pub data: Vec<UsageTimeBucket>,
    pub has_more: bool,
    pub next_page: String,
}
impl<'de> serde::Deserialize<'de> for UsageTimeBucketResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            OrganizationUsageCompletionsResult(#[allow(dead_code)] UsageCompletionsResult),
            OrganizationUsageEmbeddingsResult(#[allow(dead_code)] UsageEmbeddingsResult),
            OrganizationUsageModerationsResult(#[allow(dead_code)] UsageModerationsResult),
            OrganizationUsageImagesResult(#[allow(dead_code)] UsageImagesResult),
            OrganizationUsageAudioSpeechesResult(#[allow(dead_code)] UsageAudioSpeechesResult),
            OrganizationUsageAudioTranscriptionsResult(
                #[allow(dead_code)] UsageAudioTranscriptionsResult,
            ),
            OrganizationUsageVectorStoresResult(#[allow(dead_code)] UsageVectorStoresResult),
            OrganizationUsageCodeInterpreterSessionsResult(
                #[allow(dead_code)] UsageCodeInterpreterSessionsResult,
            ),
            OrganizationCostsResult(#[allow(dead_code)] CostsResult),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::OrganizationUsageCompletionsResult(_v) => {
                Self::OrganizationUsageCompletionsResult(_v)
            }
            _D::OrganizationUsageEmbeddingsResult(_v) => {
                Self::OrganizationUsageEmbeddingsResult(_v)
            }
            _D::OrganizationUsageModerationsResult(_v) => {
                Self::OrganizationUsageModerationsResult(_v)
            }
            _D::OrganizationUsageImagesResult(_v) => Self::OrganizationUsageImagesResult(_v),
            _D::OrganizationUsageAudioSpeechesResult(_v) => {
                Self::OrganizationUsageAudioSpeechesResult(_v)
            }
            _D::OrganizationUsageAudioTranscriptionsResult(_v) => {
                Self::OrganizationUsageAudioTranscriptionsResult(_v)
            }
            _D::OrganizationUsageVectorStoresResult(_v) => {
                Self::OrganizationUsageVectorStoresResult(_v)
            }
            _D::OrganizationUsageCodeInterpreterSessionsResult(_v) => {
                Self::OrganizationUsageCodeInterpreterSessionsResult(_v)
            }
            _D::OrganizationCostsResult(_v) => Self::OrganizationCostsResult(_v),
        })
    }
}
impl serde::Serialize for UsageTimeBucketResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            OrganizationUsageCompletionsResult(#[allow(dead_code)] &'a UsageCompletionsResult),
            OrganizationUsageEmbeddingsResult(#[allow(dead_code)] &'a UsageEmbeddingsResult),
            OrganizationUsageModerationsResult(#[allow(dead_code)] &'a UsageModerationsResult),
            OrganizationUsageImagesResult(#[allow(dead_code)] &'a UsageImagesResult),
            OrganizationUsageAudioSpeechesResult(#[allow(dead_code)] &'a UsageAudioSpeechesResult),
            OrganizationUsageAudioTranscriptionsResult(
                #[allow(dead_code)] &'a UsageAudioTranscriptionsResult,
            ),
            OrganizationUsageVectorStoresResult(#[allow(dead_code)] &'a UsageVectorStoresResult),
            OrganizationUsageCodeInterpreterSessionsResult(
                #[allow(dead_code)] &'a UsageCodeInterpreterSessionsResult,
            ),
            OrganizationCostsResult(#[allow(dead_code)] &'a CostsResult),
        }
        match self {
            Self::OrganizationUsageCompletionsResult(_v) => {
                _S::OrganizationUsageCompletionsResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageEmbeddingsResult(_v) => {
                _S::OrganizationUsageEmbeddingsResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageModerationsResult(_v) => {
                _S::OrganizationUsageModerationsResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageImagesResult(_v) => {
                _S::OrganizationUsageImagesResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageAudioSpeechesResult(_v) => {
                _S::OrganizationUsageAudioSpeechesResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageAudioTranscriptionsResult(_v) => {
                _S::OrganizationUsageAudioTranscriptionsResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageVectorStoresResult(_v) => {
                _S::OrganizationUsageVectorStoresResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageCodeInterpreterSessionsResult(_v) => {
                _S::OrganizationUsageCodeInterpreterSessionsResult(_v).serialize(serializer)
            }
            Self::OrganizationCostsResult(_v) => {
                _S::OrganizationCostsResult(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum UsageTimeBucketResult {
    OrganizationUsageCompletionsResult(UsageCompletionsResult),
    OrganizationUsageEmbeddingsResult(UsageEmbeddingsResult),
    OrganizationUsageModerationsResult(UsageModerationsResult),
    OrganizationUsageImagesResult(UsageImagesResult),
    OrganizationUsageAudioSpeechesResult(UsageAudioSpeechesResult),
    OrganizationUsageAudioTranscriptionsResult(UsageAudioTranscriptionsResult),
    OrganizationUsageVectorStoresResult(UsageVectorStoresResult),
    OrganizationUsageCodeInterpreterSessionsResult(UsageCodeInterpreterSessionsResult),
    OrganizationCostsResult(CostsResult),
}
impl<'de> serde::Deserialize<'de> for UsageTimeBucket {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageTimeBucketObject {
            #[default]
            #[serde(rename = "bucket")]
            Bucket,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageTimeBucketObject,
            #[serde(rename = "start_time")]
            #[allow(dead_code)]
            start_time: u64,
            #[serde(rename = "end_time")]
            #[allow(dead_code)]
            end_time: u64,
            #[serde(rename = "result")]
            #[allow(dead_code)]
            result: Vec<UsageTimeBucketResult>,
        }
        let _D {
            start_time,
            end_time,
            result,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageTimeBucket {
            start_time,
            end_time,
            result,
        })
    }
}
impl serde::Serialize for UsageTimeBucket {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageTimeBucketObject {
            #[default]
            #[serde(rename = "bucket")]
            Bucket,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageTimeBucketObject,
            #[serde(rename = "start_time")]
            start_time: &'a u64,
            #[serde(rename = "end_time")]
            end_time: &'a u64,
            #[serde(rename = "result")]
            result: &'a Vec<UsageTimeBucketResult>,
        }
        let UsageTimeBucket {
            start_time,
            end_time,
            result,
        } = self;
        _S {
            object: &Default::default(),
            start_time,
            end_time,
            result,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageTimeBucket {
    pub start_time: u64,
    pub end_time: u64,
    pub result: Vec<UsageTimeBucketResult>,
}
impl<'de> serde::Deserialize<'de> for UsageVectorStoresResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageVectorStoresResultObject {
            #[default]
            #[serde(rename = "organization.usage.vector_stores.result")]
            OrganizationUsageVectorStoresResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageVectorStoresResultObject,
            #[serde(rename = "usage_bytes")]
            #[allow(dead_code)]
            usage_bytes: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
        }
        let _D {
            usage_bytes,
            project_id,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UsageVectorStoresResult {
            usage_bytes,
            project_id,
        })
    }
}
impl serde::Serialize for UsageVectorStoresResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageVectorStoresResultObject {
            #[default]
            #[serde(rename = "organization.usage.vector_stores.result")]
            OrganizationUsageVectorStoresResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UsageVectorStoresResultObject,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
        }
        let UsageVectorStoresResult {
            usage_bytes,
            project_id,
        } = self;
        _S {
            object: &Default::default(),
            usage_bytes,
            project_id,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated vector stores usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageVectorStoresResult {
    #[doc = "The vector stores usage in bytes."]
    pub usage_bytes: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UserRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Owner(#[allow(dead_code)] UserRoleOwner),
            Reader(#[allow(dead_code)] UserRoleReader),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Owner(_) => Self::Owner,
            _D::Reader(_) => Self::Reader,
        })
    }
}
impl serde::Serialize for UserRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Owner(#[allow(dead_code)] &'a UserRoleOwner),
            Reader(#[allow(dead_code)] &'a UserRoleReader),
        }
        match self {
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
            Self::Reader => _S::Reader(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `reader`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum UserRole {
    #[doc = "owner"]
    Owner,
    #[doc = "reader"]
    Reader,
}
impl<'de> serde::Deserialize<'de> for User {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.user`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserObject {
            #[default]
            #[serde(rename = "organization.user")]
            OrganizationUser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UserObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: UserRole,
            #[serde(rename = "added_at")]
            #[allow(dead_code)]
            added_at: u64,
        }
        let _D {
            id,
            name,
            email,
            role,
            added_at,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(User {
            id,
            name,
            email,
            role,
            added_at,
        })
    }
}
impl serde::Serialize for User {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.user`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserObject {
            #[default]
            #[serde(rename = "organization.user")]
            OrganizationUser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UserObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a UserRole,
            #[serde(rename = "added_at")]
            added_at: &'a u64,
        }
        let User {
            id,
            name,
            email,
            role,
            added_at,
        } = self;
        _S {
            object: &Default::default(),
            id,
            name,
            email,
            role,
            added_at,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual `user` within an organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct User {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the user"]
    pub name: String,
    #[doc = "The email address of the user"]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    pub role: UserRole,
    #[doc = "The Unix timestamp (in seconds) of when the user was added."]
    pub added_at: u64,
}
impl<'de> serde::Deserialize<'de> for UserDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.user.deleted")]
            OrganizationUserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UserDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let _D { id, deleted, .. } = _D::deserialize(deserializer)?;
        Ok(UserDeleteResponse { id, deleted })
    }
}
impl serde::Serialize for UserDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.user.deleted")]
            OrganizationUserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UserDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let UserDeleteResponse { id, deleted } = self;
        _S {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UserDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for UserListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UserListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<User>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let _D {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UserListResponse {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for UserListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a UserListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<User>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let UserListResponse {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        _S {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UserListResponse {
    pub data: Vec<User>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for UserRoleUpdateRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleUpdateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleUpdateRequestRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Owner(#[allow(dead_code)] UserRoleUpdateRequestRoleOwner),
            Reader(#[allow(dead_code)] UserRoleUpdateRequestRoleReader),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Owner(_) => Self::Owner,
            _D::Reader(_) => Self::Reader,
        })
    }
}
impl serde::Serialize for UserRoleUpdateRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleUpdateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleUpdateRequestRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Owner(#[allow(dead_code)] &'a UserRoleUpdateRequestRoleOwner),
            Reader(#[allow(dead_code)] &'a UserRoleUpdateRequestRoleReader),
        }
        match self {
            Self::Owner => _S::Owner(&Default::default()).serialize(serializer),
            Self::Reader => _S::Reader(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `reader`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum UserRoleUpdateRequestRole {
    #[doc = "owner"]
    Owner,
    #[doc = "reader"]
    Reader,
}
impl<'de> serde::Deserialize<'de> for UserRoleUpdateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: UserRoleUpdateRequestRole,
        }
        let _D { role, .. } = _D::deserialize(deserializer)?;
        Ok(UserRoleUpdateRequest { role })
    }
}
impl serde::Serialize for UserRoleUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "role")]
            role: &'a UserRoleUpdateRequestRole,
        }
        let UserRoleUpdateRequest { role } = self;
        _S { role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct UserRoleUpdateRequest {
    #[doc = "`owner` or `reader`"]
    pub role: UserRoleUpdateRequestRole,
}
impl<'de> serde::Deserialize<'de> for VectorStoreExpirationAfter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreExpirationAfterAnchor {
            #[default]
            #[serde(rename = "last_active_at")]
            LastActiveAt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: VectorStoreExpirationAfterAnchor,
            #[serde(rename = "days")]
            #[allow(dead_code)]
            days: u64,
        }
        let _D { days, .. } = _D::deserialize(deserializer)?;
        Ok(VectorStoreExpirationAfter { days })
    }
}
impl serde::Serialize for VectorStoreExpirationAfter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreExpirationAfterAnchor {
            #[default]
            #[serde(rename = "last_active_at")]
            LastActiveAt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "anchor")]
            anchor: &'a VectorStoreExpirationAfterAnchor,
            #[serde(rename = "days")]
            days: &'a u64,
        }
        let VectorStoreExpirationAfter { days } = self;
        _S {
            anchor: &Default::default(),
            days,
        }
        .serialize(serializer)
    }
}
#[doc = "The expiration policy for a vector store."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct VectorStoreExpirationAfter {
    #[doc = "The number of days after the anchor time that the vector store will expire."]
    pub days: u64,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileAttribute {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Float(#[allow(dead_code)] f64),
            Bool(#[allow(dead_code)] bool),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Float(_v) => Self::Float(_v),
            _D::Bool(_v) => Self::Bool(_v),
        })
    }
}
impl serde::Serialize for VectorStoreFileAttribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Float(#[allow(dead_code)] &'a f64),
            Bool(#[allow(dead_code)] &'a bool),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Float(_v) => _S::Float(_v).serialize(serializer),
            Self::Bool(_v) => _S::Bool(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileAttribute {
    String(String),
    Float(f64),
    Bool(bool),
}
#[doc = "Set of 16 key-value pairs that can be attached to an object. This can be \nuseful for storing additional information about the object in a structured \nformat, and querying for objects via API or the dashboard. Keys are strings \nwith a maximum length of 64 characters. Values are strings with a maximum \nlength of 512 characters, booleans, or numbers.\n"]
pub type VectorStoreFileAttributes = Vec<VectorStoreFileAttribute>;
impl<'de> serde::Deserialize<'de> for VectorStoreFileBatchObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] VectorStoreFileBatchObjectStatusInProgress),
            Completed(#[allow(dead_code)] VectorStoreFileBatchObjectStatusCompleted),
            Cancelled(#[allow(dead_code)] VectorStoreFileBatchObjectStatusCancelled),
            Failed(#[allow(dead_code)] VectorStoreFileBatchObjectStatusFailed),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Cancelled(_) => Self::Cancelled,
            _D::Failed(_) => Self::Failed,
        })
    }
}
impl serde::Serialize for VectorStoreFileBatchObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a VectorStoreFileBatchObjectStatusInProgress),
            Completed(#[allow(dead_code)] &'a VectorStoreFileBatchObjectStatusCompleted),
            Cancelled(#[allow(dead_code)] &'a VectorStoreFileBatchObjectStatusCancelled),
            Failed(#[allow(dead_code)] &'a VectorStoreFileBatchObjectStatusFailed),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileBatchObjectStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileBatchObjectFileCounts {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "in_progress")]
            #[allow(dead_code)]
            in_progress: u64,
            #[serde(rename = "completed")]
            #[allow(dead_code)]
            completed: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
            #[serde(rename = "cancelled")]
            #[allow(dead_code)]
            cancelled: u64,
            #[serde(rename = "total")]
            #[allow(dead_code)]
            total: u64,
        }
        let _D {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreFileBatchObjectFileCounts {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        })
    }
}
impl serde::Serialize for VectorStoreFileBatchObjectFileCounts {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "in_progress")]
            in_progress: &'a u64,
            #[serde(rename = "completed")]
            completed: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
            #[serde(rename = "cancelled")]
            cancelled: &'a u64,
            #[serde(rename = "total")]
            total: &'a u64,
        }
        let VectorStoreFileBatchObjectFileCounts {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        } = self;
        _S {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileBatchObjectFileCounts {
    #[doc = "The number of files that are currently being processed."]
    pub in_progress: u64,
    #[doc = "The number of files that have been processed."]
    pub completed: u64,
    #[doc = "The number of files that have failed to process."]
    pub failed: u64,
    #[doc = "The number of files that where cancelled."]
    pub cancelled: u64,
    #[doc = "The total number of files."]
    pub total: u64,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileBatchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store.file_batch`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectObject {
            #[default]
            #[serde(rename = "vector_store.files_batch")]
            VectorStoreFilesBatch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreFileBatchObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "vector_store_id")]
            #[allow(dead_code)]
            vector_store_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: VectorStoreFileBatchObjectStatus,
            #[serde(rename = "file_counts")]
            #[allow(dead_code)]
            file_counts: VectorStoreFileBatchObjectFileCounts,
        }
        let _D {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreFileBatchObject {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
        })
    }
}
impl serde::Serialize for VectorStoreFileBatchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store.file_batch`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectObject {
            #[default]
            #[serde(rename = "vector_store.files_batch")]
            VectorStoreFilesBatch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a VectorStoreFileBatchObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "vector_store_id")]
            vector_store_id: &'a String,
            #[serde(rename = "status")]
            status: &'a VectorStoreFileBatchObjectStatus,
            #[serde(rename = "file_counts")]
            file_counts: &'a VectorStoreFileBatchObjectFileCounts,
        }
        let VectorStoreFileBatchObject {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
        } = self;
        _S {
            id,
            object: &Default::default(),
            created_at,
            vector_store_id,
            status,
            file_counts,
        }
        .serialize(serializer)
    }
}
#[doc = "A batch of files attached to a vector store."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileBatchObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the vector store files batch was created."]
    pub created_at: u64,
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to."]
    pub vector_store_id: String,
    #[doc = "The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`."]
    pub status: VectorStoreFileBatchObjectStatus,
    pub file_counts: VectorStoreFileBatchObjectFileCounts,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileContentResponseDatum {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
        }
        let _D { type_, text, .. } = _D::deserialize(deserializer)?;
        Ok(VectorStoreFileContentResponseDatum { type_, text })
    }
}
impl serde::Serialize for VectorStoreFileContentResponseDatum {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
        }
        let VectorStoreFileContentResponseDatum { type_, text } = self;
        _S { type_, text }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileContentResponseDatum {
    #[doc = "The content type (currently only `\"text\"`)"]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "The text content"]
    #[builder(default)]
    pub text: Option<String>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileContentResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store.file_content.page`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileContentResponseObject {
            #[default]
            #[serde(rename = "vector_store.file_content.page")]
            VectorStoreFileContentPage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreFileContentResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<VectorStoreFileContentResponseDatum>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "next_page")]
            #[allow(dead_code)]
            next_page: Option<String>,
        }
        let _D {
            data,
            has_more,
            next_page,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreFileContentResponse {
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for VectorStoreFileContentResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store.file_content.page`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileContentResponseObject {
            #[default]
            #[serde(rename = "vector_store.file_content.page")]
            VectorStoreFileContentPage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a VectorStoreFileContentResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<VectorStoreFileContentResponseDatum>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            #[serde(skip_serializing_if = "Option::is_none")]
            next_page: &'a Option<String>,
        }
        let VectorStoreFileContentResponse {
            data,
            has_more,
            next_page,
        } = self;
        _S {
            object: &Default::default(),
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents the parsed content of a vector store file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileContentResponse {
    #[doc = "Parsed content of the file."]
    pub data: Vec<VectorStoreFileContentResponseDatum>,
    #[doc = "Indicates if there are more content pages to fetch."]
    pub has_more: bool,
    #[doc = "The token for the next page, if any."]
    #[builder(default)]
    pub next_page: Option<String>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] VectorStoreFileObjectStatusInProgress),
            Completed(#[allow(dead_code)] VectorStoreFileObjectStatusCompleted),
            Cancelled(#[allow(dead_code)] VectorStoreFileObjectStatusCancelled),
            Failed(#[allow(dead_code)] VectorStoreFileObjectStatusFailed),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Cancelled(_) => Self::Cancelled,
            _D::Failed(_) => Self::Failed,
        })
    }
}
impl serde::Serialize for VectorStoreFileObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a VectorStoreFileObjectStatusInProgress),
            Completed(#[allow(dead_code)] &'a VectorStoreFileObjectStatusCompleted),
            Cancelled(#[allow(dead_code)] &'a VectorStoreFileObjectStatusCancelled),
            Failed(#[allow(dead_code)] &'a VectorStoreFileObjectStatusFailed),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Cancelled => _S::Cancelled(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileObjectStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObjectLastErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeUnsupportedFile {
            #[default]
            #[serde(rename = "unsupported_file")]
            UnsupportedFile,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeInvalidFile {
            #[default]
            #[serde(rename = "invalid_file")]
            InvalidFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ServerError(#[allow(dead_code)] VectorStoreFileObjectLastErrorCodeServerError),
            UnsupportedFile(#[allow(dead_code)] VectorStoreFileObjectLastErrorCodeUnsupportedFile),
            InvalidFile(#[allow(dead_code)] VectorStoreFileObjectLastErrorCodeInvalidFile),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ServerError(_) => Self::ServerError,
            _D::UnsupportedFile(_) => Self::UnsupportedFile,
            _D::InvalidFile(_) => Self::InvalidFile,
        })
    }
}
impl serde::Serialize for VectorStoreFileObjectLastErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeUnsupportedFile {
            #[default]
            #[serde(rename = "unsupported_file")]
            UnsupportedFile,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeInvalidFile {
            #[default]
            #[serde(rename = "invalid_file")]
            InvalidFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ServerError(#[allow(dead_code)] &'a VectorStoreFileObjectLastErrorCodeServerError),
            UnsupportedFile(
                #[allow(dead_code)] &'a VectorStoreFileObjectLastErrorCodeUnsupportedFile,
            ),
            InvalidFile(#[allow(dead_code)] &'a VectorStoreFileObjectLastErrorCodeInvalidFile),
        }
        match self {
            Self::ServerError => _S::ServerError(&Default::default()).serialize(serializer),
            Self::UnsupportedFile => _S::UnsupportedFile(&Default::default()).serialize(serializer),
            Self::InvalidFile => _S::InvalidFile(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "One of `server_error` or `rate_limit_exceeded`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileObjectLastErrorCode {
    #[doc = "server_error"]
    ServerError,
    #[doc = "unsupported_file"]
    UnsupportedFile,
    #[doc = "invalid_file"]
    InvalidFile,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObjectLastError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: VectorStoreFileObjectLastErrorCode,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let _D { code, message, .. } = _D::deserialize(deserializer)?;
        Ok(VectorStoreFileObjectLastError { code, message })
    }
}
impl serde::Serialize for VectorStoreFileObjectLastError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "code")]
            code: &'a VectorStoreFileObjectLastErrorCode,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let VectorStoreFileObjectLastError { code, message } = self;
        _S { code, message }.serialize(serializer)
    }
}
#[doc = "The last error associated with this vector store file. Will be `null` if there are no errors."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileObjectLastError {
    #[doc = "One of `server_error` or `rate_limit_exceeded`."]
    pub code: VectorStoreFileObjectLastErrorCode,
    #[doc = "A human-readable description of the error."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObjectChunkingStrategy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Static(#[allow(dead_code)] StaticChunkingStrategyResponseParam),
            Other(#[allow(dead_code)] OtherChunkingStrategyResponseParam),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Static(_v) => Self::Static(_v),
            _D::Other(_v) => Self::Other(_v),
        })
    }
}
impl serde::Serialize for VectorStoreFileObjectChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Static(#[allow(dead_code)] &'a StaticChunkingStrategyResponseParam),
            Other(#[allow(dead_code)] &'a OtherChunkingStrategyResponseParam),
        }
        match self {
            Self::Static(_v) => _S::Static(_v).serialize(serializer),
            Self::Other(_v) => _S::Other(_v).serialize(serializer),
        }
    }
}
#[doc = "The strategy used to chunk the file."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileObjectChunkingStrategy {
    Static(StaticChunkingStrategyResponseParam),
    Other(OtherChunkingStrategyResponseParam),
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store.file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectObject {
            #[default]
            #[serde(rename = "vector_store.file")]
            VectorStoreFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreFileObjectObject,
            #[serde(rename = "usage_bytes")]
            #[allow(dead_code)]
            usage_bytes: u64,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "vector_store_id")]
            #[allow(dead_code)]
            vector_store_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: VectorStoreFileObjectStatus,
            #[serde(rename = "last_error")]
            #[allow(dead_code)]
            last_error: Option<VectorStoreFileObjectLastError>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<VectorStoreFileObjectChunkingStrategy>,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
        }
        let _D {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreFileObject {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        })
    }
}
impl serde::Serialize for VectorStoreFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store.file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectObject {
            #[default]
            #[serde(rename = "vector_store.file")]
            VectorStoreFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a VectorStoreFileObjectObject,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a u64,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "vector_store_id")]
            vector_store_id: &'a String,
            #[serde(rename = "status")]
            status: &'a VectorStoreFileObjectStatus,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<VectorStoreFileObjectLastError>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<VectorStoreFileObjectChunkingStrategy>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
        }
        let VectorStoreFileObject {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        } = self;
        _S {
            id,
            object: &Default::default(),
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of files attached to a vector store."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The total vector store usage in bytes. Note that this may be different from the original file size."]
    pub usage_bytes: u64,
    #[doc = "The Unix timestamp (in seconds) for when the vector store file was created."]
    pub created_at: u64,
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to."]
    pub vector_store_id: String,
    #[doc = "The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use."]
    pub status: VectorStoreFileObjectStatus,
    #[doc = "The last error associated with this vector store file. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<VectorStoreFileObjectLastError>,
    #[doc = "The strategy used to chunk the file."]
    #[builder(default)]
    pub chunking_strategy: Option<VectorStoreFileObjectChunkingStrategy>,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreObjectFileCounts {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "in_progress")]
            #[allow(dead_code)]
            in_progress: u64,
            #[serde(rename = "completed")]
            #[allow(dead_code)]
            completed: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
            #[serde(rename = "cancelled")]
            #[allow(dead_code)]
            cancelled: u64,
            #[serde(rename = "total")]
            #[allow(dead_code)]
            total: u64,
        }
        let _D {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreObjectFileCounts {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        })
    }
}
impl serde::Serialize for VectorStoreObjectFileCounts {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "in_progress")]
            in_progress: &'a u64,
            #[serde(rename = "completed")]
            completed: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
            #[serde(rename = "cancelled")]
            cancelled: &'a u64,
            #[serde(rename = "total")]
            total: &'a u64,
        }
        let VectorStoreObjectFileCounts {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        } = self;
        _S {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct VectorStoreObjectFileCounts {
    #[doc = "The number of files that are currently being processed."]
    pub in_progress: u64,
    #[doc = "The number of files that have been successfully processed."]
    pub completed: u64,
    #[doc = "The number of files that have failed to process."]
    pub failed: u64,
    #[doc = "The number of files that were cancelled."]
    pub cancelled: u64,
    #[doc = "The total number of files."]
    pub total: u64,
}
impl<'de> serde::Deserialize<'de> for VectorStoreObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Expired(#[allow(dead_code)] VectorStoreObjectStatusExpired),
            InProgress(#[allow(dead_code)] VectorStoreObjectStatusInProgress),
            Completed(#[allow(dead_code)] VectorStoreObjectStatusCompleted),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Expired(_) => Self::Expired,
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
        })
    }
}
impl serde::Serialize for VectorStoreObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Expired(#[allow(dead_code)] &'a VectorStoreObjectStatusExpired),
            InProgress(#[allow(dead_code)] &'a VectorStoreObjectStatusInProgress),
            Completed(#[allow(dead_code)] &'a VectorStoreObjectStatusCompleted),
        }
        match self {
            Self::Expired => _S::Expired(&Default::default()).serialize(serializer),
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreObjectStatus {
    #[doc = "expired"]
    Expired,
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
}
impl<'de> serde::Deserialize<'de> for VectorStoreObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectObject {
            #[default]
            #[serde(rename = "vector_store")]
            VectorStore,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "usage_bytes")]
            #[allow(dead_code)]
            usage_bytes: u64,
            #[serde(rename = "file_counts")]
            #[allow(dead_code)]
            file_counts: VectorStoreObjectFileCounts,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: VectorStoreObjectStatus,
            #[serde(rename = "expires_after")]
            #[allow(dead_code)]
            expires_after: Option<VectorStoreExpirationAfter>,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "last_active_at")]
            #[allow(dead_code)]
            last_active_at: Option<u64>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Metadata,
        }
        let _D {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreObject {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        })
    }
}
impl serde::Serialize for VectorStoreObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectObject {
            #[default]
            #[serde(rename = "vector_store")]
            VectorStore,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a VectorStoreObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a u64,
            #[serde(rename = "file_counts")]
            file_counts: &'a VectorStoreObjectFileCounts,
            #[serde(rename = "status")]
            status: &'a VectorStoreObjectStatus,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<VectorStoreExpirationAfter>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "last_active_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_active_at: &'a Option<u64>,
            #[serde(rename = "metadata")]
            metadata: &'a Metadata,
        }
        let VectorStoreObject {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        } = self;
        _S {
            id,
            object: &Default::default(),
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "A vector store is a collection of processed files can be used by the `file_search` tool."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the vector store was created."]
    pub created_at: u64,
    #[doc = "The name of the vector store."]
    pub name: String,
    #[doc = "The total number of bytes used by the files in the vector store."]
    pub usage_bytes: u64,
    pub file_counts: VectorStoreObjectFileCounts,
    #[doc = "The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use."]
    pub status: VectorStoreObjectStatus,
    #[builder(default)]
    pub expires_after: Option<VectorStoreExpirationAfter>,
    #[doc = "The Unix timestamp (in seconds) for when the vector store will expire."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the vector store was last active."]
    #[builder(default)]
    pub last_active_at: Option<u64>,
    pub metadata: Metadata,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequestQuery {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<String>),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::String(_v) => Self::String(_v),
            _D::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for VectorStoreSearchRequestQuery {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<String>),
        }
        match self {
            Self::String(_v) => _S::String(_v).serialize(serializer),
            Self::Array(_v) => _S::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "A query string for a search"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreSearchRequestQuery {
    String(String),
    Array(Vec<String>),
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequestFilters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ComparisonFilter(#[allow(dead_code)] ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] CompoundFilter),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ComparisonFilter(_v) => Self::ComparisonFilter(_v),
            _D::CompoundFilter(_v) => Self::CompoundFilter(_v),
        })
    }
}
impl serde::Serialize for VectorStoreSearchRequestFilters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ComparisonFilter(#[allow(dead_code)] &'a ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] &'a CompoundFilter),
        }
        match self {
            Self::ComparisonFilter(_v) => _S::ComparisonFilter(_v).serialize(serializer),
            Self::CompoundFilter(_v) => _S::CompoundFilter(_v).serialize(serializer),
        }
    }
}
#[doc = "A filter to apply based on file attributes."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreSearchRequestFilters {
    ComparisonFilter(ComparisonFilter),
    CompoundFilter(CompoundFilter),
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequestRankingOptionsRanker {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchRequestRankingOptionsRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchRequestRankingOptionsRankerDefault2024_11_15 {
            #[default]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] VectorStoreSearchRequestRankingOptionsRankerAuto),
            Default2024_11_15(
                #[allow(dead_code)] VectorStoreSearchRequestRankingOptionsRankerDefault2024_11_15,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Default2024_11_15(_) => Self::Default2024_11_15,
        })
    }
}
impl serde::Serialize for VectorStoreSearchRequestRankingOptionsRanker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchRequestRankingOptionsRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchRequestRankingOptionsRankerDefault2024_11_15 {
            #[default]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a VectorStoreSearchRequestRankingOptionsRankerAuto),
            Default2024_11_15(
                #[allow(dead_code)]
                &'a VectorStoreSearchRequestRankingOptionsRankerDefault2024_11_15,
            ),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Default2024_11_15 => {
                _S::Default2024_11_15(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreSearchRequestRankingOptionsRanker {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "default-2024-11-15"]
    Default2024_11_15,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequestRankingOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "ranker")]
            #[allow(dead_code)]
            ranker: Option<VectorStoreSearchRequestRankingOptionsRanker>,
            #[serde(rename = "score_threshold")]
            #[allow(dead_code)]
            score_threshold: Option<f64>,
        }
        let _D {
            ranker,
            score_threshold,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreSearchRequestRankingOptions {
            ranker,
            score_threshold,
        })
    }
}
impl serde::Serialize for VectorStoreSearchRequestRankingOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "ranker")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranker: &'a Option<VectorStoreSearchRequestRankingOptionsRanker>,
            #[serde(rename = "score_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            score_threshold: &'a Option<f64>,
        }
        let VectorStoreSearchRequestRankingOptions {
            ranker,
            score_threshold,
        } = self;
        _S {
            ranker,
            score_threshold,
        }
        .serialize(serializer)
    }
}
#[doc = "Ranking options for search."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchRequestRankingOptions {
    #[builder(default)]
    pub ranker: Option<VectorStoreSearchRequestRankingOptionsRanker>,
    #[builder(default)]
    pub score_threshold: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "query")]
            #[allow(dead_code)]
            query: VectorStoreSearchRequestQuery,
            #[serde(rename = "rewrite_query")]
            #[allow(dead_code)]
            rewrite_query: Option<bool>,
            #[serde(rename = "max_num_results")]
            #[allow(dead_code)]
            max_num_results: Option<u64>,
            #[serde(rename = "filters")]
            #[allow(dead_code)]
            filters: Option<VectorStoreSearchRequestFilters>,
            #[serde(rename = "ranking_options")]
            #[allow(dead_code)]
            ranking_options: Option<VectorStoreSearchRequestRankingOptions>,
        }
        let _D {
            query,
            rewrite_query,
            max_num_results,
            filters,
            ranking_options,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreSearchRequest {
            query,
            rewrite_query,
            max_num_results,
            filters,
            ranking_options,
        })
    }
}
impl serde::Serialize for VectorStoreSearchRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "query")]
            query: &'a VectorStoreSearchRequestQuery,
            #[serde(rename = "rewrite_query")]
            #[serde(skip_serializing_if = "Option::is_none")]
            rewrite_query: &'a Option<bool>,
            #[serde(rename = "max_num_results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_num_results: &'a Option<u64>,
            #[serde(rename = "filters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filters: &'a Option<VectorStoreSearchRequestFilters>,
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<VectorStoreSearchRequestRankingOptions>,
        }
        let VectorStoreSearchRequest {
            query,
            rewrite_query,
            max_num_results,
            filters,
            ranking_options,
        } = self;
        _S {
            query,
            rewrite_query,
            max_num_results,
            filters,
            ranking_options,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchRequest {
    #[doc = "A query string for a search"]
    pub query: VectorStoreSearchRequestQuery,
    #[doc = "Whether to rewrite the natural language query for vector search."]
    #[builder(default)]
    pub rewrite_query: Option<bool>,
    #[doc = "The maximum number of results to return. This number should be between 1 and 50 inclusive."]
    #[builder(default)]
    pub max_num_results: Option<u64>,
    #[doc = "A filter to apply based on file attributes."]
    #[builder(default)]
    pub filters: Option<VectorStoreSearchRequestFilters>,
    #[doc = "Ranking options for search."]
    #[builder(default)]
    pub ranking_options: Option<VectorStoreSearchRequestRankingOptions>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchResultContentObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of content."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchResultContentObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: VectorStoreSearchResultContentObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(VectorStoreSearchResultContentObject { text })
    }
}
impl serde::Serialize for VectorStoreSearchResultContentObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of content."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchResultContentObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a VectorStoreSearchResultContentObjectType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let VectorStoreSearchResultContentObject { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultContentObject {
    #[doc = "The text content returned from search."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchResultItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: String,
            #[serde(rename = "score")]
            #[allow(dead_code)]
            score: f64,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: VectorStoreFileAttributes,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Vec<VectorStoreSearchResultContentObject>,
        }
        let _D {
            file_id,
            filename,
            score,
            attributes,
            content,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreSearchResultItem {
            file_id,
            filename,
            score,
            attributes,
            content,
        })
    }
}
impl serde::Serialize for VectorStoreSearchResultItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "score")]
            score: &'a f64,
            #[serde(rename = "attributes")]
            attributes: &'a VectorStoreFileAttributes,
            #[serde(rename = "content")]
            content: &'a Vec<VectorStoreSearchResultContentObject>,
        }
        let VectorStoreSearchResultItem {
            file_id,
            filename,
            score,
            attributes,
            content,
        } = self;
        _S {
            file_id,
            filename,
            score,
            attributes,
            content,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultItem {
    #[doc = "The ID of the vector store file."]
    pub file_id: String,
    #[doc = "The name of the vector store file."]
    pub filename: String,
    #[doc = "The similarity score for the result."]
    pub score: f64,
    pub attributes: VectorStoreFileAttributes,
    #[doc = "Content chunks from the file."]
    pub content: Vec<VectorStoreSearchResultContentObject>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchResultsPage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store.search_results.page`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchResultsPageObject {
            #[default]
            #[serde(rename = "vector_store.search_results.page")]
            VectorStoreSearchResultsPage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreSearchResultsPageObject,
            #[serde(rename = "search_query")]
            #[allow(dead_code)]
            search_query: Vec<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<VectorStoreSearchResultItem>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "next_page")]
            #[allow(dead_code)]
            next_page: Option<String>,
        }
        let _D {
            search_query,
            data,
            has_more,
            next_page,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(VectorStoreSearchResultsPage {
            search_query,
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for VectorStoreSearchResultsPage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store.search_results.page`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchResultsPageObject {
            #[default]
            #[serde(rename = "vector_store.search_results.page")]
            VectorStoreSearchResultsPage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "object")]
            object: &'a VectorStoreSearchResultsPageObject,
            #[serde(rename = "search_query")]
            search_query: &'a Vec<String>,
            #[serde(rename = "data")]
            data: &'a Vec<VectorStoreSearchResultItem>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            #[serde(skip_serializing_if = "Option::is_none")]
            next_page: &'a Option<String>,
        }
        let VectorStoreSearchResultsPage {
            search_query,
            data,
            has_more,
            next_page,
        } = self;
        _S {
            object: &Default::default(),
            search_query,
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultsPage {
    pub search_query: Vec<String>,
    #[doc = "The list of search result items."]
    pub data: Vec<VectorStoreSearchResultItem>,
    #[doc = "Indicates if there are more results to fetch."]
    pub has_more: bool,
    #[doc = "The token for the next page, if any."]
    #[builder(default)]
    pub next_page: Option<String>,
}
impl<'de> serde::Deserialize<'de> for VoiceIdsShared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedAlloy {
            #[default]
            #[serde(rename = "alloy")]
            Alloy,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedAsh {
            #[default]
            #[serde(rename = "ash")]
            Ash,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedBallad {
            #[default]
            #[serde(rename = "ballad")]
            Ballad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedCoral {
            #[default]
            #[serde(rename = "coral")]
            Coral,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedEcho {
            #[default]
            #[serde(rename = "echo")]
            Echo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedFable {
            #[default]
            #[serde(rename = "fable")]
            Fable,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedOnyx {
            #[default]
            #[serde(rename = "onyx")]
            Onyx,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedNova {
            #[default]
            #[serde(rename = "nova")]
            Nova,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedSage {
            #[default]
            #[serde(rename = "sage")]
            Sage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedShimmer {
            #[default]
            #[serde(rename = "shimmer")]
            Shimmer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedVerse {
            #[default]
            #[serde(rename = "verse")]
            Verse,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Alloy(#[allow(dead_code)] VoiceIdsSharedAlloy),
            Ash(#[allow(dead_code)] VoiceIdsSharedAsh),
            Ballad(#[allow(dead_code)] VoiceIdsSharedBallad),
            Coral(#[allow(dead_code)] VoiceIdsSharedCoral),
            Echo(#[allow(dead_code)] VoiceIdsSharedEcho),
            Fable(#[allow(dead_code)] VoiceIdsSharedFable),
            Onyx(#[allow(dead_code)] VoiceIdsSharedOnyx),
            Nova(#[allow(dead_code)] VoiceIdsSharedNova),
            Sage(#[allow(dead_code)] VoiceIdsSharedSage),
            Shimmer(#[allow(dead_code)] VoiceIdsSharedShimmer),
            Verse(#[allow(dead_code)] VoiceIdsSharedVerse),
            Other(#[allow(dead_code)] String),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Alloy(_) => Self::Alloy,
            _D::Ash(_) => Self::Ash,
            _D::Ballad(_) => Self::Ballad,
            _D::Coral(_) => Self::Coral,
            _D::Echo(_) => Self::Echo,
            _D::Fable(_) => Self::Fable,
            _D::Onyx(_) => Self::Onyx,
            _D::Nova(_) => Self::Nova,
            _D::Sage(_) => Self::Sage,
            _D::Shimmer(_) => Self::Shimmer,
            _D::Verse(_) => Self::Verse,
            _D::Other(_v) => Self::Other(_v),
        })
    }
}
impl serde::Serialize for VoiceIdsShared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedAlloy {
            #[default]
            #[serde(rename = "alloy")]
            Alloy,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedAsh {
            #[default]
            #[serde(rename = "ash")]
            Ash,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedBallad {
            #[default]
            #[serde(rename = "ballad")]
            Ballad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedCoral {
            #[default]
            #[serde(rename = "coral")]
            Coral,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedEcho {
            #[default]
            #[serde(rename = "echo")]
            Echo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedFable {
            #[default]
            #[serde(rename = "fable")]
            Fable,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedOnyx {
            #[default]
            #[serde(rename = "onyx")]
            Onyx,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedNova {
            #[default]
            #[serde(rename = "nova")]
            Nova,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedSage {
            #[default]
            #[serde(rename = "sage")]
            Sage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedShimmer {
            #[default]
            #[serde(rename = "shimmer")]
            Shimmer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedVerse {
            #[default]
            #[serde(rename = "verse")]
            Verse,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Alloy(#[allow(dead_code)] &'a VoiceIdsSharedAlloy),
            Ash(#[allow(dead_code)] &'a VoiceIdsSharedAsh),
            Ballad(#[allow(dead_code)] &'a VoiceIdsSharedBallad),
            Coral(#[allow(dead_code)] &'a VoiceIdsSharedCoral),
            Echo(#[allow(dead_code)] &'a VoiceIdsSharedEcho),
            Fable(#[allow(dead_code)] &'a VoiceIdsSharedFable),
            Onyx(#[allow(dead_code)] &'a VoiceIdsSharedOnyx),
            Nova(#[allow(dead_code)] &'a VoiceIdsSharedNova),
            Sage(#[allow(dead_code)] &'a VoiceIdsSharedSage),
            Shimmer(#[allow(dead_code)] &'a VoiceIdsSharedShimmer),
            Verse(#[allow(dead_code)] &'a VoiceIdsSharedVerse),
            Other(#[allow(dead_code)] &'a String),
        }
        match self {
            Self::Alloy => _S::Alloy(&Default::default()).serialize(serializer),
            Self::Ash => _S::Ash(&Default::default()).serialize(serializer),
            Self::Ballad => _S::Ballad(&Default::default()).serialize(serializer),
            Self::Coral => _S::Coral(&Default::default()).serialize(serializer),
            Self::Echo => _S::Echo(&Default::default()).serialize(serializer),
            Self::Fable => _S::Fable(&Default::default()).serialize(serializer),
            Self::Onyx => _S::Onyx(&Default::default()).serialize(serializer),
            Self::Nova => _S::Nova(&Default::default()).serialize(serializer),
            Self::Sage => _S::Sage(&Default::default()).serialize(serializer),
            Self::Shimmer => _S::Shimmer(&Default::default()).serialize(serializer),
            Self::Verse => _S::Verse(&Default::default()).serialize(serializer),
            Self::Other(_v) => _S::Other(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VoiceIdsShared {
    #[doc = "alloy"]
    Alloy,
    #[doc = "ash"]
    Ash,
    #[doc = "ballad"]
    Ballad,
    #[doc = "coral"]
    Coral,
    #[doc = "echo"]
    Echo,
    #[doc = "fable"]
    Fable,
    #[doc = "onyx"]
    Onyx,
    #[doc = "nova"]
    Nova,
    #[doc = "sage"]
    Sage,
    #[doc = "shimmer"]
    Shimmer,
    #[doc = "verse"]
    Verse,
    Other(String),
}
impl<'de> serde::Deserialize<'de> for Wait {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a wait action, this property is \nalways set to `wait`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WaitType {
            #[default]
            #[serde(rename = "wait")]
            Wait,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: WaitType,
        }
        let _D { .. } = _D::deserialize(deserializer)?;
        Ok(Wait {})
    }
}
impl serde::Serialize for Wait {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a wait action, this property is \nalways set to `wait`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WaitType {
            #[default]
            #[serde(rename = "wait")]
            Wait,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a WaitType,
        }
        let Wait {} = self;
        _S {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "A wait action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct Wait {}
impl<'de> serde::Deserialize<'de> for WebSearchContextSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Low(#[allow(dead_code)] WebSearchContextSizeLow),
            Medium(#[allow(dead_code)] WebSearchContextSizeMedium),
            High(#[allow(dead_code)] WebSearchContextSizeHigh),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Low(_) => Self::Low,
            _D::Medium(_) => Self::Medium,
            _D::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for WebSearchContextSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Low(#[allow(dead_code)] &'a WebSearchContextSizeLow),
            Medium(#[allow(dead_code)] &'a WebSearchContextSizeMedium),
            High(#[allow(dead_code)] &'a WebSearchContextSizeHigh),
        }
        match self {
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Medium => _S::Medium(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "High level guidance for the amount of context window space to use for the \nsearch. One of `low`, `medium`, or `high`. `medium` is the default.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum WebSearchContextSize {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    #[default]
    Medium,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for WebSearchLocation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "country")]
            #[allow(dead_code)]
            country: Option<String>,
            #[serde(rename = "region")]
            #[allow(dead_code)]
            region: Option<String>,
            #[serde(rename = "city")]
            #[allow(dead_code)]
            city: Option<String>,
            #[serde(rename = "timezone")]
            #[allow(dead_code)]
            timezone: Option<String>,
        }
        let _D {
            country,
            region,
            city,
            timezone,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(WebSearchLocation {
            country,
            region,
            city,
            timezone,
        })
    }
}
impl serde::Serialize for WebSearchLocation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "country")]
            #[serde(skip_serializing_if = "Option::is_none")]
            country: &'a Option<String>,
            #[serde(rename = "region")]
            #[serde(skip_serializing_if = "Option::is_none")]
            region: &'a Option<String>,
            #[serde(rename = "city")]
            #[serde(skip_serializing_if = "Option::is_none")]
            city: &'a Option<String>,
            #[serde(rename = "timezone")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timezone: &'a Option<String>,
        }
        let WebSearchLocation {
            country,
            region,
            city,
            timezone,
        } = self;
        _S {
            country,
            region,
            city,
            timezone,
        }
        .serialize(serializer)
    }
}
#[doc = "Approximate location parameters for the search."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct WebSearchLocation {
    #[doc = "The two-letter \n[ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user,\ne.g. `US`.\n"]
    #[builder(default)]
    pub country: Option<String>,
    #[doc = "Free text input for the region of the user, e.g. `California`.\n"]
    #[builder(default)]
    pub region: Option<String>,
    #[doc = "Free text input for the city of the user, e.g. `San Francisco`.\n"]
    #[builder(default)]
    pub city: Option<String>,
    #[doc = "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) \nof the user, e.g. `America/Los_Angeles`.\n"]
    #[builder(default)]
    pub timezone: Option<String>,
}
impl<'de> serde::Deserialize<'de> for WebSearchToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusSearching {
            #[default]
            #[serde(rename = "searching")]
            Searching,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] WebSearchToolCallStatusInProgress),
            Searching(#[allow(dead_code)] WebSearchToolCallStatusSearching),
            Completed(#[allow(dead_code)] WebSearchToolCallStatusCompleted),
            Failed(#[allow(dead_code)] WebSearchToolCallStatusFailed),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Searching(_) => Self::Searching,
            _D::Completed(_) => Self::Completed,
            _D::Failed(_) => Self::Failed,
        })
    }
}
impl serde::Serialize for WebSearchToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusSearching {
            #[default]
            #[serde(rename = "searching")]
            Searching,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a WebSearchToolCallStatusInProgress),
            Searching(#[allow(dead_code)] &'a WebSearchToolCallStatusSearching),
            Completed(#[allow(dead_code)] &'a WebSearchToolCallStatusCompleted),
            Failed(#[allow(dead_code)] &'a WebSearchToolCallStatusFailed),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Searching => _S::Searching(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Failed => _S::Failed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the web search tool call.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum WebSearchToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "searching"]
    Searching,
    #[doc = "completed"]
    Completed,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for WebSearchToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the web search tool call. Always `web_search_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallType {
            #[default]
            #[serde(rename = "web_search_call")]
            WebSearchCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: WebSearchToolCallType,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: WebSearchToolCallStatus,
        }
        let _D { id, status, .. } = _D::deserialize(deserializer)?;
        Ok(WebSearchToolCall { id, status })
    }
}
impl serde::Serialize for WebSearchToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the web search tool call. Always `web_search_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallType {
            #[default]
            #[serde(rename = "web_search_call")]
            WebSearchCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a WebSearchToolCallType,
            #[serde(rename = "status")]
            status: &'a WebSearchToolCallStatus,
        }
        let WebSearchToolCall { id, status } = self;
        _S {
            id,
            type_: &Default::default(),
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The results of a web search tool call. See the \n[web search guide](/docs/guides/tools-web-search) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebSearchToolCall {
    #[doc = "The unique ID of the web search tool call.\n"]
    pub id: String,
    #[doc = "The status of the web search tool call.\n"]
    pub status: WebSearchToolCallStatus,
}
impl<'de> serde::Deserialize<'de> for InputTextContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the input item. Always `input_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputTextContentType {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: InputTextContentType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let _D { text, .. } = _D::deserialize(deserializer)?;
        Ok(InputTextContent { text })
    }
}
impl serde::Serialize for InputTextContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the input item. Always `input_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputTextContentType {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a InputTextContentType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let InputTextContent { text } = self;
        _S {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "A text input to the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputTextContent {
    #[doc = "The text input to the model."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for InputImageContentDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Low(#[allow(dead_code)] InputImageContentDetailLow),
            High(#[allow(dead_code)] InputImageContentDetailHigh),
            Auto(#[allow(dead_code)] InputImageContentDetailAuto),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Low(_) => Self::Low,
            _D::High(_) => Self::High,
            _D::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for InputImageContentDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Low(#[allow(dead_code)] &'a InputImageContentDetailLow),
            High(#[allow(dead_code)] &'a InputImageContentDetailHigh),
            Auto(#[allow(dead_code)] &'a InputImageContentDetailAuto),
        }
        match self {
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InputImageContentDetail {
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    Auto,
}
impl<'de> serde::Deserialize<'de> for InputImageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the input item. Always `input_image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentType {
            #[default]
            #[serde(rename = "input_image")]
            InputImage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: InputImageContentType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: Option<String>,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: InputImageContentDetail,
        }
        let _D {
            image_url,
            file_id,
            detail,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(InputImageContent {
            image_url,
            file_id,
            detail,
        })
    }
}
impl serde::Serialize for InputImageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the input item. Always `input_image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentType {
            #[default]
            #[serde(rename = "input_image")]
            InputImage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a InputImageContentType,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "detail")]
            detail: &'a InputImageContentDetail,
        }
        let InputImageContent {
            image_url,
            file_id,
            detail,
        } = self;
        _S {
            type_: &Default::default(),
            image_url,
            file_id,
            detail,
        }
        .serialize(serializer)
    }
}
#[doc = "An image input to the model. Learn about [image inputs](/docs/guides/vision)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputImageContent {
    #[doc = "The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL."]
    #[builder(default)]
    pub image_url: Option<String>,
    #[doc = "The ID of the file to be sent to the model."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`."]
    pub detail: InputImageContentDetail,
}
impl<'de> serde::Deserialize<'de> for InputFileContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the input item. Always `input_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputFileContentType {
            #[default]
            #[serde(rename = "input_file")]
            InputFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: InputFileContentType,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: Option<String>,
            #[serde(rename = "file_data")]
            #[allow(dead_code)]
            file_data: Option<String>,
        }
        let _D {
            file_id,
            filename,
            file_data,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(InputFileContent {
            file_id,
            filename,
            file_data,
        })
    }
}
impl serde::Serialize for InputFileContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the input item. Always `input_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputFileContentType {
            #[default]
            #[serde(rename = "input_file")]
            InputFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a InputFileContentType,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "filename")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filename: &'a Option<String>,
            #[serde(rename = "file_data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_data: &'a Option<String>,
        }
        let InputFileContent {
            file_id,
            filename,
            file_data,
        } = self;
        _S {
            type_: &Default::default(),
            file_id,
            filename,
            file_data,
        }
        .serialize(serializer)
    }
}
#[doc = "A file input to the model."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct InputFileContent {
    #[doc = "The ID of the file to be sent to the model."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The name of the file to be sent to the model."]
    #[builder(default)]
    pub filename: Option<String>,
    #[doc = "The content of the file to be sent to the model.\n"]
    #[builder(default)]
    pub file_data: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RankingOptionsRanker {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RankingOptionsRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RankingOptionsRankerDefault2024_11_15 {
            #[default]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Auto(#[allow(dead_code)] RankingOptionsRankerAuto),
            Default2024_11_15(#[allow(dead_code)] RankingOptionsRankerDefault2024_11_15),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Auto(_) => Self::Auto,
            _D::Default2024_11_15(_) => Self::Default2024_11_15,
        })
    }
}
impl serde::Serialize for RankingOptionsRanker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RankingOptionsRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RankingOptionsRankerDefault2024_11_15 {
            #[default]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Auto(#[allow(dead_code)] &'a RankingOptionsRankerAuto),
            Default2024_11_15(#[allow(dead_code)] &'a RankingOptionsRankerDefault2024_11_15),
        }
        match self {
            Self::Auto => _S::Auto(&Default::default()).serialize(serializer),
            Self::Default2024_11_15 => {
                _S::Default2024_11_15(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The ranker to use for the file search."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RankingOptionsRanker {
    #[doc = "auto"]
    Auto,
    #[doc = "default-2024-11-15"]
    Default2024_11_15,
}
impl<'de> serde::Deserialize<'de> for RankingOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "ranker")]
            #[allow(dead_code)]
            ranker: Option<RankingOptionsRanker>,
            #[serde(rename = "score_threshold")]
            #[allow(dead_code)]
            score_threshold: Option<f64>,
        }
        let _D {
            ranker,
            score_threshold,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(RankingOptions {
            ranker,
            score_threshold,
        })
    }
}
impl serde::Serialize for RankingOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "ranker")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranker: &'a Option<RankingOptionsRanker>,
            #[serde(rename = "score_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            score_threshold: &'a Option<f64>,
        }
        let RankingOptions {
            ranker,
            score_threshold,
        } = self;
        _S {
            ranker,
            score_threshold,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RankingOptions {
    #[doc = "The ranker to use for the file search."]
    #[builder(default)]
    pub ranker: Option<RankingOptionsRanker>,
    #[doc = "The score threshold for the file search, a number between 0 and 1. Numbers closer to 1 will attempt to return only the most relevant results, but may return fewer results."]
    #[builder(default)]
    pub score_threshold: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for Filters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ComparisonFilter(#[allow(dead_code)] ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] CompoundFilter),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ComparisonFilter(_v) => Self::ComparisonFilter(_v),
            _D::CompoundFilter(_v) => Self::CompoundFilter(_v),
        })
    }
}
impl serde::Serialize for Filters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ComparisonFilter(#[allow(dead_code)] &'a ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] &'a CompoundFilter),
        }
        match self {
            Self::ComparisonFilter(_v) => _S::ComparisonFilter(_v).serialize(serializer),
            Self::CompoundFilter(_v) => _S::CompoundFilter(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Filters {
    ComparisonFilter(ComparisonFilter),
    CompoundFilter(CompoundFilter),
}
impl<'de> serde::Deserialize<'de> for FileSearchTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the file search tool. Always `file_search`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FileSearchToolType,
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Vec<String>,
            #[serde(rename = "max_num_results")]
            #[allow(dead_code)]
            max_num_results: Option<u64>,
            #[serde(rename = "ranking_options")]
            #[allow(dead_code)]
            ranking_options: Option<RankingOptions>,
            #[serde(rename = "filters")]
            #[allow(dead_code)]
            filters: Option<Filters>,
        }
        let _D {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FileSearchTool {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        })
    }
}
impl serde::Serialize for FileSearchTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the file search tool. Always `file_search`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a FileSearchToolType,
            #[serde(rename = "vector_store_ids")]
            vector_store_ids: &'a Vec<String>,
            #[serde(rename = "max_num_results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_num_results: &'a Option<u64>,
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<RankingOptions>,
            #[serde(rename = "filters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filters: &'a Option<Filters>,
        }
        let FileSearchTool {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        } = self;
        _S {
            type_: &Default::default(),
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool that searches for relevant content from uploaded files. Learn more about the [file search tool](https://platform.openai.com/docs/guides/tools-file-search)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileSearchTool {
    #[doc = "The IDs of the vector stores to search."]
    pub vector_store_ids: Vec<String>,
    #[doc = "The maximum number of results to return. This number should be between 1 and 50 inclusive."]
    #[builder(default)]
    pub max_num_results: Option<u64>,
    #[doc = "Ranking options for search."]
    #[builder(default)]
    pub ranking_options: Option<RankingOptions>,
    #[doc = "A filter to apply."]
    #[builder(default)]
    pub filters: Option<Filters>,
}
impl<'de> serde::Deserialize<'de> for FunctionTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the function tool. Always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FunctionToolType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<Vec<serde_json::Value>>,
            #[serde(rename = "strict")]
            #[allow(dead_code)]
            strict: Option<bool>,
        }
        let _D {
            name,
            description,
            parameters,
            strict,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FunctionTool {
            name,
            description,
            parameters,
            strict,
        })
    }
}
impl serde::Serialize for FunctionTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the function tool. Always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a FunctionToolType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<Vec<serde_json::Value>>,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let FunctionTool {
            name,
            description,
            parameters,
            strict,
        } = self;
        _S {
            type_: &Default::default(),
            name,
            description,
            parameters,
            strict,
        }
        .serialize(serializer)
    }
}
#[doc = "Defines a function in your own code the model can choose to call. Learn more about [function calling](https://platform.openai.com/docs/guides/function-calling)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionTool {
    #[doc = "The name of the function to call."]
    pub name: String,
    #[doc = "A description of the function. Used by the model to determine whether or not to call the function."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "A JSON schema object describing the parameters of the function."]
    #[builder(default)]
    pub parameters: Option<Vec<serde_json::Value>>,
    #[doc = "Whether to enforce strict parameter validation. Default `true`."]
    #[builder(default)]
    pub strict: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ApproximateLocation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of location approximation. Always `approximate`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ApproximateLocationType {
            #[default]
            #[serde(rename = "approximate")]
            Approximate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ApproximateLocationType,
            #[serde(rename = "country")]
            #[allow(dead_code)]
            country: Option<String>,
            #[serde(rename = "region")]
            #[allow(dead_code)]
            region: Option<String>,
            #[serde(rename = "city")]
            #[allow(dead_code)]
            city: Option<String>,
            #[serde(rename = "timezone")]
            #[allow(dead_code)]
            timezone: Option<String>,
        }
        let _D {
            country,
            region,
            city,
            timezone,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ApproximateLocation {
            country,
            region,
            city,
            timezone,
        })
    }
}
impl serde::Serialize for ApproximateLocation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of location approximation. Always `approximate`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ApproximateLocationType {
            #[default]
            #[serde(rename = "approximate")]
            Approximate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ApproximateLocationType,
            #[serde(rename = "country")]
            #[serde(skip_serializing_if = "Option::is_none")]
            country: &'a Option<String>,
            #[serde(rename = "region")]
            #[serde(skip_serializing_if = "Option::is_none")]
            region: &'a Option<String>,
            #[serde(rename = "city")]
            #[serde(skip_serializing_if = "Option::is_none")]
            city: &'a Option<String>,
            #[serde(rename = "timezone")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timezone: &'a Option<String>,
        }
        let ApproximateLocation {
            country,
            region,
            city,
            timezone,
        } = self;
        _S {
            type_: &Default::default(),
            country,
            region,
            city,
            timezone,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ApproximateLocation {
    #[doc = "The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`."]
    #[builder(default)]
    pub country: Option<String>,
    #[doc = "Free text input for the region of the user, e.g. `California`."]
    #[builder(default)]
    pub region: Option<String>,
    #[doc = "Free text input for the city of the user, e.g. `San Francisco`."]
    #[builder(default)]
    pub city: Option<String>,
    #[doc = "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`."]
    #[builder(default)]
    pub timezone: Option<String>,
}
impl<'de> serde::Deserialize<'de> for WebSearchPreviewToolType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolTypeWebSearchPreview {
            #[default]
            #[serde(rename = "web_search_preview")]
            WebSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolTypeWebSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "web_search_preview_2025_03_11")]
            WebSearchPreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            WebSearchPreview(#[allow(dead_code)] WebSearchPreviewToolTypeWebSearchPreview),
            WebSearchPreview2025_03_11(
                #[allow(dead_code)] WebSearchPreviewToolTypeWebSearchPreview2025_03_11,
            ),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::WebSearchPreview(_) => Self::WebSearchPreview,
            _D::WebSearchPreview2025_03_11(_) => Self::WebSearchPreview2025_03_11,
        })
    }
}
impl serde::Serialize for WebSearchPreviewToolType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolTypeWebSearchPreview {
            #[default]
            #[serde(rename = "web_search_preview")]
            WebSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolTypeWebSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "web_search_preview_2025_03_11")]
            WebSearchPreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            WebSearchPreview(#[allow(dead_code)] &'a WebSearchPreviewToolTypeWebSearchPreview),
            WebSearchPreview2025_03_11(
                #[allow(dead_code)] &'a WebSearchPreviewToolTypeWebSearchPreview2025_03_11,
            ),
        }
        match self {
            Self::WebSearchPreview => {
                _S::WebSearchPreview(&Default::default()).serialize(serializer)
            }
            Self::WebSearchPreview2025_03_11 => {
                _S::WebSearchPreview2025_03_11(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum WebSearchPreviewToolType {
    #[doc = "web_search_preview"]
    #[default]
    WebSearchPreview,
    #[doc = "web_search_preview_2025_03_11"]
    WebSearchPreview2025_03_11,
}
impl<'de> serde::Deserialize<'de> for WebSearchPreviewToolSearchContextSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Low(#[allow(dead_code)] WebSearchPreviewToolSearchContextSizeLow),
            Medium(#[allow(dead_code)] WebSearchPreviewToolSearchContextSizeMedium),
            High(#[allow(dead_code)] WebSearchPreviewToolSearchContextSizeHigh),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Low(_) => Self::Low,
            _D::Medium(_) => Self::Medium,
            _D::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for WebSearchPreviewToolSearchContextSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Low(#[allow(dead_code)] &'a WebSearchPreviewToolSearchContextSizeLow),
            Medium(#[allow(dead_code)] &'a WebSearchPreviewToolSearchContextSizeMedium),
            High(#[allow(dead_code)] &'a WebSearchPreviewToolSearchContextSizeHigh),
        }
        match self {
            Self::Low => _S::Low(&Default::default()).serialize(serializer),
            Self::Medium => _S::Medium(&Default::default()).serialize(serializer),
            Self::High => _S::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum WebSearchPreviewToolSearchContextSize {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for WebSearchPreviewTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: WebSearchPreviewToolType,
            #[serde(rename = "user_location")]
            #[allow(dead_code)]
            user_location: Option<ApproximateLocation>,
            #[serde(rename = "search_context_size")]
            #[allow(dead_code)]
            search_context_size: Option<WebSearchPreviewToolSearchContextSize>,
        }
        let _D {
            type_,
            user_location,
            search_context_size,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(WebSearchPreviewTool {
            type_,
            user_location,
            search_context_size,
        })
    }
}
impl serde::Serialize for WebSearchPreviewTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a WebSearchPreviewToolType,
            #[serde(rename = "user_location")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_location: &'a Option<ApproximateLocation>,
            #[serde(rename = "search_context_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            search_context_size: &'a Option<WebSearchPreviewToolSearchContextSize>,
        }
        let WebSearchPreviewTool {
            type_,
            user_location,
            search_context_size,
        } = self;
        _S {
            type_,
            user_location,
            search_context_size,
        }
        .serialize(serializer)
    }
}
#[doc = "This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search)."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct WebSearchPreviewTool {
    #[doc = "The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`."]
    #[builder(default)]
    pub type_: WebSearchPreviewToolType,
    #[doc = "The user's location."]
    #[builder(default)]
    pub user_location: Option<ApproximateLocation>,
    #[doc = "High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default."]
    #[builder(default)]
    pub search_context_size: Option<WebSearchPreviewToolSearchContextSize>,
}
impl<'de> serde::Deserialize<'de> for ComputerUsePreviewToolEnvironment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentWindows {
            #[default]
            #[serde(rename = "windows")]
            Windows,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentMac {
            #[default]
            #[serde(rename = "mac")]
            Mac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentLinux {
            #[default]
            #[serde(rename = "linux")]
            Linux,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentUbuntu {
            #[default]
            #[serde(rename = "ubuntu")]
            Ubuntu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentBrowser {
            #[default]
            #[serde(rename = "browser")]
            Browser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            Windows(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentWindows),
            Mac(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentMac),
            Linux(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentLinux),
            Ubuntu(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentUbuntu),
            Browser(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentBrowser),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::Windows(_) => Self::Windows,
            _D::Mac(_) => Self::Mac,
            _D::Linux(_) => Self::Linux,
            _D::Ubuntu(_) => Self::Ubuntu,
            _D::Browser(_) => Self::Browser,
        })
    }
}
impl serde::Serialize for ComputerUsePreviewToolEnvironment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentWindows {
            #[default]
            #[serde(rename = "windows")]
            Windows,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentMac {
            #[default]
            #[serde(rename = "mac")]
            Mac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentLinux {
            #[default]
            #[serde(rename = "linux")]
            Linux,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentUbuntu {
            #[default]
            #[serde(rename = "ubuntu")]
            Ubuntu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentBrowser {
            #[default]
            #[serde(rename = "browser")]
            Browser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            Windows(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentWindows),
            Mac(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentMac),
            Linux(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentLinux),
            Ubuntu(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentUbuntu),
            Browser(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentBrowser),
        }
        match self {
            Self::Windows => _S::Windows(&Default::default()).serialize(serializer),
            Self::Mac => _S::Mac(&Default::default()).serialize(serializer),
            Self::Linux => _S::Linux(&Default::default()).serialize(serializer),
            Self::Ubuntu => _S::Ubuntu(&Default::default()).serialize(serializer),
            Self::Browser => _S::Browser(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of computer environment to control."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerUsePreviewToolEnvironment {
    #[doc = "windows"]
    Windows,
    #[doc = "mac"]
    Mac,
    #[doc = "linux"]
    Linux,
    #[doc = "ubuntu"]
    Ubuntu,
    #[doc = "browser"]
    Browser,
}
impl<'de> serde::Deserialize<'de> for ComputerUsePreviewTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the computer use tool. Always `computer_use_preview`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolType {
            #[default]
            #[serde(rename = "computer_use_preview")]
            ComputerUsePreview,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerUsePreviewToolType,
            #[serde(rename = "environment")]
            #[allow(dead_code)]
            environment: ComputerUsePreviewToolEnvironment,
            #[serde(rename = "display_width")]
            #[allow(dead_code)]
            display_width: u64,
            #[serde(rename = "display_height")]
            #[allow(dead_code)]
            display_height: u64,
        }
        let _D {
            environment,
            display_width,
            display_height,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ComputerUsePreviewTool {
            environment,
            display_width,
            display_height,
        })
    }
}
impl serde::Serialize for ComputerUsePreviewTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the computer use tool. Always `computer_use_preview`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolType {
            #[default]
            #[serde(rename = "computer_use_preview")]
            ComputerUsePreview,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a ComputerUsePreviewToolType,
            #[serde(rename = "environment")]
            environment: &'a ComputerUsePreviewToolEnvironment,
            #[serde(rename = "display_width")]
            display_width: &'a u64,
            #[serde(rename = "display_height")]
            display_height: &'a u64,
        }
        let ComputerUsePreviewTool {
            environment,
            display_width,
            display_height,
        } = self;
        _S {
            type_: &Default::default(),
            environment,
            display_width,
            display_height,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use)."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ComputerUsePreviewTool {
    #[doc = "The type of computer environment to control."]
    pub environment: ComputerUsePreviewToolEnvironment,
    #[doc = "The width of the computer display."]
    pub display_width: u64,
    #[doc = "The height of the computer display."]
    pub display_height: u64,
}
impl<'de> serde::Deserialize<'de> for Tool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileSearchTool(#[allow(dead_code)] FileSearchTool),
            FunctionTool(#[allow(dead_code)] FunctionTool),
            WebSearchPreviewTool(#[allow(dead_code)] WebSearchPreviewTool),
            ComputerUsePreviewTool(#[allow(dead_code)] ComputerUsePreviewTool),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileSearchTool(_v) => Self::FileSearchTool(_v),
            _D::FunctionTool(_v) => Self::FunctionTool(_v),
            _D::WebSearchPreviewTool(_v) => Self::WebSearchPreviewTool(_v),
            _D::ComputerUsePreviewTool(_v) => Self::ComputerUsePreviewTool(_v),
        })
    }
}
impl serde::Serialize for Tool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileSearchTool(#[allow(dead_code)] &'a FileSearchTool),
            FunctionTool(#[allow(dead_code)] &'a FunctionTool),
            WebSearchPreviewTool(#[allow(dead_code)] &'a WebSearchPreviewTool),
            ComputerUsePreviewTool(#[allow(dead_code)] &'a ComputerUsePreviewTool),
        }
        match self {
            Self::FileSearchTool(_v) => _S::FileSearchTool(_v).serialize(serializer),
            Self::FunctionTool(_v) => _S::FunctionTool(_v).serialize(serializer),
            Self::WebSearchPreviewTool(_v) => _S::WebSearchPreviewTool(_v).serialize(serializer),
            Self::ComputerUsePreviewTool(_v) => {
                _S::ComputerUsePreviewTool(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Tool {
    FileSearchTool(FileSearchTool),
    FunctionTool(FunctionTool),
    WebSearchPreviewTool(WebSearchPreviewTool),
    ComputerUsePreviewTool(ComputerUsePreviewTool),
}
impl<'de> serde::Deserialize<'de> for FileCitationBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the file citation. Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileCitationBodyType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FileCitationBodyType,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
        }
        let _D { file_id, index, .. } = _D::deserialize(deserializer)?;
        Ok(FileCitationBody { file_id, index })
    }
}
impl serde::Serialize for FileCitationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the file citation. Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileCitationBodyType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a FileCitationBodyType,
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "index")]
            index: &'a u64,
        }
        let FileCitationBody { file_id, index } = self;
        _S {
            type_: &Default::default(),
            file_id,
            index,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation to a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileCitationBody {
    #[doc = "The ID of the file."]
    pub file_id: String,
    #[doc = "The index of the file in the list of files."]
    pub index: u64,
}
impl<'de> serde::Deserialize<'de> for UrlCitationBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the URL citation. Always `url_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UrlCitationBodyType {
            #[default]
            #[serde(rename = "url_citation")]
            UrlCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: UrlCitationBodyType,
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: String,
        }
        let _D {
            url,
            start_index,
            end_index,
            title,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(UrlCitationBody {
            url,
            start_index,
            end_index,
            title,
        })
    }
}
impl serde::Serialize for UrlCitationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the URL citation. Always `url_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UrlCitationBodyType {
            #[default]
            #[serde(rename = "url_citation")]
            UrlCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a UrlCitationBodyType,
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "end_index")]
            end_index: &'a u64,
            #[serde(rename = "title")]
            title: &'a String,
        }
        let UrlCitationBody {
            url,
            start_index,
            end_index,
            title,
        } = self;
        _S {
            type_: &Default::default(),
            url,
            start_index,
            end_index,
            title,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation for a web resource used to generate a model response."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UrlCitationBody {
    #[doc = "The URL of the web resource."]
    pub url: String,
    #[doc = "The index of the first character of the URL citation in the message."]
    pub start_index: u64,
    #[doc = "The index of the last character of the URL citation in the message."]
    pub end_index: u64,
    #[doc = "The title of the web resource."]
    pub title: String,
}
impl<'de> serde::Deserialize<'de> for Annotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            FileCitation(#[allow(dead_code)] FileCitationBody),
            UrlCitation(#[allow(dead_code)] UrlCitationBody),
            FilePath(#[allow(dead_code)] FilePath),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::FileCitation(_v) => Self::FileCitation(_v),
            _D::UrlCitation(_v) => Self::UrlCitation(_v),
            _D::FilePath(_v) => Self::FilePath(_v),
        })
    }
}
impl serde::Serialize for Annotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            FileCitation(#[allow(dead_code)] &'a FileCitationBody),
            UrlCitation(#[allow(dead_code)] &'a UrlCitationBody),
            FilePath(#[allow(dead_code)] &'a FilePath),
        }
        match self {
            Self::FileCitation(_v) => _S::FileCitation(_v).serialize(serializer),
            Self::UrlCitation(_v) => _S::UrlCitation(_v).serialize(serializer),
            Self::FilePath(_v) => _S::FilePath(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Annotation {
    FileCitation(FileCitationBody),
    UrlCitation(UrlCitationBody),
    FilePath(FilePath),
}
impl<'de> serde::Deserialize<'de> for OutputTextContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the output text. Always `output_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputTextContentType {
            #[default]
            #[serde(rename = "output_text")]
            OutputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: OutputTextContentType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Vec<Annotation>,
        }
        let _D {
            text, annotations, ..
        } = _D::deserialize(deserializer)?;
        Ok(OutputTextContent { text, annotations })
    }
}
impl serde::Serialize for OutputTextContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the output text. Always `output_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputTextContentType {
            #[default]
            #[serde(rename = "output_text")]
            OutputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a OutputTextContentType,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "annotations")]
            annotations: &'a Vec<Annotation>,
        }
        let OutputTextContent { text, annotations } = self;
        _S {
            type_: &Default::default(),
            text,
            annotations,
        }
        .serialize(serializer)
    }
}
#[doc = "A text output from the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputTextContent {
    #[doc = "The text output from the model."]
    pub text: String,
    #[doc = "The annotations of the text output."]
    pub annotations: Vec<Annotation>,
}
impl<'de> serde::Deserialize<'de> for RefusalContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the refusal. Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RefusalContentType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RefusalContentType,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: String,
        }
        let _D { refusal, .. } = _D::deserialize(deserializer)?;
        Ok(RefusalContent { refusal })
    }
}
impl serde::Serialize for RefusalContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the refusal. Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RefusalContentType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            type_: &'a RefusalContentType,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let RefusalContent { refusal } = self;
        _S {
            type_: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "A refusal from the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RefusalContent {
    #[doc = "The refusal explanationfrom the model."]
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for ComputerCallSafetyCheckParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: Option<String>,
        }
        let _D {
            id, code, message, ..
        } = _D::deserialize(deserializer)?;
        Ok(ComputerCallSafetyCheckParam { id, code, message })
    }
}
impl serde::Serialize for ComputerCallSafetyCheckParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message: &'a Option<String>,
        }
        let ComputerCallSafetyCheckParam { id, code, message } = self;
        _S { id, code, message }.serialize(serializer)
    }
}
#[doc = "A pending safety check for the computer call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerCallSafetyCheckParam {
    #[doc = "The ID of the pending safety check."]
    pub id: String,
    #[doc = "The type of the pending safety check."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "Details about the pending safety check."]
    #[builder(default)]
    pub message: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ComputerCallOutputItemParamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] ComputerCallOutputItemParamStatusInProgress),
            Completed(#[allow(dead_code)] ComputerCallOutputItemParamStatusCompleted),
            Incomplete(#[allow(dead_code)] ComputerCallOutputItemParamStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for ComputerCallOutputItemParamStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a ComputerCallOutputItemParamStatusInProgress),
            Completed(#[allow(dead_code)] &'a ComputerCallOutputItemParamStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a ComputerCallOutputItemParamStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the message input. One of `in_progress`, `completed`, or `incomplete`. Populated when input items are returned via API."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerCallOutputItemParamStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ComputerCallOutputItemParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the computer tool call output. Always `computer_call_output`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamType {
            #[default]
            #[serde(rename = "computer_call_output")]
            ComputerCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerCallOutputItemParamType,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: ComputerScreenshotImage,
            #[serde(rename = "acknowledged_safety_checks")]
            #[allow(dead_code)]
            acknowledged_safety_checks: Option<Vec<ComputerCallSafetyCheckParam>>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<ComputerCallOutputItemParamStatus>,
        }
        let _D {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(ComputerCallOutputItemParam {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
        })
    }
}
impl serde::Serialize for ComputerCallOutputItemParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the computer tool call output. Always `computer_call_output`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamType {
            #[default]
            #[serde(rename = "computer_call_output")]
            ComputerCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a ComputerCallOutputItemParamType,
            #[serde(rename = "output")]
            output: &'a ComputerScreenshotImage,
            #[serde(rename = "acknowledged_safety_checks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            acknowledged_safety_checks: &'a Option<Vec<ComputerCallSafetyCheckParam>>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<ComputerCallOutputItemParamStatus>,
        }
        let ComputerCallOutputItemParam {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
        } = self;
        _S {
            id,
            call_id,
            type_: &Default::default(),
            output,
            acknowledged_safety_checks,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a computer tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerCallOutputItemParam {
    #[doc = "The ID of the computer tool call output."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The ID of the computer tool call that produced the output."]
    pub call_id: String,
    #[builder(default)]
    pub output: ComputerScreenshotImage,
    #[doc = "The safety checks reported by the API that have been acknowledged by the developer."]
    #[builder(default)]
    pub acknowledged_safety_checks: Option<Vec<ComputerCallSafetyCheckParam>>,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or `incomplete`. Populated when input items are returned via API."]
    #[builder(default)]
    pub status: Option<ComputerCallOutputItemParamStatus>,
}
impl<'de> serde::Deserialize<'de> for FunctionCallOutputItemParamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            InProgress(#[allow(dead_code)] FunctionCallOutputItemParamStatusInProgress),
            Completed(#[allow(dead_code)] FunctionCallOutputItemParamStatusCompleted),
            Incomplete(#[allow(dead_code)] FunctionCallOutputItemParamStatusIncomplete),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::InProgress(_) => Self::InProgress,
            _D::Completed(_) => Self::Completed,
            _D::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for FunctionCallOutputItemParamStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            InProgress(#[allow(dead_code)] &'a FunctionCallOutputItemParamStatusInProgress),
            Completed(#[allow(dead_code)] &'a FunctionCallOutputItemParamStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a FunctionCallOutputItemParamStatusIncomplete),
        }
        match self {
            Self::InProgress => _S::InProgress(&Default::default()).serialize(serializer),
            Self::Completed => _S::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => _S::Incomplete(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`. Populated when items are returned via API."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FunctionCallOutputItemParamStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for FunctionCallOutputItemParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the function tool call output. Always `function_call_output`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamType {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FunctionCallOutputItemParamType,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<FunctionCallOutputItemParamStatus>,
        }
        let _D {
            id,
            call_id,
            output,
            status,
            ..
        } = _D::deserialize(deserializer)?;
        Ok(FunctionCallOutputItemParam {
            id,
            call_id,
            output,
            status,
        })
    }
}
impl serde::Serialize for FunctionCallOutputItemParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the function tool call output. Always `function_call_output`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamType {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a FunctionCallOutputItemParamType,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<FunctionCallOutputItemParamStatus>,
        }
        let FunctionCallOutputItemParam {
            id,
            call_id,
            output,
            status,
        } = self;
        _S {
            id,
            call_id,
            type_: &Default::default(),
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a function tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionCallOutputItemParam {
    #[doc = "The unique ID of the function tool call output. Populated when this item is returned via API."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model."]
    pub call_id: String,
    #[doc = "A JSON string of the output of the function tool call."]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`. Populated when items are returned via API."]
    #[builder(default)]
    pub status: Option<FunctionCallOutputItemParamStatus>,
}
impl<'de> serde::Deserialize<'de> for ItemReferenceParamType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ItemReferenceParamTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum _D {
            ItemReference(#[allow(dead_code)] ItemReferenceParamTypeItemReference),
        }
        Ok(match _D::deserialize(deserializer)? {
            _D::ItemReference(_) => Self::ItemReference,
        })
    }
}
impl serde::Serialize for ItemReferenceParamType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ItemReferenceParamTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum _S<'a> {
            ItemReference(#[allow(dead_code)] &'a ItemReferenceParamTypeItemReference),
        }
        match self {
            Self::ItemReference => _S::ItemReference(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of item to reference. Always `item_reference`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ItemReferenceParamType {
    #[doc = "item_reference"]
    #[default]
    ItemReference,
}
impl<'de> serde::Deserialize<'de> for ItemReferenceParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct _D {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<ItemReferenceParamType>,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let _D { type_, id, .. } = _D::deserialize(deserializer)?;
        Ok(ItemReferenceParam { type_, id })
    }
}
impl serde::Serialize for ItemReferenceParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct _S<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<ItemReferenceParamType>,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let ItemReferenceParam { type_, id } = self;
        _S { type_, id }.serialize(serializer)
    }
}
#[doc = "An internal identifier for an item to reference."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ItemReferenceParam {
    #[doc = "The type of item to reference. Always `item_reference`."]
    #[builder(default)]
    pub type_: Option<ItemReferenceParamType>,
    #[doc = "The ID of the item to reference."]
    pub id: String,
}
#[cfg(test)]
mod tests;
