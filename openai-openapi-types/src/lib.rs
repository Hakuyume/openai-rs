impl<'de> serde::Deserialize<'de> for AddUploadPartRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AddUploadPartRequest {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<u8>,
        }
        let AddUploadPartRequest { data, .. } = AddUploadPartRequest::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for AddUploadPartRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AddUploadPartRequest<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "data")]
            data: &'a Vec<u8>,
        }
        let Self { data } = self;
        AddUploadPartRequest { data }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AddUploadPartRequest {
    #[doc = "The chunk of bytes for this Part.\n"]
    pub data: Vec<u8>,
}
impl<'de> serde::Deserialize<'de> for AdminApiKeyOwner {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AdminApiKeyOwner {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<String>,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: Option<u64>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let AdminApiKeyOwner {
            type_,
            object,
            id,
            name,
            created_at,
            role,
            ..
        } = AdminApiKeyOwner::deserialize(deserializer)?;
        Ok(Self {
            type_,
            object,
            id,
            name,
            created_at,
            role,
        })
    }
}
impl serde::Serialize for AdminApiKeyOwner {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AdminApiKeyOwner<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<String>,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "created_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_at: &'a Option<u64>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let Self {
            type_,
            object,
            id,
            name,
            created_at,
            role,
        } = self;
        AdminApiKeyOwner {
            type_,
            object,
            id,
            name,
            created_at,
            role,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AdminApiKeyOwner {
    #[doc = "Always `user`"]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "The object type, which is always organization.user"]
    #[builder(default)]
    pub object: Option<String>,
    #[doc = "The identifier, which can be referenced in API endpoints"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the user"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The Unix timestamp (in seconds) of when the user was created"]
    #[builder(default)]
    pub created_at: Option<u64>,
    #[doc = "Always `owner`"]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AdminApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.admin_api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AdminApiKeyObject {
            #[default]
            #[serde(rename = "organization.admin_api_key")]
            OrganizationAdminApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AdminApiKey {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: AdminApiKeyObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "redacted_value")]
            #[allow(dead_code)]
            redacted_value: String,
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: Option<String>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "last_used_at")]
            #[allow(dead_code)]
            last_used_at: Option<u64>,
            #[serde(rename = "owner")]
            #[allow(dead_code)]
            owner: AdminApiKeyOwner,
        }
        let AdminApiKey {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
            ..
        } = AdminApiKey::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        })
    }
}
impl serde::Serialize for AdminApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.admin_api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AdminApiKeyObject {
            #[default]
            #[serde(rename = "organization.admin_api_key")]
            OrganizationAdminApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AdminApiKey<'a> {
            #[serde(rename = "object")]
            object: &'a AdminApiKeyObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "redacted_value")]
            redacted_value: &'a String,
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            value: &'a Option<String>,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "last_used_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_used_at: &'a Option<u64>,
            #[serde(rename = "owner")]
            owner: &'a AdminApiKeyOwner,
        }
        let Self {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        } = self;
        AdminApiKey {
            object: &Default::default(),
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual Admin API key in an org."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AdminApiKey {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the API key"]
    pub name: String,
    #[doc = "The redacted value of the API key"]
    pub redacted_value: String,
    #[doc = "The value of the API key. Only shown on create."]
    #[builder(default)]
    pub value: Option<String>,
    #[doc = "The Unix timestamp (in seconds) of when the API key was created"]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the API key was last used"]
    #[builder(default)]
    pub last_used_at: Option<u64>,
    #[builder(default)]
    pub owner: AdminApiKeyOwner,
}
impl<'de> serde::Deserialize<'de> for ApiKeyList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ApiKeyList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<Vec<AdminApiKey>>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: Option<bool>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
        }
        let ApiKeyList {
            object,
            data,
            has_more,
            first_id,
            last_id,
            ..
        } = ApiKeyList::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            has_more,
            first_id,
            last_id,
        })
    }
}
impl serde::Serialize for ApiKeyList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ApiKeyList<'a> {
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<Vec<AdminApiKey>>,
            #[serde(rename = "has_more")]
            #[serde(skip_serializing_if = "Option::is_none")]
            has_more: &'a Option<bool>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
        }
        let Self {
            object,
            data,
            has_more,
            first_id,
            last_id,
        } = self;
        ApiKeyList {
            object,
            data,
            has_more,
            first_id,
            last_id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ApiKeyList {
    #[builder(default)]
    pub object: Option<String>,
    #[builder(default)]
    pub data: Option<Vec<AdminApiKey>>,
    #[builder(default)]
    pub has_more: Option<bool>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AssistantObjectToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantObjectToolResourcesCodeInterpreter {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let AssistantObjectToolResourcesCodeInterpreter { file_ids, .. } =
            AssistantObjectToolResourcesCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for AssistantObjectToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantObjectToolResourcesCodeInterpreter<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        AssistantObjectToolResourcesCodeInterpreter { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AssistantObjectToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for AssistantObjectToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantObjectToolResourcesFileSearch {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let AssistantObjectToolResourcesFileSearch {
            vector_store_ids, ..
        } = AssistantObjectToolResourcesFileSearch::deserialize(deserializer)?;
        Ok(Self { vector_store_ids })
    }
}
impl serde::Serialize for AssistantObjectToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantObjectToolResourcesFileSearch<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let Self { vector_store_ids } = self;
        AssistantObjectToolResourcesFileSearch { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AssistantObjectToolResourcesFileSearch {
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for AssistantObjectToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantObjectToolResources {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<AssistantObjectToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<AssistantObjectToolResourcesFileSearch>,
        }
        let AssistantObjectToolResources {
            code_interpreter,
            file_search,
            ..
        } = AssistantObjectToolResources::deserialize(deserializer)?;
        Ok(Self {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for AssistantObjectToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantObjectToolResources<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<AssistantObjectToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<AssistantObjectToolResourcesFileSearch>,
        }
        let Self {
            code_interpreter,
            file_search,
        } = self;
        AssistantObjectToolResources {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AssistantObjectToolResources {
    #[builder(default)]
    pub code_interpreter: Option<AssistantObjectToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<AssistantObjectToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for AssistantObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `assistant`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantObjectObject {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: AssistantObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Vec<AssistantTool>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<AssistantObjectToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let AssistantObject {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
            ..
        } = AssistantObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        })
    }
}
impl serde::Serialize for AssistantObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `assistant`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantObjectObject {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a AssistantObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "tools")]
            tools: &'a Vec<AssistantTool>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<AssistantObjectToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let Self {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        } = self;
        AssistantObject {
            id,
            object: &Default::default(),
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an `assistant` that can call the model and use tools."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the assistant was created."]
    pub created_at: u64,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    pub tools: Vec<AssistantTool>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<AssistantObjectToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for AssistantStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AssistantStreamEvent {
            ThreadStreamEvent(#[allow(dead_code)] ThreadStreamEvent),
            RunStreamEvent(#[allow(dead_code)] RunStreamEvent),
            RunStepStreamEvent(#[allow(dead_code)] RunStepStreamEvent),
            MessageStreamEvent(#[allow(dead_code)] MessageStreamEvent),
            ErrorEvent(#[allow(dead_code)] ErrorEvent),
        }
        Ok(match AssistantStreamEvent::deserialize(deserializer)? {
            AssistantStreamEvent::ThreadStreamEvent(_v) => Self::ThreadStreamEvent(_v),
            AssistantStreamEvent::RunStreamEvent(_v) => Self::RunStreamEvent(_v),
            AssistantStreamEvent::RunStepStreamEvent(_v) => Self::RunStepStreamEvent(_v),
            AssistantStreamEvent::MessageStreamEvent(_v) => Self::MessageStreamEvent(_v),
            AssistantStreamEvent::ErrorEvent(_v) => Self::ErrorEvent(_v),
        })
    }
}
impl serde::Serialize for AssistantStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AssistantStreamEvent<'a> {
            ThreadStreamEvent(#[allow(dead_code)] &'a ThreadStreamEvent),
            RunStreamEvent(#[allow(dead_code)] &'a RunStreamEvent),
            RunStepStreamEvent(#[allow(dead_code)] &'a RunStepStreamEvent),
            MessageStreamEvent(#[allow(dead_code)] &'a MessageStreamEvent),
            ErrorEvent(#[allow(dead_code)] &'a ErrorEvent),
        }
        match self {
            Self::ThreadStreamEvent(_v) => {
                AssistantStreamEvent::ThreadStreamEvent(_v).serialize(serializer)
            }
            Self::RunStreamEvent(_v) => {
                AssistantStreamEvent::RunStreamEvent(_v).serialize(serializer)
            }
            Self::RunStepStreamEvent(_v) => {
                AssistantStreamEvent::RunStepStreamEvent(_v).serialize(serializer)
            }
            Self::MessageStreamEvent(_v) => {
                AssistantStreamEvent::MessageStreamEvent(_v).serialize(serializer)
            }
            Self::ErrorEvent(_v) => AssistantStreamEvent::ErrorEvent(_v).serialize(serializer),
        }
    }
}
#[doc = "Represents an event emitted when streaming a Run.\n\nEach event in a server-sent events stream has an `event` and `data` property:\n\n```\nevent: thread.created\ndata: {\"id\": \"thread_123\", \"object\": \"thread\", ...}\n```\n\nWe emit events whenever a new object is created, transitions to a new state, or is being\nstreamed in parts (deltas). For example, we emit `thread.run.created` when a new run\nis created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses\nto create a message during a run, we emit a `thread.message.created event`, a\n`thread.message.in_progress` event, many `thread.message.delta` events, and finally a\n`thread.message.completed` event.\n\nWe may add additional events over time, so we recommend handling unknown events gracefully\nin your code. See the [Assistants API quickstart](https://platform.openai.com/docs/assistants/overview) to learn how to\nintegrate the Assistants API with streaming.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantStreamEvent {
    ThreadStreamEvent(ThreadStreamEvent),
    RunStreamEvent(RunStreamEvent),
    RunStepStreamEvent(RunStepStreamEvent),
    MessageStreamEvent(MessageStreamEvent),
    ErrorEvent(ErrorEvent),
}
impl<'de> serde::Deserialize<'de> for AssistantSupportedModels {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1 {
            #[default]
            #[serde(rename = "gpt-4.1")]
            Gpt4_1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Mini {
            #[default]
            #[serde(rename = "gpt-4.1-mini")]
            Gpt4_1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Nano {
            #[default]
            #[serde(rename = "gpt-4.1-nano")]
            Gpt4_1Nano,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1_2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-2025-04-14")]
            Gpt4_1_2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Mini2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-mini-2025-04-14")]
            Gpt4_1Mini2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Nano2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-nano-2025-04-14")]
            Gpt4_1Nano2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO3Mini {
            #[default]
            #[serde(rename = "o3-mini")]
            O3Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO3Mini2025_01_31 {
            #[default]
            #[serde(rename = "o3-mini-2025-01-31")]
            O3Mini2025_01_31,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO1 {
            #[default]
            #[serde(rename = "o1")]
            O1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO1_2024_12_17 {
            #[default]
            #[serde(rename = "o1-2024-12-17")]
            O1_2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o {
            #[default]
            #[serde(rename = "gpt-4o")]
            Gpt4o,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_11_20 {
            #[default]
            #[serde(rename = "gpt-4o-2024-11-20")]
            Gpt4o2024_11_20,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_08_06 {
            #[default]
            #[serde(rename = "gpt-4o-2024-08-06")]
            Gpt4o2024_08_06,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_05_13 {
            #[default]
            #[serde(rename = "gpt-4o-2024-05-13")]
            Gpt4o2024_05_13,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4oMini {
            #[default]
            #[serde(rename = "gpt-4o-mini")]
            Gpt4oMini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4oMini2024_07_18 {
            #[default]
            #[serde(rename = "gpt-4o-mini-2024-07-18")]
            Gpt4oMini2024_07_18,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_5Preview {
            #[default]
            #[serde(rename = "gpt-4.5-preview")]
            Gpt4_5Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_5Preview2025_02_27 {
            #[default]
            #[serde(rename = "gpt-4.5-preview-2025-02-27")]
            Gpt4_5Preview2025_02_27,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4Turbo {
            #[default]
            #[serde(rename = "gpt-4-turbo")]
            Gpt4Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4Turbo2024_04_09 {
            #[default]
            #[serde(rename = "gpt-4-turbo-2024-04-09")]
            Gpt4Turbo2024_04_09,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0125Preview {
            #[default]
            #[serde(rename = "gpt-4-0125-preview")]
            Gpt4_0125Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4TurboPreview {
            #[default]
            #[serde(rename = "gpt-4-turbo-preview")]
            Gpt4TurboPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1106Preview {
            #[default]
            #[serde(rename = "gpt-4-1106-preview")]
            Gpt4_1106Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4VisionPreview {
            #[default]
            #[serde(rename = "gpt-4-vision-preview")]
            Gpt4VisionPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4 {
            #[default]
            #[serde(rename = "gpt-4")]
            Gpt4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0314 {
            #[default]
            #[serde(rename = "gpt-4-0314")]
            Gpt4_0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0613 {
            #[default]
            #[serde(rename = "gpt-4-0613")]
            Gpt4_0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k {
            #[default]
            #[serde(rename = "gpt-4-32k")]
            Gpt4_32k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k0314 {
            #[default]
            #[serde(rename = "gpt-4-32k-0314")]
            Gpt4_32k0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k0613 {
            #[default]
            #[serde(rename = "gpt-4-32k-0613")]
            Gpt4_32k0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo {
            #[default]
            #[serde(rename = "gpt-3.5-turbo")]
            Gpt3_5Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo16k {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k")]
            Gpt3_5Turbo16k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0613")]
            Gpt3_5Turbo0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo1106 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-1106")]
            Gpt3_5Turbo1106,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo0125 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0125")]
            Gpt3_5Turbo0125,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo16k0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k-0613")]
            Gpt3_5Turbo16k0613,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AssistantSupportedModels {
            Gpt4_1(#[allow(dead_code)] AssistantSupportedModelsGpt4_1),
            Gpt4_1Mini(#[allow(dead_code)] AssistantSupportedModelsGpt4_1Mini),
            Gpt4_1Nano(#[allow(dead_code)] AssistantSupportedModelsGpt4_1Nano),
            Gpt4_1_2025_04_14(#[allow(dead_code)] AssistantSupportedModelsGpt4_1_2025_04_14),
            Gpt4_1Mini2025_04_14(#[allow(dead_code)] AssistantSupportedModelsGpt4_1Mini2025_04_14),
            Gpt4_1Nano2025_04_14(#[allow(dead_code)] AssistantSupportedModelsGpt4_1Nano2025_04_14),
            O3Mini(#[allow(dead_code)] AssistantSupportedModelsO3Mini),
            O3Mini2025_01_31(#[allow(dead_code)] AssistantSupportedModelsO3Mini2025_01_31),
            O1(#[allow(dead_code)] AssistantSupportedModelsO1),
            O1_2024_12_17(#[allow(dead_code)] AssistantSupportedModelsO1_2024_12_17),
            Gpt4o(#[allow(dead_code)] AssistantSupportedModelsGpt4o),
            Gpt4o2024_11_20(#[allow(dead_code)] AssistantSupportedModelsGpt4o2024_11_20),
            Gpt4o2024_08_06(#[allow(dead_code)] AssistantSupportedModelsGpt4o2024_08_06),
            Gpt4o2024_05_13(#[allow(dead_code)] AssistantSupportedModelsGpt4o2024_05_13),
            Gpt4oMini(#[allow(dead_code)] AssistantSupportedModelsGpt4oMini),
            Gpt4oMini2024_07_18(#[allow(dead_code)] AssistantSupportedModelsGpt4oMini2024_07_18),
            Gpt4_5Preview(#[allow(dead_code)] AssistantSupportedModelsGpt4_5Preview),
            Gpt4_5Preview2025_02_27(
                #[allow(dead_code)] AssistantSupportedModelsGpt4_5Preview2025_02_27,
            ),
            Gpt4Turbo(#[allow(dead_code)] AssistantSupportedModelsGpt4Turbo),
            Gpt4Turbo2024_04_09(#[allow(dead_code)] AssistantSupportedModelsGpt4Turbo2024_04_09),
            Gpt4_0125Preview(#[allow(dead_code)] AssistantSupportedModelsGpt4_0125Preview),
            Gpt4TurboPreview(#[allow(dead_code)] AssistantSupportedModelsGpt4TurboPreview),
            Gpt4_1106Preview(#[allow(dead_code)] AssistantSupportedModelsGpt4_1106Preview),
            Gpt4VisionPreview(#[allow(dead_code)] AssistantSupportedModelsGpt4VisionPreview),
            Gpt4(#[allow(dead_code)] AssistantSupportedModelsGpt4),
            Gpt4_0314(#[allow(dead_code)] AssistantSupportedModelsGpt4_0314),
            Gpt4_0613(#[allow(dead_code)] AssistantSupportedModelsGpt4_0613),
            Gpt4_32k(#[allow(dead_code)] AssistantSupportedModelsGpt4_32k),
            Gpt4_32k0314(#[allow(dead_code)] AssistantSupportedModelsGpt4_32k0314),
            Gpt4_32k0613(#[allow(dead_code)] AssistantSupportedModelsGpt4_32k0613),
            Gpt3_5Turbo(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo),
            Gpt3_5Turbo16k(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo16k),
            Gpt3_5Turbo0613(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo0613),
            Gpt3_5Turbo1106(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo1106),
            Gpt3_5Turbo0125(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo0125),
            Gpt3_5Turbo16k0613(#[allow(dead_code)] AssistantSupportedModelsGpt3_5Turbo16k0613),
        }
        Ok(match AssistantSupportedModels::deserialize(deserializer)? {
            AssistantSupportedModels::Gpt4_1(_) => Self::Gpt4_1,
            AssistantSupportedModels::Gpt4_1Mini(_) => Self::Gpt4_1Mini,
            AssistantSupportedModels::Gpt4_1Nano(_) => Self::Gpt4_1Nano,
            AssistantSupportedModels::Gpt4_1_2025_04_14(_) => Self::Gpt4_1_2025_04_14,
            AssistantSupportedModels::Gpt4_1Mini2025_04_14(_) => Self::Gpt4_1Mini2025_04_14,
            AssistantSupportedModels::Gpt4_1Nano2025_04_14(_) => Self::Gpt4_1Nano2025_04_14,
            AssistantSupportedModels::O3Mini(_) => Self::O3Mini,
            AssistantSupportedModels::O3Mini2025_01_31(_) => Self::O3Mini2025_01_31,
            AssistantSupportedModels::O1(_) => Self::O1,
            AssistantSupportedModels::O1_2024_12_17(_) => Self::O1_2024_12_17,
            AssistantSupportedModels::Gpt4o(_) => Self::Gpt4o,
            AssistantSupportedModels::Gpt4o2024_11_20(_) => Self::Gpt4o2024_11_20,
            AssistantSupportedModels::Gpt4o2024_08_06(_) => Self::Gpt4o2024_08_06,
            AssistantSupportedModels::Gpt4o2024_05_13(_) => Self::Gpt4o2024_05_13,
            AssistantSupportedModels::Gpt4oMini(_) => Self::Gpt4oMini,
            AssistantSupportedModels::Gpt4oMini2024_07_18(_) => Self::Gpt4oMini2024_07_18,
            AssistantSupportedModels::Gpt4_5Preview(_) => Self::Gpt4_5Preview,
            AssistantSupportedModels::Gpt4_5Preview2025_02_27(_) => Self::Gpt4_5Preview2025_02_27,
            AssistantSupportedModels::Gpt4Turbo(_) => Self::Gpt4Turbo,
            AssistantSupportedModels::Gpt4Turbo2024_04_09(_) => Self::Gpt4Turbo2024_04_09,
            AssistantSupportedModels::Gpt4_0125Preview(_) => Self::Gpt4_0125Preview,
            AssistantSupportedModels::Gpt4TurboPreview(_) => Self::Gpt4TurboPreview,
            AssistantSupportedModels::Gpt4_1106Preview(_) => Self::Gpt4_1106Preview,
            AssistantSupportedModels::Gpt4VisionPreview(_) => Self::Gpt4VisionPreview,
            AssistantSupportedModels::Gpt4(_) => Self::Gpt4,
            AssistantSupportedModels::Gpt4_0314(_) => Self::Gpt4_0314,
            AssistantSupportedModels::Gpt4_0613(_) => Self::Gpt4_0613,
            AssistantSupportedModels::Gpt4_32k(_) => Self::Gpt4_32k,
            AssistantSupportedModels::Gpt4_32k0314(_) => Self::Gpt4_32k0314,
            AssistantSupportedModels::Gpt4_32k0613(_) => Self::Gpt4_32k0613,
            AssistantSupportedModels::Gpt3_5Turbo(_) => Self::Gpt3_5Turbo,
            AssistantSupportedModels::Gpt3_5Turbo16k(_) => Self::Gpt3_5Turbo16k,
            AssistantSupportedModels::Gpt3_5Turbo0613(_) => Self::Gpt3_5Turbo0613,
            AssistantSupportedModels::Gpt3_5Turbo1106(_) => Self::Gpt3_5Turbo1106,
            AssistantSupportedModels::Gpt3_5Turbo0125(_) => Self::Gpt3_5Turbo0125,
            AssistantSupportedModels::Gpt3_5Turbo16k0613(_) => Self::Gpt3_5Turbo16k0613,
        })
    }
}
impl serde::Serialize for AssistantSupportedModels {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1 {
            #[default]
            #[serde(rename = "gpt-4.1")]
            Gpt4_1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Mini {
            #[default]
            #[serde(rename = "gpt-4.1-mini")]
            Gpt4_1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Nano {
            #[default]
            #[serde(rename = "gpt-4.1-nano")]
            Gpt4_1Nano,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1_2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-2025-04-14")]
            Gpt4_1_2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Mini2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-mini-2025-04-14")]
            Gpt4_1Mini2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1Nano2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-nano-2025-04-14")]
            Gpt4_1Nano2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO3Mini {
            #[default]
            #[serde(rename = "o3-mini")]
            O3Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO3Mini2025_01_31 {
            #[default]
            #[serde(rename = "o3-mini-2025-01-31")]
            O3Mini2025_01_31,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO1 {
            #[default]
            #[serde(rename = "o1")]
            O1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsO1_2024_12_17 {
            #[default]
            #[serde(rename = "o1-2024-12-17")]
            O1_2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o {
            #[default]
            #[serde(rename = "gpt-4o")]
            Gpt4o,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_11_20 {
            #[default]
            #[serde(rename = "gpt-4o-2024-11-20")]
            Gpt4o2024_11_20,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_08_06 {
            #[default]
            #[serde(rename = "gpt-4o-2024-08-06")]
            Gpt4o2024_08_06,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4o2024_05_13 {
            #[default]
            #[serde(rename = "gpt-4o-2024-05-13")]
            Gpt4o2024_05_13,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4oMini {
            #[default]
            #[serde(rename = "gpt-4o-mini")]
            Gpt4oMini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4oMini2024_07_18 {
            #[default]
            #[serde(rename = "gpt-4o-mini-2024-07-18")]
            Gpt4oMini2024_07_18,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_5Preview {
            #[default]
            #[serde(rename = "gpt-4.5-preview")]
            Gpt4_5Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_5Preview2025_02_27 {
            #[default]
            #[serde(rename = "gpt-4.5-preview-2025-02-27")]
            Gpt4_5Preview2025_02_27,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4Turbo {
            #[default]
            #[serde(rename = "gpt-4-turbo")]
            Gpt4Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4Turbo2024_04_09 {
            #[default]
            #[serde(rename = "gpt-4-turbo-2024-04-09")]
            Gpt4Turbo2024_04_09,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0125Preview {
            #[default]
            #[serde(rename = "gpt-4-0125-preview")]
            Gpt4_0125Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4TurboPreview {
            #[default]
            #[serde(rename = "gpt-4-turbo-preview")]
            Gpt4TurboPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_1106Preview {
            #[default]
            #[serde(rename = "gpt-4-1106-preview")]
            Gpt4_1106Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4VisionPreview {
            #[default]
            #[serde(rename = "gpt-4-vision-preview")]
            Gpt4VisionPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4 {
            #[default]
            #[serde(rename = "gpt-4")]
            Gpt4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0314 {
            #[default]
            #[serde(rename = "gpt-4-0314")]
            Gpt4_0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_0613 {
            #[default]
            #[serde(rename = "gpt-4-0613")]
            Gpt4_0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k {
            #[default]
            #[serde(rename = "gpt-4-32k")]
            Gpt4_32k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k0314 {
            #[default]
            #[serde(rename = "gpt-4-32k-0314")]
            Gpt4_32k0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt4_32k0613 {
            #[default]
            #[serde(rename = "gpt-4-32k-0613")]
            Gpt4_32k0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo {
            #[default]
            #[serde(rename = "gpt-3.5-turbo")]
            Gpt3_5Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo16k {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k")]
            Gpt3_5Turbo16k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0613")]
            Gpt3_5Turbo0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo1106 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-1106")]
            Gpt3_5Turbo1106,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo0125 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0125")]
            Gpt3_5Turbo0125,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantSupportedModelsGpt3_5Turbo16k0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k-0613")]
            Gpt3_5Turbo16k0613,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AssistantSupportedModels<'a> {
            Gpt4_1(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1),
            Gpt4_1Mini(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1Mini),
            Gpt4_1Nano(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1Nano),
            Gpt4_1_2025_04_14(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1_2025_04_14),
            Gpt4_1Mini2025_04_14(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1Mini2025_04_14,
            ),
            Gpt4_1Nano2025_04_14(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1Nano2025_04_14,
            ),
            O3Mini(#[allow(dead_code)] &'a AssistantSupportedModelsO3Mini),
            O3Mini2025_01_31(#[allow(dead_code)] &'a AssistantSupportedModelsO3Mini2025_01_31),
            O1(#[allow(dead_code)] &'a AssistantSupportedModelsO1),
            O1_2024_12_17(#[allow(dead_code)] &'a AssistantSupportedModelsO1_2024_12_17),
            Gpt4o(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4o),
            Gpt4o2024_11_20(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4o2024_11_20),
            Gpt4o2024_08_06(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4o2024_08_06),
            Gpt4o2024_05_13(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4o2024_05_13),
            Gpt4oMini(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4oMini),
            Gpt4oMini2024_07_18(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4oMini2024_07_18,
            ),
            Gpt4_5Preview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_5Preview),
            Gpt4_5Preview2025_02_27(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4_5Preview2025_02_27,
            ),
            Gpt4Turbo(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4Turbo),
            Gpt4Turbo2024_04_09(
                #[allow(dead_code)] &'a AssistantSupportedModelsGpt4Turbo2024_04_09,
            ),
            Gpt4_0125Preview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_0125Preview),
            Gpt4TurboPreview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4TurboPreview),
            Gpt4_1106Preview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_1106Preview),
            Gpt4VisionPreview(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4VisionPreview),
            Gpt4(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4),
            Gpt4_0314(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_0314),
            Gpt4_0613(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_0613),
            Gpt4_32k(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_32k),
            Gpt4_32k0314(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_32k0314),
            Gpt4_32k0613(#[allow(dead_code)] &'a AssistantSupportedModelsGpt4_32k0613),
            Gpt3_5Turbo(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo),
            Gpt3_5Turbo16k(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo16k),
            Gpt3_5Turbo0613(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo0613),
            Gpt3_5Turbo1106(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo1106),
            Gpt3_5Turbo0125(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo0125),
            Gpt3_5Turbo16k0613(#[allow(dead_code)] &'a AssistantSupportedModelsGpt3_5Turbo16k0613),
        }
        match self {
            Self::Gpt4_1 => {
                AssistantSupportedModels::Gpt4_1(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1Mini => {
                AssistantSupportedModels::Gpt4_1Mini(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1Nano => {
                AssistantSupportedModels::Gpt4_1Nano(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1_2025_04_14 => {
                AssistantSupportedModels::Gpt4_1_2025_04_14(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4_1Mini2025_04_14 => {
                AssistantSupportedModels::Gpt4_1Mini2025_04_14(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4_1Nano2025_04_14 => {
                AssistantSupportedModels::Gpt4_1Nano2025_04_14(&Default::default())
                    .serialize(serializer)
            }
            Self::O3Mini => {
                AssistantSupportedModels::O3Mini(&Default::default()).serialize(serializer)
            }
            Self::O3Mini2025_01_31 => {
                AssistantSupportedModels::O3Mini2025_01_31(&Default::default())
                    .serialize(serializer)
            }
            Self::O1 => AssistantSupportedModels::O1(&Default::default()).serialize(serializer),
            Self::O1_2024_12_17 => {
                AssistantSupportedModels::O1_2024_12_17(&Default::default()).serialize(serializer)
            }
            Self::Gpt4o => {
                AssistantSupportedModels::Gpt4o(&Default::default()).serialize(serializer)
            }
            Self::Gpt4o2024_11_20 => {
                AssistantSupportedModels::Gpt4o2024_11_20(&Default::default()).serialize(serializer)
            }
            Self::Gpt4o2024_08_06 => {
                AssistantSupportedModels::Gpt4o2024_08_06(&Default::default()).serialize(serializer)
            }
            Self::Gpt4o2024_05_13 => {
                AssistantSupportedModels::Gpt4o2024_05_13(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMini => {
                AssistantSupportedModels::Gpt4oMini(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMini2024_07_18 => {
                AssistantSupportedModels::Gpt4oMini2024_07_18(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4_5Preview => {
                AssistantSupportedModels::Gpt4_5Preview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_5Preview2025_02_27 => {
                AssistantSupportedModels::Gpt4_5Preview2025_02_27(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4Turbo => {
                AssistantSupportedModels::Gpt4Turbo(&Default::default()).serialize(serializer)
            }
            Self::Gpt4Turbo2024_04_09 => {
                AssistantSupportedModels::Gpt4Turbo2024_04_09(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4_0125Preview => {
                AssistantSupportedModels::Gpt4_0125Preview(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4TurboPreview => {
                AssistantSupportedModels::Gpt4TurboPreview(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4_1106Preview => {
                AssistantSupportedModels::Gpt4_1106Preview(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4VisionPreview => {
                AssistantSupportedModels::Gpt4VisionPreview(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4 => AssistantSupportedModels::Gpt4(&Default::default()).serialize(serializer),
            Self::Gpt4_0314 => {
                AssistantSupportedModels::Gpt4_0314(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_0613 => {
                AssistantSupportedModels::Gpt4_0613(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_32k => {
                AssistantSupportedModels::Gpt4_32k(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_32k0314 => {
                AssistantSupportedModels::Gpt4_32k0314(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_32k0613 => {
                AssistantSupportedModels::Gpt4_32k0613(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo => {
                AssistantSupportedModels::Gpt3_5Turbo(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo16k => {
                AssistantSupportedModels::Gpt3_5Turbo16k(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo0613 => {
                AssistantSupportedModels::Gpt3_5Turbo0613(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo1106 => {
                AssistantSupportedModels::Gpt3_5Turbo1106(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo0125 => {
                AssistantSupportedModels::Gpt3_5Turbo0125(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo16k0613 => {
                AssistantSupportedModels::Gpt3_5Turbo16k0613(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantSupportedModels {
    #[doc = "gpt-4.1"]
    Gpt4_1,
    #[doc = "gpt-4.1-mini"]
    Gpt4_1Mini,
    #[doc = "gpt-4.1-nano"]
    Gpt4_1Nano,
    #[doc = "gpt-4.1-2025-04-14"]
    Gpt4_1_2025_04_14,
    #[doc = "gpt-4.1-mini-2025-04-14"]
    Gpt4_1Mini2025_04_14,
    #[doc = "gpt-4.1-nano-2025-04-14"]
    Gpt4_1Nano2025_04_14,
    #[doc = "o3-mini"]
    O3Mini,
    #[doc = "o3-mini-2025-01-31"]
    O3Mini2025_01_31,
    #[doc = "o1"]
    O1,
    #[doc = "o1-2024-12-17"]
    O1_2024_12_17,
    #[doc = "gpt-4o"]
    Gpt4o,
    #[doc = "gpt-4o-2024-11-20"]
    Gpt4o2024_11_20,
    #[doc = "gpt-4o-2024-08-06"]
    Gpt4o2024_08_06,
    #[doc = "gpt-4o-2024-05-13"]
    Gpt4o2024_05_13,
    #[doc = "gpt-4o-mini"]
    Gpt4oMini,
    #[doc = "gpt-4o-mini-2024-07-18"]
    Gpt4oMini2024_07_18,
    #[doc = "gpt-4.5-preview"]
    Gpt4_5Preview,
    #[doc = "gpt-4.5-preview-2025-02-27"]
    Gpt4_5Preview2025_02_27,
    #[doc = "gpt-4-turbo"]
    Gpt4Turbo,
    #[doc = "gpt-4-turbo-2024-04-09"]
    Gpt4Turbo2024_04_09,
    #[doc = "gpt-4-0125-preview"]
    Gpt4_0125Preview,
    #[doc = "gpt-4-turbo-preview"]
    Gpt4TurboPreview,
    #[doc = "gpt-4-1106-preview"]
    Gpt4_1106Preview,
    #[doc = "gpt-4-vision-preview"]
    Gpt4VisionPreview,
    #[doc = "gpt-4"]
    Gpt4,
    #[doc = "gpt-4-0314"]
    Gpt4_0314,
    #[doc = "gpt-4-0613"]
    Gpt4_0613,
    #[doc = "gpt-4-32k"]
    Gpt4_32k,
    #[doc = "gpt-4-32k-0314"]
    Gpt4_32k0314,
    #[doc = "gpt-4-32k-0613"]
    Gpt4_32k0613,
    #[doc = "gpt-3.5-turbo"]
    Gpt3_5Turbo,
    #[doc = "gpt-3.5-turbo-16k"]
    Gpt3_5Turbo16k,
    #[doc = "gpt-3.5-turbo-0613"]
    Gpt3_5Turbo0613,
    #[doc = "gpt-3.5-turbo-1106"]
    Gpt3_5Turbo1106,
    #[doc = "gpt-3.5-turbo-0125"]
    Gpt3_5Turbo0125,
    #[doc = "gpt-3.5-turbo-16k-0613"]
    Gpt3_5Turbo16k0613,
}
impl<'de> serde::Deserialize<'de> for AssistantToolsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool being defined: `code_interpreter`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsCodeType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsCode {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantToolsCodeType,
        }
        let AssistantToolsCode { .. } = AssistantToolsCode::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for AssistantToolsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool being defined: `code_interpreter`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsCodeType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsCode<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantToolsCodeType,
        }
        let Self {} = self;
        AssistantToolsCode {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AssistantToolsCode {}
impl<'de> serde::Deserialize<'de> for AssistantToolsFileSearchFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsFileSearchFileSearch {
            #[serde(rename = "max_num_results")]
            #[allow(dead_code)]
            max_num_results: Option<u64>,
            #[serde(rename = "ranking_options")]
            #[allow(dead_code)]
            ranking_options: Option<FileSearchRankingOptions>,
        }
        let AssistantToolsFileSearchFileSearch {
            max_num_results,
            ranking_options,
            ..
        } = AssistantToolsFileSearchFileSearch::deserialize(deserializer)?;
        Ok(Self {
            max_num_results,
            ranking_options,
        })
    }
}
impl serde::Serialize for AssistantToolsFileSearchFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsFileSearchFileSearch<'a> {
            #[serde(rename = "max_num_results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_num_results: &'a Option<u64>,
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<FileSearchRankingOptions>,
        }
        let Self {
            max_num_results,
            ranking_options,
        } = self;
        AssistantToolsFileSearchFileSearch {
            max_num_results,
            ranking_options,
        }
        .serialize(serializer)
    }
}
#[doc = "Overrides for the file search tool."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFileSearchFileSearch {
    #[doc = "The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive.\n\nNote that the file search tool may output fewer than `max_num_results` results. See the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
    #[builder(default)]
    pub max_num_results: Option<u64>,
    #[builder(default)]
    pub ranking_options: Option<FileSearchRankingOptions>,
}
impl<'de> serde::Deserialize<'de> for AssistantToolsFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool being defined: `file_search`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFileSearchType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsFileSearch {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantToolsFileSearchType,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<AssistantToolsFileSearchFileSearch>,
        }
        let AssistantToolsFileSearch { file_search, .. } =
            AssistantToolsFileSearch::deserialize(deserializer)?;
        Ok(Self { file_search })
    }
}
impl serde::Serialize for AssistantToolsFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool being defined: `file_search`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFileSearchType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsFileSearch<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantToolsFileSearchType,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<AssistantToolsFileSearchFileSearch>,
        }
        let Self { file_search } = self;
        AssistantToolsFileSearch {
            type_: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFileSearch {
    #[doc = "Overrides for the file search tool."]
    #[builder(default)]
    pub file_search: Option<AssistantToolsFileSearchFileSearch>,
}
impl<'de> serde::Deserialize<'de> for AssistantToolsFileSearchTypeOnly {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool being defined: `file_search`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFileSearchTypeOnlyType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsFileSearchTypeOnly {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantToolsFileSearchTypeOnlyType,
        }
        let AssistantToolsFileSearchTypeOnly { .. } =
            AssistantToolsFileSearchTypeOnly::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for AssistantToolsFileSearchTypeOnly {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool being defined: `file_search`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFileSearchTypeOnlyType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsFileSearchTypeOnly<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantToolsFileSearchTypeOnlyType,
        }
        let Self {} = self;
        AssistantToolsFileSearchTypeOnly {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFileSearchTypeOnly {}
impl<'de> serde::Deserialize<'de> for AssistantToolsFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool being defined: `function`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFunctionType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsFunction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantToolsFunctionType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: FunctionObject,
        }
        let AssistantToolsFunction { function, .. } =
            AssistantToolsFunction::deserialize(deserializer)?;
        Ok(Self { function })
    }
}
impl serde::Serialize for AssistantToolsFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool being defined: `function`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantToolsFunctionType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsFunction<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantToolsFunctionType,
            #[serde(rename = "function")]
            function: &'a FunctionObject,
        }
        let Self { function } = self;
        AssistantToolsFunction {
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFunction {
    pub function: FunctionObject,
}
impl<'de> serde::Deserialize<'de> for AssistantsApiResponseFormatOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "`auto` is the default value\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiResponseFormatOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AssistantsApiResponseFormatOption {
            Auto(#[allow(dead_code)] AssistantsApiResponseFormatOptionAuto),
            Text(#[allow(dead_code)] ResponseFormatText),
            JsonObject(#[allow(dead_code)] ResponseFormatJsonObject),
            JsonSchema(#[allow(dead_code)] ResponseFormatJsonSchema),
        }
        Ok(
            match AssistantsApiResponseFormatOption::deserialize(deserializer)? {
                AssistantsApiResponseFormatOption::Auto(_) => Self::Auto,
                AssistantsApiResponseFormatOption::Text(_v) => Self::Text(_v),
                AssistantsApiResponseFormatOption::JsonObject(_v) => Self::JsonObject(_v),
                AssistantsApiResponseFormatOption::JsonSchema(_v) => Self::JsonSchema(_v),
            },
        )
    }
}
impl serde::Serialize for AssistantsApiResponseFormatOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "`auto` is the default value\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiResponseFormatOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AssistantsApiResponseFormatOption<'a> {
            Auto(#[allow(dead_code)] &'a AssistantsApiResponseFormatOptionAuto),
            Text(#[allow(dead_code)] &'a ResponseFormatText),
            JsonObject(#[allow(dead_code)] &'a ResponseFormatJsonObject),
            JsonSchema(#[allow(dead_code)] &'a ResponseFormatJsonSchema),
        }
        match self {
            Self::Auto => {
                AssistantsApiResponseFormatOption::Auto(&Default::default()).serialize(serializer)
            }
            Self::Text(_v) => AssistantsApiResponseFormatOption::Text(_v).serialize(serializer),
            Self::JsonObject(_v) => {
                AssistantsApiResponseFormatOption::JsonObject(_v).serialize(serializer)
            }
            Self::JsonSchema(_v) => {
                AssistantsApiResponseFormatOption::JsonSchema(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models#gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.\n\n**Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantsApiResponseFormatOption {
    #[doc = "auto"]
    Auto,
    Text(ResponseFormatText),
    JsonObject(ResponseFormatJsonObject),
    JsonSchema(ResponseFormatJsonSchema),
}
impl<'de> serde::Deserialize<'de> for AssistantsApiToolChoiceOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AssistantsApiToolChoiceOption {
            None(#[allow(dead_code)] AssistantsApiToolChoiceOptionNone),
            Auto(#[allow(dead_code)] AssistantsApiToolChoiceOptionAuto),
            Required(#[allow(dead_code)] AssistantsApiToolChoiceOptionRequired),
            AssistantsNamedToolChoice(#[allow(dead_code)] AssistantsNamedToolChoice),
        }
        Ok(
            match AssistantsApiToolChoiceOption::deserialize(deserializer)? {
                AssistantsApiToolChoiceOption::None(_) => Self::None,
                AssistantsApiToolChoiceOption::Auto(_) => Self::Auto,
                AssistantsApiToolChoiceOption::Required(_) => Self::Required,
                AssistantsApiToolChoiceOption::AssistantsNamedToolChoice(_v) => {
                    Self::AssistantsNamedToolChoice(_v)
                }
            },
        )
    }
}
impl serde::Serialize for AssistantsApiToolChoiceOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsApiToolChoiceOptionRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AssistantsApiToolChoiceOption<'a> {
            None(#[allow(dead_code)] &'a AssistantsApiToolChoiceOptionNone),
            Auto(#[allow(dead_code)] &'a AssistantsApiToolChoiceOptionAuto),
            Required(#[allow(dead_code)] &'a AssistantsApiToolChoiceOptionRequired),
            AssistantsNamedToolChoice(#[allow(dead_code)] &'a AssistantsNamedToolChoice),
        }
        match self {
            Self::None => {
                AssistantsApiToolChoiceOption::None(&Default::default()).serialize(serializer)
            }
            Self::Auto => {
                AssistantsApiToolChoiceOption::Auto(&Default::default()).serialize(serializer)
            }
            Self::Required => {
                AssistantsApiToolChoiceOption::Required(&Default::default()).serialize(serializer)
            }
            Self::AssistantsNamedToolChoice(_v) => {
                AssistantsApiToolChoiceOption::AssistantsNamedToolChoice(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tools and instead generates a message.\n`auto` is the default value and means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools before responding to the user.\nSpecifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantsApiToolChoiceOption {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    #[doc = "required"]
    Required,
    AssistantsNamedToolChoice(AssistantsNamedToolChoice),
}
impl<'de> serde::Deserialize<'de> for AssistantsNamedToolChoiceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeFunction {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeCodeInterpreter {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeFileSearch {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AssistantsNamedToolChoiceType {
            Function(#[allow(dead_code)] AssistantsNamedToolChoiceTypeFunction),
            CodeInterpreter(#[allow(dead_code)] AssistantsNamedToolChoiceTypeCodeInterpreter),
            FileSearch(#[allow(dead_code)] AssistantsNamedToolChoiceTypeFileSearch),
        }
        Ok(
            match AssistantsNamedToolChoiceType::deserialize(deserializer)? {
                AssistantsNamedToolChoiceType::Function(_) => Self::Function,
                AssistantsNamedToolChoiceType::CodeInterpreter(_) => Self::CodeInterpreter,
                AssistantsNamedToolChoiceType::FileSearch(_) => Self::FileSearch,
            },
        )
    }
}
impl serde::Serialize for AssistantsNamedToolChoiceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeFunction {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeCodeInterpreter {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AssistantsNamedToolChoiceTypeFileSearch {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AssistantsNamedToolChoiceType<'a> {
            Function(#[allow(dead_code)] &'a AssistantsNamedToolChoiceTypeFunction),
            CodeInterpreter(#[allow(dead_code)] &'a AssistantsNamedToolChoiceTypeCodeInterpreter),
            FileSearch(#[allow(dead_code)] &'a AssistantsNamedToolChoiceTypeFileSearch),
        }
        match self {
            Self::Function => {
                AssistantsNamedToolChoiceType::Function(&Default::default()).serialize(serializer)
            }
            Self::CodeInterpreter => {
                AssistantsNamedToolChoiceType::CodeInterpreter(&Default::default())
                    .serialize(serializer)
            }
            Self::FileSearch => {
                AssistantsNamedToolChoiceType::FileSearch(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of the tool. If type is `function`, the function name must be set"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantsNamedToolChoiceType {
    #[doc = "function"]
    Function,
    #[doc = "code_interpreter"]
    CodeInterpreter,
    #[doc = "file_search"]
    FileSearch,
}
impl<'de> serde::Deserialize<'de> for AssistantsNamedToolChoiceFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantsNamedToolChoiceFunction {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let AssistantsNamedToolChoiceFunction { name, .. } =
            AssistantsNamedToolChoiceFunction::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for AssistantsNamedToolChoiceFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantsNamedToolChoiceFunction<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        AssistantsNamedToolChoiceFunction { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantsNamedToolChoiceFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for AssistantsNamedToolChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantsNamedToolChoice {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AssistantsNamedToolChoiceType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: Option<AssistantsNamedToolChoiceFunction>,
        }
        let AssistantsNamedToolChoice {
            type_, function, ..
        } = AssistantsNamedToolChoice::deserialize(deserializer)?;
        Ok(Self { type_, function })
    }
}
impl serde::Serialize for AssistantsNamedToolChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantsNamedToolChoice<'a> {
            #[serde(rename = "type")]
            type_: &'a AssistantsNamedToolChoiceType,
            #[serde(rename = "function")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function: &'a Option<AssistantsNamedToolChoiceFunction>,
        }
        let Self { type_, function } = self;
        AssistantsNamedToolChoice { type_, function }.serialize(serializer)
    }
}
#[doc = "Specifies a tool the model should use. Use to force the model to call a specific tool."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantsNamedToolChoice {
    #[doc = "The type of the tool. If type is `function`, the function name must be set"]
    pub type_: AssistantsNamedToolChoiceType,
    #[builder(default)]
    pub function: Option<AssistantsNamedToolChoiceFunction>,
}
impl<'de> serde::Deserialize<'de> for AudioResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatJson {
            #[default]
            #[serde(rename = "json")]
            Json,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatSrt {
            #[default]
            #[serde(rename = "srt")]
            Srt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatVerboseJson {
            #[default]
            #[serde(rename = "verbose_json")]
            VerboseJson,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatVtt {
            #[default]
            #[serde(rename = "vtt")]
            Vtt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AudioResponseFormat {
            Json(#[allow(dead_code)] AudioResponseFormatJson),
            Text(#[allow(dead_code)] AudioResponseFormatText),
            Srt(#[allow(dead_code)] AudioResponseFormatSrt),
            VerboseJson(#[allow(dead_code)] AudioResponseFormatVerboseJson),
            Vtt(#[allow(dead_code)] AudioResponseFormatVtt),
        }
        Ok(match AudioResponseFormat::deserialize(deserializer)? {
            AudioResponseFormat::Json(_) => Self::Json,
            AudioResponseFormat::Text(_) => Self::Text,
            AudioResponseFormat::Srt(_) => Self::Srt,
            AudioResponseFormat::VerboseJson(_) => Self::VerboseJson,
            AudioResponseFormat::Vtt(_) => Self::Vtt,
        })
    }
}
impl serde::Serialize for AudioResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatJson {
            #[default]
            #[serde(rename = "json")]
            Json,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatSrt {
            #[default]
            #[serde(rename = "srt")]
            Srt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatVerboseJson {
            #[default]
            #[serde(rename = "verbose_json")]
            VerboseJson,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AudioResponseFormatVtt {
            #[default]
            #[serde(rename = "vtt")]
            Vtt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AudioResponseFormat<'a> {
            Json(#[allow(dead_code)] &'a AudioResponseFormatJson),
            Text(#[allow(dead_code)] &'a AudioResponseFormatText),
            Srt(#[allow(dead_code)] &'a AudioResponseFormatSrt),
            VerboseJson(#[allow(dead_code)] &'a AudioResponseFormatVerboseJson),
            Vtt(#[allow(dead_code)] &'a AudioResponseFormatVtt),
        }
        match self {
            Self::Json => AudioResponseFormat::Json(&Default::default()).serialize(serializer),
            Self::Text => AudioResponseFormat::Text(&Default::default()).serialize(serializer),
            Self::Srt => AudioResponseFormat::Srt(&Default::default()).serialize(serializer),
            Self::VerboseJson => {
                AudioResponseFormat::VerboseJson(&Default::default()).serialize(serializer)
            }
            Self::Vtt => AudioResponseFormat::Vtt(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`. For `gpt-4o-transcribe` and `gpt-4o-mini-transcribe`, the only supported format is `json`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum AudioResponseFormat {
    #[doc = "json"]
    #[default]
    Json,
    #[doc = "text"]
    Text,
    #[doc = "srt"]
    Srt,
    #[doc = "verbose_json"]
    VerboseJson,
    #[doc = "vtt"]
    Vtt,
}
impl<'de> serde::Deserialize<'de> for AuditLogProject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogProject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let AuditLogProject { id, name, .. } = AuditLogProject::deserialize(deserializer)?;
        Ok(Self { id, name })
    }
}
impl serde::Serialize for AuditLogProject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogProject<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { id, name } = self;
        AuditLogProject { id, name }.serialize(serializer)
    }
}
#[doc = "The project that the action was scoped to. Absent for actions not scoped to projects."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProject {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The project title."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyCreatedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogApiKeyCreatedData {
            #[serde(rename = "scopes")]
            #[allow(dead_code)]
            scopes: Option<Vec<String>>,
        }
        let AuditLogApiKeyCreatedData { scopes, .. } =
            AuditLogApiKeyCreatedData::deserialize(deserializer)?;
        Ok(Self { scopes })
    }
}
impl serde::Serialize for AuditLogApiKeyCreatedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogApiKeyCreatedData<'a> {
            #[serde(rename = "scopes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            scopes: &'a Option<Vec<String>>,
        }
        let Self { scopes } = self;
        AuditLogApiKeyCreatedData { scopes }.serialize(serializer)
    }
}
#[doc = "The payload used to create the API key."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyCreatedData {
    #[doc = "A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`"]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogApiKeyCreated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogApiKeyCreatedData>,
        }
        let AuditLogApiKeyCreated { id, data, .. } =
            AuditLogApiKeyCreated::deserialize(deserializer)?;
        Ok(Self { id, data })
    }
}
impl serde::Serialize for AuditLogApiKeyCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogApiKeyCreated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogApiKeyCreatedData>,
        }
        let Self { id, data } = self;
        AuditLogApiKeyCreated { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyCreated {
    #[doc = "The tracking ID of the API key."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the API key."]
    #[builder(default)]
    pub data: Option<AuditLogApiKeyCreatedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogApiKeyUpdatedChangesRequested {
            #[serde(rename = "scopes")]
            #[allow(dead_code)]
            scopes: Option<Vec<String>>,
        }
        let AuditLogApiKeyUpdatedChangesRequested { scopes, .. } =
            AuditLogApiKeyUpdatedChangesRequested::deserialize(deserializer)?;
        Ok(Self { scopes })
    }
}
impl serde::Serialize for AuditLogApiKeyUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogApiKeyUpdatedChangesRequested<'a> {
            #[serde(rename = "scopes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            scopes: &'a Option<Vec<String>>,
        }
        let Self { scopes } = self;
        AuditLogApiKeyUpdatedChangesRequested { scopes }.serialize(serializer)
    }
}
#[doc = "The payload used to update the API key."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyUpdatedChangesRequested {
    #[doc = "A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`"]
    #[builder(default)]
    pub scopes: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogApiKeyUpdated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogApiKeyUpdatedChangesRequested>,
        }
        let AuditLogApiKeyUpdated {
            id,
            changes_requested,
            ..
        } = AuditLogApiKeyUpdated::deserialize(deserializer)?;
        Ok(Self {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogApiKeyUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogApiKeyUpdated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogApiKeyUpdatedChangesRequested>,
        }
        let Self {
            id,
            changes_requested,
        } = self;
        AuditLogApiKeyUpdated {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyUpdated {
    #[doc = "The tracking ID of the API key."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the API key."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogApiKeyUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogApiKeyDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogApiKeyDeleted {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogApiKeyDeleted { id, .. } = AuditLogApiKeyDeleted::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogApiKeyDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogApiKeyDeleted<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogApiKeyDeleted { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogApiKeyDeleted {
    #[doc = "The tracking ID of the API key."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCheckpointPermissionCreatedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCheckpointPermissionCreatedData {
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            #[allow(dead_code)]
            fine_tuned_model_checkpoint: Option<String>,
        }
        let AuditLogCheckpointPermissionCreatedData {
            project_id,
            fine_tuned_model_checkpoint,
            ..
        } = AuditLogCheckpointPermissionCreatedData::deserialize(deserializer)?;
        Ok(Self {
            project_id,
            fine_tuned_model_checkpoint,
        })
    }
}
impl serde::Serialize for AuditLogCheckpointPermissionCreatedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCheckpointPermissionCreatedData<'a> {
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            fine_tuned_model_checkpoint: &'a Option<String>,
        }
        let Self {
            project_id,
            fine_tuned_model_checkpoint,
        } = self;
        AuditLogCheckpointPermissionCreatedData {
            project_id,
            fine_tuned_model_checkpoint,
        }
        .serialize(serializer)
    }
}
#[doc = "The payload used to create the checkpoint permission."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCheckpointPermissionCreatedData {
    #[doc = "The ID of the project that the checkpoint permission was created for."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "The ID of the fine-tuned model checkpoint."]
    #[builder(default)]
    pub fine_tuned_model_checkpoint: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCheckpointPermissionCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCheckpointPermissionCreated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogCheckpointPermissionCreatedData>,
        }
        let AuditLogCheckpointPermissionCreated { id, data, .. } =
            AuditLogCheckpointPermissionCreated::deserialize(deserializer)?;
        Ok(Self { id, data })
    }
}
impl serde::Serialize for AuditLogCheckpointPermissionCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCheckpointPermissionCreated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogCheckpointPermissionCreatedData>,
        }
        let Self { id, data } = self;
        AuditLogCheckpointPermissionCreated { id, data }.serialize(serializer)
    }
}
#[doc = "The project and fine-tuned model checkpoint that the checkpoint permission was created for."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCheckpointPermissionCreated {
    #[doc = "The ID of the checkpoint permission."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the checkpoint permission."]
    #[builder(default)]
    pub data: Option<AuditLogCheckpointPermissionCreatedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCheckpointPermissionDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCheckpointPermissionDeleted {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogCheckpointPermissionDeleted { id, .. } =
            AuditLogCheckpointPermissionDeleted::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogCheckpointPermissionDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCheckpointPermissionDeleted<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogCheckpointPermissionDeleted { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCheckpointPermissionDeleted {
    #[doc = "The ID of the checkpoint permission."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogInviteSentData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogInviteSentData {
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: Option<String>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let AuditLogInviteSentData { email, role, .. } =
            AuditLogInviteSentData::deserialize(deserializer)?;
        Ok(Self { email, role })
    }
}
impl serde::Serialize for AuditLogInviteSentData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogInviteSentData<'a> {
            #[serde(rename = "email")]
            #[serde(skip_serializing_if = "Option::is_none")]
            email: &'a Option<String>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let Self { email, role } = self;
        AuditLogInviteSentData { email, role }.serialize(serializer)
    }
}
#[doc = "The payload used to create the invite."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogInviteSentData {
    #[doc = "The email invited to the organization."]
    #[builder(default)]
    pub email: Option<String>,
    #[doc = "The role the email was invited to be. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogInviteSent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogInviteSent {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogInviteSentData>,
        }
        let AuditLogInviteSent { id, data, .. } = AuditLogInviteSent::deserialize(deserializer)?;
        Ok(Self { id, data })
    }
}
impl serde::Serialize for AuditLogInviteSent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogInviteSent<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogInviteSentData>,
        }
        let Self { id, data } = self;
        AuditLogInviteSent { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogInviteSent {
    #[doc = "The ID of the invite."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the invite."]
    #[builder(default)]
    pub data: Option<AuditLogInviteSentData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogInviteAccepted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogInviteAccepted {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogInviteAccepted { id, .. } = AuditLogInviteAccepted::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogInviteAccepted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogInviteAccepted<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogInviteAccepted { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogInviteAccepted {
    #[doc = "The ID of the invite."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogInviteDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogInviteDeleted {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogInviteDeleted { id, .. } = AuditLogInviteDeleted::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogInviteDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogInviteDeleted<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogInviteDeleted { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogInviteDeleted {
    #[doc = "The ID of the invite."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogLoginFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogLoginFailed {
            #[serde(rename = "error_code")]
            #[allow(dead_code)]
            error_code: Option<String>,
            #[serde(rename = "error_message")]
            #[allow(dead_code)]
            error_message: Option<String>,
        }
        let AuditLogLoginFailed {
            error_code,
            error_message,
            ..
        } = AuditLogLoginFailed::deserialize(deserializer)?;
        Ok(Self {
            error_code,
            error_message,
        })
    }
}
impl serde::Serialize for AuditLogLoginFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogLoginFailed<'a> {
            #[serde(rename = "error_code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_code: &'a Option<String>,
            #[serde(rename = "error_message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_message: &'a Option<String>,
        }
        let Self {
            error_code,
            error_message,
        } = self;
        AuditLogLoginFailed {
            error_code,
            error_message,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogLoginFailed {
    #[doc = "The error code of the failure."]
    #[builder(default)]
    pub error_code: Option<String>,
    #[doc = "The error message of the failure."]
    #[builder(default)]
    pub error_message: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogLogoutFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogLogoutFailed {
            #[serde(rename = "error_code")]
            #[allow(dead_code)]
            error_code: Option<String>,
            #[serde(rename = "error_message")]
            #[allow(dead_code)]
            error_message: Option<String>,
        }
        let AuditLogLogoutFailed {
            error_code,
            error_message,
            ..
        } = AuditLogLogoutFailed::deserialize(deserializer)?;
        Ok(Self {
            error_code,
            error_message,
        })
    }
}
impl serde::Serialize for AuditLogLogoutFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogLogoutFailed<'a> {
            #[serde(rename = "error_code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_code: &'a Option<String>,
            #[serde(rename = "error_message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_message: &'a Option<String>,
        }
        let Self {
            error_code,
            error_message,
        } = self;
        AuditLogLogoutFailed {
            error_code,
            error_message,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogLogoutFailed {
    #[doc = "The error code of the failure."]
    #[builder(default)]
    pub error_code: Option<String>,
    #[doc = "The error message of the failure."]
    #[builder(default)]
    pub error_message: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogOrganizationUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogOrganizationUpdatedChangesRequested {
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "threads_ui_visibility")]
            #[allow(dead_code)]
            threads_ui_visibility: Option<String>,
            #[serde(rename = "usage_dashboard_visibility")]
            #[allow(dead_code)]
            usage_dashboard_visibility: Option<String>,
            #[serde(rename = "api_call_logging")]
            #[allow(dead_code)]
            api_call_logging: Option<String>,
            #[serde(rename = "api_call_logging_project_ids")]
            #[allow(dead_code)]
            api_call_logging_project_ids: Option<String>,
        }
        let AuditLogOrganizationUpdatedChangesRequested {
            title,
            description,
            name,
            threads_ui_visibility,
            usage_dashboard_visibility,
            api_call_logging,
            api_call_logging_project_ids,
            ..
        } = AuditLogOrganizationUpdatedChangesRequested::deserialize(deserializer)?;
        Ok(Self {
            title,
            description,
            name,
            threads_ui_visibility,
            usage_dashboard_visibility,
            api_call_logging,
            api_call_logging_project_ids,
        })
    }
}
impl serde::Serialize for AuditLogOrganizationUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogOrganizationUpdatedChangesRequested<'a> {
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            title: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "threads_ui_visibility")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threads_ui_visibility: &'a Option<String>,
            #[serde(rename = "usage_dashboard_visibility")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage_dashboard_visibility: &'a Option<String>,
            #[serde(rename = "api_call_logging")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_call_logging: &'a Option<String>,
            #[serde(rename = "api_call_logging_project_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_call_logging_project_ids: &'a Option<String>,
        }
        let Self {
            title,
            description,
            name,
            threads_ui_visibility,
            usage_dashboard_visibility,
            api_call_logging,
            api_call_logging_project_ids,
        } = self;
        AuditLogOrganizationUpdatedChangesRequested {
            title,
            description,
            name,
            threads_ui_visibility,
            usage_dashboard_visibility,
            api_call_logging,
            api_call_logging_project_ids,
        }
        .serialize(serializer)
    }
}
#[doc = "The payload used to update the organization settings."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogOrganizationUpdatedChangesRequested {
    #[doc = "The organization title."]
    #[builder(default)]
    pub title: Option<String>,
    #[doc = "The organization description."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The organization name."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "Visibility of the threads page which shows messages created with the Assistants API and Playground. One of `ANY_ROLE`, `OWNERS`, or `NONE`."]
    #[builder(default)]
    pub threads_ui_visibility: Option<String>,
    #[doc = "Visibility of the usage dashboard which shows activity and costs for your organization. One of `ANY_ROLE` or `OWNERS`."]
    #[builder(default)]
    pub usage_dashboard_visibility: Option<String>,
    #[doc = "How your organization logs data from supported API calls. One of `disabled`, `enabled_per_call`, `enabled_for_all_projects`, or `enabled_for_selected_projects`"]
    #[builder(default)]
    pub api_call_logging: Option<String>,
    #[doc = "The list of project ids if api_call_logging is set to `enabled_for_selected_projects`"]
    #[builder(default)]
    pub api_call_logging_project_ids: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogOrganizationUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogOrganizationUpdated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogOrganizationUpdatedChangesRequested>,
        }
        let AuditLogOrganizationUpdated {
            id,
            changes_requested,
            ..
        } = AuditLogOrganizationUpdated::deserialize(deserializer)?;
        Ok(Self {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogOrganizationUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogOrganizationUpdated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogOrganizationUpdatedChangesRequested>,
        }
        let Self {
            id,
            changes_requested,
        } = self;
        AuditLogOrganizationUpdated {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogOrganizationUpdated {
    #[doc = "The organization ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the organization settings."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogOrganizationUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectCreatedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogProjectCreatedData {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: Option<String>,
        }
        let AuditLogProjectCreatedData { name, title, .. } =
            AuditLogProjectCreatedData::deserialize(deserializer)?;
        Ok(Self { name, title })
    }
}
impl serde::Serialize for AuditLogProjectCreatedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogProjectCreatedData<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            title: &'a Option<String>,
        }
        let Self { name, title } = self;
        AuditLogProjectCreatedData { name, title }.serialize(serializer)
    }
}
#[doc = "The payload used to create the project."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectCreatedData {
    #[doc = "The project name."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The title of the project as seen on the dashboard."]
    #[builder(default)]
    pub title: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogProjectCreated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogProjectCreatedData>,
        }
        let AuditLogProjectCreated { id, data, .. } =
            AuditLogProjectCreated::deserialize(deserializer)?;
        Ok(Self { id, data })
    }
}
impl serde::Serialize for AuditLogProjectCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogProjectCreated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogProjectCreatedData>,
        }
        let Self { id, data } = self;
        AuditLogProjectCreated { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectCreated {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the project."]
    #[builder(default)]
    pub data: Option<AuditLogProjectCreatedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogProjectUpdatedChangesRequested {
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: Option<String>,
        }
        let AuditLogProjectUpdatedChangesRequested { title, .. } =
            AuditLogProjectUpdatedChangesRequested::deserialize(deserializer)?;
        Ok(Self { title })
    }
}
impl serde::Serialize for AuditLogProjectUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogProjectUpdatedChangesRequested<'a> {
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            title: &'a Option<String>,
        }
        let Self { title } = self;
        AuditLogProjectUpdatedChangesRequested { title }.serialize(serializer)
    }
}
#[doc = "The payload used to update the project."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectUpdatedChangesRequested {
    #[doc = "The title of the project as seen on the dashboard."]
    #[builder(default)]
    pub title: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogProjectUpdated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogProjectUpdatedChangesRequested>,
        }
        let AuditLogProjectUpdated {
            id,
            changes_requested,
            ..
        } = AuditLogProjectUpdated::deserialize(deserializer)?;
        Ok(Self {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogProjectUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogProjectUpdated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogProjectUpdatedChangesRequested>,
        }
        let Self {
            id,
            changes_requested,
        } = self;
        AuditLogProjectUpdated {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectUpdated {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the project."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogProjectUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogProjectArchived {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogProjectArchived {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogProjectArchived { id, .. } =
            AuditLogProjectArchived::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogProjectArchived {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogProjectArchived<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogProjectArchived { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogProjectArchived {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogRateLimitUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogRateLimitUpdatedChangesRequested {
            #[serde(rename = "max_requests_per_1_minute")]
            #[allow(dead_code)]
            max_requests_per_1_minute: Option<u64>,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[allow(dead_code)]
            max_tokens_per_1_minute: Option<u64>,
            #[serde(rename = "max_images_per_1_minute")]
            #[allow(dead_code)]
            max_images_per_1_minute: Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[allow(dead_code)]
            max_audio_megabytes_per_1_minute: Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[allow(dead_code)]
            max_requests_per_1_day: Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[allow(dead_code)]
            batch_1_day_max_input_tokens: Option<u64>,
        }
        let AuditLogRateLimitUpdatedChangesRequested {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
            ..
        } = AuditLogRateLimitUpdatedChangesRequested::deserialize(deserializer)?;
        Ok(Self {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        })
    }
}
impl serde::Serialize for AuditLogRateLimitUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogRateLimitUpdatedChangesRequested<'a> {
            #[serde(rename = "max_requests_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tokens_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_images_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_images_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_audio_megabytes_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_day: &'a Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_1_day_max_input_tokens: &'a Option<u64>,
        }
        let Self {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        } = self;
        AuditLogRateLimitUpdatedChangesRequested {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "The payload used to update the rate limits."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogRateLimitUpdatedChangesRequested {
    #[doc = "The maximum requests per minute."]
    #[builder(default)]
    pub max_requests_per_1_minute: Option<u64>,
    #[doc = "The maximum tokens per minute."]
    #[builder(default)]
    pub max_tokens_per_1_minute: Option<u64>,
    #[doc = "The maximum images per minute. Only relevant for certain models."]
    #[builder(default)]
    pub max_images_per_1_minute: Option<u64>,
    #[doc = "The maximum audio megabytes per minute. Only relevant for certain models."]
    #[builder(default)]
    pub max_audio_megabytes_per_1_minute: Option<u64>,
    #[doc = "The maximum requests per day. Only relevant for certain models."]
    #[builder(default)]
    pub max_requests_per_1_day: Option<u64>,
    #[doc = "The maximum batch input tokens per day. Only relevant for certain models."]
    #[builder(default)]
    pub batch_1_day_max_input_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for AuditLogRateLimitUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogRateLimitUpdated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogRateLimitUpdatedChangesRequested>,
        }
        let AuditLogRateLimitUpdated {
            id,
            changes_requested,
            ..
        } = AuditLogRateLimitUpdated::deserialize(deserializer)?;
        Ok(Self {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogRateLimitUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogRateLimitUpdated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogRateLimitUpdatedChangesRequested>,
        }
        let Self {
            id,
            changes_requested,
        } = self;
        AuditLogRateLimitUpdated {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogRateLimitUpdated {
    #[doc = "The rate limit ID"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the rate limits."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogRateLimitUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogRateLimitDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogRateLimitDeleted {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogRateLimitDeleted { id, .. } =
            AuditLogRateLimitDeleted::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogRateLimitDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogRateLimitDeleted<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogRateLimitDeleted { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogRateLimitDeleted {
    #[doc = "The rate limit ID"]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountCreatedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogServiceAccountCreatedData {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let AuditLogServiceAccountCreatedData { role, .. } =
            AuditLogServiceAccountCreatedData::deserialize(deserializer)?;
        Ok(Self { role })
    }
}
impl serde::Serialize for AuditLogServiceAccountCreatedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogServiceAccountCreatedData<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let Self { role } = self;
        AuditLogServiceAccountCreatedData { role }.serialize(serializer)
    }
}
#[doc = "The payload used to create the service account."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountCreatedData {
    #[doc = "The role of the service account. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogServiceAccountCreated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogServiceAccountCreatedData>,
        }
        let AuditLogServiceAccountCreated { id, data, .. } =
            AuditLogServiceAccountCreated::deserialize(deserializer)?;
        Ok(Self { id, data })
    }
}
impl serde::Serialize for AuditLogServiceAccountCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogServiceAccountCreated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogServiceAccountCreatedData>,
        }
        let Self { id, data } = self;
        AuditLogServiceAccountCreated { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountCreated {
    #[doc = "The service account ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to create the service account."]
    #[builder(default)]
    pub data: Option<AuditLogServiceAccountCreatedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogServiceAccountUpdatedChangesRequested {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let AuditLogServiceAccountUpdatedChangesRequested { role, .. } =
            AuditLogServiceAccountUpdatedChangesRequested::deserialize(deserializer)?;
        Ok(Self { role })
    }
}
impl serde::Serialize for AuditLogServiceAccountUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogServiceAccountUpdatedChangesRequested<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let Self { role } = self;
        AuditLogServiceAccountUpdatedChangesRequested { role }.serialize(serializer)
    }
}
#[doc = "The payload used to updated the service account."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountUpdatedChangesRequested {
    #[doc = "The role of the service account. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogServiceAccountUpdated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogServiceAccountUpdatedChangesRequested>,
        }
        let AuditLogServiceAccountUpdated {
            id,
            changes_requested,
            ..
        } = AuditLogServiceAccountUpdated::deserialize(deserializer)?;
        Ok(Self {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogServiceAccountUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogServiceAccountUpdated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogServiceAccountUpdatedChangesRequested>,
        }
        let Self {
            id,
            changes_requested,
        } = self;
        AuditLogServiceAccountUpdated {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountUpdated {
    #[doc = "The service account ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to updated the service account."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogServiceAccountUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogServiceAccountDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogServiceAccountDeleted {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogServiceAccountDeleted { id, .. } =
            AuditLogServiceAccountDeleted::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogServiceAccountDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogServiceAccountDeleted<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogServiceAccountDeleted { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogServiceAccountDeleted {
    #[doc = "The service account ID."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserAddedData {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogUserAddedData {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let AuditLogUserAddedData { role, .. } = AuditLogUserAddedData::deserialize(deserializer)?;
        Ok(Self { role })
    }
}
impl serde::Serialize for AuditLogUserAddedData {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogUserAddedData<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let Self { role } = self;
        AuditLogUserAddedData { role }.serialize(serializer)
    }
}
#[doc = "The payload used to add the user to the project."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserAddedData {
    #[doc = "The role of the user. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserAdded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogUserAdded {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<AuditLogUserAddedData>,
        }
        let AuditLogUserAdded { id, data, .. } = AuditLogUserAdded::deserialize(deserializer)?;
        Ok(Self { id, data })
    }
}
impl serde::Serialize for AuditLogUserAdded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogUserAdded<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<AuditLogUserAddedData>,
        }
        let Self { id, data } = self;
        AuditLogUserAdded { id, data }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserAdded {
    #[doc = "The user ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to add the user to the project."]
    #[builder(default)]
    pub data: Option<AuditLogUserAddedData>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserUpdatedChangesRequested {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogUserUpdatedChangesRequested {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
        }
        let AuditLogUserUpdatedChangesRequested { role, .. } =
            AuditLogUserUpdatedChangesRequested::deserialize(deserializer)?;
        Ok(Self { role })
    }
}
impl serde::Serialize for AuditLogUserUpdatedChangesRequested {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogUserUpdatedChangesRequested<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
        }
        let Self { role } = self;
        AuditLogUserUpdatedChangesRequested { role }.serialize(serializer)
    }
}
#[doc = "The payload used to update the user."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserUpdatedChangesRequested {
    #[doc = "The role of the user. Is either `owner` or `member`."]
    #[builder(default)]
    pub role: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogUserUpdated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "changes_requested")]
            #[allow(dead_code)]
            changes_requested: Option<AuditLogUserUpdatedChangesRequested>,
        }
        let AuditLogUserUpdated {
            id,
            changes_requested,
            ..
        } = AuditLogUserUpdated::deserialize(deserializer)?;
        Ok(Self {
            id,
            changes_requested,
        })
    }
}
impl serde::Serialize for AuditLogUserUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogUserUpdated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "changes_requested")]
            #[serde(skip_serializing_if = "Option::is_none")]
            changes_requested: &'a Option<AuditLogUserUpdatedChangesRequested>,
        }
        let Self {
            id,
            changes_requested,
        } = self;
        AuditLogUserUpdated {
            id,
            changes_requested,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserUpdated {
    #[doc = "The project ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The payload used to update the user."]
    #[builder(default)]
    pub changes_requested: Option<AuditLogUserUpdatedChangesRequested>,
}
impl<'de> serde::Deserialize<'de> for AuditLogUserDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogUserDeleted {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogUserDeleted { id, .. } = AuditLogUserDeleted::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogUserDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogUserDeleted<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogUserDeleted { id }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogUserDeleted {
    #[doc = "The user ID."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificateCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCertificateCreated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let AuditLogCertificateCreated { id, name, .. } =
            AuditLogCertificateCreated::deserialize(deserializer)?;
        Ok(Self { id, name })
    }
}
impl serde::Serialize for AuditLogCertificateCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCertificateCreated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { id, name } = self;
        AuditLogCertificateCreated { id, name }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificateCreated {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificateUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCertificateUpdated {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let AuditLogCertificateUpdated { id, name, .. } =
            AuditLogCertificateUpdated::deserialize(deserializer)?;
        Ok(Self { id, name })
    }
}
impl serde::Serialize for AuditLogCertificateUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCertificateUpdated<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { id, name } = self;
        AuditLogCertificateUpdated { id, name }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificateUpdated {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificateDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCertificateDeleted {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "certificate")]
            #[allow(dead_code)]
            certificate: Option<String>,
        }
        let AuditLogCertificateDeleted {
            id,
            name,
            certificate,
            ..
        } = AuditLogCertificateDeleted::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            certificate,
        })
    }
}
impl serde::Serialize for AuditLogCertificateDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCertificateDeleted<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "certificate")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificate: &'a Option<String>,
        }
        let Self {
            id,
            name,
            certificate,
        } = self;
        AuditLogCertificateDeleted {
            id,
            name,
            certificate,
        }
        .serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificateDeleted {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The certificate content in PEM format."]
    #[builder(default)]
    pub certificate: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificatesActivatedCertificate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCertificatesActivatedCertificate {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let AuditLogCertificatesActivatedCertificate { id, name, .. } =
            AuditLogCertificatesActivatedCertificate::deserialize(deserializer)?;
        Ok(Self { id, name })
    }
}
impl serde::Serialize for AuditLogCertificatesActivatedCertificate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCertificatesActivatedCertificate<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { id, name } = self;
        AuditLogCertificatesActivatedCertificate { id, name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificatesActivatedCertificate {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificatesActivated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCertificatesActivated {
            #[serde(rename = "certificates")]
            #[allow(dead_code)]
            certificates: Option<Vec<AuditLogCertificatesActivatedCertificate>>,
        }
        let AuditLogCertificatesActivated { certificates, .. } =
            AuditLogCertificatesActivated::deserialize(deserializer)?;
        Ok(Self { certificates })
    }
}
impl serde::Serialize for AuditLogCertificatesActivated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCertificatesActivated<'a> {
            #[serde(rename = "certificates")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificates: &'a Option<Vec<AuditLogCertificatesActivatedCertificate>>,
        }
        let Self { certificates } = self;
        AuditLogCertificatesActivated { certificates }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificatesActivated {
    #[builder(default)]
    pub certificates: Option<Vec<AuditLogCertificatesActivatedCertificate>>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificatesDeactivatedCertificate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCertificatesDeactivatedCertificate {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let AuditLogCertificatesDeactivatedCertificate { id, name, .. } =
            AuditLogCertificatesDeactivatedCertificate::deserialize(deserializer)?;
        Ok(Self { id, name })
    }
}
impl serde::Serialize for AuditLogCertificatesDeactivatedCertificate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCertificatesDeactivatedCertificate<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { id, name } = self;
        AuditLogCertificatesDeactivatedCertificate { id, name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificatesDeactivatedCertificate {
    #[doc = "The certificate ID."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The name of the certificate."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogCertificatesDeactivated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogCertificatesDeactivated {
            #[serde(rename = "certificates")]
            #[allow(dead_code)]
            certificates: Option<Vec<AuditLogCertificatesDeactivatedCertificate>>,
        }
        let AuditLogCertificatesDeactivated { certificates, .. } =
            AuditLogCertificatesDeactivated::deserialize(deserializer)?;
        Ok(Self { certificates })
    }
}
impl serde::Serialize for AuditLogCertificatesDeactivated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogCertificatesDeactivated<'a> {
            #[serde(rename = "certificates")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificates: &'a Option<Vec<AuditLogCertificatesDeactivatedCertificate>>,
        }
        let Self { certificates } = self;
        AuditLogCertificatesDeactivated { certificates }.serialize(serializer)
    }
}
#[doc = "The details for events with this `type`."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogCertificatesDeactivated {
    #[builder(default)]
    pub certificates: Option<Vec<AuditLogCertificatesDeactivatedCertificate>>,
}
impl<'de> serde::Deserialize<'de> for AuditLog {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLog {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AuditLogEventType,
            #[serde(rename = "effective_at")]
            #[allow(dead_code)]
            effective_at: u64,
            #[serde(rename = "project")]
            #[allow(dead_code)]
            project: Option<AuditLogProject>,
            #[serde(rename = "actor")]
            #[allow(dead_code)]
            actor: AuditLogActor,
            #[serde(rename = "api_key.created")]
            #[allow(dead_code)]
            api_key_created: Option<AuditLogApiKeyCreated>,
            #[serde(rename = "api_key.updated")]
            #[allow(dead_code)]
            api_key_updated: Option<AuditLogApiKeyUpdated>,
            #[serde(rename = "api_key.deleted")]
            #[allow(dead_code)]
            api_key_deleted: Option<AuditLogApiKeyDeleted>,
            #[serde(rename = "checkpoint_permission.created")]
            #[allow(dead_code)]
            checkpoint_permission_created: Option<AuditLogCheckpointPermissionCreated>,
            #[serde(rename = "checkpoint_permission.deleted")]
            #[allow(dead_code)]
            checkpoint_permission_deleted: Option<AuditLogCheckpointPermissionDeleted>,
            #[serde(rename = "invite.sent")]
            #[allow(dead_code)]
            invite_sent: Option<AuditLogInviteSent>,
            #[serde(rename = "invite.accepted")]
            #[allow(dead_code)]
            invite_accepted: Option<AuditLogInviteAccepted>,
            #[serde(rename = "invite.deleted")]
            #[allow(dead_code)]
            invite_deleted: Option<AuditLogInviteDeleted>,
            #[serde(rename = "login.failed")]
            #[allow(dead_code)]
            login_failed: Option<AuditLogLoginFailed>,
            #[serde(rename = "logout.failed")]
            #[allow(dead_code)]
            logout_failed: Option<AuditLogLogoutFailed>,
            #[serde(rename = "organization.updated")]
            #[allow(dead_code)]
            organization_updated: Option<AuditLogOrganizationUpdated>,
            #[serde(rename = "project.created")]
            #[allow(dead_code)]
            project_created: Option<AuditLogProjectCreated>,
            #[serde(rename = "project.updated")]
            #[allow(dead_code)]
            project_updated: Option<AuditLogProjectUpdated>,
            #[serde(rename = "project.archived")]
            #[allow(dead_code)]
            project_archived: Option<AuditLogProjectArchived>,
            #[serde(rename = "rate_limit.updated")]
            #[allow(dead_code)]
            rate_limit_updated: Option<AuditLogRateLimitUpdated>,
            #[serde(rename = "rate_limit.deleted")]
            #[allow(dead_code)]
            rate_limit_deleted: Option<AuditLogRateLimitDeleted>,
            #[serde(rename = "service_account.created")]
            #[allow(dead_code)]
            service_account_created: Option<AuditLogServiceAccountCreated>,
            #[serde(rename = "service_account.updated")]
            #[allow(dead_code)]
            service_account_updated: Option<AuditLogServiceAccountUpdated>,
            #[serde(rename = "service_account.deleted")]
            #[allow(dead_code)]
            service_account_deleted: Option<AuditLogServiceAccountDeleted>,
            #[serde(rename = "user.added")]
            #[allow(dead_code)]
            user_added: Option<AuditLogUserAdded>,
            #[serde(rename = "user.updated")]
            #[allow(dead_code)]
            user_updated: Option<AuditLogUserUpdated>,
            #[serde(rename = "user.deleted")]
            #[allow(dead_code)]
            user_deleted: Option<AuditLogUserDeleted>,
            #[serde(rename = "certificate.created")]
            #[allow(dead_code)]
            certificate_created: Option<AuditLogCertificateCreated>,
            #[serde(rename = "certificate.updated")]
            #[allow(dead_code)]
            certificate_updated: Option<AuditLogCertificateUpdated>,
            #[serde(rename = "certificate.deleted")]
            #[allow(dead_code)]
            certificate_deleted: Option<AuditLogCertificateDeleted>,
            #[serde(rename = "certificates.activated")]
            #[allow(dead_code)]
            certificates_activated: Option<AuditLogCertificatesActivated>,
            #[serde(rename = "certificates.deactivated")]
            #[allow(dead_code)]
            certificates_deactivated: Option<AuditLogCertificatesDeactivated>,
        }
        let AuditLog {
            id,
            type_,
            effective_at,
            project,
            actor,
            api_key_created,
            api_key_updated,
            api_key_deleted,
            checkpoint_permission_created,
            checkpoint_permission_deleted,
            invite_sent,
            invite_accepted,
            invite_deleted,
            login_failed,
            logout_failed,
            organization_updated,
            project_created,
            project_updated,
            project_archived,
            rate_limit_updated,
            rate_limit_deleted,
            service_account_created,
            service_account_updated,
            service_account_deleted,
            user_added,
            user_updated,
            user_deleted,
            certificate_created,
            certificate_updated,
            certificate_deleted,
            certificates_activated,
            certificates_deactivated,
            ..
        } = AuditLog::deserialize(deserializer)?;
        Ok(Self {
            id,
            type_,
            effective_at,
            project,
            actor,
            api_key_created,
            api_key_updated,
            api_key_deleted,
            checkpoint_permission_created,
            checkpoint_permission_deleted,
            invite_sent,
            invite_accepted,
            invite_deleted,
            login_failed,
            logout_failed,
            organization_updated,
            project_created,
            project_updated,
            project_archived,
            rate_limit_updated,
            rate_limit_deleted,
            service_account_created,
            service_account_updated,
            service_account_deleted,
            user_added,
            user_updated,
            user_deleted,
            certificate_created,
            certificate_updated,
            certificate_deleted,
            certificates_activated,
            certificates_deactivated,
        })
    }
}
impl serde::Serialize for AuditLog {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLog<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a AuditLogEventType,
            #[serde(rename = "effective_at")]
            effective_at: &'a u64,
            #[serde(rename = "project")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project: &'a Option<AuditLogProject>,
            #[serde(rename = "actor")]
            actor: &'a AuditLogActor,
            #[serde(rename = "api_key.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_created: &'a Option<AuditLogApiKeyCreated>,
            #[serde(rename = "api_key.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_updated: &'a Option<AuditLogApiKeyUpdated>,
            #[serde(rename = "api_key.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_deleted: &'a Option<AuditLogApiKeyDeleted>,
            #[serde(rename = "checkpoint_permission.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            checkpoint_permission_created: &'a Option<AuditLogCheckpointPermissionCreated>,
            #[serde(rename = "checkpoint_permission.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            checkpoint_permission_deleted: &'a Option<AuditLogCheckpointPermissionDeleted>,
            #[serde(rename = "invite.sent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            invite_sent: &'a Option<AuditLogInviteSent>,
            #[serde(rename = "invite.accepted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            invite_accepted: &'a Option<AuditLogInviteAccepted>,
            #[serde(rename = "invite.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            invite_deleted: &'a Option<AuditLogInviteDeleted>,
            #[serde(rename = "login.failed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            login_failed: &'a Option<AuditLogLoginFailed>,
            #[serde(rename = "logout.failed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logout_failed: &'a Option<AuditLogLogoutFailed>,
            #[serde(rename = "organization.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            organization_updated: &'a Option<AuditLogOrganizationUpdated>,
            #[serde(rename = "project.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_created: &'a Option<AuditLogProjectCreated>,
            #[serde(rename = "project.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_updated: &'a Option<AuditLogProjectUpdated>,
            #[serde(rename = "project.archived")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_archived: &'a Option<AuditLogProjectArchived>,
            #[serde(rename = "rate_limit.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            rate_limit_updated: &'a Option<AuditLogRateLimitUpdated>,
            #[serde(rename = "rate_limit.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            rate_limit_deleted: &'a Option<AuditLogRateLimitDeleted>,
            #[serde(rename = "service_account.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account_created: &'a Option<AuditLogServiceAccountCreated>,
            #[serde(rename = "service_account.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account_updated: &'a Option<AuditLogServiceAccountUpdated>,
            #[serde(rename = "service_account.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account_deleted: &'a Option<AuditLogServiceAccountDeleted>,
            #[serde(rename = "user.added")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_added: &'a Option<AuditLogUserAdded>,
            #[serde(rename = "user.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_updated: &'a Option<AuditLogUserUpdated>,
            #[serde(rename = "user.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_deleted: &'a Option<AuditLogUserDeleted>,
            #[serde(rename = "certificate.created")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificate_created: &'a Option<AuditLogCertificateCreated>,
            #[serde(rename = "certificate.updated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificate_updated: &'a Option<AuditLogCertificateUpdated>,
            #[serde(rename = "certificate.deleted")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificate_deleted: &'a Option<AuditLogCertificateDeleted>,
            #[serde(rename = "certificates.activated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificates_activated: &'a Option<AuditLogCertificatesActivated>,
            #[serde(rename = "certificates.deactivated")]
            #[serde(skip_serializing_if = "Option::is_none")]
            certificates_deactivated: &'a Option<AuditLogCertificatesDeactivated>,
        }
        let Self {
            id,
            type_,
            effective_at,
            project,
            actor,
            api_key_created,
            api_key_updated,
            api_key_deleted,
            checkpoint_permission_created,
            checkpoint_permission_deleted,
            invite_sent,
            invite_accepted,
            invite_deleted,
            login_failed,
            logout_failed,
            organization_updated,
            project_created,
            project_updated,
            project_archived,
            rate_limit_updated,
            rate_limit_deleted,
            service_account_created,
            service_account_updated,
            service_account_deleted,
            user_added,
            user_updated,
            user_deleted,
            certificate_created,
            certificate_updated,
            certificate_deleted,
            certificates_activated,
            certificates_deactivated,
        } = self;
        AuditLog {
            id,
            type_,
            effective_at,
            project,
            actor,
            api_key_created,
            api_key_updated,
            api_key_deleted,
            checkpoint_permission_created,
            checkpoint_permission_deleted,
            invite_sent,
            invite_accepted,
            invite_deleted,
            login_failed,
            logout_failed,
            organization_updated,
            project_created,
            project_updated,
            project_archived,
            rate_limit_updated,
            rate_limit_deleted,
            service_account_created,
            service_account_updated,
            service_account_deleted,
            user_added,
            user_updated,
            user_deleted,
            certificate_created,
            certificate_updated,
            certificate_deleted,
            certificates_activated,
            certificates_deactivated,
        }
        .serialize(serializer)
    }
}
#[doc = "A log of a user action or configuration change within this organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AuditLog {
    #[doc = "The ID of this log."]
    pub id: String,
    pub type_: AuditLogEventType,
    #[doc = "The Unix timestamp (in seconds) of the event."]
    pub effective_at: u64,
    #[doc = "The project that the action was scoped to. Absent for actions not scoped to projects."]
    #[builder(default)]
    pub project: Option<AuditLogProject>,
    #[builder(default)]
    pub actor: AuditLogActor,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub api_key_created: Option<AuditLogApiKeyCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub api_key_updated: Option<AuditLogApiKeyUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub api_key_deleted: Option<AuditLogApiKeyDeleted>,
    #[doc = "The project and fine-tuned model checkpoint that the checkpoint permission was created for."]
    #[builder(default)]
    pub checkpoint_permission_created: Option<AuditLogCheckpointPermissionCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub checkpoint_permission_deleted: Option<AuditLogCheckpointPermissionDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub invite_sent: Option<AuditLogInviteSent>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub invite_accepted: Option<AuditLogInviteAccepted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub invite_deleted: Option<AuditLogInviteDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub login_failed: Option<AuditLogLoginFailed>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub logout_failed: Option<AuditLogLogoutFailed>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub organization_updated: Option<AuditLogOrganizationUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub project_created: Option<AuditLogProjectCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub project_updated: Option<AuditLogProjectUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub project_archived: Option<AuditLogProjectArchived>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub rate_limit_updated: Option<AuditLogRateLimitUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub rate_limit_deleted: Option<AuditLogRateLimitDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub service_account_created: Option<AuditLogServiceAccountCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub service_account_updated: Option<AuditLogServiceAccountUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub service_account_deleted: Option<AuditLogServiceAccountDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub user_added: Option<AuditLogUserAdded>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub user_updated: Option<AuditLogUserUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub user_deleted: Option<AuditLogUserDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificate_created: Option<AuditLogCertificateCreated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificate_updated: Option<AuditLogCertificateUpdated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificate_deleted: Option<AuditLogCertificateDeleted>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificates_activated: Option<AuditLogCertificatesActivated>,
    #[doc = "The details for events with this `type`."]
    #[builder(default)]
    pub certificates_deactivated: Option<AuditLogCertificatesDeactivated>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorTypeSession {
            #[default]
            #[serde(rename = "session")]
            Session,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorTypeApiKey {
            #[default]
            #[serde(rename = "api_key")]
            ApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AuditLogActorType {
            Session(#[allow(dead_code)] AuditLogActorTypeSession),
            ApiKey(#[allow(dead_code)] AuditLogActorTypeApiKey),
        }
        Ok(match AuditLogActorType::deserialize(deserializer)? {
            AuditLogActorType::Session(_) => Self::Session,
            AuditLogActorType::ApiKey(_) => Self::ApiKey,
        })
    }
}
impl serde::Serialize for AuditLogActorType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorTypeSession {
            #[default]
            #[serde(rename = "session")]
            Session,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorTypeApiKey {
            #[default]
            #[serde(rename = "api_key")]
            ApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AuditLogActorType<'a> {
            Session(#[allow(dead_code)] &'a AuditLogActorTypeSession),
            ApiKey(#[allow(dead_code)] &'a AuditLogActorTypeApiKey),
        }
        match self {
            Self::Session => AuditLogActorType::Session(&Default::default()).serialize(serializer),
            Self::ApiKey => AuditLogActorType::ApiKey(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of actor. Is either `session` or `api_key`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AuditLogActorType {
    #[doc = "session"]
    Session,
    #[doc = "api_key"]
    ApiKey,
}
impl<'de> serde::Deserialize<'de> for AuditLogActor {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogActor {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<AuditLogActorType>,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: Option<AuditLogActorSession>,
            #[serde(rename = "api_key")]
            #[allow(dead_code)]
            api_key: Option<AuditLogActorApiKey>,
        }
        let AuditLogActor {
            type_,
            session,
            api_key,
            ..
        } = AuditLogActor::deserialize(deserializer)?;
        Ok(Self {
            type_,
            session,
            api_key,
        })
    }
}
impl serde::Serialize for AuditLogActor {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogActor<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<AuditLogActorType>,
            #[serde(rename = "session")]
            #[serde(skip_serializing_if = "Option::is_none")]
            session: &'a Option<AuditLogActorSession>,
            #[serde(rename = "api_key")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key: &'a Option<AuditLogActorApiKey>,
        }
        let Self {
            type_,
            session,
            api_key,
        } = self;
        AuditLogActor {
            type_,
            session,
            api_key,
        }
        .serialize(serializer)
    }
}
#[doc = "The actor who performed the audit logged action."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActor {
    #[doc = "The type of actor. Is either `session` or `api_key`."]
    #[builder(default)]
    pub type_: Option<AuditLogActorType>,
    #[builder(default)]
    pub session: Option<AuditLogActorSession>,
    #[builder(default)]
    pub api_key: Option<AuditLogActorApiKey>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorApiKeyType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorApiKeyTypeUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorApiKeyTypeServiceAccount {
            #[default]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AuditLogActorApiKeyType {
            User(#[allow(dead_code)] AuditLogActorApiKeyTypeUser),
            ServiceAccount(#[allow(dead_code)] AuditLogActorApiKeyTypeServiceAccount),
        }
        Ok(match AuditLogActorApiKeyType::deserialize(deserializer)? {
            AuditLogActorApiKeyType::User(_) => Self::User,
            AuditLogActorApiKeyType::ServiceAccount(_) => Self::ServiceAccount,
        })
    }
}
impl serde::Serialize for AuditLogActorApiKeyType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorApiKeyTypeUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogActorApiKeyTypeServiceAccount {
            #[default]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AuditLogActorApiKeyType<'a> {
            User(#[allow(dead_code)] &'a AuditLogActorApiKeyTypeUser),
            ServiceAccount(#[allow(dead_code)] &'a AuditLogActorApiKeyTypeServiceAccount),
        }
        match self {
            Self::User => AuditLogActorApiKeyType::User(&Default::default()).serialize(serializer),
            Self::ServiceAccount => {
                AuditLogActorApiKeyType::ServiceAccount(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of API key. Can be either `user` or `service_account`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AuditLogActorApiKeyType {
    #[doc = "user"]
    User,
    #[doc = "service_account"]
    ServiceAccount,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogActorApiKey {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<AuditLogActorApiKeyType>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<AuditLogActorUser>,
            #[serde(rename = "service_account")]
            #[allow(dead_code)]
            service_account: Option<AuditLogActorServiceAccount>,
        }
        let AuditLogActorApiKey {
            id,
            type_,
            user,
            service_account,
            ..
        } = AuditLogActorApiKey::deserialize(deserializer)?;
        Ok(Self {
            id,
            type_,
            user,
            service_account,
        })
    }
}
impl serde::Serialize for AuditLogActorApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogActorApiKey<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<AuditLogActorApiKeyType>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<AuditLogActorUser>,
            #[serde(rename = "service_account")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account: &'a Option<AuditLogActorServiceAccount>,
        }
        let Self {
            id,
            type_,
            user,
            service_account,
        } = self;
        AuditLogActorApiKey {
            id,
            type_,
            user,
            service_account,
        }
        .serialize(serializer)
    }
}
#[doc = "The API Key used to perform the audit logged action."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActorApiKey {
    #[doc = "The tracking id of the API key."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of API key. Can be either `user` or `service_account`."]
    #[builder(default)]
    pub type_: Option<AuditLogActorApiKeyType>,
    #[builder(default)]
    pub user: Option<AuditLogActorUser>,
    #[builder(default)]
    pub service_account: Option<AuditLogActorServiceAccount>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorServiceAccount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogActorServiceAccount {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
        }
        let AuditLogActorServiceAccount { id, .. } =
            AuditLogActorServiceAccount::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for AuditLogActorServiceAccount {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogActorServiceAccount<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
        }
        let Self { id } = self;
        AuditLogActorServiceAccount { id }.serialize(serializer)
    }
}
#[doc = "The service account that performed the audit logged action."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActorServiceAccount {
    #[doc = "The service account id."]
    #[builder(default)]
    pub id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorSession {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogActorSession {
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<AuditLogActorUser>,
            #[serde(rename = "ip_address")]
            #[allow(dead_code)]
            ip_address: Option<String>,
        }
        let AuditLogActorSession {
            user, ip_address, ..
        } = AuditLogActorSession::deserialize(deserializer)?;
        Ok(Self { user, ip_address })
    }
}
impl serde::Serialize for AuditLogActorSession {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogActorSession<'a> {
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<AuditLogActorUser>,
            #[serde(rename = "ip_address")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ip_address: &'a Option<String>,
        }
        let Self { user, ip_address } = self;
        AuditLogActorSession { user, ip_address }.serialize(serializer)
    }
}
#[doc = "The session in which the audit logged action was performed."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActorSession {
    #[builder(default)]
    pub user: Option<AuditLogActorUser>,
    #[doc = "The IP address from which the action was performed."]
    #[builder(default)]
    pub ip_address: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogActorUser {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AuditLogActorUser {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: Option<String>,
        }
        let AuditLogActorUser { id, email, .. } = AuditLogActorUser::deserialize(deserializer)?;
        Ok(Self { id, email })
    }
}
impl serde::Serialize for AuditLogActorUser {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AuditLogActorUser<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "email")]
            #[serde(skip_serializing_if = "Option::is_none")]
            email: &'a Option<String>,
        }
        let Self { id, email } = self;
        AuditLogActorUser { id, email }.serialize(serializer)
    }
}
#[doc = "The user who performed the audit logged action."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct AuditLogActorUser {
    #[doc = "The user id."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The user email."]
    #[builder(default)]
    pub email: Option<String>,
}
impl<'de> serde::Deserialize<'de> for AuditLogEventType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyCreated {
            #[default]
            #[serde(rename = "api_key.created")]
            ApiKeyCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyUpdated {
            #[default]
            #[serde(rename = "api_key.updated")]
            ApiKeyUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyDeleted {
            #[default]
            #[serde(rename = "api_key.deleted")]
            ApiKeyDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeCheckpointPermissionCreated {
            #[default]
            #[serde(rename = "checkpoint_permission.created")]
            CheckpointPermissionCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeCheckpointPermissionDeleted {
            #[default]
            #[serde(rename = "checkpoint_permission.deleted")]
            CheckpointPermissionDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteSent {
            #[default]
            #[serde(rename = "invite.sent")]
            InviteSent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteAccepted {
            #[default]
            #[serde(rename = "invite.accepted")]
            InviteAccepted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteDeleted {
            #[default]
            #[serde(rename = "invite.deleted")]
            InviteDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLoginSucceeded {
            #[default]
            #[serde(rename = "login.succeeded")]
            LoginSucceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLoginFailed {
            #[default]
            #[serde(rename = "login.failed")]
            LoginFailed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLogoutSucceeded {
            #[default]
            #[serde(rename = "logout.succeeded")]
            LogoutSucceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLogoutFailed {
            #[default]
            #[serde(rename = "logout.failed")]
            LogoutFailed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeOrganizationUpdated {
            #[default]
            #[serde(rename = "organization.updated")]
            OrganizationUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectCreated {
            #[default]
            #[serde(rename = "project.created")]
            ProjectCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectUpdated {
            #[default]
            #[serde(rename = "project.updated")]
            ProjectUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectArchived {
            #[default]
            #[serde(rename = "project.archived")]
            ProjectArchived,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountCreated {
            #[default]
            #[serde(rename = "service_account.created")]
            ServiceAccountCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountUpdated {
            #[default]
            #[serde(rename = "service_account.updated")]
            ServiceAccountUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountDeleted {
            #[default]
            #[serde(rename = "service_account.deleted")]
            ServiceAccountDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeRateLimitUpdated {
            #[default]
            #[serde(rename = "rate_limit.updated")]
            RateLimitUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeRateLimitDeleted {
            #[default]
            #[serde(rename = "rate_limit.deleted")]
            RateLimitDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserAdded {
            #[default]
            #[serde(rename = "user.added")]
            UserAdded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserUpdated {
            #[default]
            #[serde(rename = "user.updated")]
            UserUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserDeleted {
            #[default]
            #[serde(rename = "user.deleted")]
            UserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AuditLogEventType {
            ApiKeyCreated(#[allow(dead_code)] AuditLogEventTypeApiKeyCreated),
            ApiKeyUpdated(#[allow(dead_code)] AuditLogEventTypeApiKeyUpdated),
            ApiKeyDeleted(#[allow(dead_code)] AuditLogEventTypeApiKeyDeleted),
            CheckpointPermissionCreated(
                #[allow(dead_code)] AuditLogEventTypeCheckpointPermissionCreated,
            ),
            CheckpointPermissionDeleted(
                #[allow(dead_code)] AuditLogEventTypeCheckpointPermissionDeleted,
            ),
            InviteSent(#[allow(dead_code)] AuditLogEventTypeInviteSent),
            InviteAccepted(#[allow(dead_code)] AuditLogEventTypeInviteAccepted),
            InviteDeleted(#[allow(dead_code)] AuditLogEventTypeInviteDeleted),
            LoginSucceeded(#[allow(dead_code)] AuditLogEventTypeLoginSucceeded),
            LoginFailed(#[allow(dead_code)] AuditLogEventTypeLoginFailed),
            LogoutSucceeded(#[allow(dead_code)] AuditLogEventTypeLogoutSucceeded),
            LogoutFailed(#[allow(dead_code)] AuditLogEventTypeLogoutFailed),
            OrganizationUpdated(#[allow(dead_code)] AuditLogEventTypeOrganizationUpdated),
            ProjectCreated(#[allow(dead_code)] AuditLogEventTypeProjectCreated),
            ProjectUpdated(#[allow(dead_code)] AuditLogEventTypeProjectUpdated),
            ProjectArchived(#[allow(dead_code)] AuditLogEventTypeProjectArchived),
            ServiceAccountCreated(#[allow(dead_code)] AuditLogEventTypeServiceAccountCreated),
            ServiceAccountUpdated(#[allow(dead_code)] AuditLogEventTypeServiceAccountUpdated),
            ServiceAccountDeleted(#[allow(dead_code)] AuditLogEventTypeServiceAccountDeleted),
            RateLimitUpdated(#[allow(dead_code)] AuditLogEventTypeRateLimitUpdated),
            RateLimitDeleted(#[allow(dead_code)] AuditLogEventTypeRateLimitDeleted),
            UserAdded(#[allow(dead_code)] AuditLogEventTypeUserAdded),
            UserUpdated(#[allow(dead_code)] AuditLogEventTypeUserUpdated),
            UserDeleted(#[allow(dead_code)] AuditLogEventTypeUserDeleted),
        }
        Ok(match AuditLogEventType::deserialize(deserializer)? {
            AuditLogEventType::ApiKeyCreated(_) => Self::ApiKeyCreated,
            AuditLogEventType::ApiKeyUpdated(_) => Self::ApiKeyUpdated,
            AuditLogEventType::ApiKeyDeleted(_) => Self::ApiKeyDeleted,
            AuditLogEventType::CheckpointPermissionCreated(_) => Self::CheckpointPermissionCreated,
            AuditLogEventType::CheckpointPermissionDeleted(_) => Self::CheckpointPermissionDeleted,
            AuditLogEventType::InviteSent(_) => Self::InviteSent,
            AuditLogEventType::InviteAccepted(_) => Self::InviteAccepted,
            AuditLogEventType::InviteDeleted(_) => Self::InviteDeleted,
            AuditLogEventType::LoginSucceeded(_) => Self::LoginSucceeded,
            AuditLogEventType::LoginFailed(_) => Self::LoginFailed,
            AuditLogEventType::LogoutSucceeded(_) => Self::LogoutSucceeded,
            AuditLogEventType::LogoutFailed(_) => Self::LogoutFailed,
            AuditLogEventType::OrganizationUpdated(_) => Self::OrganizationUpdated,
            AuditLogEventType::ProjectCreated(_) => Self::ProjectCreated,
            AuditLogEventType::ProjectUpdated(_) => Self::ProjectUpdated,
            AuditLogEventType::ProjectArchived(_) => Self::ProjectArchived,
            AuditLogEventType::ServiceAccountCreated(_) => Self::ServiceAccountCreated,
            AuditLogEventType::ServiceAccountUpdated(_) => Self::ServiceAccountUpdated,
            AuditLogEventType::ServiceAccountDeleted(_) => Self::ServiceAccountDeleted,
            AuditLogEventType::RateLimitUpdated(_) => Self::RateLimitUpdated,
            AuditLogEventType::RateLimitDeleted(_) => Self::RateLimitDeleted,
            AuditLogEventType::UserAdded(_) => Self::UserAdded,
            AuditLogEventType::UserUpdated(_) => Self::UserUpdated,
            AuditLogEventType::UserDeleted(_) => Self::UserDeleted,
        })
    }
}
impl serde::Serialize for AuditLogEventType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyCreated {
            #[default]
            #[serde(rename = "api_key.created")]
            ApiKeyCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyUpdated {
            #[default]
            #[serde(rename = "api_key.updated")]
            ApiKeyUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeApiKeyDeleted {
            #[default]
            #[serde(rename = "api_key.deleted")]
            ApiKeyDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeCheckpointPermissionCreated {
            #[default]
            #[serde(rename = "checkpoint_permission.created")]
            CheckpointPermissionCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeCheckpointPermissionDeleted {
            #[default]
            #[serde(rename = "checkpoint_permission.deleted")]
            CheckpointPermissionDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteSent {
            #[default]
            #[serde(rename = "invite.sent")]
            InviteSent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteAccepted {
            #[default]
            #[serde(rename = "invite.accepted")]
            InviteAccepted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeInviteDeleted {
            #[default]
            #[serde(rename = "invite.deleted")]
            InviteDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLoginSucceeded {
            #[default]
            #[serde(rename = "login.succeeded")]
            LoginSucceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLoginFailed {
            #[default]
            #[serde(rename = "login.failed")]
            LoginFailed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLogoutSucceeded {
            #[default]
            #[serde(rename = "logout.succeeded")]
            LogoutSucceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeLogoutFailed {
            #[default]
            #[serde(rename = "logout.failed")]
            LogoutFailed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeOrganizationUpdated {
            #[default]
            #[serde(rename = "organization.updated")]
            OrganizationUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectCreated {
            #[default]
            #[serde(rename = "project.created")]
            ProjectCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectUpdated {
            #[default]
            #[serde(rename = "project.updated")]
            ProjectUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeProjectArchived {
            #[default]
            #[serde(rename = "project.archived")]
            ProjectArchived,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountCreated {
            #[default]
            #[serde(rename = "service_account.created")]
            ServiceAccountCreated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountUpdated {
            #[default]
            #[serde(rename = "service_account.updated")]
            ServiceAccountUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeServiceAccountDeleted {
            #[default]
            #[serde(rename = "service_account.deleted")]
            ServiceAccountDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeRateLimitUpdated {
            #[default]
            #[serde(rename = "rate_limit.updated")]
            RateLimitUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeRateLimitDeleted {
            #[default]
            #[serde(rename = "rate_limit.deleted")]
            RateLimitDeleted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserAdded {
            #[default]
            #[serde(rename = "user.added")]
            UserAdded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserUpdated {
            #[default]
            #[serde(rename = "user.updated")]
            UserUpdated,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AuditLogEventTypeUserDeleted {
            #[default]
            #[serde(rename = "user.deleted")]
            UserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AuditLogEventType<'a> {
            ApiKeyCreated(#[allow(dead_code)] &'a AuditLogEventTypeApiKeyCreated),
            ApiKeyUpdated(#[allow(dead_code)] &'a AuditLogEventTypeApiKeyUpdated),
            ApiKeyDeleted(#[allow(dead_code)] &'a AuditLogEventTypeApiKeyDeleted),
            CheckpointPermissionCreated(
                #[allow(dead_code)] &'a AuditLogEventTypeCheckpointPermissionCreated,
            ),
            CheckpointPermissionDeleted(
                #[allow(dead_code)] &'a AuditLogEventTypeCheckpointPermissionDeleted,
            ),
            InviteSent(#[allow(dead_code)] &'a AuditLogEventTypeInviteSent),
            InviteAccepted(#[allow(dead_code)] &'a AuditLogEventTypeInviteAccepted),
            InviteDeleted(#[allow(dead_code)] &'a AuditLogEventTypeInviteDeleted),
            LoginSucceeded(#[allow(dead_code)] &'a AuditLogEventTypeLoginSucceeded),
            LoginFailed(#[allow(dead_code)] &'a AuditLogEventTypeLoginFailed),
            LogoutSucceeded(#[allow(dead_code)] &'a AuditLogEventTypeLogoutSucceeded),
            LogoutFailed(#[allow(dead_code)] &'a AuditLogEventTypeLogoutFailed),
            OrganizationUpdated(#[allow(dead_code)] &'a AuditLogEventTypeOrganizationUpdated),
            ProjectCreated(#[allow(dead_code)] &'a AuditLogEventTypeProjectCreated),
            ProjectUpdated(#[allow(dead_code)] &'a AuditLogEventTypeProjectUpdated),
            ProjectArchived(#[allow(dead_code)] &'a AuditLogEventTypeProjectArchived),
            ServiceAccountCreated(#[allow(dead_code)] &'a AuditLogEventTypeServiceAccountCreated),
            ServiceAccountUpdated(#[allow(dead_code)] &'a AuditLogEventTypeServiceAccountUpdated),
            ServiceAccountDeleted(#[allow(dead_code)] &'a AuditLogEventTypeServiceAccountDeleted),
            RateLimitUpdated(#[allow(dead_code)] &'a AuditLogEventTypeRateLimitUpdated),
            RateLimitDeleted(#[allow(dead_code)] &'a AuditLogEventTypeRateLimitDeleted),
            UserAdded(#[allow(dead_code)] &'a AuditLogEventTypeUserAdded),
            UserUpdated(#[allow(dead_code)] &'a AuditLogEventTypeUserUpdated),
            UserDeleted(#[allow(dead_code)] &'a AuditLogEventTypeUserDeleted),
        }
        match self {
            Self::ApiKeyCreated => {
                AuditLogEventType::ApiKeyCreated(&Default::default()).serialize(serializer)
            }
            Self::ApiKeyUpdated => {
                AuditLogEventType::ApiKeyUpdated(&Default::default()).serialize(serializer)
            }
            Self::ApiKeyDeleted => {
                AuditLogEventType::ApiKeyDeleted(&Default::default()).serialize(serializer)
            }
            Self::CheckpointPermissionCreated => {
                AuditLogEventType::CheckpointPermissionCreated(&Default::default())
                    .serialize(serializer)
            }
            Self::CheckpointPermissionDeleted => {
                AuditLogEventType::CheckpointPermissionDeleted(&Default::default())
                    .serialize(serializer)
            }
            Self::InviteSent => {
                AuditLogEventType::InviteSent(&Default::default()).serialize(serializer)
            }
            Self::InviteAccepted => {
                AuditLogEventType::InviteAccepted(&Default::default()).serialize(serializer)
            }
            Self::InviteDeleted => {
                AuditLogEventType::InviteDeleted(&Default::default()).serialize(serializer)
            }
            Self::LoginSucceeded => {
                AuditLogEventType::LoginSucceeded(&Default::default()).serialize(serializer)
            }
            Self::LoginFailed => {
                AuditLogEventType::LoginFailed(&Default::default()).serialize(serializer)
            }
            Self::LogoutSucceeded => {
                AuditLogEventType::LogoutSucceeded(&Default::default()).serialize(serializer)
            }
            Self::LogoutFailed => {
                AuditLogEventType::LogoutFailed(&Default::default()).serialize(serializer)
            }
            Self::OrganizationUpdated => {
                AuditLogEventType::OrganizationUpdated(&Default::default()).serialize(serializer)
            }
            Self::ProjectCreated => {
                AuditLogEventType::ProjectCreated(&Default::default()).serialize(serializer)
            }
            Self::ProjectUpdated => {
                AuditLogEventType::ProjectUpdated(&Default::default()).serialize(serializer)
            }
            Self::ProjectArchived => {
                AuditLogEventType::ProjectArchived(&Default::default()).serialize(serializer)
            }
            Self::ServiceAccountCreated => {
                AuditLogEventType::ServiceAccountCreated(&Default::default()).serialize(serializer)
            }
            Self::ServiceAccountUpdated => {
                AuditLogEventType::ServiceAccountUpdated(&Default::default()).serialize(serializer)
            }
            Self::ServiceAccountDeleted => {
                AuditLogEventType::ServiceAccountDeleted(&Default::default()).serialize(serializer)
            }
            Self::RateLimitUpdated => {
                AuditLogEventType::RateLimitUpdated(&Default::default()).serialize(serializer)
            }
            Self::RateLimitDeleted => {
                AuditLogEventType::RateLimitDeleted(&Default::default()).serialize(serializer)
            }
            Self::UserAdded => {
                AuditLogEventType::UserAdded(&Default::default()).serialize(serializer)
            }
            Self::UserUpdated => {
                AuditLogEventType::UserUpdated(&Default::default()).serialize(serializer)
            }
            Self::UserDeleted => {
                AuditLogEventType::UserDeleted(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The event type."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum AuditLogEventType {
    #[doc = "api_key.created"]
    ApiKeyCreated,
    #[doc = "api_key.updated"]
    ApiKeyUpdated,
    #[doc = "api_key.deleted"]
    ApiKeyDeleted,
    #[doc = "checkpoint_permission.created"]
    CheckpointPermissionCreated,
    #[doc = "checkpoint_permission.deleted"]
    CheckpointPermissionDeleted,
    #[doc = "invite.sent"]
    InviteSent,
    #[doc = "invite.accepted"]
    InviteAccepted,
    #[doc = "invite.deleted"]
    InviteDeleted,
    #[doc = "login.succeeded"]
    LoginSucceeded,
    #[doc = "login.failed"]
    LoginFailed,
    #[doc = "logout.succeeded"]
    LogoutSucceeded,
    #[doc = "logout.failed"]
    LogoutFailed,
    #[doc = "organization.updated"]
    OrganizationUpdated,
    #[doc = "project.created"]
    ProjectCreated,
    #[doc = "project.updated"]
    ProjectUpdated,
    #[doc = "project.archived"]
    ProjectArchived,
    #[doc = "service_account.created"]
    ServiceAccountCreated,
    #[doc = "service_account.updated"]
    ServiceAccountUpdated,
    #[doc = "service_account.deleted"]
    ServiceAccountDeleted,
    #[doc = "rate_limit.updated"]
    RateLimitUpdated,
    #[doc = "rate_limit.deleted"]
    RateLimitDeleted,
    #[doc = "user.added"]
    UserAdded,
    #[doc = "user.updated"]
    UserUpdated,
    #[doc = "user.deleted"]
    UserDeleted,
}
impl<'de> serde::Deserialize<'de> for AutoChunkingStrategyRequestParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AutoChunkingStrategyRequestParamType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AutoChunkingStrategyRequestParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: AutoChunkingStrategyRequestParamType,
        }
        let AutoChunkingStrategyRequestParam { .. } =
            AutoChunkingStrategyRequestParam::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for AutoChunkingStrategyRequestParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum AutoChunkingStrategyRequestParamType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AutoChunkingStrategyRequestParam<'a> {
            #[serde(rename = "type")]
            type_: &'a AutoChunkingStrategyRequestParamType,
        }
        let Self {} = self;
        AutoChunkingStrategyRequestParam {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct AutoChunkingStrategyRequestParam {}
impl<'de> serde::Deserialize<'de> for BatchErrors {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct BatchErrors {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<Vec<BatchError>>,
        }
        let BatchErrors { object, data, .. } = BatchErrors::deserialize(deserializer)?;
        Ok(Self { object, data })
    }
}
impl serde::Serialize for BatchErrors {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct BatchErrors<'a> {
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<String>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<Vec<BatchError>>,
        }
        let Self { object, data } = self;
        BatchErrors { object, data }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchErrors {
    #[doc = "The object type, which is always `list`."]
    #[builder(default)]
    pub object: Option<String>,
    #[builder(default)]
    pub data: Option<Vec<BatchError>>,
}
impl<'de> serde::Deserialize<'de> for BatchStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusValidating {
            #[default]
            #[serde(rename = "validating")]
            Validating,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusFinalizing {
            #[default]
            #[serde(rename = "finalizing")]
            Finalizing,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCancelling {
            #[default]
            #[serde(rename = "cancelling")]
            Cancelling,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum BatchStatus {
            Validating(#[allow(dead_code)] BatchStatusValidating),
            Failed(#[allow(dead_code)] BatchStatusFailed),
            InProgress(#[allow(dead_code)] BatchStatusInProgress),
            Finalizing(#[allow(dead_code)] BatchStatusFinalizing),
            Completed(#[allow(dead_code)] BatchStatusCompleted),
            Expired(#[allow(dead_code)] BatchStatusExpired),
            Cancelling(#[allow(dead_code)] BatchStatusCancelling),
            Cancelled(#[allow(dead_code)] BatchStatusCancelled),
        }
        Ok(match BatchStatus::deserialize(deserializer)? {
            BatchStatus::Validating(_) => Self::Validating,
            BatchStatus::Failed(_) => Self::Failed,
            BatchStatus::InProgress(_) => Self::InProgress,
            BatchStatus::Finalizing(_) => Self::Finalizing,
            BatchStatus::Completed(_) => Self::Completed,
            BatchStatus::Expired(_) => Self::Expired,
            BatchStatus::Cancelling(_) => Self::Cancelling,
            BatchStatus::Cancelled(_) => Self::Cancelled,
        })
    }
}
impl serde::Serialize for BatchStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusValidating {
            #[default]
            #[serde(rename = "validating")]
            Validating,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusFinalizing {
            #[default]
            #[serde(rename = "finalizing")]
            Finalizing,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCancelling {
            #[default]
            #[serde(rename = "cancelling")]
            Cancelling,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum BatchStatus<'a> {
            Validating(#[allow(dead_code)] &'a BatchStatusValidating),
            Failed(#[allow(dead_code)] &'a BatchStatusFailed),
            InProgress(#[allow(dead_code)] &'a BatchStatusInProgress),
            Finalizing(#[allow(dead_code)] &'a BatchStatusFinalizing),
            Completed(#[allow(dead_code)] &'a BatchStatusCompleted),
            Expired(#[allow(dead_code)] &'a BatchStatusExpired),
            Cancelling(#[allow(dead_code)] &'a BatchStatusCancelling),
            Cancelled(#[allow(dead_code)] &'a BatchStatusCancelled),
        }
        match self {
            Self::Validating => BatchStatus::Validating(&Default::default()).serialize(serializer),
            Self::Failed => BatchStatus::Failed(&Default::default()).serialize(serializer),
            Self::InProgress => BatchStatus::InProgress(&Default::default()).serialize(serializer),
            Self::Finalizing => BatchStatus::Finalizing(&Default::default()).serialize(serializer),
            Self::Completed => BatchStatus::Completed(&Default::default()).serialize(serializer),
            Self::Expired => BatchStatus::Expired(&Default::default()).serialize(serializer),
            Self::Cancelling => BatchStatus::Cancelling(&Default::default()).serialize(serializer),
            Self::Cancelled => BatchStatus::Cancelled(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The current status of the batch."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum BatchStatus {
    #[doc = "validating"]
    Validating,
    #[doc = "failed"]
    Failed,
    #[doc = "in_progress"]
    InProgress,
    #[doc = "finalizing"]
    Finalizing,
    #[doc = "completed"]
    Completed,
    #[doc = "expired"]
    Expired,
    #[doc = "cancelling"]
    Cancelling,
    #[doc = "cancelled"]
    Cancelled,
}
impl<'de> serde::Deserialize<'de> for Batch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `batch`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchObject {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Batch {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: BatchObject,
            #[serde(rename = "endpoint")]
            #[allow(dead_code)]
            endpoint: String,
            #[serde(rename = "errors")]
            #[allow(dead_code)]
            errors: Option<BatchErrors>,
            #[serde(rename = "input_file_id")]
            #[allow(dead_code)]
            input_file_id: String,
            #[serde(rename = "completion_window")]
            #[allow(dead_code)]
            completion_window: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: BatchStatus,
            #[serde(rename = "output_file_id")]
            #[allow(dead_code)]
            output_file_id: Option<String>,
            #[serde(rename = "error_file_id")]
            #[allow(dead_code)]
            error_file_id: Option<String>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "in_progress_at")]
            #[allow(dead_code)]
            in_progress_at: Option<u64>,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "finalizing_at")]
            #[allow(dead_code)]
            finalizing_at: Option<u64>,
            #[serde(rename = "completed_at")]
            #[allow(dead_code)]
            completed_at: Option<u64>,
            #[serde(rename = "failed_at")]
            #[allow(dead_code)]
            failed_at: Option<u64>,
            #[serde(rename = "expired_at")]
            #[allow(dead_code)]
            expired_at: Option<u64>,
            #[serde(rename = "cancelling_at")]
            #[allow(dead_code)]
            cancelling_at: Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[allow(dead_code)]
            cancelled_at: Option<u64>,
            #[serde(rename = "request_counts")]
            #[allow(dead_code)]
            request_counts: Option<BatchRequestCounts>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let Batch {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
            ..
        } = Batch::deserialize(deserializer)?;
        Ok(Self {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        })
    }
}
impl serde::Serialize for Batch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `batch`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum BatchObject {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Batch<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a BatchObject,
            #[serde(rename = "endpoint")]
            endpoint: &'a String,
            #[serde(rename = "errors")]
            #[serde(skip_serializing_if = "Option::is_none")]
            errors: &'a Option<BatchErrors>,
            #[serde(rename = "input_file_id")]
            input_file_id: &'a String,
            #[serde(rename = "completion_window")]
            completion_window: &'a String,
            #[serde(rename = "status")]
            status: &'a BatchStatus,
            #[serde(rename = "output_file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_file_id: &'a Option<String>,
            #[serde(rename = "error_file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_file_id: &'a Option<String>,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "in_progress_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            in_progress_at: &'a Option<u64>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "finalizing_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            finalizing_at: &'a Option<u64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<u64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<u64>,
            #[serde(rename = "expired_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expired_at: &'a Option<u64>,
            #[serde(rename = "cancelling_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelling_at: &'a Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<u64>,
            #[serde(rename = "request_counts")]
            #[serde(skip_serializing_if = "Option::is_none")]
            request_counts: &'a Option<BatchRequestCounts>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        } = self;
        Batch {
            id,
            object: &Default::default(),
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Batch {
    pub id: String,
    #[doc = "The OpenAI API endpoint used by the batch."]
    pub endpoint: String,
    #[builder(default)]
    pub errors: Option<BatchErrors>,
    #[doc = "The ID of the input file for the batch."]
    pub input_file_id: String,
    #[doc = "The time frame within which the batch should be processed."]
    pub completion_window: String,
    #[doc = "The current status of the batch."]
    pub status: BatchStatus,
    #[doc = "The ID of the file containing the outputs of successfully executed requests."]
    #[builder(default)]
    pub output_file_id: Option<String>,
    #[doc = "The ID of the file containing the outputs of requests with errors."]
    #[builder(default)]
    pub error_file_id: Option<String>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was created."]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) for when the batch started processing."]
    #[builder(default)]
    pub in_progress_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch will expire."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch started finalizing."]
    #[builder(default)]
    pub finalizing_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was completed."]
    #[builder(default)]
    pub completed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch failed."]
    #[builder(default)]
    pub failed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch expired."]
    #[builder(default)]
    pub expired_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch started cancelling."]
    #[builder(default)]
    pub cancelling_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<u64>,
    #[builder(default)]
    pub request_counts: Option<BatchRequestCounts>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
#[doc = "The HTTP method to be used for the request. Currently only `POST` is supported."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum BatchRequestInputMethod {
    #[default]
    #[serde(rename = "POST")]
    Post,
}
impl<'de> serde::Deserialize<'de> for BatchRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct BatchRequestInput {
            #[serde(rename = "custom_id")]
            #[allow(dead_code)]
            custom_id: Option<String>,
            #[serde(rename = "method")]
            #[allow(dead_code)]
            method: Option<BatchRequestInputMethod>,
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: Option<String>,
        }
        let BatchRequestInput {
            custom_id,
            method,
            url,
            ..
        } = BatchRequestInput::deserialize(deserializer)?;
        Ok(Self {
            custom_id,
            method,
            url,
        })
    }
}
impl serde::Serialize for BatchRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct BatchRequestInput<'a> {
            #[serde(rename = "custom_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            custom_id: &'a Option<String>,
            #[serde(rename = "method")]
            #[serde(skip_serializing_if = "Option::is_none")]
            method: &'a Option<BatchRequestInputMethod>,
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            url: &'a Option<String>,
        }
        let Self {
            custom_id,
            method,
            url,
        } = self;
        BatchRequestInput {
            custom_id,
            method,
            url,
        }
        .serialize(serializer)
    }
}
#[doc = "The per-line object of the batch input file"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchRequestInput {
    #[doc = "A developer-provided per-request id that will be used to match outputs to inputs. Must be unique for each request in a batch."]
    #[builder(default)]
    pub custom_id: Option<String>,
    #[doc = "The HTTP method to be used for the request. Currently only `POST` is supported."]
    #[builder(default)]
    pub method: Option<BatchRequestInputMethod>,
    #[doc = "The OpenAI API relative URL to be used for the request. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported."]
    #[builder(default)]
    pub url: Option<String>,
}
impl<'de> serde::Deserialize<'de> for BatchRequestOutputResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct BatchRequestOutputResponse {
            #[serde(rename = "status_code")]
            #[allow(dead_code)]
            status_code: Option<u64>,
            #[serde(rename = "request_id")]
            #[allow(dead_code)]
            request_id: Option<String>,
            #[serde(rename = "body")]
            #[allow(dead_code)]
            body: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let BatchRequestOutputResponse {
            status_code,
            request_id,
            body,
            ..
        } = BatchRequestOutputResponse::deserialize(deserializer)?;
        Ok(Self {
            status_code,
            request_id,
            body,
        })
    }
}
impl serde::Serialize for BatchRequestOutputResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct BatchRequestOutputResponse<'a> {
            #[serde(rename = "status_code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status_code: &'a Option<u64>,
            #[serde(rename = "request_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            request_id: &'a Option<String>,
            #[serde(rename = "body")]
            #[serde(skip_serializing_if = "Option::is_none")]
            body: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            status_code,
            request_id,
            body,
        } = self;
        BatchRequestOutputResponse {
            status_code,
            request_id,
            body,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchRequestOutputResponse {
    #[doc = "The HTTP status code of the response"]
    #[builder(default)]
    pub status_code: Option<u64>,
    #[doc = "An unique identifier for the OpenAI API request. Please include this request ID when contacting support."]
    #[builder(default)]
    pub request_id: Option<String>,
    #[doc = "The JSON body of the response"]
    #[builder(default)]
    pub body: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for BatchRequestOutputError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct BatchRequestOutputError {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: Option<String>,
        }
        let BatchRequestOutputError { code, message, .. } =
            BatchRequestOutputError::deserialize(deserializer)?;
        Ok(Self { code, message })
    }
}
impl serde::Serialize for BatchRequestOutputError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct BatchRequestOutputError<'a> {
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message: &'a Option<String>,
        }
        let Self { code, message } = self;
        BatchRequestOutputError { code, message }.serialize(serializer)
    }
}
#[doc = "For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchRequestOutputError {
    #[doc = "A machine-readable error code."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable error message."]
    #[builder(default)]
    pub message: Option<String>,
}
impl<'de> serde::Deserialize<'de> for BatchRequestOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct BatchRequestOutput {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "custom_id")]
            #[allow(dead_code)]
            custom_id: Option<String>,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Option<BatchRequestOutputResponse>,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<BatchRequestOutputError>,
        }
        let BatchRequestOutput {
            id,
            custom_id,
            response,
            error,
            ..
        } = BatchRequestOutput::deserialize(deserializer)?;
        Ok(Self {
            id,
            custom_id,
            response,
            error,
        })
    }
}
impl serde::Serialize for BatchRequestOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct BatchRequestOutput<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "custom_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            custom_id: &'a Option<String>,
            #[serde(rename = "response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response: &'a Option<BatchRequestOutputResponse>,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<BatchRequestOutputError>,
        }
        let Self {
            id,
            custom_id,
            response,
            error,
        } = self;
        BatchRequestOutput {
            id,
            custom_id,
            response,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "The per-line object of the batch output and error files"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchRequestOutput {
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "A developer-provided per-request id that will be used to match outputs to inputs."]
    #[builder(default)]
    pub custom_id: Option<String>,
    #[builder(default)]
    pub response: Option<BatchRequestOutputResponse>,
    #[doc = "For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure."]
    #[builder(default)]
    pub error: Option<BatchRequestOutputError>,
}
impl<'de> serde::Deserialize<'de> for CertificateObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectCertificate {
            #[default]
            #[serde(rename = "certificate")]
            Certificate,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectOrganizationCertificate {
            #[default]
            #[serde(rename = "organization.certificate")]
            OrganizationCertificate,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectOrganizationProjectCertificate {
            #[default]
            #[serde(rename = "organization.project.certificate")]
            OrganizationProjectCertificate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CertificateObject {
            Certificate(#[allow(dead_code)] CertificateObjectCertificate),
            OrganizationCertificate(#[allow(dead_code)] CertificateObjectOrganizationCertificate),
            OrganizationProjectCertificate(
                #[allow(dead_code)] CertificateObjectOrganizationProjectCertificate,
            ),
        }
        Ok(match CertificateObject::deserialize(deserializer)? {
            CertificateObject::Certificate(_) => Self::Certificate,
            CertificateObject::OrganizationCertificate(_) => Self::OrganizationCertificate,
            CertificateObject::OrganizationProjectCertificate(_) => {
                Self::OrganizationProjectCertificate
            }
        })
    }
}
impl serde::Serialize for CertificateObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectCertificate {
            #[default]
            #[serde(rename = "certificate")]
            Certificate,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectOrganizationCertificate {
            #[default]
            #[serde(rename = "organization.certificate")]
            OrganizationCertificate,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CertificateObjectOrganizationProjectCertificate {
            #[default]
            #[serde(rename = "organization.project.certificate")]
            OrganizationProjectCertificate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CertificateObject<'a> {
            Certificate(#[allow(dead_code)] &'a CertificateObjectCertificate),
            OrganizationCertificate(
                #[allow(dead_code)] &'a CertificateObjectOrganizationCertificate,
            ),
            OrganizationProjectCertificate(
                #[allow(dead_code)] &'a CertificateObjectOrganizationProjectCertificate,
            ),
        }
        match self {
            Self::Certificate => {
                CertificateObject::Certificate(&Default::default()).serialize(serializer)
            }
            Self::OrganizationCertificate => {
                CertificateObject::OrganizationCertificate(&Default::default())
                    .serialize(serializer)
            }
            Self::OrganizationProjectCertificate => {
                CertificateObject::OrganizationProjectCertificate(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The object type.\n\n- If creating, updating, or getting a specific certificate, the object type is `certificate`.\n- If listing, activating, or deactivating certificates for the organization, the object type is `organization.certificate`.\n- If listing, activating, or deactivating certificates for a project, the object type is `organization.project.certificate`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CertificateObject {
    #[doc = "certificate"]
    Certificate,
    #[doc = "organization.certificate"]
    OrganizationCertificate,
    #[doc = "organization.project.certificate"]
    OrganizationProjectCertificate,
}
impl<'de> serde::Deserialize<'de> for CertificateCertificateDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CertificateCertificateDetails {
            #[serde(rename = "valid_at")]
            #[allow(dead_code)]
            valid_at: Option<u64>,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
        }
        let CertificateCertificateDetails {
            valid_at,
            expires_at,
            content,
            ..
        } = CertificateCertificateDetails::deserialize(deserializer)?;
        Ok(Self {
            valid_at,
            expires_at,
            content,
        })
    }
}
impl serde::Serialize for CertificateCertificateDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CertificateCertificateDetails<'a> {
            #[serde(rename = "valid_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            valid_at: &'a Option<u64>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
        }
        let Self {
            valid_at,
            expires_at,
            content,
        } = self;
        CertificateCertificateDetails {
            valid_at,
            expires_at,
            content,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CertificateCertificateDetails {
    #[doc = "The Unix timestamp (in seconds) of when the certificate becomes valid."]
    #[builder(default)]
    pub valid_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) of when the certificate expires."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The content of the certificate in PEM format."]
    #[builder(default)]
    pub content: Option<String>,
}
impl<'de> serde::Deserialize<'de> for Certificate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Certificate {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CertificateObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "certificate_details")]
            #[allow(dead_code)]
            certificate_details: CertificateCertificateDetails,
            #[serde(rename = "active")]
            #[allow(dead_code)]
            active: Option<bool>,
        }
        let Certificate {
            object,
            id,
            name,
            created_at,
            certificate_details,
            active,
            ..
        } = Certificate::deserialize(deserializer)?;
        Ok(Self {
            object,
            id,
            name,
            created_at,
            certificate_details,
            active,
        })
    }
}
impl serde::Serialize for Certificate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Certificate<'a> {
            #[serde(rename = "object")]
            object: &'a CertificateObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "certificate_details")]
            certificate_details: &'a CertificateCertificateDetails,
            #[serde(rename = "active")]
            #[serde(skip_serializing_if = "Option::is_none")]
            active: &'a Option<bool>,
        }
        let Self {
            object,
            id,
            name,
            created_at,
            certificate_details,
            active,
        } = self;
        Certificate {
            object,
            id,
            name,
            created_at,
            certificate_details,
            active,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual `certificate` uploaded to the organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Certificate {
    #[doc = "The object type.\n\n- If creating, updating, or getting a specific certificate, the object type is `certificate`.\n- If listing, activating, or deactivating certificates for the organization, the object type is `organization.certificate`.\n- If listing, activating, or deactivating certificates for a project, the object type is `organization.project.certificate`.\n"]
    pub object: CertificateObject,
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the certificate."]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the certificate was uploaded."]
    pub created_at: u64,
    #[builder(default)]
    pub certificate_details: CertificateCertificateDetails,
    #[doc = "Whether the certificate is currently active at the specified scope. Not returned when getting details for a specific certificate."]
    #[builder(default)]
    pub active: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of object being deleted."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionDeletedObject {
            #[default]
            #[serde(rename = "chat.completion.deleted")]
            ChatCompletionDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionDeleted {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ChatCompletionDeletedObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let ChatCompletionDeleted { id, deleted, .. } =
            ChatCompletionDeleted::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for ChatCompletionDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of object being deleted."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionDeletedObject {
            #[default]
            #[serde(rename = "chat.completion.deleted")]
            ChatCompletionDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionDeleted<'a> {
            #[serde(rename = "object")]
            object: &'a ChatCompletionDeletedObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        ChatCompletionDeleted {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionDeleted {
    #[doc = "The ID of the chat completion that was deleted."]
    pub id: String,
    #[doc = "Whether the chat completion was deleted."]
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionFunctionCallOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionFunctionCallOption {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ChatCompletionFunctionCallOption { name, .. } =
            ChatCompletionFunctionCallOption::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ChatCompletionFunctionCallOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionFunctionCallOption<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ChatCompletionFunctionCallOption { name }.serialize(serializer)
    }
}
#[doc = "Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionFunctionCallOption {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionFunctions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionFunctions {
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<FunctionParameters>,
        }
        let ChatCompletionFunctions {
            description,
            name,
            parameters,
            ..
        } = ChatCompletionFunctions::deserialize(deserializer)?;
        Ok(Self {
            description,
            name,
            parameters,
        })
    }
}
impl serde::Serialize for ChatCompletionFunctions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionFunctions<'a> {
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<FunctionParameters>,
        }
        let Self {
            description,
            name,
            parameters,
        } = self;
        ChatCompletionFunctions {
            description,
            name,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionFunctions {
    #[doc = "A description of what the function does, used by the model to choose when and how to call the function."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."]
    pub name: String,
    #[builder(default)]
    pub parameters: Option<FunctionParameters>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ChatCompletionListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<CreateChatCompletionResponse>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ChatCompletionList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ChatCompletionList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ChatCompletionList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionList<'a> {
            #[serde(rename = "object")]
            object: &'a ChatCompletionListObject,
            #[serde(rename = "data")]
            data: &'a Vec<CreateChatCompletionResponse>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ChatCompletionList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of Chat Completions.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionList {
    #[doc = "An array of chat completion objects.\n"]
    pub data: Vec<CreateChatCompletionResponse>,
    #[doc = "The identifier of the first chat completion in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last chat completion in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more Chat Completions available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageListDatum {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageListDatum {
            #[serde(flatten)]
            #[allow(dead_code)]
            chat_completion_response_message: ChatCompletionResponseMessage,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let ChatCompletionMessageListDatum {
            chat_completion_response_message,
            id,
            ..
        } = ChatCompletionMessageListDatum::deserialize(deserializer)?;
        Ok(Self {
            chat_completion_response_message,
            id,
        })
    }
}
impl serde::Serialize for ChatCompletionMessageListDatum {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageListDatum<'a> {
            #[serde(flatten)]
            chat_completion_response_message: &'a ChatCompletionResponseMessage,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self {
            chat_completion_response_message,
            id,
        } = self;
        ChatCompletionMessageListDatum {
            chat_completion_response_message,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageListDatum {
    #[builder(default)]
    pub chat_completion_response_message: ChatCompletionResponseMessage,
    #[doc = "The identifier of the chat message."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionMessageListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ChatCompletionMessageListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ChatCompletionMessageListDatum>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ChatCompletionMessageList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ChatCompletionMessageList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ChatCompletionMessageList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionMessageListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageList<'a> {
            #[serde(rename = "object")]
            object: &'a ChatCompletionMessageListObject,
            #[serde(rename = "data")]
            data: &'a Vec<ChatCompletionMessageListDatum>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ChatCompletionMessageList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of chat completion messages.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageList {
    #[doc = "An array of chat completion message objects.\n"]
    pub data: Vec<ChatCompletionMessageListDatum>,
    #[doc = "The identifier of the first chat message in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last chat message in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more chat messages available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCallFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageToolCallFunction {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let ChatCompletionMessageToolCallFunction {
            name, arguments, ..
        } = ChatCompletionMessageToolCallFunction::deserialize(deserializer)?;
        Ok(Self { name, arguments })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCallFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageToolCallFunction<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let Self { name, arguments } = self;
        ChatCompletionMessageToolCallFunction { name, arguments }.serialize(serializer)
    }
}
#[doc = "The function that the model called."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCallFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionMessageToolCallType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageToolCall {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionMessageToolCallType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: ChatCompletionMessageToolCallFunction,
        }
        let ChatCompletionMessageToolCall { id, function, .. } =
            ChatCompletionMessageToolCall::deserialize(deserializer)?;
        Ok(Self { id, function })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionMessageToolCallType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageToolCall<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a ChatCompletionMessageToolCallType,
            #[serde(rename = "function")]
            function: &'a ChatCompletionMessageToolCallFunction,
        }
        let Self { id, function } = self;
        ChatCompletionMessageToolCall {
            id,
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCall {
    #[doc = "The ID of the tool call."]
    pub id: String,
    #[doc = "The function that the model called."]
    pub function: ChatCompletionMessageToolCallFunction,
}
#[doc = "The type of the tool. Currently, only `function` is supported."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum ChatCompletionMessageToolCallChunkType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCallChunkFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageToolCallChunkFunction {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
        }
        let ChatCompletionMessageToolCallChunkFunction {
            name, arguments, ..
        } = ChatCompletionMessageToolCallChunkFunction::deserialize(deserializer)?;
        Ok(Self { name, arguments })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCallChunkFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageToolCallChunkFunction<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
        }
        let Self { name, arguments } = self;
        ChatCompletionMessageToolCallChunkFunction { name, arguments }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCallChunkFunction {
    #[doc = "The name of the function to call."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    #[builder(default)]
    pub arguments: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCallChunk {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageToolCallChunk {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<ChatCompletionMessageToolCallChunkType>,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: Option<ChatCompletionMessageToolCallChunkFunction>,
        }
        let ChatCompletionMessageToolCallChunk {
            index,
            id,
            type_,
            function,
            ..
        } = ChatCompletionMessageToolCallChunk::deserialize(deserializer)?;
        Ok(Self {
            index,
            id,
            type_,
            function,
        })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCallChunk {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageToolCallChunk<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<ChatCompletionMessageToolCallChunkType>,
            #[serde(rename = "function")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function: &'a Option<ChatCompletionMessageToolCallChunkFunction>,
        }
        let Self {
            index,
            id,
            type_,
            function,
        } = self;
        ChatCompletionMessageToolCallChunk {
            index,
            id,
            type_,
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCallChunk {
    pub index: u64,
    #[doc = "The ID of the tool call."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the tool. Currently, only `function` is supported."]
    #[builder(default)]
    pub type_: Option<ChatCompletionMessageToolCallChunkType>,
    #[builder(default)]
    pub function: Option<ChatCompletionMessageToolCallChunkFunction>,
}
#[doc = "The tool calls generated by the model, such as function calls."]
pub type ChatCompletionMessageToolCalls = Vec<ChatCompletionMessageToolCall>;
impl<'de> serde::Deserialize<'de> for ChatCompletionModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionModality {
            Text(#[allow(dead_code)] ChatCompletionModalityText),
            Audio(#[allow(dead_code)] ChatCompletionModalityAudio),
        }
        Ok(match ChatCompletionModality::deserialize(deserializer)? {
            ChatCompletionModality::Text(_) => Self::Text,
            ChatCompletionModality::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for ChatCompletionModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionModality<'a> {
            Text(#[allow(dead_code)] &'a ChatCompletionModalityText),
            Audio(#[allow(dead_code)] &'a ChatCompletionModalityAudio),
        }
        match self {
            Self::Text => ChatCompletionModality::Text(&Default::default()).serialize(serializer),
            Self::Audio => ChatCompletionModality::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
#[doc = "Output types that you would like the model to generate for this request.\nMost models are capable of generating text, which is the default:\n\n`[\"text\"]`\n\nThe `gpt-4o-audio-preview` model can also be used to [generate audio](https://platform.openai.com/docs/guides/audio). To\nrequest that this model generate both text and audio responses, you can\nuse:\n\n`[\"text\", \"audio\"]`\n"]
pub type ChatCompletionModalities = Vec<ChatCompletionModality>;
impl<'de> serde::Deserialize<'de> for ChatCompletionNamedToolChoiceFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionNamedToolChoiceFunction {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ChatCompletionNamedToolChoiceFunction { name, .. } =
            ChatCompletionNamedToolChoiceFunction::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ChatCompletionNamedToolChoiceFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionNamedToolChoiceFunction<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ChatCompletionNamedToolChoiceFunction { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionNamedToolChoiceFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionNamedToolChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionNamedToolChoiceType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionNamedToolChoice {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionNamedToolChoiceType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: ChatCompletionNamedToolChoiceFunction,
        }
        let ChatCompletionNamedToolChoice { function, .. } =
            ChatCompletionNamedToolChoice::deserialize(deserializer)?;
        Ok(Self { function })
    }
}
impl serde::Serialize for ChatCompletionNamedToolChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionNamedToolChoiceType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionNamedToolChoice<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionNamedToolChoiceType,
            #[serde(rename = "function")]
            function: &'a ChatCompletionNamedToolChoiceFunction,
        }
        let Self { function } = self;
        ChatCompletionNamedToolChoice {
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[doc = "Specifies a tool the model should use. Use to force the model to call a specific function."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionNamedToolChoice {
    pub function: ChatCompletionNamedToolChoiceFunction,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestAssistantMessageContent {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestAssistantMessageContentPart>),
        }
        Ok(
            match ChatCompletionRequestAssistantMessageContent::deserialize(deserializer)? {
                ChatCompletionRequestAssistantMessageContent::String(_v) => Self::String(_v),
                ChatCompletionRequestAssistantMessageContent::Array(_v) => Self::Array(_v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestAssistantMessageContent<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestAssistantMessageContentPart>),
        }
        match self {
            Self::String(_v) => {
                ChatCompletionRequestAssistantMessageContent::String(_v).serialize(serializer)
            }
            Self::Array(_v) => {
                ChatCompletionRequestAssistantMessageContent::Array(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestAssistantMessageContent {
    #[doc = "The contents of the assistant message."]
    String(String),
    #[doc = "An array of content parts with a defined type. Can be one or more of type `text`, or exactly one of type `refusal`."]
    Array(Vec<ChatCompletionRequestAssistantMessageContentPart>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessageAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestAssistantMessageAudio {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let ChatCompletionRequestAssistantMessageAudio { id, .. } =
            ChatCompletionRequestAssistantMessageAudio::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessageAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestAssistantMessageAudio<'a> {
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self { id } = self;
        ChatCompletionRequestAssistantMessageAudio { id }.serialize(serializer)
    }
}
#[doc = "Data about a previous audio response from the model. \n[Learn more](https://platform.openai.com/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestAssistantMessageAudio {
    #[doc = "Unique identifier for a previous audio response from the model.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessageFunctionCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestAssistantMessageFunctionCall {
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ChatCompletionRequestAssistantMessageFunctionCall {
            arguments, name, ..
        } = ChatCompletionRequestAssistantMessageFunctionCall::deserialize(deserializer)?;
        Ok(Self { arguments, name })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessageFunctionCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestAssistantMessageFunctionCall<'a> {
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { arguments, name } = self;
        ChatCompletionRequestAssistantMessageFunctionCall { arguments, name }.serialize(serializer)
    }
}
#[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestAssistantMessageFunctionCall {
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    pub arguments: String,
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `assistant`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestAssistantMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestAssistantMessage {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<ChatCompletionRequestAssistantMessageContent>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<String>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestAssistantMessageRole,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<ChatCompletionRequestAssistantMessageAudio>,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Option<ChatCompletionMessageToolCalls>,
            #[serde(rename = "function_call")]
            #[allow(dead_code)]
            function_call: Option<ChatCompletionRequestAssistantMessageFunctionCall>,
        }
        let ChatCompletionRequestAssistantMessage {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
            ..
        } = ChatCompletionRequestAssistantMessage::deserialize(deserializer)?;
        Ok(Self {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `assistant`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestAssistantMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestAssistantMessage<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<ChatCompletionRequestAssistantMessageContent>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestAssistantMessageRole,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<ChatCompletionRequestAssistantMessageAudio>,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<ChatCompletionMessageToolCalls>,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<ChatCompletionRequestAssistantMessageFunctionCall>,
        }
        let Self {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
        } = self;
        ChatCompletionRequestAssistantMessage {
            content,
            refusal,
            role: &Default::default(),
            name,
            audio,
            tool_calls,
            function_call,
        }
        .serialize(serializer)
    }
}
#[doc = "Messages sent by the model in response to user messages.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestAssistantMessage {
    #[doc = "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"]
    #[builder(default)]
    pub content: Option<ChatCompletionRequestAssistantMessageContent>,
    #[doc = "The refusal message by the assistant."]
    #[builder(default)]
    pub refusal: Option<String>,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "Data about a previous audio response from the model. \n[Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<ChatCompletionRequestAssistantMessageAudio>,
    #[builder(default)]
    pub tool_calls: Option<ChatCompletionMessageToolCalls>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call: Option<ChatCompletionRequestAssistantMessageFunctionCall>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessageContentPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestAssistantMessageContentPart {
            Text(#[allow(dead_code)] ChatCompletionRequestMessageContentPartText),
            Refusal(#[allow(dead_code)] ChatCompletionRequestMessageContentPartRefusal),
        }
        Ok(
            match ChatCompletionRequestAssistantMessageContentPart::deserialize(deserializer)? {
                ChatCompletionRequestAssistantMessageContentPart::Text(_v) => Self::Text(_v),
                ChatCompletionRequestAssistantMessageContentPart::Refusal(_v) => Self::Refusal(_v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessageContentPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestAssistantMessageContentPart<'a> {
            Text(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartText),
            Refusal(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartRefusal),
        }
        match self {
            Self::Text(_v) => {
                ChatCompletionRequestAssistantMessageContentPart::Text(_v).serialize(serializer)
            }
            Self::Refusal(_v) => {
                ChatCompletionRequestAssistantMessageContentPart::Refusal(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestAssistantMessageContentPart {
    Text(ChatCompletionRequestMessageContentPartText),
    Refusal(ChatCompletionRequestMessageContentPartRefusal),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestDeveloperMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestDeveloperMessageContent {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestMessageContentPartText>),
        }
        Ok(
            match ChatCompletionRequestDeveloperMessageContent::deserialize(deserializer)? {
                ChatCompletionRequestDeveloperMessageContent::String(_v) => Self::String(_v),
                ChatCompletionRequestDeveloperMessageContent::Array(_v) => Self::Array(_v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestDeveloperMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestDeveloperMessageContent<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestMessageContentPartText>),
        }
        match self {
            Self::String(_v) => {
                ChatCompletionRequestDeveloperMessageContent::String(_v).serialize(serializer)
            }
            Self::Array(_v) => {
                ChatCompletionRequestDeveloperMessageContent::Array(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The contents of the developer message."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestDeveloperMessageContent {
    #[doc = "The contents of the developer message."]
    String(String),
    #[doc = "An array of content parts with a defined type. For developer messages, only type `text` is supported."]
    Array(Vec<ChatCompletionRequestMessageContentPartText>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestDeveloperMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `developer`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestDeveloperMessageRole {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestDeveloperMessage {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: ChatCompletionRequestDeveloperMessageContent,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestDeveloperMessageRole,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let ChatCompletionRequestDeveloperMessage { content, name, .. } =
            ChatCompletionRequestDeveloperMessage::deserialize(deserializer)?;
        Ok(Self { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestDeveloperMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `developer`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestDeveloperMessageRole {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestDeveloperMessage<'a> {
            #[serde(rename = "content")]
            content: &'a ChatCompletionRequestDeveloperMessageContent,
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestDeveloperMessageRole,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { content, name } = self;
        ChatCompletionRequestDeveloperMessage {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Developer-provided instructions that the model should follow, regardless of\nmessages sent by the user. With o1 models and newer, `developer` messages\nreplace the previous `system` messages.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestDeveloperMessage {
    #[doc = "The contents of the developer message."]
    pub content: ChatCompletionRequestDeveloperMessageContent,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestFunctionMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestFunctionMessageRole {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestFunctionMessage {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestFunctionMessageRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ChatCompletionRequestFunctionMessage { content, name, .. } =
            ChatCompletionRequestFunctionMessage::deserialize(deserializer)?;
        Ok(Self { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestFunctionMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestFunctionMessageRole {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestFunctionMessage<'a> {
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestFunctionMessageRole,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { content, name } = self;
        ChatCompletionRequestFunctionMessage {
            role: &Default::default(),
            content,
            name,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestFunctionMessage {
    #[doc = "The contents of the function message."]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestMessage {
            Developer(#[allow(dead_code)] ChatCompletionRequestDeveloperMessage),
            System(#[allow(dead_code)] ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] ChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] ChatCompletionRequestFunctionMessage),
        }
        Ok(
            match ChatCompletionRequestMessage::deserialize(deserializer)? {
                ChatCompletionRequestMessage::Developer(_v) => Self::Developer(_v),
                ChatCompletionRequestMessage::System(_v) => Self::System(_v),
                ChatCompletionRequestMessage::User(_v) => Self::User(_v),
                ChatCompletionRequestMessage::Assistant(_v) => Self::Assistant(_v),
                ChatCompletionRequestMessage::Tool(_v) => Self::Tool(_v),
                ChatCompletionRequestMessage::Function(_v) => Self::Function(_v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestMessage<'a> {
            Developer(#[allow(dead_code)] &'a ChatCompletionRequestDeveloperMessage),
            System(#[allow(dead_code)] &'a ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] &'a ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] &'a ChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] &'a ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] &'a ChatCompletionRequestFunctionMessage),
        }
        match self {
            Self::Developer(_v) => {
                ChatCompletionRequestMessage::Developer(_v).serialize(serializer)
            }
            Self::System(_v) => ChatCompletionRequestMessage::System(_v).serialize(serializer),
            Self::User(_v) => ChatCompletionRequestMessage::User(_v).serialize(serializer),
            Self::Assistant(_v) => {
                ChatCompletionRequestMessage::Assistant(_v).serialize(serializer)
            }
            Self::Tool(_v) => ChatCompletionRequestMessage::Tool(_v).serialize(serializer),
            Self::Function(_v) => ChatCompletionRequestMessage::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestMessage {
    Developer(ChatCompletionRequestDeveloperMessage),
    System(ChatCompletionRequestSystemMessage),
    User(ChatCompletionRequestUserMessage),
    Assistant(ChatCompletionRequestAssistantMessage),
    Tool(ChatCompletionRequestToolMessage),
    Function(ChatCompletionRequestFunctionMessage),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartAudioInputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormat {
            Wav(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav,
            ),
            Mp3(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3,
            ),
        }
        Ok(
            match ChatCompletionRequestMessageContentPartAudioInputAudioFormat::deserialize(
                deserializer,
            )? {
                ChatCompletionRequestMessageContentPartAudioInputAudioFormat::Wav(_) => Self::Wav,
                ChatCompletionRequestMessageContentPartAudioInputAudioFormat::Mp3(_) => Self::Mp3,
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartAudioInputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestMessageContentPartAudioInputAudioFormat<'a> {
            Wav(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartAudioInputAudioFormatWav,
            ),
            Mp3(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartAudioInputAudioFormatMp3,
            ),
        }
        match self {
            Self::Wav => ChatCompletionRequestMessageContentPartAudioInputAudioFormat::Wav(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Mp3 => ChatCompletionRequestMessageContentPartAudioInputAudioFormat::Mp3(
                &Default::default(),
            )
            .serialize(serializer),
        }
    }
}
#[doc = "The format of the encoded audio data. Currently supports \"wav\" and \"mp3\".\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestMessageContentPartAudioInputAudioFormat {
    #[doc = "wav"]
    Wav,
    #[doc = "mp3"]
    Mp3,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartAudioInputAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartAudioInputAudio {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: String,
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: ChatCompletionRequestMessageContentPartAudioInputAudioFormat,
        }
        let ChatCompletionRequestMessageContentPartAudioInputAudio { data, format, .. } =
            ChatCompletionRequestMessageContentPartAudioInputAudio::deserialize(deserializer)?;
        Ok(Self { data, format })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartAudioInputAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartAudioInputAudio<'a> {
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "format")]
            format: &'a ChatCompletionRequestMessageContentPartAudioInputAudioFormat,
        }
        let Self { data, format } = self;
        ChatCompletionRequestMessageContentPartAudioInputAudio { data, format }
            .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartAudioInputAudio {
    #[doc = "Base64 encoded audio data."]
    pub data: String,
    #[doc = "The format of the encoded audio data. Currently supports \"wav\" and \"mp3\".\n"]
    pub format: ChatCompletionRequestMessageContentPartAudioInputAudioFormat,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part. Always `input_audio`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioType {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartAudio {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartAudioType,
            #[serde(rename = "input_audio")]
            #[allow(dead_code)]
            input_audio: ChatCompletionRequestMessageContentPartAudioInputAudio,
        }
        let ChatCompletionRequestMessageContentPartAudio { input_audio, .. } =
            ChatCompletionRequestMessageContentPartAudio::deserialize(deserializer)?;
        Ok(Self { input_audio })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part. Always `input_audio`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartAudioType {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartAudio<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartAudioType,
            #[serde(rename = "input_audio")]
            input_audio: &'a ChatCompletionRequestMessageContentPartAudioInputAudio,
        }
        let Self { input_audio } = self;
        ChatCompletionRequestMessageContentPartAudio {
            type_: &Default::default(),
            input_audio,
        }
        .serialize(serializer)
    }
}
#[doc = "Learn about [audio inputs](https://platform.openai.com/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartAudio {
    pub input_audio: ChatCompletionRequestMessageContentPartAudioInputAudio,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartFileFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartFileFile {
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: Option<String>,
            #[serde(rename = "file_data")]
            #[allow(dead_code)]
            file_data: Option<String>,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let ChatCompletionRequestMessageContentPartFileFile {
            filename,
            file_data,
            file_id,
            ..
        } = ChatCompletionRequestMessageContentPartFileFile::deserialize(deserializer)?;
        Ok(Self {
            filename,
            file_data,
            file_id,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartFileFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartFileFile<'a> {
            #[serde(rename = "filename")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filename: &'a Option<String>,
            #[serde(rename = "file_data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_data: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let Self {
            filename,
            file_data,
            file_id,
        } = self;
        ChatCompletionRequestMessageContentPartFileFile {
            filename,
            file_data,
            file_id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartFileFile {
    #[doc = "The name of the file, used when passing the file to the model as a \nstring.\n"]
    #[builder(default)]
    pub filename: Option<String>,
    #[doc = "The base64 encoded file data, used when passing the file to the model \nas a string.\n"]
    #[builder(default)]
    pub file_data: Option<String>,
    #[doc = "The ID of an uploaded file to use as input.\n"]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part. Always `file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartFileType {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartFile {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartFileType,
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: ChatCompletionRequestMessageContentPartFileFile,
        }
        let ChatCompletionRequestMessageContentPartFile { file, .. } =
            ChatCompletionRequestMessageContentPartFile::deserialize(deserializer)?;
        Ok(Self { file })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part. Always `file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartFileType {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartFile<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartFileType,
            #[serde(rename = "file")]
            file: &'a ChatCompletionRequestMessageContentPartFileFile,
        }
        let Self { file } = self;
        ChatCompletionRequestMessageContentPartFile {
            type_: &Default::default(),
            file,
        }
        .serialize(serializer)
    }
}
#[doc = "Learn about [file inputs](https://platform.openai.com/docs/guides/text) for text generation.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartFile {
    #[builder(default)]
    pub file: ChatCompletionRequestMessageContentPartFileFile,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartImageImageUrlDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetail {
            Auto(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto,
            ),
            Low(#[allow(dead_code)] ChatCompletionRequestMessageContentPartImageImageUrlDetailLow),
            High(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh,
            ),
        }
        Ok(
            match ChatCompletionRequestMessageContentPartImageImageUrlDetail::deserialize(
                deserializer,
            )? {
                ChatCompletionRequestMessageContentPartImageImageUrlDetail::Auto(_) => Self::Auto,
                ChatCompletionRequestMessageContentPartImageImageUrlDetail::Low(_) => Self::Low,
                ChatCompletionRequestMessageContentPartImageImageUrlDetail::High(_) => Self::High,
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartImageImageUrlDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestMessageContentPartImageImageUrlDetail<'a> {
            Auto(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartImageImageUrlDetailAuto,
            ),
            Low(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartImageImageUrlDetailLow,
            ),
            High(
                #[allow(dead_code)]
                &'a ChatCompletionRequestMessageContentPartImageImageUrlDetailHigh,
            ),
        }
        match self {
            Self::Auto => ChatCompletionRequestMessageContentPartImageImageUrlDetail::Auto(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Low => {
                ChatCompletionRequestMessageContentPartImageImageUrlDetail::Low(&Default::default())
                    .serialize(serializer)
            }
            Self::High => ChatCompletionRequestMessageContentPartImageImageUrlDetail::High(
                &Default::default(),
            )
            .serialize(serializer),
        }
    }
}
#[doc = "Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding)."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestMessageContentPartImageImageUrlDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartImageImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartImageImageUrl {
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<ChatCompletionRequestMessageContentPartImageImageUrlDetail>,
        }
        let ChatCompletionRequestMessageContentPartImageImageUrl { url, detail, .. } =
            ChatCompletionRequestMessageContentPartImageImageUrl::deserialize(deserializer)?;
        Ok(Self { url, detail })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartImageImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartImageImageUrl<'a> {
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<ChatCompletionRequestMessageContentPartImageImageUrlDetail>,
        }
        let Self { url, detail } = self;
        ChatCompletionRequestMessageContentPartImageImageUrl { url, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartImageImageUrl {
    #[doc = "Either a URL of the image or the base64 encoded image data."]
    pub url: String,
    #[doc = "Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding)."]
    #[builder(default)]
    pub detail: Option<ChatCompletionRequestMessageContentPartImageImageUrlDetail>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartImage {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartImageType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: ChatCompletionRequestMessageContentPartImageImageUrl,
        }
        let ChatCompletionRequestMessageContentPartImage { image_url, .. } =
            ChatCompletionRequestMessageContentPartImage::deserialize(deserializer)?;
        Ok(Self { image_url })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartImageType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartImage<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartImageType,
            #[serde(rename = "image_url")]
            image_url: &'a ChatCompletionRequestMessageContentPartImageImageUrl,
        }
        let Self { image_url } = self;
        ChatCompletionRequestMessageContentPartImage {
            type_: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[doc = "Learn about [image inputs](https://platform.openai.com/docs/guides/vision).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartImage {
    pub image_url: ChatCompletionRequestMessageContentPartImageImageUrl,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartRefusal {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartRefusalType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartRefusal {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartRefusalType,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: String,
        }
        let ChatCompletionRequestMessageContentPartRefusal { refusal, .. } =
            ChatCompletionRequestMessageContentPartRefusal::deserialize(deserializer)?;
        Ok(Self { refusal })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartRefusal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartRefusalType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartRefusal<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartRefusalType,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let Self { refusal } = self;
        ChatCompletionRequestMessageContentPartRefusal {
            type_: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartRefusal {
    #[doc = "The refusal message generated by the model."]
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartTextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartText {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionRequestMessageContentPartTextType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let ChatCompletionRequestMessageContentPartText { text, .. } =
            ChatCompletionRequestMessageContentPartText::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestMessageContentPartTextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartText<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionRequestMessageContentPartTextType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        ChatCompletionRequestMessageContentPartText {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "Learn about [text inputs](https://platform.openai.com/docs/guides/text-generation).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartText {
    #[doc = "The text content."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestSystemMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestSystemMessageContent {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestSystemMessageContentPart>),
        }
        Ok(
            match ChatCompletionRequestSystemMessageContent::deserialize(deserializer)? {
                ChatCompletionRequestSystemMessageContent::String(_v) => Self::String(_v),
                ChatCompletionRequestSystemMessageContent::Array(_v) => Self::Array(_v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestSystemMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestSystemMessageContent<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestSystemMessageContentPart>),
        }
        match self {
            Self::String(_v) => {
                ChatCompletionRequestSystemMessageContent::String(_v).serialize(serializer)
            }
            Self::Array(_v) => {
                ChatCompletionRequestSystemMessageContent::Array(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The contents of the system message."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestSystemMessageContent {
    #[doc = "The contents of the system message."]
    String(String),
    #[doc = "An array of content parts with a defined type. For system messages, only type `text` is supported."]
    Array(Vec<ChatCompletionRequestSystemMessageContentPart>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestSystemMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `system`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestSystemMessageRole {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestSystemMessage {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: ChatCompletionRequestSystemMessageContent,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestSystemMessageRole,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let ChatCompletionRequestSystemMessage { content, name, .. } =
            ChatCompletionRequestSystemMessage::deserialize(deserializer)?;
        Ok(Self { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestSystemMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `system`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestSystemMessageRole {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestSystemMessage<'a> {
            #[serde(rename = "content")]
            content: &'a ChatCompletionRequestSystemMessageContent,
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestSystemMessageRole,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { content, name } = self;
        ChatCompletionRequestSystemMessage {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Developer-provided instructions that the model should follow, regardless of\nmessages sent by the user. With o1 models and newer, use `developer` messages\nfor this purpose instead.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestSystemMessage {
    #[doc = "The contents of the system message."]
    pub content: ChatCompletionRequestSystemMessageContent,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestSystemMessageContentPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestSystemMessageContentPart {
            ChatCompletionRequestMessageContentPartText(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartText,
            ),
        }
        Ok (match ChatCompletionRequestSystemMessageContentPart :: deserialize (deserializer) ? { ChatCompletionRequestSystemMessageContentPart :: ChatCompletionRequestMessageContentPartText (_v) => Self :: ChatCompletionRequestMessageContentPartText (_v) })
    }
}
impl serde::Serialize for ChatCompletionRequestSystemMessageContentPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestSystemMessageContentPart<'a> {
            ChatCompletionRequestMessageContentPartText(
                #[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartText,
            ),
        }
        match self { Self :: ChatCompletionRequestMessageContentPartText (_v) => { ChatCompletionRequestSystemMessageContentPart :: ChatCompletionRequestMessageContentPartText (_v) . serialize (serializer) } }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestSystemMessageContentPart {
    ChatCompletionRequestMessageContentPartText(ChatCompletionRequestMessageContentPartText),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestToolMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestToolMessageContent {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestToolMessageContentPart>),
        }
        Ok(
            match ChatCompletionRequestToolMessageContent::deserialize(deserializer)? {
                ChatCompletionRequestToolMessageContent::String(_v) => Self::String(_v),
                ChatCompletionRequestToolMessageContent::Array(_v) => Self::Array(_v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestToolMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestToolMessageContent<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestToolMessageContentPart>),
        }
        match self {
            Self::String(_v) => {
                ChatCompletionRequestToolMessageContent::String(_v).serialize(serializer)
            }
            Self::Array(_v) => {
                ChatCompletionRequestToolMessageContent::Array(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The contents of the tool message."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestToolMessageContent {
    #[doc = "The contents of the tool message."]
    String(String),
    #[doc = "An array of content parts with a defined type. For tool messages, only type `text` is supported."]
    Array(Vec<ChatCompletionRequestToolMessageContentPart>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestToolMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `tool`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestToolMessageRole {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestToolMessage {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestToolMessageRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: ChatCompletionRequestToolMessageContent,
            #[serde(rename = "tool_call_id")]
            #[allow(dead_code)]
            tool_call_id: String,
        }
        let ChatCompletionRequestToolMessage {
            content,
            tool_call_id,
            ..
        } = ChatCompletionRequestToolMessage::deserialize(deserializer)?;
        Ok(Self {
            content,
            tool_call_id,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestToolMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `tool`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestToolMessageRole {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestToolMessage<'a> {
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestToolMessageRole,
            #[serde(rename = "content")]
            content: &'a ChatCompletionRequestToolMessageContent,
            #[serde(rename = "tool_call_id")]
            tool_call_id: &'a String,
        }
        let Self {
            content,
            tool_call_id,
        } = self;
        ChatCompletionRequestToolMessage {
            role: &Default::default(),
            content,
            tool_call_id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestToolMessage {
    #[doc = "The contents of the tool message."]
    pub content: ChatCompletionRequestToolMessageContent,
    #[doc = "Tool call that this message is responding to."]
    pub tool_call_id: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestToolMessageContentPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestToolMessageContentPart {
            ChatCompletionRequestMessageContentPartText(
                #[allow(dead_code)] ChatCompletionRequestMessageContentPartText,
            ),
        }
        Ok (match ChatCompletionRequestToolMessageContentPart :: deserialize (deserializer) ? { ChatCompletionRequestToolMessageContentPart :: ChatCompletionRequestMessageContentPartText (_v) => Self :: ChatCompletionRequestMessageContentPartText (_v) })
    }
}
impl serde::Serialize for ChatCompletionRequestToolMessageContentPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestToolMessageContentPart<'a> {
            ChatCompletionRequestMessageContentPartText(
                #[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartText,
            ),
        }
        match self { Self :: ChatCompletionRequestMessageContentPartText (_v) => { ChatCompletionRequestToolMessageContentPart :: ChatCompletionRequestMessageContentPartText (_v) . serialize (serializer) } }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestToolMessageContentPart {
    ChatCompletionRequestMessageContentPartText(ChatCompletionRequestMessageContentPartText),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestUserMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestUserMessageContent {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestUserMessageContentPart>),
        }
        Ok(
            match ChatCompletionRequestUserMessageContent::deserialize(deserializer)? {
                ChatCompletionRequestUserMessageContent::String(_v) => Self::String(_v),
                ChatCompletionRequestUserMessageContent::Array(_v) => Self::Array(_v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestUserMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestUserMessageContent<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestUserMessageContentPart>),
        }
        match self {
            Self::String(_v) => {
                ChatCompletionRequestUserMessageContent::String(_v).serialize(serializer)
            }
            Self::Array(_v) => {
                ChatCompletionRequestUserMessageContent::Array(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The contents of the user message.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestUserMessageContent {
    #[doc = "The text contents of the message."]
    String(String),
    #[doc = "An array of content parts with a defined type. Supported options differ based on the [model](https://platform.openai.com/docs/models) being used to generate the response. Can contain text, image, or audio inputs."]
    Array(Vec<ChatCompletionRequestUserMessageContentPart>),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestUserMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the messages author, in this case `user`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestUserMessageRole {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestUserMessage {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: ChatCompletionRequestUserMessageContent,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionRequestUserMessageRole,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let ChatCompletionRequestUserMessage { content, name, .. } =
            ChatCompletionRequestUserMessage::deserialize(deserializer)?;
        Ok(Self { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestUserMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the messages author, in this case `user`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRequestUserMessageRole {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestUserMessage<'a> {
            #[serde(rename = "content")]
            content: &'a ChatCompletionRequestUserMessageContent,
            #[serde(rename = "role")]
            role: &'a ChatCompletionRequestUserMessageRole,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { content, name } = self;
        ChatCompletionRequestUserMessage {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Messages sent by an end user, containing prompts or additional context\ninformation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestUserMessage {
    #[doc = "The contents of the user message.\n"]
    pub content: ChatCompletionRequestUserMessageContent,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestUserMessageContentPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRequestUserMessageContentPart {
            Text(#[allow(dead_code)] ChatCompletionRequestMessageContentPartText),
            ImageUrl(#[allow(dead_code)] ChatCompletionRequestMessageContentPartImage),
            InputAudio(#[allow(dead_code)] ChatCompletionRequestMessageContentPartAudio),
            File(#[allow(dead_code)] ChatCompletionRequestMessageContentPartFile),
        }
        Ok(
            match ChatCompletionRequestUserMessageContentPart::deserialize(deserializer)? {
                ChatCompletionRequestUserMessageContentPart::Text(_v) => Self::Text(_v),
                ChatCompletionRequestUserMessageContentPart::ImageUrl(_v) => Self::ImageUrl(_v),
                ChatCompletionRequestUserMessageContentPart::InputAudio(_v) => Self::InputAudio(_v),
                ChatCompletionRequestUserMessageContentPart::File(_v) => Self::File(_v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionRequestUserMessageContentPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRequestUserMessageContentPart<'a> {
            Text(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartText),
            ImageUrl(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartImage),
            InputAudio(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartAudio),
            File(#[allow(dead_code)] &'a ChatCompletionRequestMessageContentPartFile),
        }
        match self {
            Self::Text(_v) => {
                ChatCompletionRequestUserMessageContentPart::Text(_v).serialize(serializer)
            }
            Self::ImageUrl(_v) => {
                ChatCompletionRequestUserMessageContentPart::ImageUrl(_v).serialize(serializer)
            }
            Self::InputAudio(_v) => {
                ChatCompletionRequestUserMessageContentPart::InputAudio(_v).serialize(serializer)
            }
            Self::File(_v) => {
                ChatCompletionRequestUserMessageContentPart::File(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestUserMessageContentPart {
    Text(ChatCompletionRequestMessageContentPartText),
    ImageUrl(ChatCompletionRequestMessageContentPartImage),
    InputAudio(ChatCompletionRequestMessageContentPartAudio),
    File(ChatCompletionRequestMessageContentPartFile),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessageAnnotationUrlCitation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionResponseMessageAnnotationUrlCitation {
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: String,
        }
        let ChatCompletionResponseMessageAnnotationUrlCitation {
            end_index,
            start_index,
            url,
            title,
            ..
        } = ChatCompletionResponseMessageAnnotationUrlCitation::deserialize(deserializer)?;
        Ok(Self {
            end_index,
            start_index,
            url,
            title,
        })
    }
}
impl serde::Serialize for ChatCompletionResponseMessageAnnotationUrlCitation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionResponseMessageAnnotationUrlCitation<'a> {
            #[serde(rename = "end_index")]
            end_index: &'a u64,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "title")]
            title: &'a String,
        }
        let Self {
            end_index,
            start_index,
            url,
            title,
        } = self;
        ChatCompletionResponseMessageAnnotationUrlCitation {
            end_index,
            start_index,
            url,
            title,
        }
        .serialize(serializer)
    }
}
#[doc = "A URL citation when using web search."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessageAnnotationUrlCitation {
    #[doc = "The index of the last character of the URL citation in the message."]
    pub end_index: u64,
    #[doc = "The index of the first character of the URL citation in the message."]
    pub start_index: u64,
    #[doc = "The URL of the web resource."]
    pub url: String,
    #[doc = "The title of the web resource."]
    pub title: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessageAnnotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the URL citation. Always `url_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionResponseMessageAnnotationType {
            #[default]
            #[serde(rename = "url_citation")]
            UrlCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionResponseMessageAnnotation {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionResponseMessageAnnotationType,
            #[serde(rename = "url_citation")]
            #[allow(dead_code)]
            url_citation: ChatCompletionResponseMessageAnnotationUrlCitation,
        }
        let ChatCompletionResponseMessageAnnotation { url_citation, .. } =
            ChatCompletionResponseMessageAnnotation::deserialize(deserializer)?;
        Ok(Self { url_citation })
    }
}
impl serde::Serialize for ChatCompletionResponseMessageAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the URL citation. Always `url_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionResponseMessageAnnotationType {
            #[default]
            #[serde(rename = "url_citation")]
            UrlCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionResponseMessageAnnotation<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionResponseMessageAnnotationType,
            #[serde(rename = "url_citation")]
            url_citation: &'a ChatCompletionResponseMessageAnnotationUrlCitation,
        }
        let Self { url_citation } = self;
        ChatCompletionResponseMessageAnnotation {
            type_: &Default::default(),
            url_citation,
        }
        .serialize(serializer)
    }
}
#[doc = "A URL citation when using web search.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessageAnnotation {
    #[doc = "A URL citation when using web search."]
    pub url_citation: ChatCompletionResponseMessageAnnotationUrlCitation,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessageFunctionCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionResponseMessageFunctionCall {
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ChatCompletionResponseMessageFunctionCall {
            arguments, name, ..
        } = ChatCompletionResponseMessageFunctionCall::deserialize(deserializer)?;
        Ok(Self { arguments, name })
    }
}
impl serde::Serialize for ChatCompletionResponseMessageFunctionCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionResponseMessageFunctionCall<'a> {
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { arguments, name } = self;
        ChatCompletionResponseMessageFunctionCall { arguments, name }.serialize(serializer)
    }
}
#[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessageFunctionCall {
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    pub arguments: String,
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessageAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionResponseMessageAudio {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: String,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: String,
        }
        let ChatCompletionResponseMessageAudio {
            id,
            expires_at,
            data,
            transcript,
            ..
        } = ChatCompletionResponseMessageAudio::deserialize(deserializer)?;
        Ok(Self {
            id,
            expires_at,
            data,
            transcript,
        })
    }
}
impl serde::Serialize for ChatCompletionResponseMessageAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionResponseMessageAudio<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "transcript")]
            transcript: &'a String,
        }
        let Self {
            id,
            expires_at,
            data,
            transcript,
        } = self;
        ChatCompletionResponseMessageAudio {
            id,
            expires_at,
            data,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessageAudio {
    #[doc = "Unique identifier for this audio response."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when this audio response will\nno longer be accessible on the server for use in multi-turn\nconversations.\n"]
    pub expires_at: u64,
    #[doc = "Base64 encoded audio bytes generated by the model, in the format\nspecified in the request.\n"]
    pub data: String,
    #[doc = "Transcript of the audio generated by the model."]
    pub transcript: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The role of the author of this message."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionResponseMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionResponseMessage {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<String>,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Option<ChatCompletionMessageToolCalls>,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Option<Vec<ChatCompletionResponseMessageAnnotation>>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ChatCompletionResponseMessageRole,
            #[serde(rename = "function_call")]
            #[allow(dead_code)]
            function_call: Option<ChatCompletionResponseMessageFunctionCall>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<ChatCompletionResponseMessageAudio>,
        }
        let ChatCompletionResponseMessage {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
            ..
        } = ChatCompletionResponseMessage::deserialize(deserializer)?;
        Ok(Self {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
        })
    }
}
impl serde::Serialize for ChatCompletionResponseMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The role of the author of this message."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionResponseMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionResponseMessage<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<ChatCompletionMessageToolCalls>,
            #[serde(rename = "annotations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            annotations: &'a Option<Vec<ChatCompletionResponseMessageAnnotation>>,
            #[serde(rename = "role")]
            role: &'a ChatCompletionResponseMessageRole,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<ChatCompletionResponseMessageFunctionCall>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<ChatCompletionResponseMessageAudio>,
        }
        let Self {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
        } = self;
        ChatCompletionResponseMessage {
            content,
            refusal,
            tool_calls,
            annotations,
            role: &Default::default(),
            function_call,
            audio,
        }
        .serialize(serializer)
    }
}
#[doc = "A chat completion message generated by the model."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessage {
    #[doc = "The contents of the message."]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "The refusal message generated by the model."]
    #[builder(default)]
    pub refusal: Option<String>,
    #[builder(default)]
    pub tool_calls: Option<ChatCompletionMessageToolCalls>,
    #[doc = "Annotations for the message, when applicable, as when using the\n[web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\n"]
    #[builder(default)]
    pub annotations: Option<Vec<ChatCompletionResponseMessageAnnotation>>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call: Option<ChatCompletionResponseMessageFunctionCall>,
    #[doc = "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<ChatCompletionResponseMessageAudio>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleTool {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleFunction {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionRole {
            Developer(#[allow(dead_code)] ChatCompletionRoleDeveloper),
            System(#[allow(dead_code)] ChatCompletionRoleSystem),
            User(#[allow(dead_code)] ChatCompletionRoleUser),
            Assistant(#[allow(dead_code)] ChatCompletionRoleAssistant),
            Tool(#[allow(dead_code)] ChatCompletionRoleTool),
            Function(#[allow(dead_code)] ChatCompletionRoleFunction),
        }
        Ok(match ChatCompletionRole::deserialize(deserializer)? {
            ChatCompletionRole::Developer(_) => Self::Developer,
            ChatCompletionRole::System(_) => Self::System,
            ChatCompletionRole::User(_) => Self::User,
            ChatCompletionRole::Assistant(_) => Self::Assistant,
            ChatCompletionRole::Tool(_) => Self::Tool,
            ChatCompletionRole::Function(_) => Self::Function,
        })
    }
}
impl serde::Serialize for ChatCompletionRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleTool {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionRoleFunction {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionRole<'a> {
            Developer(#[allow(dead_code)] &'a ChatCompletionRoleDeveloper),
            System(#[allow(dead_code)] &'a ChatCompletionRoleSystem),
            User(#[allow(dead_code)] &'a ChatCompletionRoleUser),
            Assistant(#[allow(dead_code)] &'a ChatCompletionRoleAssistant),
            Tool(#[allow(dead_code)] &'a ChatCompletionRoleTool),
            Function(#[allow(dead_code)] &'a ChatCompletionRoleFunction),
        }
        match self {
            Self::Developer => {
                ChatCompletionRole::Developer(&Default::default()).serialize(serializer)
            }
            Self::System => ChatCompletionRole::System(&Default::default()).serialize(serializer),
            Self::User => ChatCompletionRole::User(&Default::default()).serialize(serializer),
            Self::Assistant => {
                ChatCompletionRole::Assistant(&Default::default()).serialize(serializer)
            }
            Self::Tool => ChatCompletionRole::Tool(&Default::default()).serialize(serializer),
            Self::Function => {
                ChatCompletionRole::Function(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The role of the author of a message"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRole {
    #[doc = "developer"]
    Developer,
    #[doc = "system"]
    System,
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "tool"]
    Tool,
    #[doc = "function"]
    Function,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionStreamOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionStreamOptions {
            #[serde(rename = "include_usage")]
            #[allow(dead_code)]
            include_usage: Option<bool>,
        }
        let ChatCompletionStreamOptions { include_usage, .. } =
            ChatCompletionStreamOptions::deserialize(deserializer)?;
        Ok(Self { include_usage })
    }
}
impl serde::Serialize for ChatCompletionStreamOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionStreamOptions<'a> {
            #[serde(rename = "include_usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_usage: &'a Option<bool>,
        }
        let Self { include_usage } = self;
        ChatCompletionStreamOptions { include_usage }.serialize(serializer)
    }
}
#[doc = "Options for streaming response. Only set this when you set `stream: true`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionStreamOptions {
    #[doc = "If set, an additional chunk will be streamed before the `data: [DONE]`\nmessage. The `usage` field on this chunk shows the token usage statistics\nfor the entire request, and the `choices` field will always be an empty\narray. \n\nAll other chunks will also include a `usage` field, but with a null\nvalue. **NOTE:** If the stream is interrupted, you may not receive the\nfinal usage chunk which contains the total token usage for the request.\n"]
    #[builder(default)]
    pub include_usage: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionStreamResponseDeltaFunctionCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionStreamResponseDeltaFunctionCall {
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
        }
        let ChatCompletionStreamResponseDeltaFunctionCall {
            arguments, name, ..
        } = ChatCompletionStreamResponseDeltaFunctionCall::deserialize(deserializer)?;
        Ok(Self { arguments, name })
    }
}
impl serde::Serialize for ChatCompletionStreamResponseDeltaFunctionCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionStreamResponseDeltaFunctionCall<'a> {
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { arguments, name } = self;
        ChatCompletionStreamResponseDeltaFunctionCall { arguments, name }.serialize(serializer)
    }
}
#[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionStreamResponseDeltaFunctionCall {
    #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The name of the function to call."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionStreamResponseDeltaRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleTool {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionStreamResponseDeltaRole {
            Developer(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleDeveloper),
            System(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleSystem),
            User(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleUser),
            Assistant(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleAssistant),
            Tool(#[allow(dead_code)] ChatCompletionStreamResponseDeltaRoleTool),
        }
        Ok(
            match ChatCompletionStreamResponseDeltaRole::deserialize(deserializer)? {
                ChatCompletionStreamResponseDeltaRole::Developer(_) => Self::Developer,
                ChatCompletionStreamResponseDeltaRole::System(_) => Self::System,
                ChatCompletionStreamResponseDeltaRole::User(_) => Self::User,
                ChatCompletionStreamResponseDeltaRole::Assistant(_) => Self::Assistant,
                ChatCompletionStreamResponseDeltaRole::Tool(_) => Self::Tool,
            },
        )
    }
}
impl serde::Serialize for ChatCompletionStreamResponseDeltaRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionStreamResponseDeltaRoleTool {
            #[default]
            #[serde(rename = "tool")]
            Tool,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionStreamResponseDeltaRole<'a> {
            Developer(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleDeveloper),
            System(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleSystem),
            User(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleUser),
            Assistant(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleAssistant),
            Tool(#[allow(dead_code)] &'a ChatCompletionStreamResponseDeltaRoleTool),
        }
        match self {
            Self::Developer => {
                ChatCompletionStreamResponseDeltaRole::Developer(&Default::default())
                    .serialize(serializer)
            }
            Self::System => ChatCompletionStreamResponseDeltaRole::System(&Default::default())
                .serialize(serializer),
            Self::User => ChatCompletionStreamResponseDeltaRole::User(&Default::default())
                .serialize(serializer),
            Self::Assistant => {
                ChatCompletionStreamResponseDeltaRole::Assistant(&Default::default())
                    .serialize(serializer)
            }
            Self::Tool => ChatCompletionStreamResponseDeltaRole::Tool(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The role of the author of this message."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionStreamResponseDeltaRole {
    #[doc = "developer"]
    Developer,
    #[doc = "system"]
    System,
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "tool"]
    Tool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionStreamResponseDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionStreamResponseDelta {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
            #[serde(rename = "function_call")]
            #[allow(dead_code)]
            function_call: Option<ChatCompletionStreamResponseDeltaFunctionCall>,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Option<Vec<ChatCompletionMessageToolCallChunk>>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<ChatCompletionStreamResponseDeltaRole>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<String>,
        }
        let ChatCompletionStreamResponseDelta {
            content,
            function_call,
            tool_calls,
            role,
            refusal,
            ..
        } = ChatCompletionStreamResponseDelta::deserialize(deserializer)?;
        Ok(Self {
            content,
            function_call,
            tool_calls,
            role,
            refusal,
        })
    }
}
impl serde::Serialize for ChatCompletionStreamResponseDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionStreamResponseDelta<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<ChatCompletionStreamResponseDeltaFunctionCall>,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<Vec<ChatCompletionMessageToolCallChunk>>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<ChatCompletionStreamResponseDeltaRole>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
        }
        let Self {
            content,
            function_call,
            tool_calls,
            role,
            refusal,
        } = self;
        ChatCompletionStreamResponseDelta {
            content,
            function_call,
            tool_calls,
            role,
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "A chat completion delta generated by streamed model responses."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ChatCompletionStreamResponseDelta {
    #[doc = "The contents of the chunk message."]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call: Option<ChatCompletionStreamResponseDeltaFunctionCall>,
    #[builder(default)]
    pub tool_calls: Option<Vec<ChatCompletionMessageToolCallChunk>>,
    #[doc = "The role of the author of this message."]
    #[builder(default)]
    pub role: Option<ChatCompletionStreamResponseDeltaRole>,
    #[doc = "The refusal message generated by the model."]
    #[builder(default)]
    pub refusal: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionTokenLogprobTopLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionTokenLogprobTopLogprob {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: String,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: f64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<u64>>,
        }
        let ChatCompletionTokenLogprobTopLogprob {
            token,
            logprob,
            bytes,
            ..
        } = ChatCompletionTokenLogprobTopLogprob::deserialize(deserializer)?;
        Ok(Self {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for ChatCompletionTokenLogprobTopLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionTokenLogprobTopLogprob<'a> {
            #[serde(rename = "token")]
            token: &'a String,
            #[serde(rename = "logprob")]
            logprob: &'a f64,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<u64>>,
        }
        let Self {
            token,
            logprob,
            bytes,
        } = self;
        ChatCompletionTokenLogprobTopLogprob {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionTokenLogprobTopLogprob {
    #[doc = "The token."]
    pub token: String,
    #[doc = "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely."]
    pub logprob: f64,
    #[doc = "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token."]
    #[builder(default)]
    pub bytes: Option<Vec<u64>>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionTokenLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionTokenLogprob {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: String,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: f64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<u64>>,
            #[serde(rename = "top_logprobs")]
            #[allow(dead_code)]
            top_logprobs: Vec<ChatCompletionTokenLogprobTopLogprob>,
        }
        let ChatCompletionTokenLogprob {
            token,
            logprob,
            bytes,
            top_logprobs,
            ..
        } = ChatCompletionTokenLogprob::deserialize(deserializer)?;
        Ok(Self {
            token,
            logprob,
            bytes,
            top_logprobs,
        })
    }
}
impl serde::Serialize for ChatCompletionTokenLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionTokenLogprob<'a> {
            #[serde(rename = "token")]
            token: &'a String,
            #[serde(rename = "logprob")]
            logprob: &'a f64,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<u64>>,
            #[serde(rename = "top_logprobs")]
            top_logprobs: &'a Vec<ChatCompletionTokenLogprobTopLogprob>,
        }
        let Self {
            token,
            logprob,
            bytes,
            top_logprobs,
        } = self;
        ChatCompletionTokenLogprob {
            token,
            logprob,
            bytes,
            top_logprobs,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionTokenLogprob {
    #[doc = "The token."]
    pub token: String,
    #[doc = "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely."]
    pub logprob: f64,
    #[doc = "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token."]
    #[builder(default)]
    pub bytes: Option<Vec<u64>>,
    #[doc = "List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned."]
    pub top_logprobs: Vec<ChatCompletionTokenLogprobTopLogprob>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ChatCompletionToolType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: FunctionObject,
        }
        let ChatCompletionTool { function, .. } = ChatCompletionTool::deserialize(deserializer)?;
        Ok(Self { function })
    }
}
impl serde::Serialize for ChatCompletionTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the tool. Currently, only `function` is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionTool<'a> {
            #[serde(rename = "type")]
            type_: &'a ChatCompletionToolType,
            #[serde(rename = "function")]
            function: &'a FunctionObject,
        }
        let Self { function } = self;
        ChatCompletionTool {
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionTool {
    pub function: FunctionObject,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionToolChoiceOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionToolChoiceOption {
            None(#[allow(dead_code)] ChatCompletionToolChoiceOptionNone),
            Auto(#[allow(dead_code)] ChatCompletionToolChoiceOptionAuto),
            Required(#[allow(dead_code)] ChatCompletionToolChoiceOptionRequired),
            ChatCompletionNamedToolChoice(#[allow(dead_code)] ChatCompletionNamedToolChoice),
        }
        Ok(
            match ChatCompletionToolChoiceOption::deserialize(deserializer)? {
                ChatCompletionToolChoiceOption::None(_) => Self::None,
                ChatCompletionToolChoiceOption::Auto(_) => Self::Auto,
                ChatCompletionToolChoiceOption::Required(_) => Self::Required,
                ChatCompletionToolChoiceOption::ChatCompletionNamedToolChoice(_v) => {
                    Self::ChatCompletionNamedToolChoice(_v)
                }
            },
        )
    }
}
impl serde::Serialize for ChatCompletionToolChoiceOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatCompletionToolChoiceOptionRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionToolChoiceOption<'a> {
            None(#[allow(dead_code)] &'a ChatCompletionToolChoiceOptionNone),
            Auto(#[allow(dead_code)] &'a ChatCompletionToolChoiceOptionAuto),
            Required(#[allow(dead_code)] &'a ChatCompletionToolChoiceOptionRequired),
            ChatCompletionNamedToolChoice(#[allow(dead_code)] &'a ChatCompletionNamedToolChoice),
        }
        match self {
            Self::None => {
                ChatCompletionToolChoiceOption::None(&Default::default()).serialize(serializer)
            }
            Self::Auto => {
                ChatCompletionToolChoiceOption::Auto(&Default::default()).serialize(serializer)
            }
            Self::Required => {
                ChatCompletionToolChoiceOption::Required(&Default::default()).serialize(serializer)
            }
            Self::ChatCompletionNamedToolChoice(_v) => {
                ChatCompletionToolChoiceOption::ChatCompletionNamedToolChoice(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tool and instead generates a message.\n`auto` means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools.\nSpecifying a particular tool via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n\n`none` is the default when no tools are present. `auto` is the default if tools are present.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionToolChoiceOption {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    #[doc = "required"]
    Required,
    ChatCompletionNamedToolChoice(ChatCompletionNamedToolChoice),
}
impl<'de> serde::Deserialize<'de> for ChunkingStrategyRequestParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChunkingStrategyRequestParam {
            Auto(#[allow(dead_code)] AutoChunkingStrategyRequestParam),
            Static(#[allow(dead_code)] StaticChunkingStrategyRequestParam),
        }
        Ok(
            match ChunkingStrategyRequestParam::deserialize(deserializer)? {
                ChunkingStrategyRequestParam::Auto(_v) => Self::Auto(_v),
                ChunkingStrategyRequestParam::Static(_v) => Self::Static(_v),
            },
        )
    }
}
impl serde::Serialize for ChunkingStrategyRequestParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChunkingStrategyRequestParam<'a> {
            Auto(#[allow(dead_code)] &'a AutoChunkingStrategyRequestParam),
            Static(#[allow(dead_code)] &'a StaticChunkingStrategyRequestParam),
        }
        match self {
            Self::Auto(_v) => ChunkingStrategyRequestParam::Auto(_v).serialize(serializer),
            Self::Static(_v) => ChunkingStrategyRequestParam::Static(_v).serialize(serializer),
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChunkingStrategyRequestParam {
    Auto(AutoChunkingStrategyRequestParam),
    Static(StaticChunkingStrategyRequestParam),
}
impl<'de> serde::Deserialize<'de> for ClickButton {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonLeft {
            #[default]
            #[serde(rename = "left")]
            Left,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonRight {
            #[default]
            #[serde(rename = "right")]
            Right,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonWheel {
            #[default]
            #[serde(rename = "wheel")]
            Wheel,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonBack {
            #[default]
            #[serde(rename = "back")]
            Back,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonForward {
            #[default]
            #[serde(rename = "forward")]
            Forward,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ClickButton {
            Left(#[allow(dead_code)] ClickButtonLeft),
            Right(#[allow(dead_code)] ClickButtonRight),
            Wheel(#[allow(dead_code)] ClickButtonWheel),
            Back(#[allow(dead_code)] ClickButtonBack),
            Forward(#[allow(dead_code)] ClickButtonForward),
        }
        Ok(match ClickButton::deserialize(deserializer)? {
            ClickButton::Left(_) => Self::Left,
            ClickButton::Right(_) => Self::Right,
            ClickButton::Wheel(_) => Self::Wheel,
            ClickButton::Back(_) => Self::Back,
            ClickButton::Forward(_) => Self::Forward,
        })
    }
}
impl serde::Serialize for ClickButton {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonLeft {
            #[default]
            #[serde(rename = "left")]
            Left,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonRight {
            #[default]
            #[serde(rename = "right")]
            Right,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonWheel {
            #[default]
            #[serde(rename = "wheel")]
            Wheel,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonBack {
            #[default]
            #[serde(rename = "back")]
            Back,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickButtonForward {
            #[default]
            #[serde(rename = "forward")]
            Forward,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ClickButton<'a> {
            Left(#[allow(dead_code)] &'a ClickButtonLeft),
            Right(#[allow(dead_code)] &'a ClickButtonRight),
            Wheel(#[allow(dead_code)] &'a ClickButtonWheel),
            Back(#[allow(dead_code)] &'a ClickButtonBack),
            Forward(#[allow(dead_code)] &'a ClickButtonForward),
        }
        match self {
            Self::Left => ClickButton::Left(&Default::default()).serialize(serializer),
            Self::Right => ClickButton::Right(&Default::default()).serialize(serializer),
            Self::Wheel => ClickButton::Wheel(&Default::default()).serialize(serializer),
            Self::Back => ClickButton::Back(&Default::default()).serialize(serializer),
            Self::Forward => ClickButton::Forward(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Indicates which mouse button was pressed during the click. One of `left`, `right`, `wheel`, `back`, or `forward`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ClickButton {
    #[doc = "left"]
    Left,
    #[doc = "right"]
    Right,
    #[doc = "wheel"]
    Wheel,
    #[doc = "back"]
    Back,
    #[doc = "forward"]
    Forward,
}
impl<'de> serde::Deserialize<'de> for Click {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a click action, this property is \nalways set to `click`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickType {
            #[default]
            #[serde(rename = "click")]
            Click,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Click {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ClickType,
            #[serde(rename = "button")]
            #[allow(dead_code)]
            button: ClickButton,
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
        }
        let Click { button, x, y, .. } = Click::deserialize(deserializer)?;
        Ok(Self { button, x, y })
    }
}
impl serde::Serialize for Click {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a click action, this property is \nalways set to `click`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ClickType {
            #[default]
            #[serde(rename = "click")]
            Click,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Click<'a> {
            #[serde(rename = "type")]
            type_: &'a ClickType,
            #[serde(rename = "button")]
            button: &'a ClickButton,
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
        }
        let Self { button, x, y } = self;
        Click {
            type_: &Default::default(),
            button,
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[doc = "A click action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct Click {
    #[doc = "Indicates which mouse button was pressed during the click. One of `left`, `right`, `wheel`, `back`, or `forward`.\n"]
    pub button: ClickButton,
    #[doc = "The x-coordinate where the click occurred.\n"]
    pub x: u64,
    #[doc = "The y-coordinate where the click occurred.\n"]
    pub y: u64,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterFileOutputFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterFileOutputFile {
            #[serde(rename = "mime_type")]
            #[allow(dead_code)]
            mime_type: String,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
        }
        let CodeInterpreterFileOutputFile {
            mime_type, file_id, ..
        } = CodeInterpreterFileOutputFile::deserialize(deserializer)?;
        Ok(Self { mime_type, file_id })
    }
}
impl serde::Serialize for CodeInterpreterFileOutputFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterFileOutputFile<'a> {
            #[serde(rename = "mime_type")]
            mime_type: &'a String,
            #[serde(rename = "file_id")]
            file_id: &'a String,
        }
        let Self { mime_type, file_id } = self;
        CodeInterpreterFileOutputFile { mime_type, file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterFileOutputFile {
    #[doc = "The MIME type of the file.\n"]
    pub mime_type: String,
    #[doc = "The ID of the file.\n"]
    pub file_id: String,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterFileOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the code interpreter file output. Always `files`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterFileOutputType {
            #[default]
            #[serde(rename = "files")]
            Files,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterFileOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CodeInterpreterFileOutputType,
            #[serde(rename = "files")]
            #[allow(dead_code)]
            files: Vec<CodeInterpreterFileOutputFile>,
        }
        let CodeInterpreterFileOutput { files, .. } =
            CodeInterpreterFileOutput::deserialize(deserializer)?;
        Ok(Self { files })
    }
}
impl serde::Serialize for CodeInterpreterFileOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the code interpreter file output. Always `files`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterFileOutputType {
            #[default]
            #[serde(rename = "files")]
            Files,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterFileOutput<'a> {
            #[serde(rename = "type")]
            type_: &'a CodeInterpreterFileOutputType,
            #[serde(rename = "files")]
            files: &'a Vec<CodeInterpreterFileOutputFile>,
        }
        let Self { files } = self;
        CodeInterpreterFileOutput {
            type_: &Default::default(),
            files,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a code interpreter tool call that is a file.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterFileOutput {
    pub files: Vec<CodeInterpreterFileOutputFile>,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterTextOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the code interpreter text output. Always `logs`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterTextOutputType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterTextOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CodeInterpreterTextOutputType,
            #[serde(rename = "logs")]
            #[allow(dead_code)]
            logs: String,
        }
        let CodeInterpreterTextOutput { logs, .. } =
            CodeInterpreterTextOutput::deserialize(deserializer)?;
        Ok(Self { logs })
    }
}
impl serde::Serialize for CodeInterpreterTextOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the code interpreter text output. Always `logs`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterTextOutputType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterTextOutput<'a> {
            #[serde(rename = "type")]
            type_: &'a CodeInterpreterTextOutputType,
            #[serde(rename = "logs")]
            logs: &'a String,
        }
        let Self { logs } = self;
        CodeInterpreterTextOutput {
            type_: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a code interpreter tool call that is text.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterTextOutput {
    #[doc = "The logs of the code interpreter tool call.\n"]
    pub logs: String,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolContainer {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CodeInterpreterToolContainer {
            Other(#[allow(dead_code)] String),
            CodeInterpreterToolAuto(#[allow(dead_code)] CodeInterpreterToolAuto),
        }
        Ok(
            match CodeInterpreterToolContainer::deserialize(deserializer)? {
                CodeInterpreterToolContainer::Other(_v) => Self::Other(_v),
                CodeInterpreterToolContainer::CodeInterpreterToolAuto(_v) => {
                    Self::CodeInterpreterToolAuto(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CodeInterpreterToolContainer {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CodeInterpreterToolContainer<'a> {
            Other(#[allow(dead_code)] &'a String),
            CodeInterpreterToolAuto(#[allow(dead_code)] &'a CodeInterpreterToolAuto),
        }
        match self {
            Self::Other(_v) => CodeInterpreterToolContainer::Other(_v).serialize(serializer),
            Self::CodeInterpreterToolAuto(_v) => {
                CodeInterpreterToolContainer::CodeInterpreterToolAuto(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The code interpreter container. Can be a container ID or an object that\nspecifies uploaded file IDs to make available to your code.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CodeInterpreterToolContainer {
    #[doc = "The container ID."]
    Other(String),
    CodeInterpreterToolAuto(CodeInterpreterToolAuto),
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the code interpreter tool. Always `code_interpreter`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CodeInterpreterToolType,
            #[serde(rename = "container")]
            #[allow(dead_code)]
            container: CodeInterpreterToolContainer,
        }
        let CodeInterpreterTool { container, .. } = CodeInterpreterTool::deserialize(deserializer)?;
        Ok(Self { container })
    }
}
impl serde::Serialize for CodeInterpreterTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the code interpreter tool. Always `code_interpreter`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterTool<'a> {
            #[serde(rename = "type")]
            type_: &'a CodeInterpreterToolType,
            #[serde(rename = "container")]
            container: &'a CodeInterpreterToolContainer,
        }
        let Self { container } = self;
        CodeInterpreterTool {
            type_: &Default::default(),
            container,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool that runs Python code to help generate a response to a prompt.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterTool {
    #[doc = "The code interpreter container. Can be a container ID or an object that\nspecifies uploaded file IDs to make available to your code.\n"]
    pub container: CodeInterpreterToolContainer,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolAuto {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterToolAuto {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CodeInterpreterToolAutoType,
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let CodeInterpreterToolAuto { file_ids, .. } =
            CodeInterpreterToolAuto::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for CodeInterpreterToolAuto {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterToolAuto<'a> {
            #[serde(rename = "type")]
            type_: &'a CodeInterpreterToolAutoType,
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        CodeInterpreterToolAuto {
            type_: &Default::default(),
            file_ids,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for a code interpreter container. Optionally specify the IDs\nof the files to run the code on.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterToolAuto {
    #[doc = "An optional list of uploaded files to make available to your code.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusInterpreting {
            #[default]
            #[serde(rename = "interpreting")]
            Interpreting,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CodeInterpreterToolCallStatus {
            InProgress(#[allow(dead_code)] CodeInterpreterToolCallStatusInProgress),
            Interpreting(#[allow(dead_code)] CodeInterpreterToolCallStatusInterpreting),
            Completed(#[allow(dead_code)] CodeInterpreterToolCallStatusCompleted),
        }
        Ok(
            match CodeInterpreterToolCallStatus::deserialize(deserializer)? {
                CodeInterpreterToolCallStatus::InProgress(_) => Self::InProgress,
                CodeInterpreterToolCallStatus::Interpreting(_) => Self::Interpreting,
                CodeInterpreterToolCallStatus::Completed(_) => Self::Completed,
            },
        )
    }
}
impl serde::Serialize for CodeInterpreterToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusInterpreting {
            #[default]
            #[serde(rename = "interpreting")]
            Interpreting,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CodeInterpreterToolCallStatus<'a> {
            InProgress(#[allow(dead_code)] &'a CodeInterpreterToolCallStatusInProgress),
            Interpreting(#[allow(dead_code)] &'a CodeInterpreterToolCallStatusInterpreting),
            Completed(#[allow(dead_code)] &'a CodeInterpreterToolCallStatusCompleted),
        }
        match self {
            Self::InProgress => {
                CodeInterpreterToolCallStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Interpreting => CodeInterpreterToolCallStatus::Interpreting(&Default::default())
                .serialize(serializer),
            Self::Completed => {
                CodeInterpreterToolCallStatus::Completed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the code interpreter tool call.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CodeInterpreterToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "interpreting"]
    Interpreting,
    #[doc = "completed"]
    Completed,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the code interpreter tool call. Always `code_interpreter_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallType {
            #[default]
            #[serde(rename = "code_interpreter_call")]
            CodeInterpreterCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterToolCall {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CodeInterpreterToolCallType,
            #[serde(rename = "container_id")]
            #[allow(dead_code)]
            container_id: Option<String>,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: CodeInterpreterToolCallStatus,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Vec<CodeInterpreterToolOutput>,
        }
        let CodeInterpreterToolCall {
            id,
            container_id,
            code,
            status,
            results,
            ..
        } = CodeInterpreterToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            container_id,
            code,
            status,
            results,
        })
    }
}
impl serde::Serialize for CodeInterpreterToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the code interpreter tool call. Always `code_interpreter_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CodeInterpreterToolCallType {
            #[default]
            #[serde(rename = "code_interpreter_call")]
            CodeInterpreterCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterToolCall<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a CodeInterpreterToolCallType,
            #[serde(rename = "container_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            container_id: &'a Option<String>,
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "status")]
            status: &'a CodeInterpreterToolCallStatus,
            #[serde(rename = "results")]
            results: &'a Vec<CodeInterpreterToolOutput>,
        }
        let Self {
            id,
            container_id,
            code,
            status,
            results,
        } = self;
        CodeInterpreterToolCall {
            id,
            type_: &Default::default(),
            container_id,
            code,
            status,
            results,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool call to run code.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterToolCall {
    #[doc = "The unique ID of the code interpreter tool call.\n"]
    pub id: String,
    #[doc = "The ID of the container used to run the code.\n"]
    #[builder(default)]
    pub container_id: Option<String>,
    #[doc = "The code to run.\n"]
    pub code: String,
    #[doc = "The status of the code interpreter tool call.\n"]
    pub status: CodeInterpreterToolCallStatus,
    #[doc = "The results of the code interpreter tool call.\n"]
    pub results: Vec<CodeInterpreterToolOutput>,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CodeInterpreterToolOutput {
            Logs(#[allow(dead_code)] CodeInterpreterTextOutput),
            Files(#[allow(dead_code)] CodeInterpreterFileOutput),
        }
        Ok(
            match CodeInterpreterToolOutput::deserialize(deserializer)? {
                CodeInterpreterToolOutput::Logs(_v) => Self::Logs(_v),
                CodeInterpreterToolOutput::Files(_v) => Self::Files(_v),
            },
        )
    }
}
impl serde::Serialize for CodeInterpreterToolOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CodeInterpreterToolOutput<'a> {
            Logs(#[allow(dead_code)] &'a CodeInterpreterTextOutput),
            Files(#[allow(dead_code)] &'a CodeInterpreterFileOutput),
        }
        match self {
            Self::Logs(_v) => CodeInterpreterToolOutput::Logs(_v).serialize(serializer),
            Self::Files(_v) => CodeInterpreterToolOutput::Files(_v).serialize(serializer),
        }
    }
}
#[doc = "The output of a code interpreter tool.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CodeInterpreterToolOutput {
    Logs(CodeInterpreterTextOutput),
    Files(CodeInterpreterFileOutput),
}
impl<'de> serde::Deserialize<'de> for ComparisonFilterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeEq {
            #[default]
            #[serde(rename = "eq")]
            Eq,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeNe {
            #[default]
            #[serde(rename = "ne")]
            Ne,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeGt {
            #[default]
            #[serde(rename = "gt")]
            Gt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeGte {
            #[default]
            #[serde(rename = "gte")]
            Gte,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeLt {
            #[default]
            #[serde(rename = "lt")]
            Lt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeLte {
            #[default]
            #[serde(rename = "lte")]
            Lte,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ComparisonFilterType {
            Eq(#[allow(dead_code)] ComparisonFilterTypeEq),
            Ne(#[allow(dead_code)] ComparisonFilterTypeNe),
            Gt(#[allow(dead_code)] ComparisonFilterTypeGt),
            Gte(#[allow(dead_code)] ComparisonFilterTypeGte),
            Lt(#[allow(dead_code)] ComparisonFilterTypeLt),
            Lte(#[allow(dead_code)] ComparisonFilterTypeLte),
        }
        Ok(match ComparisonFilterType::deserialize(deserializer)? {
            ComparisonFilterType::Eq(_) => Self::Eq,
            ComparisonFilterType::Ne(_) => Self::Ne,
            ComparisonFilterType::Gt(_) => Self::Gt,
            ComparisonFilterType::Gte(_) => Self::Gte,
            ComparisonFilterType::Lt(_) => Self::Lt,
            ComparisonFilterType::Lte(_) => Self::Lte,
        })
    }
}
impl serde::Serialize for ComparisonFilterType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeEq {
            #[default]
            #[serde(rename = "eq")]
            Eq,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeNe {
            #[default]
            #[serde(rename = "ne")]
            Ne,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeGt {
            #[default]
            #[serde(rename = "gt")]
            Gt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeGte {
            #[default]
            #[serde(rename = "gte")]
            Gte,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeLt {
            #[default]
            #[serde(rename = "lt")]
            Lt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComparisonFilterTypeLte {
            #[default]
            #[serde(rename = "lte")]
            Lte,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ComparisonFilterType<'a> {
            Eq(#[allow(dead_code)] &'a ComparisonFilterTypeEq),
            Ne(#[allow(dead_code)] &'a ComparisonFilterTypeNe),
            Gt(#[allow(dead_code)] &'a ComparisonFilterTypeGt),
            Gte(#[allow(dead_code)] &'a ComparisonFilterTypeGte),
            Lt(#[allow(dead_code)] &'a ComparisonFilterTypeLt),
            Lte(#[allow(dead_code)] &'a ComparisonFilterTypeLte),
        }
        match self {
            Self::Eq => ComparisonFilterType::Eq(&Default::default()).serialize(serializer),
            Self::Ne => ComparisonFilterType::Ne(&Default::default()).serialize(serializer),
            Self::Gt => ComparisonFilterType::Gt(&Default::default()).serialize(serializer),
            Self::Gte => ComparisonFilterType::Gte(&Default::default()).serialize(serializer),
            Self::Lt => ComparisonFilterType::Lt(&Default::default()).serialize(serializer),
            Self::Lte => ComparisonFilterType::Lte(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ComparisonFilterType {
    #[doc = "eq"]
    #[default]
    Eq,
    #[doc = "ne"]
    Ne,
    #[doc = "gt"]
    Gt,
    #[doc = "gte"]
    Gte,
    #[doc = "lt"]
    Lt,
    #[doc = "lte"]
    Lte,
}
impl<'de> serde::Deserialize<'de> for ComparisonFilterValue {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ComparisonFilterValue {
            String(#[allow(dead_code)] String),
            Number(#[allow(dead_code)] f64),
            Bool(#[allow(dead_code)] bool),
        }
        Ok(match ComparisonFilterValue::deserialize(deserializer)? {
            ComparisonFilterValue::String(_v) => Self::String(_v),
            ComparisonFilterValue::Number(_v) => Self::Number(_v),
            ComparisonFilterValue::Bool(_v) => Self::Bool(_v),
        })
    }
}
impl serde::Serialize for ComparisonFilterValue {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ComparisonFilterValue<'a> {
            String(#[allow(dead_code)] &'a String),
            Number(#[allow(dead_code)] &'a f64),
            Bool(#[allow(dead_code)] &'a bool),
        }
        match self {
            Self::String(_v) => ComparisonFilterValue::String(_v).serialize(serializer),
            Self::Number(_v) => ComparisonFilterValue::Number(_v).serialize(serializer),
            Self::Bool(_v) => ComparisonFilterValue::Bool(_v).serialize(serializer),
        }
    }
}
#[doc = "The value to compare against the attribute key; supports string, number, or boolean types."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ComparisonFilterValue {
    String(String),
    Number(f64),
    Bool(bool),
}
impl<'de> serde::Deserialize<'de> for ComparisonFilter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComparisonFilter {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComparisonFilterType,
            #[serde(rename = "key")]
            #[allow(dead_code)]
            key: String,
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: ComparisonFilterValue,
        }
        let ComparisonFilter {
            type_, key, value, ..
        } = ComparisonFilter::deserialize(deserializer)?;
        Ok(Self { type_, key, value })
    }
}
impl serde::Serialize for ComparisonFilter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComparisonFilter<'a> {
            #[serde(rename = "type")]
            type_: &'a ComparisonFilterType,
            #[serde(rename = "key")]
            key: &'a String,
            #[serde(rename = "value")]
            value: &'a ComparisonFilterValue,
        }
        let Self { type_, key, value } = self;
        ComparisonFilter { type_, key, value }.serialize(serializer)
    }
}
#[doc = "A filter used to compare a specified attribute key to a given value using a defined comparison operation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComparisonFilter {
    #[doc = "Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n"]
    #[builder(default)]
    pub type_: ComparisonFilterType,
    #[doc = "The key to compare against the value."]
    pub key: String,
    #[doc = "The value to compare against the attribute key; supports string, number, or boolean types."]
    pub value: ComparisonFilterValue,
}
impl<'de> serde::Deserialize<'de> for CompleteUploadRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CompleteUploadRequest {
            #[serde(rename = "part_ids")]
            #[allow(dead_code)]
            part_ids: Vec<String>,
            #[serde(rename = "md5")]
            #[allow(dead_code)]
            md5: Option<String>,
        }
        let CompleteUploadRequest { part_ids, md5, .. } =
            CompleteUploadRequest::deserialize(deserializer)?;
        Ok(Self { part_ids, md5 })
    }
}
impl serde::Serialize for CompleteUploadRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CompleteUploadRequest<'a> {
            #[serde(rename = "part_ids")]
            part_ids: &'a Vec<String>,
            #[serde(rename = "md5")]
            #[serde(skip_serializing_if = "Option::is_none")]
            md5: &'a Option<String>,
        }
        let Self { part_ids, md5 } = self;
        CompleteUploadRequest { part_ids, md5 }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CompleteUploadRequest {
    #[doc = "The ordered list of Part IDs.\n"]
    pub part_ids: Vec<String>,
    #[doc = "The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect.\n"]
    #[builder(default)]
    pub md5: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CompletionUsageCompletionTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CompletionUsageCompletionTokensDetails {
            #[serde(rename = "accepted_prediction_tokens")]
            #[allow(dead_code)]
            accepted_prediction_tokens: Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[allow(dead_code)]
            audio_tokens: Option<u64>,
            #[serde(rename = "reasoning_tokens")]
            #[allow(dead_code)]
            reasoning_tokens: Option<u64>,
            #[serde(rename = "rejected_prediction_tokens")]
            #[allow(dead_code)]
            rejected_prediction_tokens: Option<u64>,
        }
        let CompletionUsageCompletionTokensDetails {
            accepted_prediction_tokens,
            audio_tokens,
            reasoning_tokens,
            rejected_prediction_tokens,
            ..
        } = CompletionUsageCompletionTokensDetails::deserialize(deserializer)?;
        Ok(Self {
            accepted_prediction_tokens,
            audio_tokens,
            reasoning_tokens,
            rejected_prediction_tokens,
        })
    }
}
impl serde::Serialize for CompletionUsageCompletionTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CompletionUsageCompletionTokensDetails<'a> {
            #[serde(rename = "accepted_prediction_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            accepted_prediction_tokens: &'a Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio_tokens: &'a Option<u64>,
            #[serde(rename = "reasoning_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_tokens: &'a Option<u64>,
            #[serde(rename = "rejected_prediction_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            rejected_prediction_tokens: &'a Option<u64>,
        }
        let Self {
            accepted_prediction_tokens,
            audio_tokens,
            reasoning_tokens,
            rejected_prediction_tokens,
        } = self;
        CompletionUsageCompletionTokensDetails {
            accepted_prediction_tokens,
            audio_tokens,
            reasoning_tokens,
            rejected_prediction_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Breakdown of tokens used in a completion."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CompletionUsageCompletionTokensDetails {
    #[doc = "When using Predicted Outputs, the number of tokens in the\nprediction that appeared in the completion.\n"]
    #[builder(default)]
    pub accepted_prediction_tokens: Option<u64>,
    #[doc = "Audio input tokens generated by the model."]
    #[builder(default)]
    pub audio_tokens: Option<u64>,
    #[doc = "Tokens generated by the model for reasoning."]
    #[builder(default)]
    pub reasoning_tokens: Option<u64>,
    #[doc = "When using Predicted Outputs, the number of tokens in the\nprediction that did not appear in the completion. However, like\nreasoning tokens, these tokens are still counted in the total\ncompletion tokens for purposes of billing, output, and context window\nlimits.\n"]
    #[builder(default)]
    pub rejected_prediction_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for CompletionUsagePromptTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CompletionUsagePromptTokensDetails {
            #[serde(rename = "audio_tokens")]
            #[allow(dead_code)]
            audio_tokens: Option<u64>,
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: Option<u64>,
        }
        let CompletionUsagePromptTokensDetails {
            audio_tokens,
            cached_tokens,
            ..
        } = CompletionUsagePromptTokensDetails::deserialize(deserializer)?;
        Ok(Self {
            audio_tokens,
            cached_tokens,
        })
    }
}
impl serde::Serialize for CompletionUsagePromptTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CompletionUsagePromptTokensDetails<'a> {
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio_tokens: &'a Option<u64>,
            #[serde(rename = "cached_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cached_tokens: &'a Option<u64>,
        }
        let Self {
            audio_tokens,
            cached_tokens,
        } = self;
        CompletionUsagePromptTokensDetails {
            audio_tokens,
            cached_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Breakdown of tokens used in the prompt."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CompletionUsagePromptTokensDetails {
    #[doc = "Audio input tokens present in the prompt."]
    #[builder(default)]
    pub audio_tokens: Option<u64>,
    #[doc = "Cached tokens present in the prompt."]
    #[builder(default)]
    pub cached_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for CompletionUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CompletionUsage {
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
            #[serde(rename = "completion_tokens_details")]
            #[allow(dead_code)]
            completion_tokens_details: Option<CompletionUsageCompletionTokensDetails>,
            #[serde(rename = "prompt_tokens_details")]
            #[allow(dead_code)]
            prompt_tokens_details: Option<CompletionUsagePromptTokensDetails>,
        }
        let CompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            completion_tokens_details,
            prompt_tokens_details,
            ..
        } = CompletionUsage::deserialize(deserializer)?;
        Ok(Self {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            completion_tokens_details,
            prompt_tokens_details,
        })
    }
}
impl serde::Serialize for CompletionUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CompletionUsage<'a> {
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
            #[serde(rename = "completion_tokens_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completion_tokens_details: &'a Option<CompletionUsageCompletionTokensDetails>,
            #[serde(rename = "prompt_tokens_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt_tokens_details: &'a Option<CompletionUsagePromptTokensDetails>,
        }
        let Self {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            completion_tokens_details,
            prompt_tokens_details,
        } = self;
        CompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            completion_tokens_details,
            prompt_tokens_details,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics for the completion request."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CompletionUsage {
    #[doc = "Number of tokens in the generated completion."]
    pub completion_tokens: u64,
    #[doc = "Number of tokens in the prompt."]
    pub prompt_tokens: u64,
    #[doc = "Total number of tokens used in the request (prompt + completion)."]
    pub total_tokens: u64,
    #[doc = "Breakdown of tokens used in a completion."]
    #[builder(default)]
    pub completion_tokens_details: Option<CompletionUsageCompletionTokensDetails>,
    #[doc = "Breakdown of tokens used in the prompt."]
    #[builder(default)]
    pub prompt_tokens_details: Option<CompletionUsagePromptTokensDetails>,
}
impl<'de> serde::Deserialize<'de> for CompoundFilterType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CompoundFilterTypeAnd {
            #[default]
            #[serde(rename = "and")]
            And,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CompoundFilterTypeOr {
            #[default]
            #[serde(rename = "or")]
            Or,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CompoundFilterType {
            And(#[allow(dead_code)] CompoundFilterTypeAnd),
            Or(#[allow(dead_code)] CompoundFilterTypeOr),
        }
        Ok(match CompoundFilterType::deserialize(deserializer)? {
            CompoundFilterType::And(_) => Self::And,
            CompoundFilterType::Or(_) => Self::Or,
        })
    }
}
impl serde::Serialize for CompoundFilterType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CompoundFilterTypeAnd {
            #[default]
            #[serde(rename = "and")]
            And,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CompoundFilterTypeOr {
            #[default]
            #[serde(rename = "or")]
            Or,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CompoundFilterType<'a> {
            And(#[allow(dead_code)] &'a CompoundFilterTypeAnd),
            Or(#[allow(dead_code)] &'a CompoundFilterTypeOr),
        }
        match self {
            Self::And => CompoundFilterType::And(&Default::default()).serialize(serializer),
            Self::Or => CompoundFilterType::Or(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Type of operation: `and` or `or`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CompoundFilterType {
    #[doc = "and"]
    And,
    #[doc = "or"]
    Or,
}
impl<'de> serde::Deserialize<'de> for CompoundFilterFilter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CompoundFilterFilter {
            ComparisonFilter(#[allow(dead_code)] ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] CompoundFilter),
        }
        Ok(match CompoundFilterFilter::deserialize(deserializer)? {
            CompoundFilterFilter::ComparisonFilter(_v) => Self::ComparisonFilter(_v),
            CompoundFilterFilter::CompoundFilter(_v) => Self::CompoundFilter(_v),
        })
    }
}
impl serde::Serialize for CompoundFilterFilter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CompoundFilterFilter<'a> {
            ComparisonFilter(#[allow(dead_code)] &'a ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] &'a CompoundFilter),
        }
        match self {
            Self::ComparisonFilter(_v) => {
                CompoundFilterFilter::ComparisonFilter(_v).serialize(serializer)
            }
            Self::CompoundFilter(_v) => {
                CompoundFilterFilter::CompoundFilter(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CompoundFilterFilter {
    ComparisonFilter(ComparisonFilter),
    CompoundFilter(CompoundFilter),
}
impl<'de> serde::Deserialize<'de> for CompoundFilter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CompoundFilter {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CompoundFilterType,
            #[serde(rename = "filters")]
            #[allow(dead_code)]
            filters: Vec<CompoundFilterFilter>,
        }
        let CompoundFilter { type_, filters, .. } = CompoundFilter::deserialize(deserializer)?;
        Ok(Self { type_, filters })
    }
}
impl serde::Serialize for CompoundFilter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CompoundFilter<'a> {
            #[serde(rename = "type")]
            type_: &'a CompoundFilterType,
            #[serde(rename = "filters")]
            filters: &'a Vec<CompoundFilterFilter>,
        }
        let Self { type_, filters } = self;
        CompoundFilter { type_, filters }.serialize(serializer)
    }
}
#[doc = "Combine multiple filters using `and` or `or`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CompoundFilter {
    #[doc = "Type of operation: `and` or `or`."]
    pub type_: CompoundFilterType,
    #[doc = "Array of filters to combine. Items can be `ComparisonFilter` or `CompoundFilter`."]
    pub filters: Vec<CompoundFilterFilter>,
}
impl<'de> serde::Deserialize<'de> for ComputerAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ComputerAction {
            Click(#[allow(dead_code)] Click),
            DoubleClick(#[allow(dead_code)] DoubleClick),
            Drag(#[allow(dead_code)] Drag),
            Keypress(#[allow(dead_code)] KeyPress),
            Move(#[allow(dead_code)] Move),
            Screenshot(#[allow(dead_code)] Screenshot),
            Scroll(#[allow(dead_code)] Scroll),
            Type(#[allow(dead_code)] Type),
            Wait(#[allow(dead_code)] Wait),
        }
        Ok(match ComputerAction::deserialize(deserializer)? {
            ComputerAction::Click(_v) => Self::Click(_v),
            ComputerAction::DoubleClick(_v) => Self::DoubleClick(_v),
            ComputerAction::Drag(_v) => Self::Drag(_v),
            ComputerAction::Keypress(_v) => Self::Keypress(_v),
            ComputerAction::Move(_v) => Self::Move(_v),
            ComputerAction::Screenshot(_v) => Self::Screenshot(_v),
            ComputerAction::Scroll(_v) => Self::Scroll(_v),
            ComputerAction::Type(_v) => Self::Type(_v),
            ComputerAction::Wait(_v) => Self::Wait(_v),
        })
    }
}
impl serde::Serialize for ComputerAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ComputerAction<'a> {
            Click(#[allow(dead_code)] &'a Click),
            DoubleClick(#[allow(dead_code)] &'a DoubleClick),
            Drag(#[allow(dead_code)] &'a Drag),
            Keypress(#[allow(dead_code)] &'a KeyPress),
            Move(#[allow(dead_code)] &'a Move),
            Screenshot(#[allow(dead_code)] &'a Screenshot),
            Scroll(#[allow(dead_code)] &'a Scroll),
            Type(#[allow(dead_code)] &'a Type),
            Wait(#[allow(dead_code)] &'a Wait),
        }
        match self {
            Self::Click(_v) => ComputerAction::Click(_v).serialize(serializer),
            Self::DoubleClick(_v) => ComputerAction::DoubleClick(_v).serialize(serializer),
            Self::Drag(_v) => ComputerAction::Drag(_v).serialize(serializer),
            Self::Keypress(_v) => ComputerAction::Keypress(_v).serialize(serializer),
            Self::Move(_v) => ComputerAction::Move(_v).serialize(serializer),
            Self::Screenshot(_v) => ComputerAction::Screenshot(_v).serialize(serializer),
            Self::Scroll(_v) => ComputerAction::Scroll(_v).serialize(serializer),
            Self::Type(_v) => ComputerAction::Type(_v).serialize(serializer),
            Self::Wait(_v) => ComputerAction::Wait(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerAction {
    Click(Click),
    DoubleClick(DoubleClick),
    Drag(Drag),
    Keypress(KeyPress),
    Move(Move),
    Screenshot(Screenshot),
    Scroll(Scroll),
    Type(Type),
    Wait(Wait),
}
impl<'de> serde::Deserialize<'de> for ComputerScreenshotImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a computer screenshot, this property is \nalways set to `computer_screenshot`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerScreenshotImageType {
            #[default]
            #[serde(rename = "computer_screenshot")]
            ComputerScreenshot,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerScreenshotImage {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerScreenshotImageType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: Option<String>,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let ComputerScreenshotImage {
            image_url, file_id, ..
        } = ComputerScreenshotImage::deserialize(deserializer)?;
        Ok(Self { image_url, file_id })
    }
}
impl serde::Serialize for ComputerScreenshotImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a computer screenshot, this property is \nalways set to `computer_screenshot`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerScreenshotImageType {
            #[default]
            #[serde(rename = "computer_screenshot")]
            ComputerScreenshot,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerScreenshotImage<'a> {
            #[serde(rename = "type")]
            type_: &'a ComputerScreenshotImageType,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let Self { image_url, file_id } = self;
        ComputerScreenshotImage {
            type_: &Default::default(),
            image_url,
            file_id,
        }
        .serialize(serializer)
    }
}
#[doc = "A computer screenshot image used with the computer use tool.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ComputerScreenshotImage {
    #[doc = "The URL of the screenshot image."]
    #[builder(default)]
    pub image_url: Option<String>,
    #[doc = "The identifier of an uploaded file that contains the screenshot."]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ComputerToolCallStatus {
            InProgress(#[allow(dead_code)] ComputerToolCallStatusInProgress),
            Completed(#[allow(dead_code)] ComputerToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] ComputerToolCallStatusIncomplete),
        }
        Ok(match ComputerToolCallStatus::deserialize(deserializer)? {
            ComputerToolCallStatus::InProgress(_) => Self::InProgress,
            ComputerToolCallStatus::Completed(_) => Self::Completed,
            ComputerToolCallStatus::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for ComputerToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ComputerToolCallStatus<'a> {
            InProgress(#[allow(dead_code)] &'a ComputerToolCallStatusInProgress),
            Completed(#[allow(dead_code)] &'a ComputerToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a ComputerToolCallStatusIncomplete),
        }
        match self {
            Self::InProgress => {
                ComputerToolCallStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                ComputerToolCallStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                ComputerToolCallStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the computer call. Always `computer_call`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallType {
            #[default]
            #[serde(rename = "computer_call")]
            ComputerCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerToolCallType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "action")]
            #[allow(dead_code)]
            action: ComputerAction,
            #[serde(rename = "pending_safety_checks")]
            #[allow(dead_code)]
            pending_safety_checks: Vec<ComputerToolCallSafetyCheck>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: ComputerToolCallStatus,
        }
        let ComputerToolCall {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
            ..
        } = ComputerToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        })
    }
}
impl serde::Serialize for ComputerToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the computer call. Always `computer_call`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallType {
            #[default]
            #[serde(rename = "computer_call")]
            ComputerCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerToolCall<'a> {
            #[serde(rename = "type")]
            type_: &'a ComputerToolCallType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "action")]
            action: &'a ComputerAction,
            #[serde(rename = "pending_safety_checks")]
            pending_safety_checks: &'a Vec<ComputerToolCallSafetyCheck>,
            #[serde(rename = "status")]
            status: &'a ComputerToolCallStatus,
        }
        let Self {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        } = self;
        ComputerToolCall {
            type_: &Default::default(),
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool call to a computer use tool. See the \n[computer use guide](https://platform.openai.com/docs/guides/tools-computer-use) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCall {
    #[doc = "The unique ID of the computer call."]
    pub id: String,
    #[doc = "An identifier used when responding to the tool call with output.\n"]
    pub call_id: String,
    pub action: ComputerAction,
    #[doc = "The pending safety checks for the computer call.\n"]
    pub pending_safety_checks: Vec<ComputerToolCallSafetyCheck>,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    pub status: ComputerToolCallStatus,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallOutputStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ComputerToolCallOutputStatus {
            InProgress(#[allow(dead_code)] ComputerToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] ComputerToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] ComputerToolCallOutputStatusIncomplete),
        }
        Ok(
            match ComputerToolCallOutputStatus::deserialize(deserializer)? {
                ComputerToolCallOutputStatus::InProgress(_) => Self::InProgress,
                ComputerToolCallOutputStatus::Completed(_) => Self::Completed,
                ComputerToolCallOutputStatus::Incomplete(_) => Self::Incomplete,
            },
        )
    }
}
impl serde::Serialize for ComputerToolCallOutputStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ComputerToolCallOutputStatus<'a> {
            InProgress(#[allow(dead_code)] &'a ComputerToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] &'a ComputerToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a ComputerToolCallOutputStatusIncomplete),
        }
        match self {
            Self::InProgress => {
                ComputerToolCallOutputStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                ComputerToolCallOutputStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                ComputerToolCallOutputStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerToolCallOutputStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the computer tool call output. Always `computer_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputType {
            #[default]
            #[serde(rename = "computer_call_output")]
            ComputerCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerToolCallOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerToolCallOutputType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "acknowledged_safety_checks")]
            #[allow(dead_code)]
            acknowledged_safety_checks: Option<Vec<ComputerToolCallSafetyCheck>>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: ComputerScreenshotImage,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<ComputerToolCallOutputStatus>,
        }
        let ComputerToolCallOutput {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
            ..
        } = ComputerToolCallOutput::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        })
    }
}
impl serde::Serialize for ComputerToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the computer tool call output. Always `computer_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerToolCallOutputType {
            #[default]
            #[serde(rename = "computer_call_output")]
            ComputerCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerToolCallOutput<'a> {
            #[serde(rename = "type")]
            type_: &'a ComputerToolCallOutputType,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "acknowledged_safety_checks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            acknowledged_safety_checks: &'a Option<Vec<ComputerToolCallSafetyCheck>>,
            #[serde(rename = "output")]
            output: &'a ComputerScreenshotImage,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<ComputerToolCallOutputStatus>,
        }
        let Self {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        } = self;
        ComputerToolCallOutput {
            type_: &Default::default(),
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a computer tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallOutput {
    #[doc = "The ID of the computer tool call output.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The ID of the computer tool call that produced the output.\n"]
    pub call_id: String,
    #[doc = "The safety checks reported by the API that have been acknowledged by the \ndeveloper.\n"]
    #[builder(default)]
    pub acknowledged_safety_checks: Option<Vec<ComputerToolCallSafetyCheck>>,
    #[builder(default)]
    pub output: ComputerScreenshotImage,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<ComputerToolCallOutputStatus>,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallOutputResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerToolCallOutputResource {
            #[serde(flatten)]
            #[allow(dead_code)]
            computer_tool_call_output: ComputerToolCallOutput,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let ComputerToolCallOutputResource {
            computer_tool_call_output,
            id,
            ..
        } = ComputerToolCallOutputResource::deserialize(deserializer)?;
        Ok(Self {
            computer_tool_call_output,
            id,
        })
    }
}
impl serde::Serialize for ComputerToolCallOutputResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerToolCallOutputResource<'a> {
            #[serde(flatten)]
            computer_tool_call_output: &'a ComputerToolCallOutput,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self {
            computer_tool_call_output,
            id,
        } = self;
        ComputerToolCallOutputResource {
            computer_tool_call_output,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallOutputResource {
    pub computer_tool_call_output: ComputerToolCallOutput,
    #[doc = "The unique ID of the computer call tool output.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallSafetyCheck {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerToolCallSafetyCheck {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let ComputerToolCallSafetyCheck {
            id, code, message, ..
        } = ComputerToolCallSafetyCheck::deserialize(deserializer)?;
        Ok(Self { id, code, message })
    }
}
impl serde::Serialize for ComputerToolCallSafetyCheck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerToolCallSafetyCheck<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let Self { id, code, message } = self;
        ComputerToolCallSafetyCheck { id, code, message }.serialize(serializer)
    }
}
#[doc = "A pending safety check for the computer call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallSafetyCheck {
    #[doc = "The ID of the pending safety check."]
    pub id: String,
    #[doc = "The type of the pending safety check."]
    pub code: String,
    #[doc = "Details about the pending safety check."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for ContainerFileListResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerFileListResource {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: serde_json::Value,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ContainerFileResource>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ContainerFileListResource {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ContainerFileListResource::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ContainerFileListResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerFileListResource<'a> {
            #[serde(rename = "object")]
            object: &'a serde_json::Value,
            #[serde(rename = "data")]
            data: &'a Vec<ContainerFileResource>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ContainerFileListResource {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ContainerFileListResource {
    #[doc = "The type of object returned, must be 'list'."]
    pub object: serde_json::Value,
    #[doc = "A list of container files."]
    pub data: Vec<ContainerFileResource>,
    #[doc = "The ID of the first file in the list."]
    pub first_id: String,
    #[doc = "The ID of the last file in the list."]
    pub last_id: String,
    #[doc = "Whether there are more files available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ContainerFileResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerFileResource {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "container_id")]
            #[allow(dead_code)]
            container_id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: u64,
            #[serde(rename = "path")]
            #[allow(dead_code)]
            path: String,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: String,
        }
        let ContainerFileResource {
            id,
            object,
            container_id,
            created_at,
            bytes,
            path,
            source,
            ..
        } = ContainerFileResource::deserialize(deserializer)?;
        Ok(Self {
            id,
            object,
            container_id,
            created_at,
            bytes,
            path,
            source,
        })
    }
}
impl serde::Serialize for ContainerFileResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerFileResource<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "container_id")]
            container_id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "bytes")]
            bytes: &'a u64,
            #[serde(rename = "path")]
            path: &'a String,
            #[serde(rename = "source")]
            source: &'a String,
        }
        let Self {
            id,
            object,
            container_id,
            created_at,
            bytes,
            path,
            source,
        } = self;
        ContainerFileResource {
            id,
            object,
            container_id,
            created_at,
            bytes,
            path,
            source,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ContainerFileResource {
    #[doc = "Unique identifier for the file."]
    pub id: String,
    #[doc = "The type of this object (`container.file`)."]
    pub object: String,
    #[doc = "The container this file belongs to."]
    pub container_id: String,
    #[doc = "Unix timestamp (in seconds) when the file was created."]
    pub created_at: u64,
    #[doc = "Size of the file in bytes."]
    pub bytes: u64,
    #[doc = "Path of the file in the container."]
    pub path: String,
    #[doc = "Source of the file (e.g., `user`, `assistant`)."]
    pub source: String,
}
impl<'de> serde::Deserialize<'de> for ContainerListResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerListResource {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: serde_json::Value,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ContainerResource>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ContainerListResource {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ContainerListResource::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ContainerListResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerListResource<'a> {
            #[serde(rename = "object")]
            object: &'a serde_json::Value,
            #[serde(rename = "data")]
            data: &'a Vec<ContainerResource>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ContainerListResource {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ContainerListResource {
    #[doc = "The type of object returned, must be 'list'."]
    pub object: serde_json::Value,
    #[doc = "A list of containers."]
    pub data: Vec<ContainerResource>,
    #[doc = "The ID of the first container in the list."]
    pub first_id: String,
    #[doc = "The ID of the last container in the list."]
    pub last_id: String,
    #[doc = "Whether there are more containers available."]
    pub has_more: bool,
}
#[doc = "The reference point for the expiration."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum ContainerResourceExpiresAfterAnchor {
    #[default]
    #[serde(rename = "last_active_at")]
    LastActiveAt,
}
impl<'de> serde::Deserialize<'de> for ContainerResourceExpiresAfter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerResourceExpiresAfter {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: Option<ContainerResourceExpiresAfterAnchor>,
            #[serde(rename = "minutes")]
            #[allow(dead_code)]
            minutes: Option<u64>,
        }
        let ContainerResourceExpiresAfter {
            anchor, minutes, ..
        } = ContainerResourceExpiresAfter::deserialize(deserializer)?;
        Ok(Self { anchor, minutes })
    }
}
impl serde::Serialize for ContainerResourceExpiresAfter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerResourceExpiresAfter<'a> {
            #[serde(rename = "anchor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            anchor: &'a Option<ContainerResourceExpiresAfterAnchor>,
            #[serde(rename = "minutes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            minutes: &'a Option<u64>,
        }
        let Self { anchor, minutes } = self;
        ContainerResourceExpiresAfter { anchor, minutes }.serialize(serializer)
    }
}
#[doc = "The container will expire after this time period.\nThe anchor is the reference point for the expiration.\nThe minutes is the number of minutes after the anchor before the container expires.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ContainerResourceExpiresAfter {
    #[doc = "The reference point for the expiration."]
    #[builder(default)]
    pub anchor: Option<ContainerResourceExpiresAfterAnchor>,
    #[doc = "The number of minutes after the anchor before the container expires."]
    #[builder(default)]
    pub minutes: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for ContainerResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerResource {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: String,
            #[serde(rename = "expires_after")]
            #[allow(dead_code)]
            expires_after: Option<ContainerResourceExpiresAfter>,
        }
        let ContainerResource {
            id,
            object,
            name,
            created_at,
            status,
            expires_after,
            ..
        } = ContainerResource::deserialize(deserializer)?;
        Ok(Self {
            id,
            object,
            name,
            created_at,
            status,
            expires_after,
        })
    }
}
impl serde::Serialize for ContainerResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerResource<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "status")]
            status: &'a String,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<ContainerResourceExpiresAfter>,
        }
        let Self {
            id,
            object,
            name,
            created_at,
            status,
            expires_after,
        } = self;
        ContainerResource {
            id,
            object,
            name,
            created_at,
            status,
            expires_after,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ContainerResource {
    #[doc = "Unique identifier for the container."]
    pub id: String,
    #[doc = "The type of this object."]
    pub object: String,
    #[doc = "Name of the container."]
    pub name: String,
    #[doc = "Unix timestamp (in seconds) when the container was created."]
    pub created_at: u64,
    #[doc = "Status of the container (e.g., active, deleted)."]
    pub status: String,
    #[doc = "The container will expire after this time period.\nThe anchor is the reference point for the expiration.\nThe minutes is the number of minutes after the anchor before the container expires.\n"]
    #[builder(default)]
    pub expires_after: Option<ContainerResourceExpiresAfter>,
}
impl<'de> serde::Deserialize<'de> for Content {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum Content {
            InputContent(#[allow(dead_code)] InputContent),
            OutputContent(#[allow(dead_code)] OutputContent),
        }
        Ok(match Content::deserialize(deserializer)? {
            Content::InputContent(_v) => Self::InputContent(_v),
            Content::OutputContent(_v) => Self::OutputContent(_v),
        })
    }
}
impl serde::Serialize for Content {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum Content<'a> {
            InputContent(#[allow(dead_code)] &'a InputContent),
            OutputContent(#[allow(dead_code)] &'a OutputContent),
        }
        match self {
            Self::InputContent(_v) => Content::InputContent(_v).serialize(serializer),
            Self::OutputContent(_v) => Content::OutputContent(_v).serialize(serializer),
        }
    }
}
#[doc = "Multi-modal input and output contents.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Content {
    InputContent(InputContent),
    OutputContent(OutputContent),
}
impl<'de> serde::Deserialize<'de> for Coordinate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Coordinate {
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
        }
        let Coordinate { x, y, .. } = Coordinate::deserialize(deserializer)?;
        Ok(Self { x, y })
    }
}
impl serde::Serialize for Coordinate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Coordinate<'a> {
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
        }
        let Self { x, y } = self;
        Coordinate { x, y }.serialize(serializer)
    }
}
#[doc = "An x/y coordinate pair, e.g. `{ x: 100, y: 200 }`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct Coordinate {
    #[doc = "The x-coordinate.\n"]
    pub x: u64,
    #[doc = "The y-coordinate.\n"]
    pub y: u64,
}
impl<'de> serde::Deserialize<'de> for CostsResultAmount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CostsResultAmount {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: Option<f64>,
            #[serde(rename = "currency")]
            #[allow(dead_code)]
            currency: Option<String>,
        }
        let CostsResultAmount {
            value, currency, ..
        } = CostsResultAmount::deserialize(deserializer)?;
        Ok(Self { value, currency })
    }
}
impl serde::Serialize for CostsResultAmount {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CostsResultAmount<'a> {
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            value: &'a Option<f64>,
            #[serde(rename = "currency")]
            #[serde(skip_serializing_if = "Option::is_none")]
            currency: &'a Option<String>,
        }
        let Self { value, currency } = self;
        CostsResultAmount { value, currency }.serialize(serializer)
    }
}
#[doc = "The monetary value in its associated currency."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CostsResultAmount {
    #[doc = "The numeric value of the cost."]
    #[builder(default)]
    pub value: Option<f64>,
    #[doc = "Lowercase ISO-4217 currency e.g. \"usd\""]
    #[builder(default)]
    pub currency: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CostsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CostsResultObject {
            #[default]
            #[serde(rename = "organization.costs.result")]
            OrganizationCostsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CostsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CostsResultObject,
            #[serde(rename = "amount")]
            #[allow(dead_code)]
            amount: Option<CostsResultAmount>,
            #[serde(rename = "line_item")]
            #[allow(dead_code)]
            line_item: Option<String>,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
        }
        let CostsResult {
            amount,
            line_item,
            project_id,
            ..
        } = CostsResult::deserialize(deserializer)?;
        Ok(Self {
            amount,
            line_item,
            project_id,
        })
    }
}
impl serde::Serialize for CostsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CostsResultObject {
            #[default]
            #[serde(rename = "organization.costs.result")]
            OrganizationCostsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CostsResult<'a> {
            #[serde(rename = "object")]
            object: &'a CostsResultObject,
            #[serde(rename = "amount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            amount: &'a Option<CostsResultAmount>,
            #[serde(rename = "line_item")]
            #[serde(skip_serializing_if = "Option::is_none")]
            line_item: &'a Option<String>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
        }
        let Self {
            amount,
            line_item,
            project_id,
        } = self;
        CostsResult {
            object: &Default::default(),
            amount,
            line_item,
            project_id,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated costs details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CostsResult {
    #[doc = "The monetary value in its associated currency."]
    #[builder(default)]
    pub amount: Option<CostsResultAmount>,
    #[doc = "When `group_by=line_item`, this field provides the line item of the grouped costs result."]
    #[builder(default)]
    pub line_item: Option<String>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped costs result."]
    #[builder(default)]
    pub project_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesCodeInterpreter {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let CreateAssistantRequestToolResourcesCodeInterpreter { file_ids, .. } =
            CreateAssistantRequestToolResourcesCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesCodeInterpreter<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        CreateAssistantRequestToolResourcesCodeInterpreter { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_:
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType,
        }
        let CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto { .. } = CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto :: deserialize (deserializer) ? ;
        Ok(Self {})
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto < 'a > { # [serde (rename = "type")] type_ : & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType }
        let Self {} = self;
        CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic { max_chunk_size_tokens , chunk_overlap_tokens , .. } = CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic :: deserialize (deserializer) ? ;
        Ok(Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        })
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic<
            'a,
        > {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic { # [serde (rename = "type")] # [allow (dead_code)] type_ : CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] # [allow (dead_code)] static_ : CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic }
        let CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic { static_ , .. } = CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic :: deserialize (deserializer) ? ;
        Ok(Self { static_ })
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic < 'a > { # [serde (rename = "type")] type_ : & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] static_ : & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic }
        let Self { static_ } = self;
        CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
    pub static_:
        CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy {
            Auto(
                #[allow(dead_code)]
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic,
            ),
        }
        Ok (match CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy :: deserialize (deserializer) ? { CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy :: Auto (_v) => Self :: Auto (_v) , CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy :: Static (_v) => Self :: Static (_v) })
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy<'a> {
            Auto (# [allow (dead_code)] & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto) , Static (# [allow (dead_code)] & 'a CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic) }
        match self {
            Self::Auto(_v) => {
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy::Auto(_v)
                    .serialize(serializer)
            }
            Self::Static(_v) => {
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy::Static(
                    _v,
                )
                .serialize(serializer)
            }
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy {
    #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
    Auto(CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto),
    Static(CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic),
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch0VectorStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0VectorStore {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy:
                Option<CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let CreateAssistantRequestToolResourcesFileSearch0VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
            ..
        } = CreateAssistantRequestToolResourcesFileSearch0VectorStore::deserialize(deserializer)?;
        Ok(Self {
            file_ids,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch0VectorStore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0VectorStore<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<
                CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy,
            >,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            file_ids,
            chunking_strategy,
            metadata,
        } = self;
        CreateAssistantRequestToolResourcesFileSearch0VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0VectorStore {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
    #[builder(default)]
    pub chunking_strategy:
        Option<CreateAssistantRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch0 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0 {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Vec<String>,
            #[serde(rename = "vector_stores")]
            #[allow(dead_code)]
            vector_stores: Option<Vec<CreateAssistantRequestToolResourcesFileSearch0VectorStore>>,
        }
        let CreateAssistantRequestToolResourcesFileSearch0 {
            vector_store_ids,
            vector_stores,
            ..
        } = CreateAssistantRequestToolResourcesFileSearch0::deserialize(deserializer)?;
        Ok(Self {
            vector_store_ids,
            vector_stores,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch0<'a> {
            #[serde(rename = "vector_store_ids")]
            vector_store_ids: &'a Vec<String>,
            #[serde(rename = "vector_stores")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_stores:
                &'a Option<Vec<CreateAssistantRequestToolResourcesFileSearch0VectorStore>>,
        }
        let Self {
            vector_store_ids,
            vector_stores,
        } = self;
        CreateAssistantRequestToolResourcesFileSearch0 {
            vector_store_ids,
            vector_stores,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch0 {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    pub vector_store_ids: Vec<String>,
    #[doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_stores: Option<Vec<CreateAssistantRequestToolResourcesFileSearch0VectorStore>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_:
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType,
        }
        let CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto { .. } = CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto :: deserialize (deserializer) ? ;
        Ok(Self {})
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto < 'a > { # [serde (rename = "type")] type_ : & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType }
        let Self {} = self;
        CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic { max_chunk_size_tokens , chunk_overlap_tokens , .. } = CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic :: deserialize (deserializer) ? ;
        Ok(Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        })
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic<
            'a,
        > {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic { # [serde (rename = "type")] # [allow (dead_code)] type_ : CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] # [allow (dead_code)] static_ : CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic }
        let CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic { static_ , .. } = CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic :: deserialize (deserializer) ? ;
        Ok(Self { static_ })
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic < 'a > { # [serde (rename = "type")] type_ : & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] static_ : & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic }
        let Self { static_ } = self;
        CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
    pub static_:
        CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic,
}
impl<'de> serde::Deserialize<'de>
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy {
            Auto(
                #[allow(dead_code)]
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic,
            ),
        }
        Ok (match CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy :: deserialize (deserializer) ? { CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy :: Auto (_v) => Self :: Auto (_v) , CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy :: Static (_v) => Self :: Static (_v) })
    }
}
impl serde::Serialize
    for CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy<'a> {
            Auto (# [allow (dead_code)] & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto) , Static (# [allow (dead_code)] & 'a CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic) }
        match self {
            Self::Auto(_v) => {
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy::Auto(_v)
                    .serialize(serializer)
            }
            Self::Static(_v) => {
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy::Static(
                    _v,
                )
                .serialize(serializer)
            }
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy {
    #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
    Auto(CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto),
    Static(CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic),
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch1VectorStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1VectorStore {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy:
                Option<CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let CreateAssistantRequestToolResourcesFileSearch1VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
            ..
        } = CreateAssistantRequestToolResourcesFileSearch1VectorStore::deserialize(deserializer)?;
        Ok(Self {
            file_ids,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch1VectorStore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1VectorStore<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<
                CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy,
            >,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            file_ids,
            chunking_strategy,
            metadata,
        } = self;
        CreateAssistantRequestToolResourcesFileSearch1VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1VectorStore {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
    #[builder(default)]
    pub chunking_strategy:
        Option<CreateAssistantRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1 {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
            #[serde(rename = "vector_stores")]
            #[allow(dead_code)]
            vector_stores: Vec<CreateAssistantRequestToolResourcesFileSearch1VectorStore>,
        }
        let CreateAssistantRequestToolResourcesFileSearch1 {
            vector_store_ids,
            vector_stores,
            ..
        } = CreateAssistantRequestToolResourcesFileSearch1::deserialize(deserializer)?;
        Ok(Self {
            vector_store_ids,
            vector_stores,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch1 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResourcesFileSearch1<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
            #[serde(rename = "vector_stores")]
            vector_stores: &'a Vec<CreateAssistantRequestToolResourcesFileSearch1VectorStore>,
        }
        let Self {
            vector_store_ids,
            vector_stores,
        } = self;
        CreateAssistantRequestToolResourcesFileSearch1 {
            vector_store_ids,
            vector_stores,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResourcesFileSearch1 {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
    #[doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    pub vector_stores: Vec<CreateAssistantRequestToolResourcesFileSearch1VectorStore>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateAssistantRequestToolResourcesFileSearch {
            _0(#[allow(dead_code)] CreateAssistantRequestToolResourcesFileSearch0),
            _1(#[allow(dead_code)] CreateAssistantRequestToolResourcesFileSearch1),
        }
        Ok(
            match CreateAssistantRequestToolResourcesFileSearch::deserialize(deserializer)? {
                CreateAssistantRequestToolResourcesFileSearch::_0(_v) => Self::_0(_v),
                CreateAssistantRequestToolResourcesFileSearch::_1(_v) => Self::_1(_v),
            },
        )
    }
}
impl serde::Serialize for CreateAssistantRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateAssistantRequestToolResourcesFileSearch<'a> {
            _0(#[allow(dead_code)] &'a CreateAssistantRequestToolResourcesFileSearch0),
            _1(#[allow(dead_code)] &'a CreateAssistantRequestToolResourcesFileSearch1),
        }
        match self {
            Self::_0(_v) => {
                CreateAssistantRequestToolResourcesFileSearch::_0(_v).serialize(serializer)
            }
            Self::_1(_v) => {
                CreateAssistantRequestToolResourcesFileSearch::_1(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateAssistantRequestToolResourcesFileSearch {
    _0(CreateAssistantRequestToolResourcesFileSearch0),
    _1(CreateAssistantRequestToolResourcesFileSearch1),
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequestToolResources {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<CreateAssistantRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<CreateAssistantRequestToolResourcesFileSearch>,
        }
        let CreateAssistantRequestToolResources {
            code_interpreter,
            file_search,
            ..
        } = CreateAssistantRequestToolResources::deserialize(deserializer)?;
        Ok(Self {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for CreateAssistantRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequestToolResources<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<CreateAssistantRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<CreateAssistantRequestToolResourcesFileSearch>,
        }
        let Self {
            code_interpreter,
            file_search,
        } = self;
        CreateAssistantRequestToolResources {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<CreateAssistantRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<CreateAssistantRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for CreateAssistantRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateAssistantRequest {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<AssistantTool>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<CreateAssistantRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let CreateAssistantRequest {
            model,
            name,
            description,
            instructions,
            reasoning_effort,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
            ..
        } = CreateAssistantRequest::deserialize(deserializer)?;
        Ok(Self {
            model,
            name,
            description,
            instructions,
            reasoning_effort,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        })
    }
}
impl serde::Serialize for CreateAssistantRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateAssistantRequest<'a> {
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<AssistantTool>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<CreateAssistantRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let Self {
            model,
            name,
            description,
            instructions,
            reasoning_effort,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        } = self;
        CreateAssistantRequest {
            model,
            name,
            description,
            instructions,
            reasoning_effort,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    #[builder(default)]
    pub tools: Option<Vec<AssistantTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<CreateAssistantRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestWebSearchOptionsUserLocation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of location approximation. Always `approximate`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestWebSearchOptionsUserLocationType {
            #[default]
            #[serde(rename = "approximate")]
            Approximate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionRequestWebSearchOptionsUserLocation {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateChatCompletionRequestWebSearchOptionsUserLocationType,
            #[serde(rename = "approximate")]
            #[allow(dead_code)]
            approximate: WebSearchLocation,
        }
        let CreateChatCompletionRequestWebSearchOptionsUserLocation { approximate, .. } =
            CreateChatCompletionRequestWebSearchOptionsUserLocation::deserialize(deserializer)?;
        Ok(Self { approximate })
    }
}
impl serde::Serialize for CreateChatCompletionRequestWebSearchOptionsUserLocation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of location approximation. Always `approximate`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestWebSearchOptionsUserLocationType {
            #[default]
            #[serde(rename = "approximate")]
            Approximate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionRequestWebSearchOptionsUserLocation<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateChatCompletionRequestWebSearchOptionsUserLocationType,
            #[serde(rename = "approximate")]
            approximate: &'a WebSearchLocation,
        }
        let Self { approximate } = self;
        CreateChatCompletionRequestWebSearchOptionsUserLocation {
            type_: &Default::default(),
            approximate,
        }
        .serialize(serializer)
    }
}
#[doc = "Approximate location parameters for the search.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequestWebSearchOptionsUserLocation {
    #[builder(default)]
    pub approximate: WebSearchLocation,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestWebSearchOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionRequestWebSearchOptions {
            #[serde(rename = "user_location")]
            #[allow(dead_code)]
            user_location: Option<CreateChatCompletionRequestWebSearchOptionsUserLocation>,
            #[serde(rename = "search_context_size")]
            #[allow(dead_code)]
            search_context_size: Option<WebSearchContextSize>,
        }
        let CreateChatCompletionRequestWebSearchOptions {
            user_location,
            search_context_size,
            ..
        } = CreateChatCompletionRequestWebSearchOptions::deserialize(deserializer)?;
        Ok(Self {
            user_location,
            search_context_size,
        })
    }
}
impl serde::Serialize for CreateChatCompletionRequestWebSearchOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionRequestWebSearchOptions<'a> {
            #[serde(rename = "user_location")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_location: &'a Option<CreateChatCompletionRequestWebSearchOptionsUserLocation>,
            #[serde(rename = "search_context_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            search_context_size: &'a Option<WebSearchContextSize>,
        }
        let Self {
            user_location,
            search_context_size,
        } = self;
        CreateChatCompletionRequestWebSearchOptions {
            user_location,
            search_context_size,
        }
        .serialize(serializer)
    }
}
#[doc = "This tool searches the web for relevant results to use in a response.\nLearn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequestWebSearchOptions {
    #[doc = "Approximate location parameters for the search.\n"]
    #[builder(default)]
    pub user_location: Option<CreateChatCompletionRequestWebSearchOptionsUserLocation>,
    #[builder(default)]
    pub search_context_size: Option<WebSearchContextSize>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateChatCompletionRequestResponseFormat {
            Text(#[allow(dead_code)] ResponseFormatText),
            JsonSchema(#[allow(dead_code)] ResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] ResponseFormatJsonObject),
        }
        Ok(
            match CreateChatCompletionRequestResponseFormat::deserialize(deserializer)? {
                CreateChatCompletionRequestResponseFormat::Text(_v) => Self::Text(_v),
                CreateChatCompletionRequestResponseFormat::JsonSchema(_v) => Self::JsonSchema(_v),
                CreateChatCompletionRequestResponseFormat::JsonObject(_v) => Self::JsonObject(_v),
            },
        )
    }
}
impl serde::Serialize for CreateChatCompletionRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateChatCompletionRequestResponseFormat<'a> {
            Text(#[allow(dead_code)] &'a ResponseFormatText),
            JsonSchema(#[allow(dead_code)] &'a ResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] &'a ResponseFormatJsonObject),
        }
        match self {
            Self::Text(_v) => {
                CreateChatCompletionRequestResponseFormat::Text(_v).serialize(serializer)
            }
            Self::JsonSchema(_v) => {
                CreateChatCompletionRequestResponseFormat::JsonSchema(_v).serialize(serializer)
            }
            Self::JsonObject(_v) => {
                CreateChatCompletionRequestResponseFormat::JsonObject(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestResponseFormat {
    Text(ResponseFormatText),
    JsonSchema(ResponseFormatJsonSchema),
    JsonObject(ResponseFormatJsonObject),
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatAac {
            #[default]
            #[serde(rename = "aac")]
            Aac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatFlac {
            #[default]
            #[serde(rename = "flac")]
            Flac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatOpus {
            #[default]
            #[serde(rename = "opus")]
            Opus,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateChatCompletionRequestAudioFormat {
            Wav(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatWav),
            Aac(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatAac),
            Mp3(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatMp3),
            Flac(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatFlac),
            Opus(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatOpus),
            Pcm16(#[allow(dead_code)] CreateChatCompletionRequestAudioFormatPcm16),
        }
        Ok(
            match CreateChatCompletionRequestAudioFormat::deserialize(deserializer)? {
                CreateChatCompletionRequestAudioFormat::Wav(_) => Self::Wav,
                CreateChatCompletionRequestAudioFormat::Aac(_) => Self::Aac,
                CreateChatCompletionRequestAudioFormat::Mp3(_) => Self::Mp3,
                CreateChatCompletionRequestAudioFormat::Flac(_) => Self::Flac,
                CreateChatCompletionRequestAudioFormat::Opus(_) => Self::Opus,
                CreateChatCompletionRequestAudioFormat::Pcm16(_) => Self::Pcm16,
            },
        )
    }
}
impl serde::Serialize for CreateChatCompletionRequestAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatAac {
            #[default]
            #[serde(rename = "aac")]
            Aac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatFlac {
            #[default]
            #[serde(rename = "flac")]
            Flac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatOpus {
            #[default]
            #[serde(rename = "opus")]
            Opus,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateChatCompletionRequestAudioFormat<'a> {
            Wav(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatWav),
            Aac(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatAac),
            Mp3(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatMp3),
            Flac(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatFlac),
            Opus(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatOpus),
            Pcm16(#[allow(dead_code)] &'a CreateChatCompletionRequestAudioFormatPcm16),
        }
        match self {
            Self::Wav => CreateChatCompletionRequestAudioFormat::Wav(&Default::default())
                .serialize(serializer),
            Self::Aac => CreateChatCompletionRequestAudioFormat::Aac(&Default::default())
                .serialize(serializer),
            Self::Mp3 => CreateChatCompletionRequestAudioFormat::Mp3(&Default::default())
                .serialize(serializer),
            Self::Flac => CreateChatCompletionRequestAudioFormat::Flac(&Default::default())
                .serialize(serializer),
            Self::Opus => CreateChatCompletionRequestAudioFormat::Opus(&Default::default())
                .serialize(serializer),
            Self::Pcm16 => CreateChatCompletionRequestAudioFormat::Pcm16(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,\n`opus`, or `pcm16`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestAudioFormat {
    #[doc = "wav"]
    Wav,
    #[doc = "aac"]
    Aac,
    #[doc = "mp3"]
    Mp3,
    #[doc = "flac"]
    Flac,
    #[doc = "opus"]
    Opus,
    #[doc = "pcm16"]
    Pcm16,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionRequestAudio {
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: VoiceIdsShared,
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: CreateChatCompletionRequestAudioFormat,
        }
        let CreateChatCompletionRequestAudio { voice, format, .. } =
            CreateChatCompletionRequestAudio::deserialize(deserializer)?;
        Ok(Self { voice, format })
    }
}
impl serde::Serialize for CreateChatCompletionRequestAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionRequestAudio<'a> {
            #[serde(rename = "voice")]
            voice: &'a VoiceIdsShared,
            #[serde(rename = "format")]
            format: &'a CreateChatCompletionRequestAudioFormat,
        }
        let Self { voice, format } = self;
        CreateChatCompletionRequestAudio { voice, format }.serialize(serializer)
    }
}
#[doc = "Parameters for audio output. Required when audio output is requested with\n`modalities: [\"audio\"]`. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequestAudio {
    #[doc = "The voice the model uses to respond. Supported voices are \n`alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`, `nova`, `onyx`, `sage`, and `shimmer`.\n"]
    pub voice: VoiceIdsShared,
    #[doc = "Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,\n`opus`, or `pcm16`.\n"]
    pub format: CreateChatCompletionRequestAudioFormat,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestPrediction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateChatCompletionRequestPrediction {
            PredictionContent(#[allow(dead_code)] PredictionContent),
        }
        Ok(
            match CreateChatCompletionRequestPrediction::deserialize(deserializer)? {
                CreateChatCompletionRequestPrediction::PredictionContent(_v) => {
                    Self::PredictionContent(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateChatCompletionRequestPrediction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateChatCompletionRequestPrediction<'a> {
            PredictionContent(#[allow(dead_code)] &'a PredictionContent),
        }
        match self {
            Self::PredictionContent(_v) => {
                CreateChatCompletionRequestPrediction::PredictionContent(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Configuration for a [Predicted Output](https://platform.openai.com/docs/guides/predicted-outputs),\nwhich can greatly improve response times when large parts of the model\nresponse are known ahead of time. This is most common when you are\nregenerating a file with only minor changes to most of the content.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestPrediction {
    PredictionContent(PredictionContent),
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequestFunctionCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestFunctionCallNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestFunctionCallAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateChatCompletionRequestFunctionCall {
            None(#[allow(dead_code)] CreateChatCompletionRequestFunctionCallNone),
            Auto(#[allow(dead_code)] CreateChatCompletionRequestFunctionCallAuto),
            ChatCompletionFunctionCallOption(#[allow(dead_code)] ChatCompletionFunctionCallOption),
        }
        Ok(
            match CreateChatCompletionRequestFunctionCall::deserialize(deserializer)? {
                CreateChatCompletionRequestFunctionCall::None(_) => Self::None,
                CreateChatCompletionRequestFunctionCall::Auto(_) => Self::Auto,
                CreateChatCompletionRequestFunctionCall::ChatCompletionFunctionCallOption(_v) => {
                    Self::ChatCompletionFunctionCallOption(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateChatCompletionRequestFunctionCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestFunctionCallNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionRequestFunctionCallAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateChatCompletionRequestFunctionCall<'a> {
            None(#[allow(dead_code)] &'a CreateChatCompletionRequestFunctionCallNone),
            Auto(#[allow(dead_code)] &'a CreateChatCompletionRequestFunctionCallAuto),
            ChatCompletionFunctionCallOption(
                #[allow(dead_code)] &'a ChatCompletionFunctionCallOption,
            ),
        }
        match self {
            Self::None => CreateChatCompletionRequestFunctionCall::None(&Default::default())
                .serialize(serializer),
            Self::Auto => CreateChatCompletionRequestFunctionCall::Auto(&Default::default())
                .serialize(serializer),
            Self::ChatCompletionFunctionCallOption(_v) => {
                CreateChatCompletionRequestFunctionCall::ChatCompletionFunctionCallOption(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Deprecated in favor of `tool_choice`.\n\nControls which (if any) function is called by the model.\n\n`none` means the model will not call a function and instead generates a\nmessage.\n\n`auto` means the model can pick between generating a message or calling a\nfunction.\n\nSpecifying a particular function via `{\"name\": \"my_function\"}` forces the\nmodel to call that function.\n\n`none` is the default when no functions are present. `auto` is the default\nif functions are present.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionRequestFunctionCall {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    ChatCompletionFunctionCallOption(ChatCompletionFunctionCallOption),
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionRequest {
            #[serde(flatten)]
            #[allow(dead_code)]
            create_model_response_properties: CreateModelResponseProperties,
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Vec<ChatCompletionRequestMessage>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: ModelIdsShared,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<ResponseModalities>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "frequency_penalty")]
            #[allow(dead_code)]
            frequency_penalty: Option<f64>,
            #[serde(rename = "presence_penalty")]
            #[allow(dead_code)]
            presence_penalty: Option<f64>,
            #[serde(rename = "web_search_options")]
            #[allow(dead_code)]
            web_search_options: Option<CreateChatCompletionRequestWebSearchOptions>,
            #[serde(rename = "top_logprobs")]
            #[allow(dead_code)]
            top_logprobs: Option<u64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateChatCompletionRequestResponseFormat>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<CreateChatCompletionRequestAudio>,
            #[serde(rename = "store")]
            #[allow(dead_code)]
            store: Option<bool>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "stop")]
            #[allow(dead_code)]
            stop: Option<StopConfiguration>,
            #[serde(rename = "logit_bias")]
            #[allow(dead_code)]
            logit_bias: Option<std::collections::HashMap<String, u64>>,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<bool>,
            #[serde(rename = "max_tokens")]
            #[allow(dead_code)]
            max_tokens: Option<u64>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "prediction")]
            #[allow(dead_code)]
            prediction: Option<CreateChatCompletionRequestPrediction>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
            #[serde(rename = "stream_options")]
            #[allow(dead_code)]
            stream_options: Option<ChatCompletionStreamOptions>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<ChatCompletionToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "function_call")]
            #[allow(dead_code)]
            function_call: Option<CreateChatCompletionRequestFunctionCall>,
            #[serde(rename = "functions")]
            #[allow(dead_code)]
            functions: Option<Vec<ChatCompletionFunctions>>,
        }
        let CreateChatCompletionRequest {
            create_model_response_properties,
            messages,
            model,
            modalities,
            reasoning_effort,
            max_completion_tokens,
            frequency_penalty,
            presence_penalty,
            web_search_options,
            top_logprobs,
            response_format,
            audio,
            store,
            stream,
            stop,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            prediction,
            seed,
            stream_options,
            tools,
            tool_choice,
            parallel_tool_calls,
            function_call,
            functions,
            ..
        } = CreateChatCompletionRequest::deserialize(deserializer)?;
        Ok(Self {
            create_model_response_properties,
            messages,
            model,
            modalities,
            reasoning_effort,
            max_completion_tokens,
            frequency_penalty,
            presence_penalty,
            web_search_options,
            top_logprobs,
            response_format,
            audio,
            store,
            stream,
            stop,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            prediction,
            seed,
            stream_options,
            tools,
            tool_choice,
            parallel_tool_calls,
            function_call,
            functions,
        })
    }
}
impl serde::Serialize for CreateChatCompletionRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionRequest<'a> {
            #[serde(flatten)]
            create_model_response_properties: &'a CreateModelResponseProperties,
            #[serde(rename = "messages")]
            messages: &'a Vec<ChatCompletionRequestMessage>,
            #[serde(rename = "model")]
            model: &'a ModelIdsShared,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<ResponseModalities>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "frequency_penalty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            frequency_penalty: &'a Option<f64>,
            #[serde(rename = "presence_penalty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            presence_penalty: &'a Option<f64>,
            #[serde(rename = "web_search_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            web_search_options: &'a Option<CreateChatCompletionRequestWebSearchOptions>,
            #[serde(rename = "top_logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_logprobs: &'a Option<u64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateChatCompletionRequestResponseFormat>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<CreateChatCompletionRequestAudio>,
            #[serde(rename = "store")]
            #[serde(skip_serializing_if = "Option::is_none")]
            store: &'a Option<bool>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "stop")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stop: &'a Option<StopConfiguration>,
            #[serde(rename = "logit_bias")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logit_bias: &'a Option<std::collections::HashMap<String, u64>>,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<bool>,
            #[serde(rename = "max_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tokens: &'a Option<u64>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "prediction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prediction: &'a Option<CreateChatCompletionRequestPrediction>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
            #[serde(rename = "stream_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream_options: &'a Option<ChatCompletionStreamOptions>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<ChatCompletionToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<CreateChatCompletionRequestFunctionCall>,
            #[serde(rename = "functions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            functions: &'a Option<Vec<ChatCompletionFunctions>>,
        }
        let Self {
            create_model_response_properties,
            messages,
            model,
            modalities,
            reasoning_effort,
            max_completion_tokens,
            frequency_penalty,
            presence_penalty,
            web_search_options,
            top_logprobs,
            response_format,
            audio,
            store,
            stream,
            stop,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            prediction,
            seed,
            stream_options,
            tools,
            tool_choice,
            parallel_tool_calls,
            function_call,
            functions,
        } = self;
        CreateChatCompletionRequest {
            create_model_response_properties,
            messages,
            model,
            modalities,
            reasoning_effort,
            max_completion_tokens,
            frequency_penalty,
            presence_penalty,
            web_search_options,
            top_logprobs,
            response_format,
            audio,
            store,
            stream,
            stop,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            prediction,
            seed,
            stream_options,
            tools,
            tool_choice,
            parallel_tool_calls,
            function_call,
            functions,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequest {
    #[builder(default)]
    pub create_model_response_properties: CreateModelResponseProperties,
    #[doc = "A list of messages comprising the conversation so far. Depending on the\n[model](https://platform.openai.com/docs/models) you use, different message types (modalities) are\nsupported, like [text](https://platform.openai.com/docs/guides/text-generation),\n[images](https://platform.openai.com/docs/guides/vision), and [audio](https://platform.openai.com/docs/guides/audio).\n"]
    pub messages: Vec<ChatCompletionRequestMessage>,
    #[doc = "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\nto browse and compare available models.\n"]
    pub model: ModelIdsShared,
    #[builder(default)]
    pub modalities: Option<ResponseModalities>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on\ntheir existing frequency in the text so far, decreasing the model's\nlikelihood to repeat the same line verbatim.\n"]
    #[builder(default)]
    pub frequency_penalty: Option<f64>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on\nwhether they appear in the text so far, increasing the model's likelihood\nto talk about new topics.\n"]
    #[builder(default)]
    pub presence_penalty: Option<f64>,
    #[doc = "This tool searches the web for relevant results to use in a response.\nLearn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\n"]
    #[builder(default)]
    pub web_search_options: Option<CreateChatCompletionRequestWebSearchOptions>,
    #[doc = "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n`logprobs` must be set to `true` if this parameter is used.\n"]
    #[builder(default)]
    pub top_logprobs: Option<u64>,
    #[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
    #[builder(default)]
    pub response_format: Option<CreateChatCompletionRequestResponseFormat>,
    #[doc = "Parameters for audio output. Required when audio output is requested with\n`modalities: [\"audio\"]`. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<CreateChatCompletionRequestAudio>,
    #[doc = "Whether or not to store the output of this chat completion request for \nuse in our [model distillation](https://platform.openai.com/docs/guides/distillation) or\n[evals](https://platform.openai.com/docs/guides/evals) products.\n"]
    #[builder(default)]
    pub store: Option<bool>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](https://platform.openai.com/docs/api-reference/chat/streaming)\nfor more information, along with the [streaming responses](https://platform.openai.com/docs/guides/streaming-responses)\nguide for more information on how to handle the streaming events.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[builder(default)]
    pub stop: Option<StopConfiguration>,
    #[doc = "Modify the likelihood of specified tokens appearing in the completion.\n\nAccepts a JSON object that maps tokens (specified by their token ID in the\ntokenizer) to an associated bias value from -100 to 100. Mathematically,\nthe bias is added to the logits generated by the model prior to sampling.\nThe exact effect will vary per model, but values between -1 and 1 should\ndecrease or increase likelihood of selection; values like -100 or 100\nshould result in a ban or exclusive selection of the relevant token.\n"]
    #[builder(default)]
    pub logit_bias: Option<std::collections::HashMap<String, u64>>,
    #[doc = "Whether to return log probabilities of the output tokens or not. If true,\nreturns the log probabilities of each output token returned in the\n`content` of `message`.\n"]
    #[builder(default)]
    pub logprobs: Option<bool>,
    #[doc = "The maximum number of [tokens](/tokenizer) that can be generated in the\nchat completion. This value can be used to control\n[costs](https://openai.com/api/pricing/) for text generated via API.\n\nThis value is now deprecated in favor of `max_completion_tokens`, and is\nnot compatible with [o-series models](https://platform.openai.com/docs/guides/reasoning).\n"]
    #[builder(default)]
    pub max_tokens: Option<u64>,
    #[doc = "How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs."]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "Configuration for a [Predicted Output](https://platform.openai.com/docs/guides/predicted-outputs),\nwhich can greatly improve response times when large parts of the model\nresponse are known ahead of time. This is most common when you are\nregenerating a file with only minor changes to most of the content.\n"]
    #[builder(default)]
    pub prediction: Option<CreateChatCompletionRequestPrediction>,
    #[doc = "This feature is in Beta.\nIf specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.\nDeterminism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.\n"]
    #[builder(default)]
    pub seed: Option<u64>,
    #[builder(default)]
    pub stream_options: Option<ChatCompletionStreamOptions>,
    #[doc = "A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.\n"]
    #[builder(default)]
    pub tools: Option<Vec<ChatCompletionTool>>,
    #[builder(default)]
    pub tool_choice: Option<ChatCompletionToolChoiceOption>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[doc = "Deprecated in favor of `tool_choice`.\n\nControls which (if any) function is called by the model.\n\n`none` means the model will not call a function and instead generates a\nmessage.\n\n`auto` means the model can pick between generating a message or calling a\nfunction.\n\nSpecifying a particular function via `{\"name\": \"my_function\"}` forces the\nmodel to call that function.\n\n`none` is the default when no functions are present. `auto` is the default\nif functions are present.\n"]
    #[builder(default)]
    pub function_call: Option<CreateChatCompletionRequestFunctionCall>,
    #[doc = "Deprecated in favor of `tools`.\n\nA list of functions the model may generate JSON inputs for.\n"]
    #[builder(default)]
    pub functions: Option<Vec<ChatCompletionFunctions>>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponseChoiceFinishReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateChatCompletionResponseChoiceFinishReason {
            Stop(#[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonLength),
            ToolCalls(#[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonToolCalls),
            ContentFilter(
                #[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonContentFilter,
            ),
            FunctionCall(
                #[allow(dead_code)] CreateChatCompletionResponseChoiceFinishReasonFunctionCall,
            ),
        }
        Ok(
            match CreateChatCompletionResponseChoiceFinishReason::deserialize(deserializer)? {
                CreateChatCompletionResponseChoiceFinishReason::Stop(_) => Self::Stop,
                CreateChatCompletionResponseChoiceFinishReason::Length(_) => Self::Length,
                CreateChatCompletionResponseChoiceFinishReason::ToolCalls(_) => Self::ToolCalls,
                CreateChatCompletionResponseChoiceFinishReason::ContentFilter(_) => {
                    Self::ContentFilter
                }
                CreateChatCompletionResponseChoiceFinishReason::FunctionCall(_) => {
                    Self::FunctionCall
                }
            },
        )
    }
}
impl serde::Serialize for CreateChatCompletionResponseChoiceFinishReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseChoiceFinishReasonFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateChatCompletionResponseChoiceFinishReason<'a> {
            Stop(#[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonLength),
            ToolCalls(
                #[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonToolCalls,
            ),
            ContentFilter(
                #[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonContentFilter,
            ),
            FunctionCall(
                #[allow(dead_code)] &'a CreateChatCompletionResponseChoiceFinishReasonFunctionCall,
            ),
        }
        match self {
            Self::Stop => CreateChatCompletionResponseChoiceFinishReason::Stop(&Default::default())
                .serialize(serializer),
            Self::Length => {
                CreateChatCompletionResponseChoiceFinishReason::Length(&Default::default())
                    .serialize(serializer)
            }
            Self::ToolCalls => {
                CreateChatCompletionResponseChoiceFinishReason::ToolCalls(&Default::default())
                    .serialize(serializer)
            }
            Self::ContentFilter => {
                CreateChatCompletionResponseChoiceFinishReason::ContentFilter(&Default::default())
                    .serialize(serializer)
            }
            Self::FunctionCall => {
                CreateChatCompletionResponseChoiceFinishReason::FunctionCall(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionResponseChoiceFinishReason {
    #[doc = "stop"]
    Stop,
    #[doc = "length"]
    Length,
    #[doc = "tool_calls"]
    ToolCalls,
    #[doc = "content_filter"]
    ContentFilter,
    #[doc = "function_call"]
    FunctionCall,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponseChoiceLogprobs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionResponseChoiceLogprobs {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<ChatCompletionTokenLogprob>>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<Vec<ChatCompletionTokenLogprob>>,
        }
        let CreateChatCompletionResponseChoiceLogprobs {
            content, refusal, ..
        } = CreateChatCompletionResponseChoiceLogprobs::deserialize(deserializer)?;
        Ok(Self { content, refusal })
    }
}
impl serde::Serialize for CreateChatCompletionResponseChoiceLogprobs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionResponseChoiceLogprobs<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<ChatCompletionTokenLogprob>>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<Vec<ChatCompletionTokenLogprob>>,
        }
        let Self { content, refusal } = self;
        CreateChatCompletionResponseChoiceLogprobs { content, refusal }.serialize(serializer)
    }
}
#[doc = "Log probability information for the choice."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionResponseChoiceLogprobs {
    #[doc = "A list of message content tokens with log probability information."]
    #[builder(default)]
    pub content: Option<Vec<ChatCompletionTokenLogprob>>,
    #[doc = "A list of message refusal tokens with log probability information."]
    #[builder(default)]
    pub refusal: Option<Vec<ChatCompletionTokenLogprob>>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponseChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionResponseChoice {
            #[serde(rename = "finish_reason")]
            #[allow(dead_code)]
            finish_reason: CreateChatCompletionResponseChoiceFinishReason,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: ChatCompletionResponseMessage,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<CreateChatCompletionResponseChoiceLogprobs>,
        }
        let CreateChatCompletionResponseChoice {
            finish_reason,
            index,
            message,
            logprobs,
            ..
        } = CreateChatCompletionResponseChoice::deserialize(deserializer)?;
        Ok(Self {
            finish_reason,
            index,
            message,
            logprobs,
        })
    }
}
impl serde::Serialize for CreateChatCompletionResponseChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionResponseChoice<'a> {
            #[serde(rename = "finish_reason")]
            finish_reason: &'a CreateChatCompletionResponseChoiceFinishReason,
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "message")]
            message: &'a ChatCompletionResponseMessage,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<CreateChatCompletionResponseChoiceLogprobs>,
        }
        let Self {
            finish_reason,
            index,
            message,
            logprobs,
        } = self;
        CreateChatCompletionResponseChoice {
            finish_reason,
            index,
            message,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionResponseChoice {
    #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
    pub finish_reason: CreateChatCompletionResponseChoiceFinishReason,
    #[doc = "The index of the choice in the list of choices."]
    pub index: u64,
    #[builder(default)]
    pub message: ChatCompletionResponseMessage,
    #[doc = "Log probability information for the choice."]
    #[builder(default)]
    pub logprobs: Option<CreateChatCompletionResponseChoiceLogprobs>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `chat.completion`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseObject {
            #[default]
            #[serde(rename = "chat.completion")]
            ChatCompletion,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "choices")]
            #[allow(dead_code)]
            choices: Vec<CreateChatCompletionResponseChoice>,
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "service_tier")]
            #[allow(dead_code)]
            service_tier: Option<ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[allow(dead_code)]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CreateChatCompletionResponseObject,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<CompletionUsage>,
        }
        let CreateChatCompletionResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
            ..
        } = CreateChatCompletionResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateChatCompletionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `chat.completion`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionResponseObject {
            #[default]
            #[serde(rename = "chat.completion")]
            ChatCompletion,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<CreateChatCompletionResponseChoice>,
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a CreateChatCompletionResponseObject,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<CompletionUsage>,
        }
        let Self {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        } = self;
        CreateChatCompletionResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a chat completion response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionResponse {
    #[doc = "A unique identifier for the chat completion."]
    pub id: String,
    #[doc = "A list of chat completion choices. Can be more than one if `n` is greater than 1."]
    pub choices: Vec<CreateChatCompletionResponseChoice>,
    #[doc = "The Unix timestamp (in seconds) of when the chat completion was created."]
    pub created: u64,
    #[doc = "The model used for the chat completion."]
    pub model: String,
    #[builder(default)]
    pub service_tier: Option<ServiceTier>,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\n\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[builder(default)]
    pub usage: Option<CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponseChoiceLogprobs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionStreamResponseChoiceLogprobs {
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<ChatCompletionTokenLogprob>>,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<Vec<ChatCompletionTokenLogprob>>,
        }
        let CreateChatCompletionStreamResponseChoiceLogprobs {
            content, refusal, ..
        } = CreateChatCompletionStreamResponseChoiceLogprobs::deserialize(deserializer)?;
        Ok(Self { content, refusal })
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponseChoiceLogprobs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionStreamResponseChoiceLogprobs<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<ChatCompletionTokenLogprob>>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<Vec<ChatCompletionTokenLogprob>>,
        }
        let Self { content, refusal } = self;
        CreateChatCompletionStreamResponseChoiceLogprobs { content, refusal }.serialize(serializer)
    }
}
#[doc = "Log probability information for the choice."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionStreamResponseChoiceLogprobs {
    #[doc = "A list of message content tokens with log probability information."]
    #[builder(default)]
    pub content: Option<Vec<ChatCompletionTokenLogprob>>,
    #[doc = "A list of message refusal tokens with log probability information."]
    #[builder(default)]
    pub refusal: Option<Vec<ChatCompletionTokenLogprob>>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponseChoiceFinishReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateChatCompletionStreamResponseChoiceFinishReason {
            Stop(#[allow(dead_code)] CreateChatCompletionStreamResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] CreateChatCompletionStreamResponseChoiceFinishReasonLength),
            ToolCalls(
                #[allow(dead_code)] CreateChatCompletionStreamResponseChoiceFinishReasonToolCalls,
            ),
            ContentFilter(
                #[allow(dead_code)]
                CreateChatCompletionStreamResponseChoiceFinishReasonContentFilter,
            ),
            FunctionCall(
                #[allow(dead_code)]
                CreateChatCompletionStreamResponseChoiceFinishReasonFunctionCall,
            ),
        }
        Ok(
            match CreateChatCompletionStreamResponseChoiceFinishReason::deserialize(deserializer)? {
                CreateChatCompletionStreamResponseChoiceFinishReason::Stop(_) => Self::Stop,
                CreateChatCompletionStreamResponseChoiceFinishReason::Length(_) => Self::Length,
                CreateChatCompletionStreamResponseChoiceFinishReason::ToolCalls(_) => {
                    Self::ToolCalls
                }
                CreateChatCompletionStreamResponseChoiceFinishReason::ContentFilter(_) => {
                    Self::ContentFilter
                }
                CreateChatCompletionStreamResponseChoiceFinishReason::FunctionCall(_) => {
                    Self::FunctionCall
                }
            },
        )
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponseChoiceFinishReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseChoiceFinishReasonFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateChatCompletionStreamResponseChoiceFinishReason<'a> {
            Stop(#[allow(dead_code)] &'a CreateChatCompletionStreamResponseChoiceFinishReasonStop),
            Length(
                #[allow(dead_code)] &'a CreateChatCompletionStreamResponseChoiceFinishReasonLength,
            ),
            ToolCalls(
                #[allow(dead_code)]
                &'a CreateChatCompletionStreamResponseChoiceFinishReasonToolCalls,
            ),
            ContentFilter(
                #[allow(dead_code)]
                &'a CreateChatCompletionStreamResponseChoiceFinishReasonContentFilter,
            ),
            FunctionCall(
                #[allow(dead_code)]
                &'a CreateChatCompletionStreamResponseChoiceFinishReasonFunctionCall,
            ),
        }
        match self {
            Self::Stop => {
                CreateChatCompletionStreamResponseChoiceFinishReason::Stop(&Default::default())
                    .serialize(serializer)
            }
            Self::Length => {
                CreateChatCompletionStreamResponseChoiceFinishReason::Length(&Default::default())
                    .serialize(serializer)
            }
            Self::ToolCalls => {
                CreateChatCompletionStreamResponseChoiceFinishReason::ToolCalls(&Default::default())
                    .serialize(serializer)
            }
            Self::ContentFilter => {
                CreateChatCompletionStreamResponseChoiceFinishReason::ContentFilter(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::FunctionCall => {
                CreateChatCompletionStreamResponseChoiceFinishReason::FunctionCall(
                    &Default::default(),
                )
                .serialize(serializer)
            }
        }
    }
}
#[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateChatCompletionStreamResponseChoiceFinishReason {
    #[doc = "stop"]
    Stop,
    #[doc = "length"]
    Length,
    #[doc = "tool_calls"]
    ToolCalls,
    #[doc = "content_filter"]
    ContentFilter,
    #[doc = "function_call"]
    FunctionCall,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponseChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionStreamResponseChoice {
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: ChatCompletionStreamResponseDelta,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<CreateChatCompletionStreamResponseChoiceLogprobs>,
            #[serde(rename = "finish_reason")]
            #[allow(dead_code)]
            finish_reason: Option<CreateChatCompletionStreamResponseChoiceFinishReason>,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
        }
        let CreateChatCompletionStreamResponseChoice {
            delta,
            logprobs,
            finish_reason,
            index,
            ..
        } = CreateChatCompletionStreamResponseChoice::deserialize(deserializer)?;
        Ok(Self {
            delta,
            logprobs,
            finish_reason,
            index,
        })
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponseChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionStreamResponseChoice<'a> {
            #[serde(rename = "delta")]
            delta: &'a ChatCompletionStreamResponseDelta,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<CreateChatCompletionStreamResponseChoiceLogprobs>,
            #[serde(rename = "finish_reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            finish_reason: &'a Option<CreateChatCompletionStreamResponseChoiceFinishReason>,
            #[serde(rename = "index")]
            index: &'a u64,
        }
        let Self {
            delta,
            logprobs,
            finish_reason,
            index,
        } = self;
        CreateChatCompletionStreamResponseChoice {
            delta,
            logprobs,
            finish_reason,
            index,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionStreamResponseChoice {
    #[builder(default)]
    pub delta: ChatCompletionStreamResponseDelta,
    #[doc = "Log probability information for the choice."]
    #[builder(default)]
    pub logprobs: Option<CreateChatCompletionStreamResponseChoiceLogprobs>,
    #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
    #[builder(default)]
    pub finish_reason: Option<CreateChatCompletionStreamResponseChoiceFinishReason>,
    #[doc = "The index of the choice in the list of choices."]
    pub index: u64,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `chat.completion.chunk`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseObject {
            #[default]
            #[serde(rename = "chat.completion.chunk")]
            ChatCompletionChunk,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionStreamResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "choices")]
            #[allow(dead_code)]
            choices: Vec<CreateChatCompletionStreamResponseChoice>,
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "service_tier")]
            #[allow(dead_code)]
            service_tier: Option<ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[allow(dead_code)]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CreateChatCompletionStreamResponseObject,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<CompletionUsage>,
        }
        let CreateChatCompletionStreamResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
            ..
        } = CreateChatCompletionStreamResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `chat.completion.chunk`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateChatCompletionStreamResponseObject {
            #[default]
            #[serde(rename = "chat.completion.chunk")]
            ChatCompletionChunk,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionStreamResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<CreateChatCompletionStreamResponseChoice>,
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a CreateChatCompletionStreamResponseObject,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<CompletionUsage>,
        }
        let Self {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        } = self;
        CreateChatCompletionStreamResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a streamed chunk of a chat completion response returned\nby the model, based on the provided input. \n[Learn more](https://platform.openai.com/docs/guides/streaming-responses).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionStreamResponse {
    #[doc = "A unique identifier for the chat completion. Each chunk has the same ID."]
    pub id: String,
    #[doc = "A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the\nlast chunk if you set `stream_options: {\"include_usage\": true}`.\n"]
    pub choices: Vec<CreateChatCompletionStreamResponseChoice>,
    #[doc = "The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp."]
    pub created: u64,
    #[doc = "The model to generate the completion."]
    pub model: String,
    #[builder(default)]
    pub service_tier: Option<ServiceTier>,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[doc = "An optional field that will only be present when you set\n`stream_options: {\"include_usage\": true}` in your request. When present, it\ncontains a null value **except for the last chunk** which contains the\ntoken usage statistics for the entire request.\n\n**NOTE:** If the stream is interrupted or cancelled, you may not\nreceive the final usage chunk which contains the total token usage for\nthe request.\n"]
    #[builder(default)]
    pub usage: Option<CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionRequestPrompt {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateCompletionRequestPrompt {
            String(#[allow(dead_code)] String),
            ArrayOfString(#[allow(dead_code)] Vec<String>),
            ArrayOfInteger(#[allow(dead_code)] Vec<u64>),
            ArrayOfArray(#[allow(dead_code)] Vec<Vec<u64>>),
        }
        Ok(
            match CreateCompletionRequestPrompt::deserialize(deserializer)? {
                CreateCompletionRequestPrompt::String(_v) => Self::String(_v),
                CreateCompletionRequestPrompt::ArrayOfString(_v) => Self::ArrayOfString(_v),
                CreateCompletionRequestPrompt::ArrayOfInteger(_v) => Self::ArrayOfInteger(_v),
                CreateCompletionRequestPrompt::ArrayOfArray(_v) => Self::ArrayOfArray(_v),
            },
        )
    }
}
impl serde::Serialize for CreateCompletionRequestPrompt {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateCompletionRequestPrompt<'a> {
            String(#[allow(dead_code)] &'a String),
            ArrayOfString(#[allow(dead_code)] &'a Vec<String>),
            ArrayOfInteger(#[allow(dead_code)] &'a Vec<u64>),
            ArrayOfArray(#[allow(dead_code)] &'a Vec<Vec<u64>>),
        }
        match self {
            Self::String(_v) => CreateCompletionRequestPrompt::String(_v).serialize(serializer),
            Self::ArrayOfString(_v) => {
                CreateCompletionRequestPrompt::ArrayOfString(_v).serialize(serializer)
            }
            Self::ArrayOfInteger(_v) => {
                CreateCompletionRequestPrompt::ArrayOfInteger(_v).serialize(serializer)
            }
            Self::ArrayOfArray(_v) => {
                CreateCompletionRequestPrompt::ArrayOfArray(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.\n\nNote that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateCompletionRequestPrompt {
    String(String),
    ArrayOfString(Vec<String>),
    ArrayOfInteger(Vec<u64>),
    ArrayOfArray(Vec<Vec<u64>>),
}
impl<'de> serde::Deserialize<'de> for CreateCompletionRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateCompletionRequest {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<CreateCompletionRequestPrompt>,
            #[serde(rename = "best_of")]
            #[allow(dead_code)]
            best_of: Option<u64>,
            #[serde(rename = "echo")]
            #[allow(dead_code)]
            echo: Option<bool>,
            #[serde(rename = "frequency_penalty")]
            #[allow(dead_code)]
            frequency_penalty: Option<f64>,
            #[serde(rename = "logit_bias")]
            #[allow(dead_code)]
            logit_bias: Option<std::collections::HashMap<String, u64>>,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<u64>,
            #[serde(rename = "max_tokens")]
            #[allow(dead_code)]
            max_tokens: Option<u64>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "presence_penalty")]
            #[allow(dead_code)]
            presence_penalty: Option<f64>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
            #[serde(rename = "stop")]
            #[allow(dead_code)]
            stop: Option<StopConfiguration>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "stream_options")]
            #[allow(dead_code)]
            stream_options: Option<ChatCompletionStreamOptions>,
            #[serde(rename = "suffix")]
            #[allow(dead_code)]
            suffix: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let CreateCompletionRequest {
            model,
            prompt,
            best_of,
            echo,
            frequency_penalty,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            presence_penalty,
            seed,
            stop,
            stream,
            stream_options,
            suffix,
            temperature,
            top_p,
            user,
            ..
        } = CreateCompletionRequest::deserialize(deserializer)?;
        Ok(Self {
            model,
            prompt,
            best_of,
            echo,
            frequency_penalty,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            presence_penalty,
            seed,
            stop,
            stream,
            stream_options,
            suffix,
            temperature,
            top_p,
            user,
        })
    }
}
impl serde::Serialize for CreateCompletionRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateCompletionRequest<'a> {
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<CreateCompletionRequestPrompt>,
            #[serde(rename = "best_of")]
            #[serde(skip_serializing_if = "Option::is_none")]
            best_of: &'a Option<u64>,
            #[serde(rename = "echo")]
            #[serde(skip_serializing_if = "Option::is_none")]
            echo: &'a Option<bool>,
            #[serde(rename = "frequency_penalty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            frequency_penalty: &'a Option<f64>,
            #[serde(rename = "logit_bias")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logit_bias: &'a Option<std::collections::HashMap<String, u64>>,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<u64>,
            #[serde(rename = "max_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tokens: &'a Option<u64>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "presence_penalty")]
            #[serde(skip_serializing_if = "Option::is_none")]
            presence_penalty: &'a Option<f64>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
            #[serde(rename = "stop")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stop: &'a Option<StopConfiguration>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "stream_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream_options: &'a Option<ChatCompletionStreamOptions>,
            #[serde(rename = "suffix")]
            #[serde(skip_serializing_if = "Option::is_none")]
            suffix: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let Self {
            model,
            prompt,
            best_of,
            echo,
            frequency_penalty,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            presence_penalty,
            seed,
            stop,
            stream,
            stream_options,
            suffix,
            temperature,
            top_p,
            user,
        } = self;
        CreateCompletionRequest {
            model,
            prompt,
            best_of,
            echo,
            frequency_penalty,
            logit_bias,
            logprobs,
            max_tokens,
            n,
            presence_penalty,
            seed,
            stop,
            stream,
            stream_options,
            suffix,
            temperature,
            top_p,
            user,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateCompletionRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.\n\nNote that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.\n"]
    #[builder(default)]
    pub prompt: Option<CreateCompletionRequestPrompt>,
    #[doc = "Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.\n\nWhen used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return – `best_of` must be greater than `n`.\n\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.\n"]
    #[builder(default)]
    pub best_of: Option<u64>,
    #[doc = "Echo back the prompt in addition to the completion\n"]
    #[builder(default)]
    pub echo: Option<bool>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.\n\n[See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation)\n"]
    #[builder(default)]
    pub frequency_penalty: Option<f64>,
    #[doc = "Modify the likelihood of specified tokens appearing in the completion.\n\nAccepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.\n\nAs an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated.\n"]
    #[builder(default)]
    pub logit_bias: Option<std::collections::HashMap<String, u64>>,
    #[doc = "Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.\n\nThe maximum value for `logprobs` is 5.\n"]
    #[builder(default)]
    pub logprobs: Option<u64>,
    #[doc = "The maximum number of [tokens](/tokenizer) that can be generated in the completion.\n\nThe token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.\n"]
    #[builder(default)]
    pub max_tokens: Option<u64>,
    #[doc = "How many completions to generate for each prompt.\n\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.\n"]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.\n\n[See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation)\n"]
    #[builder(default)]
    pub presence_penalty: Option<f64>,
    #[doc = "If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.\n\nDeterminism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.\n"]
    #[builder(default)]
    pub seed: Option<u64>,
    #[builder(default)]
    pub stop: Option<StopConfiguration>,
    #[doc = "Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[builder(default)]
    pub stream_options: Option<ChatCompletionStreamOptions>,
    #[doc = "The suffix that comes after a completion of inserted text.\n\nThis parameter is only supported for `gpt-3.5-turbo-instruct`.\n"]
    #[builder(default)]
    pub suffix: Option<String>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponseChoiceFinishReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateCompletionResponseChoiceFinishReason {
            Stop(#[allow(dead_code)] CreateCompletionResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] CreateCompletionResponseChoiceFinishReasonLength),
            ContentFilter(
                #[allow(dead_code)] CreateCompletionResponseChoiceFinishReasonContentFilter,
            ),
        }
        Ok(
            match CreateCompletionResponseChoiceFinishReason::deserialize(deserializer)? {
                CreateCompletionResponseChoiceFinishReason::Stop(_) => Self::Stop,
                CreateCompletionResponseChoiceFinishReason::Length(_) => Self::Length,
                CreateCompletionResponseChoiceFinishReason::ContentFilter(_) => Self::ContentFilter,
            },
        )
    }
}
impl serde::Serialize for CreateCompletionResponseChoiceFinishReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonStop {
            #[default]
            #[serde(rename = "stop")]
            Stop,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonLength {
            #[default]
            #[serde(rename = "length")]
            Length,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseChoiceFinishReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateCompletionResponseChoiceFinishReason<'a> {
            Stop(#[allow(dead_code)] &'a CreateCompletionResponseChoiceFinishReasonStop),
            Length(#[allow(dead_code)] &'a CreateCompletionResponseChoiceFinishReasonLength),
            ContentFilter(
                #[allow(dead_code)] &'a CreateCompletionResponseChoiceFinishReasonContentFilter,
            ),
        }
        match self {
            Self::Stop => CreateCompletionResponseChoiceFinishReason::Stop(&Default::default())
                .serialize(serializer),
            Self::Length => CreateCompletionResponseChoiceFinishReason::Length(&Default::default())
                .serialize(serializer),
            Self::ContentFilter => {
                CreateCompletionResponseChoiceFinishReason::ContentFilter(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\nor `content_filter` if content was omitted due to a flag from our content filters.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateCompletionResponseChoiceFinishReason {
    #[doc = "stop"]
    Stop,
    #[doc = "length"]
    Length,
    #[doc = "content_filter"]
    ContentFilter,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponseChoiceLogprobs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateCompletionResponseChoiceLogprobs {
            #[serde(rename = "text_offset")]
            #[allow(dead_code)]
            text_offset: Option<Vec<u64>>,
            #[serde(rename = "token_logprobs")]
            #[allow(dead_code)]
            token_logprobs: Option<Vec<f64>>,
            #[serde(rename = "tokens")]
            #[allow(dead_code)]
            tokens: Option<Vec<String>>,
            #[serde(rename = "top_logprobs")]
            #[allow(dead_code)]
            top_logprobs: Option<Vec<std::collections::HashMap<String, f64>>>,
        }
        let CreateCompletionResponseChoiceLogprobs {
            text_offset,
            token_logprobs,
            tokens,
            top_logprobs,
            ..
        } = CreateCompletionResponseChoiceLogprobs::deserialize(deserializer)?;
        Ok(Self {
            text_offset,
            token_logprobs,
            tokens,
            top_logprobs,
        })
    }
}
impl serde::Serialize for CreateCompletionResponseChoiceLogprobs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateCompletionResponseChoiceLogprobs<'a> {
            #[serde(rename = "text_offset")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text_offset: &'a Option<Vec<u64>>,
            #[serde(rename = "token_logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token_logprobs: &'a Option<Vec<f64>>,
            #[serde(rename = "tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tokens: &'a Option<Vec<String>>,
            #[serde(rename = "top_logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_logprobs: &'a Option<Vec<std::collections::HashMap<String, f64>>>,
        }
        let Self {
            text_offset,
            token_logprobs,
            tokens,
            top_logprobs,
        } = self;
        CreateCompletionResponseChoiceLogprobs {
            text_offset,
            token_logprobs,
            tokens,
            top_logprobs,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateCompletionResponseChoiceLogprobs {
    #[builder(default)]
    pub text_offset: Option<Vec<u64>>,
    #[builder(default)]
    pub token_logprobs: Option<Vec<f64>>,
    #[builder(default)]
    pub tokens: Option<Vec<String>>,
    #[builder(default)]
    pub top_logprobs: Option<Vec<std::collections::HashMap<String, f64>>>,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponseChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateCompletionResponseChoice {
            #[serde(rename = "finish_reason")]
            #[allow(dead_code)]
            finish_reason: CreateCompletionResponseChoiceFinishReason,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<CreateCompletionResponseChoiceLogprobs>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let CreateCompletionResponseChoice {
            finish_reason,
            index,
            logprobs,
            text,
            ..
        } = CreateCompletionResponseChoice::deserialize(deserializer)?;
        Ok(Self {
            finish_reason,
            index,
            logprobs,
            text,
        })
    }
}
impl serde::Serialize for CreateCompletionResponseChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateCompletionResponseChoice<'a> {
            #[serde(rename = "finish_reason")]
            finish_reason: &'a CreateCompletionResponseChoiceFinishReason,
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<CreateCompletionResponseChoiceLogprobs>,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self {
            finish_reason,
            index,
            logprobs,
            text,
        } = self;
        CreateCompletionResponseChoice {
            finish_reason,
            index,
            logprobs,
            text,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateCompletionResponseChoice {
    #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\nor `content_filter` if content was omitted due to a flag from our content filters.\n"]
    pub finish_reason: CreateCompletionResponseChoiceFinishReason,
    pub index: u64,
    #[builder(default)]
    pub logprobs: Option<CreateCompletionResponseChoiceLogprobs>,
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"text_completion\""]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseObject {
            #[default]
            #[serde(rename = "text_completion")]
            TextCompletion,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateCompletionResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "choices")]
            #[allow(dead_code)]
            choices: Vec<CreateCompletionResponseChoice>,
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "system_fingerprint")]
            #[allow(dead_code)]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CreateCompletionResponseObject,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<CompletionUsage>,
        }
        let CreateCompletionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
            ..
        } = CreateCompletionResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateCompletionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"text_completion\""]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateCompletionResponseObject {
            #[default]
            #[serde(rename = "text_completion")]
            TextCompletion,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateCompletionResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<CreateCompletionResponseChoice>,
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a CreateCompletionResponseObject,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<CompletionUsage>,
        }
        let Self {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
        } = self;
        CreateCompletionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateCompletionResponse {
    #[doc = "A unique identifier for the completion."]
    pub id: String,
    #[doc = "The list of completion choices the model generated for the input prompt."]
    pub choices: Vec<CreateCompletionResponseChoice>,
    #[doc = "The Unix timestamp (in seconds) of when the completion was created."]
    pub created: u64,
    #[doc = "The model used for completion."]
    pub model: String,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\n\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[builder(default)]
    pub usage: Option<CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateContainerBodyExpiresAfter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Time anchor for the expiration time. Currently only 'last_active_at' is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateContainerBodyExpiresAfterAnchor {
            #[default]
            #[serde(rename = "last_active_at")]
            LastActiveAt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateContainerBodyExpiresAfter {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: CreateContainerBodyExpiresAfterAnchor,
            #[serde(rename = "minutes")]
            #[allow(dead_code)]
            minutes: u64,
        }
        let CreateContainerBodyExpiresAfter { minutes, .. } =
            CreateContainerBodyExpiresAfter::deserialize(deserializer)?;
        Ok(Self { minutes })
    }
}
impl serde::Serialize for CreateContainerBodyExpiresAfter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Time anchor for the expiration time. Currently only 'last_active_at' is supported."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateContainerBodyExpiresAfterAnchor {
            #[default]
            #[serde(rename = "last_active_at")]
            LastActiveAt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateContainerBodyExpiresAfter<'a> {
            #[serde(rename = "anchor")]
            anchor: &'a CreateContainerBodyExpiresAfterAnchor,
            #[serde(rename = "minutes")]
            minutes: &'a u64,
        }
        let Self { minutes } = self;
        CreateContainerBodyExpiresAfter {
            anchor: &Default::default(),
            minutes,
        }
        .serialize(serializer)
    }
}
#[doc = "Container expiration time in seconds relative to the 'anchor' time."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateContainerBodyExpiresAfter {
    pub minutes: u64,
}
impl<'de> serde::Deserialize<'de> for CreateContainerBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateContainerBody {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "expires_after")]
            #[allow(dead_code)]
            expires_after: Option<CreateContainerBodyExpiresAfter>,
        }
        let CreateContainerBody {
            name,
            file_ids,
            expires_after,
            ..
        } = CreateContainerBody::deserialize(deserializer)?;
        Ok(Self {
            name,
            file_ids,
            expires_after,
        })
    }
}
impl serde::Serialize for CreateContainerBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateContainerBody<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<CreateContainerBodyExpiresAfter>,
        }
        let Self {
            name,
            file_ids,
            expires_after,
        } = self;
        CreateContainerBody {
            name,
            file_ids,
            expires_after,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateContainerBody {
    #[doc = "Name of the container to create."]
    pub name: String,
    #[doc = "IDs of files to copy to the container."]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "Container expiration time in seconds relative to the 'anchor' time."]
    #[builder(default)]
    pub expires_after: Option<CreateContainerBodyExpiresAfter>,
}
impl<'de> serde::Deserialize<'de> for CreateContainerFileBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateContainerFileBody {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde_as(as = "Option<serde_with::base64::Base64>")]
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Option<Vec<u8>>,
        }
        let CreateContainerFileBody { file_id, file, .. } =
            CreateContainerFileBody::deserialize(deserializer)?;
        Ok(Self { file_id, file })
    }
}
impl serde::Serialize for CreateContainerFileBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateContainerFileBody<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde_as(as = "Option<serde_with::base64::Base64>")]
            #[serde(rename = "file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file: &'a Option<Vec<u8>>,
        }
        let Self { file_id, file } = self;
        CreateContainerFileBody { file_id, file }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateContainerFileBody {
    #[doc = "Name of the file to create."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The File object (not file name) to be uploaded.\n"]
    #[builder(default)]
    pub file: Option<Vec<u8>>,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEmbeddingRequestInput {
            String(#[allow(dead_code)] String),
            ArrayOfString(#[allow(dead_code)] Vec<String>),
            ArrayOfInteger(#[allow(dead_code)] Vec<u64>),
            ArrayOfArray(#[allow(dead_code)] Vec<Vec<u64>>),
        }
        Ok(
            match CreateEmbeddingRequestInput::deserialize(deserializer)? {
                CreateEmbeddingRequestInput::String(_v) => Self::String(_v),
                CreateEmbeddingRequestInput::ArrayOfString(_v) => Self::ArrayOfString(_v),
                CreateEmbeddingRequestInput::ArrayOfInteger(_v) => Self::ArrayOfInteger(_v),
                CreateEmbeddingRequestInput::ArrayOfArray(_v) => Self::ArrayOfArray(_v),
            },
        )
    }
}
impl serde::Serialize for CreateEmbeddingRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEmbeddingRequestInput<'a> {
            String(#[allow(dead_code)] &'a String),
            ArrayOfString(#[allow(dead_code)] &'a Vec<String>),
            ArrayOfInteger(#[allow(dead_code)] &'a Vec<u64>),
            ArrayOfArray(#[allow(dead_code)] &'a Vec<Vec<u64>>),
        }
        match self {
            Self::String(_v) => CreateEmbeddingRequestInput::String(_v).serialize(serializer),
            Self::ArrayOfString(_v) => {
                CreateEmbeddingRequestInput::ArrayOfString(_v).serialize(serializer)
            }
            Self::ArrayOfInteger(_v) => {
                CreateEmbeddingRequestInput::ArrayOfInteger(_v).serialize(serializer)
            }
            Self::ArrayOfArray(_v) => {
                CreateEmbeddingRequestInput::ArrayOfArray(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for all embedding models), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. In addition to the per-input token limit, all embedding  models enforce a maximum of 300,000 tokens summed across all inputs in a  single request.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEmbeddingRequestInput {
    #[doc = "The string that will be turned into an embedding."]
    String(String),
    #[doc = "The array of strings that will be turned into an embedding."]
    ArrayOfString(Vec<String>),
    #[doc = "The array of integers that will be turned into an embedding."]
    ArrayOfInteger(Vec<u64>),
    #[doc = "The array of arrays containing integers that will be turned into an embedding."]
    ArrayOfArray(Vec<Vec<u64>>),
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingRequestEncodingFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingRequestEncodingFormatFloat {
            #[default]
            #[serde(rename = "float")]
            Float,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingRequestEncodingFormatBase64 {
            #[default]
            #[serde(rename = "base64")]
            Base64,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEmbeddingRequestEncodingFormat {
            Float(#[allow(dead_code)] CreateEmbeddingRequestEncodingFormatFloat),
            Base64(#[allow(dead_code)] CreateEmbeddingRequestEncodingFormatBase64),
        }
        Ok(
            match CreateEmbeddingRequestEncodingFormat::deserialize(deserializer)? {
                CreateEmbeddingRequestEncodingFormat::Float(_) => Self::Float,
                CreateEmbeddingRequestEncodingFormat::Base64(_) => Self::Base64,
            },
        )
    }
}
impl serde::Serialize for CreateEmbeddingRequestEncodingFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingRequestEncodingFormatFloat {
            #[default]
            #[serde(rename = "float")]
            Float,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingRequestEncodingFormatBase64 {
            #[default]
            #[serde(rename = "base64")]
            Base64,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEmbeddingRequestEncodingFormat<'a> {
            Float(#[allow(dead_code)] &'a CreateEmbeddingRequestEncodingFormatFloat),
            Base64(#[allow(dead_code)] &'a CreateEmbeddingRequestEncodingFormatBase64),
        }
        match self {
            Self::Float => CreateEmbeddingRequestEncodingFormat::Float(&Default::default())
                .serialize(serializer),
            Self::Base64 => CreateEmbeddingRequestEncodingFormat::Base64(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/)."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEmbeddingRequestEncodingFormat {
    #[doc = "float"]
    #[default]
    Float,
    #[doc = "base64"]
    Base64,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEmbeddingRequest {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: CreateEmbeddingRequestInput,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "encoding_format")]
            #[allow(dead_code)]
            encoding_format: Option<CreateEmbeddingRequestEncodingFormat>,
            #[serde(rename = "dimensions")]
            #[allow(dead_code)]
            dimensions: Option<u64>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let CreateEmbeddingRequest {
            input,
            model,
            encoding_format,
            dimensions,
            user,
            ..
        } = CreateEmbeddingRequest::deserialize(deserializer)?;
        Ok(Self {
            input,
            model,
            encoding_format,
            dimensions,
            user,
        })
    }
}
impl serde::Serialize for CreateEmbeddingRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEmbeddingRequest<'a> {
            #[serde(rename = "input")]
            input: &'a CreateEmbeddingRequestInput,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "encoding_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            encoding_format: &'a Option<CreateEmbeddingRequestEncodingFormat>,
            #[serde(rename = "dimensions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            dimensions: &'a Option<u64>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let Self {
            input,
            model,
            encoding_format,
            dimensions,
            user,
        } = self;
        CreateEmbeddingRequest {
            input,
            model,
            encoding_format,
            dimensions,
            user,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEmbeddingRequest {
    #[doc = "Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for all embedding models), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. In addition to the per-input token limit, all embedding  models enforce a maximum of 300,000 tokens summed across all inputs in a  single request.\n"]
    pub input: CreateEmbeddingRequestInput,
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/)."]
    #[builder(default)]
    pub encoding_format: Option<CreateEmbeddingRequestEncodingFormat>,
    #[doc = "The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.\n"]
    #[builder(default)]
    pub dimensions: Option<u64>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingResponseUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEmbeddingResponseUsage {
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
        }
        let CreateEmbeddingResponseUsage {
            prompt_tokens,
            total_tokens,
            ..
        } = CreateEmbeddingResponseUsage::deserialize(deserializer)?;
        Ok(Self {
            prompt_tokens,
            total_tokens,
        })
    }
}
impl serde::Serialize for CreateEmbeddingResponseUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEmbeddingResponseUsage<'a> {
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
        }
        let Self {
            prompt_tokens,
            total_tokens,
        } = self;
        CreateEmbeddingResponseUsage {
            prompt_tokens,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "The usage information for the request."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateEmbeddingResponseUsage {
    #[doc = "The number of tokens used by the prompt."]
    pub prompt_tokens: u64,
    #[doc = "The total number of tokens used by the request."]
    pub total_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"list\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEmbeddingResponse {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Embedding>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: CreateEmbeddingResponseObject,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: CreateEmbeddingResponseUsage,
        }
        let CreateEmbeddingResponse {
            data, model, usage, ..
        } = CreateEmbeddingResponse::deserialize(deserializer)?;
        Ok(Self { data, model, usage })
    }
}
impl serde::Serialize for CreateEmbeddingResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"list\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEmbeddingResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEmbeddingResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<Embedding>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "object")]
            object: &'a CreateEmbeddingResponseObject,
            #[serde(rename = "usage")]
            usage: &'a CreateEmbeddingResponseUsage,
        }
        let Self { data, model, usage } = self;
        CreateEmbeddingResponse {
            data,
            model,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEmbeddingResponse {
    #[doc = "The list of embeddings generated by the model."]
    pub data: Vec<Embedding>,
    #[doc = "The name of the model used to generate the embedding."]
    pub model: String,
    #[doc = "The usage information for the request."]
    pub usage: CreateEmbeddingResponseUsage,
}
impl<'de> serde::Deserialize<'de>
    for CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate {
            EasyInputMessage(#[allow(dead_code)] EasyInputMessage),
            EvalItem(#[allow(dead_code)] EvalItem),
        }
        Ok (match CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate :: deserialize (deserializer) ? { CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate :: EasyInputMessage (_v) => Self :: EasyInputMessage (_v) , CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate :: EvalItem (_v) => Self :: EvalItem (_v) })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate<'a> {
            EasyInputMessage(#[allow(dead_code)] &'a EasyInputMessage),
            EvalItem(#[allow(dead_code)] &'a EvalItem),
        }
        match self {
            Self::EasyInputMessage(_v) => {
                CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate::EasyInputMessage(
                    _v,
                )
                .serialize(serializer)
            }
            Self::EvalItem(_v) => {
                CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate::EvalItem(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate {
    EasyInputMessage(EasyInputMessage),
    EvalItem(EvalItem),
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceInputMessagesTemplate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of input messages. Always `template`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceInputMessagesTemplateType {
            #[default]
            #[serde(rename = "template")]
            Template,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalCompletionsRunDataSourceInputMessagesTemplate {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalCompletionsRunDataSourceInputMessagesTemplateType,
            #[serde(rename = "template")]
            #[allow(dead_code)]
            template: Vec<CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate>,
        }
        let CreateEvalCompletionsRunDataSourceInputMessagesTemplate { template, .. } =
            CreateEvalCompletionsRunDataSourceInputMessagesTemplate::deserialize(deserializer)?;
        Ok(Self { template })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceInputMessagesTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of input messages. Always `template`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceInputMessagesTemplateType {
            #[default]
            #[serde(rename = "template")]
            Template,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalCompletionsRunDataSourceInputMessagesTemplate<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalCompletionsRunDataSourceInputMessagesTemplateType,
            #[serde(rename = "template")]
            template: &'a Vec<CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate>,
        }
        let Self { template } = self;
        CreateEvalCompletionsRunDataSourceInputMessagesTemplate {
            type_: &Default::default(),
            template,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSourceInputMessagesTemplate {
    #[doc = "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."]
    pub template: Vec<CreateEvalCompletionsRunDataSourceInputMessagesTemplateTemplate>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceInputMessagesItemReference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of input messages. Always `item_reference`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceInputMessagesItemReferenceType {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalCompletionsRunDataSourceInputMessagesItemReference {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalCompletionsRunDataSourceInputMessagesItemReferenceType,
            #[serde(rename = "item_reference")]
            #[allow(dead_code)]
            item_reference: String,
        }
        let CreateEvalCompletionsRunDataSourceInputMessagesItemReference { item_reference, .. } =
            CreateEvalCompletionsRunDataSourceInputMessagesItemReference::deserialize(
                deserializer,
            )?;
        Ok(Self { item_reference })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceInputMessagesItemReference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of input messages. Always `item_reference`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceInputMessagesItemReferenceType {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalCompletionsRunDataSourceInputMessagesItemReference<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalCompletionsRunDataSourceInputMessagesItemReferenceType,
            #[serde(rename = "item_reference")]
            item_reference: &'a String,
        }
        let Self { item_reference } = self;
        CreateEvalCompletionsRunDataSourceInputMessagesItemReference {
            type_: &Default::default(),
            item_reference,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSourceInputMessagesItemReference {
    #[doc = "A reference to a variable in the `item` namespace. Ie, \"item.input_trajectory\""]
    pub item_reference: String,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalCompletionsRunDataSourceInputMessages {
            Template(#[allow(dead_code)] CreateEvalCompletionsRunDataSourceInputMessagesTemplate),
            ItemReference(
                #[allow(dead_code)] CreateEvalCompletionsRunDataSourceInputMessagesItemReference,
            ),
        }
        Ok(
            match CreateEvalCompletionsRunDataSourceInputMessages::deserialize(deserializer)? {
                CreateEvalCompletionsRunDataSourceInputMessages::Template(_v) => Self::Template(_v),
                CreateEvalCompletionsRunDataSourceInputMessages::ItemReference(_v) => {
                    Self::ItemReference(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalCompletionsRunDataSourceInputMessages<'a> {
            Template(
                #[allow(dead_code)] &'a CreateEvalCompletionsRunDataSourceInputMessagesTemplate,
            ),
            ItemReference(
                #[allow(dead_code)]
                &'a CreateEvalCompletionsRunDataSourceInputMessagesItemReference,
            ),
        }
        match self {
            Self::Template(_v) => {
                CreateEvalCompletionsRunDataSourceInputMessages::Template(_v).serialize(serializer)
            }
            Self::ItemReference(_v) => {
                CreateEvalCompletionsRunDataSourceInputMessages::ItemReference(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalCompletionsRunDataSourceInputMessages {
    Template(CreateEvalCompletionsRunDataSourceInputMessagesTemplate),
    ItemReference(CreateEvalCompletionsRunDataSourceInputMessagesItemReference),
}
impl<'de> serde::Deserialize<'de>
    for CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat {
            Text(#[allow(dead_code)] ResponseFormatText),
            JsonSchema(#[allow(dead_code)] ResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] ResponseFormatJsonObject),
        }
        Ok(
            match CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat::deserialize(
                deserializer,
            )? {
                CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat::Text(_v) => {
                    Self::Text(_v)
                }
                CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat::JsonSchema(_v) => {
                    Self::JsonSchema(_v)
                }
                CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat::JsonObject(_v) => {
                    Self::JsonObject(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat<'a> {
            Text(#[allow(dead_code)] &'a ResponseFormatText),
            JsonSchema(#[allow(dead_code)] &'a ResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] &'a ResponseFormatJsonObject),
        }
        match self {
            Self::Text(_v) => {
                CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat::Text(_v)
                    .serialize(serializer)
            }
            Self::JsonSchema(_v) => {
                CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat::JsonSchema(_v)
                    .serialize(serializer)
            }
            Self::JsonObject(_v) => {
                CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat::JsonObject(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat {
    Text(ResponseFormatText),
    JsonSchema(ResponseFormatJsonSchema),
    JsonObject(ResponseFormatJsonObject),
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceSamplingParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalCompletionsRunDataSourceSamplingParams {
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ChatCompletionTool>>,
        }
        let CreateEvalCompletionsRunDataSourceSamplingParams {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            response_format,
            tools,
            ..
        } = CreateEvalCompletionsRunDataSourceSamplingParams::deserialize(deserializer)?;
        Ok(Self {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            response_format,
            tools,
        })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceSamplingParams {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalCompletionsRunDataSourceSamplingParams<'a> {
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format:
                &'a Option<CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ChatCompletionTool>>,
        }
        let Self {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            response_format,
            tools,
        } = self;
        CreateEvalCompletionsRunDataSourceSamplingParams {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            response_format,
            tools,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSourceSamplingParams {
    #[doc = "A higher temperature increases randomness in the outputs."]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "The maximum number of tokens in the generated output."]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[doc = "An alternative to temperature for nucleus sampling; 1.0 includes all tokens."]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "A seed value to initialize the randomness, during sampling."]
    #[builder(default)]
    pub seed: Option<u64>,
    #[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
    #[builder(default)]
    pub response_format: Option<CreateEvalCompletionsRunDataSourceSamplingParamsResponseFormat>,
    #[doc = "A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.\n"]
    #[builder(default)]
    pub tools: Option<Vec<ChatCompletionTool>>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSourceSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalCompletionsRunDataSourceSource {
            FileContent(#[allow(dead_code)] EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] EvalJsonlFileIdSource),
            StoredCompletions(#[allow(dead_code)] EvalStoredCompletionsSource),
        }
        Ok(
            match CreateEvalCompletionsRunDataSourceSource::deserialize(deserializer)? {
                CreateEvalCompletionsRunDataSourceSource::FileContent(_v) => Self::FileContent(_v),
                CreateEvalCompletionsRunDataSourceSource::FileId(_v) => Self::FileId(_v),
                CreateEvalCompletionsRunDataSourceSource::StoredCompletions(_v) => {
                    Self::StoredCompletions(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSourceSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalCompletionsRunDataSourceSource<'a> {
            FileContent(#[allow(dead_code)] &'a EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] &'a EvalJsonlFileIdSource),
            StoredCompletions(#[allow(dead_code)] &'a EvalStoredCompletionsSource),
        }
        match self {
            Self::FileContent(_v) => {
                CreateEvalCompletionsRunDataSourceSource::FileContent(_v).serialize(serializer)
            }
            Self::FileId(_v) => {
                CreateEvalCompletionsRunDataSourceSource::FileId(_v).serialize(serializer)
            }
            Self::StoredCompletions(_v) => {
                CreateEvalCompletionsRunDataSourceSource::StoredCompletions(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Determines what populates the `item` namespace in this run's data source."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalCompletionsRunDataSourceSource {
    FileContent(EvalJsonlFileContentSource),
    FileId(EvalJsonlFileIdSource),
    StoredCompletions(EvalStoredCompletionsSource),
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of run data source. Always `completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceType {
            #[default]
            #[serde(rename = "completions")]
            Completions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalCompletionsRunDataSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalCompletionsRunDataSourceType,
            #[serde(rename = "input_messages")]
            #[allow(dead_code)]
            input_messages: Option<CreateEvalCompletionsRunDataSourceInputMessages>,
            #[serde(rename = "sampling_params")]
            #[allow(dead_code)]
            sampling_params: Option<CreateEvalCompletionsRunDataSourceSamplingParams>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: CreateEvalCompletionsRunDataSourceSource,
        }
        let CreateEvalCompletionsRunDataSource {
            input_messages,
            sampling_params,
            model,
            source,
            ..
        } = CreateEvalCompletionsRunDataSource::deserialize(deserializer)?;
        Ok(Self {
            input_messages,
            sampling_params,
            model,
            source,
        })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of run data source. Always `completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCompletionsRunDataSourceType {
            #[default]
            #[serde(rename = "completions")]
            Completions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalCompletionsRunDataSource<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalCompletionsRunDataSourceType,
            #[serde(rename = "input_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_messages: &'a Option<CreateEvalCompletionsRunDataSourceInputMessages>,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params: &'a Option<CreateEvalCompletionsRunDataSourceSamplingParams>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "source")]
            source: &'a CreateEvalCompletionsRunDataSourceSource,
        }
        let Self {
            input_messages,
            sampling_params,
            model,
            source,
        } = self;
        CreateEvalCompletionsRunDataSource {
            type_: &Default::default(),
            input_messages,
            sampling_params,
            model,
            source,
        }
        .serialize(serializer)
    }
}
#[doc = "A CompletionsRunDataSource object describing a model sampling configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSource {
    #[doc = "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."]
    #[builder(default)]
    pub input_messages: Option<CreateEvalCompletionsRunDataSourceInputMessages>,
    #[builder(default)]
    pub sampling_params: Option<CreateEvalCompletionsRunDataSourceSamplingParams>,
    #[doc = "The name of the model to use for generating completions (e.g. \"o3-mini\")."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Determines what populates the `item` namespace in this run's data source."]
    pub source: CreateEvalCompletionsRunDataSourceSource,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCustomDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `custom`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCustomDataSourceConfigType {
            #[default]
            #[serde(rename = "custom")]
            Custom,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalCustomDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalCustomDataSourceConfigType,
            #[serde(rename = "item_schema")]
            #[allow(dead_code)]
            item_schema: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "include_sample_schema")]
            #[allow(dead_code)]
            include_sample_schema: Option<bool>,
        }
        let CreateEvalCustomDataSourceConfig {
            item_schema,
            include_sample_schema,
            ..
        } = CreateEvalCustomDataSourceConfig::deserialize(deserializer)?;
        Ok(Self {
            item_schema,
            include_sample_schema,
        })
    }
}
impl serde::Serialize for CreateEvalCustomDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `custom`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalCustomDataSourceConfigType {
            #[default]
            #[serde(rename = "custom")]
            Custom,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalCustomDataSourceConfig<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalCustomDataSourceConfigType,
            #[serde(rename = "item_schema")]
            item_schema: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "include_sample_schema")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_sample_schema: &'a Option<bool>,
        }
        let Self {
            item_schema,
            include_sample_schema,
        } = self;
        CreateEvalCustomDataSourceConfig {
            type_: &Default::default(),
            item_schema,
            include_sample_schema,
        }
        .serialize(serializer)
    }
}
#[doc = "A CustomDataSourceConfig object that defines the schema for the data source used for the evaluation runs.\nThis schema is used to define the shape of the data that will be:\n- Used to define your testing criteria and\n- What data is required when creating a run\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCustomDataSourceConfig {
    #[doc = "The json schema for each row in the data source."]
    pub item_schema: std::collections::HashMap<String, serde_json::Value>,
    #[doc = "Whether the eval should expect you to populate the sample namespace (ie, by generating responses off of your data source)"]
    #[builder(default)]
    pub include_sample_schema: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalItem0 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalItem0 {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: String,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: String,
        }
        let CreateEvalItem0 { role, content, .. } = CreateEvalItem0::deserialize(deserializer)?;
        Ok(Self { role, content })
    }
}
impl serde::Serialize for CreateEvalItem0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalItem0<'a> {
            #[serde(rename = "role")]
            role: &'a String,
            #[serde(rename = "content")]
            content: &'a String,
        }
        let Self { role, content } = self;
        CreateEvalItem0 { role, content }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalItem0 {
    #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
    pub role: String,
    #[doc = "The content of the message."]
    pub content: String,
}
impl<'de> serde::Deserialize<'de> for CreateEvalItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalItem {
            _0(#[allow(dead_code)] CreateEvalItem0),
            EvalItem(#[allow(dead_code)] EvalItem),
        }
        Ok(match CreateEvalItem::deserialize(deserializer)? {
            CreateEvalItem::_0(_v) => Self::_0(_v),
            CreateEvalItem::EvalItem(_v) => Self::EvalItem(_v),
        })
    }
}
impl serde::Serialize for CreateEvalItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalItem<'a> {
            _0(#[allow(dead_code)] &'a CreateEvalItem0),
            EvalItem(#[allow(dead_code)] &'a EvalItem),
        }
        match self {
            Self::_0(_v) => CreateEvalItem::_0(_v).serialize(serializer),
            Self::EvalItem(_v) => CreateEvalItem::EvalItem(_v).serialize(serializer),
        }
    }
}
#[doc = "A chat message that makes up the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalItem {
    _0(CreateEvalItem0),
    EvalItem(EvalItem),
}
impl<'de> serde::Deserialize<'de> for CreateEvalJsonlRunDataSourceSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalJsonlRunDataSourceSource {
            FileContent(#[allow(dead_code)] EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] EvalJsonlFileIdSource),
        }
        Ok(
            match CreateEvalJsonlRunDataSourceSource::deserialize(deserializer)? {
                CreateEvalJsonlRunDataSourceSource::FileContent(_v) => Self::FileContent(_v),
                CreateEvalJsonlRunDataSourceSource::FileId(_v) => Self::FileId(_v),
            },
        )
    }
}
impl serde::Serialize for CreateEvalJsonlRunDataSourceSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalJsonlRunDataSourceSource<'a> {
            FileContent(#[allow(dead_code)] &'a EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] &'a EvalJsonlFileIdSource),
        }
        match self {
            Self::FileContent(_v) => {
                CreateEvalJsonlRunDataSourceSource::FileContent(_v).serialize(serializer)
            }
            Self::FileId(_v) => {
                CreateEvalJsonlRunDataSourceSource::FileId(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Determines what populates the `item` namespace in the data source."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalJsonlRunDataSourceSource {
    FileContent(EvalJsonlFileContentSource),
    FileId(EvalJsonlFileIdSource),
}
impl<'de> serde::Deserialize<'de> for CreateEvalJsonlRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `jsonl`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalJsonlRunDataSourceType {
            #[default]
            #[serde(rename = "jsonl")]
            Jsonl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalJsonlRunDataSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalJsonlRunDataSourceType,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: CreateEvalJsonlRunDataSourceSource,
        }
        let CreateEvalJsonlRunDataSource { source, .. } =
            CreateEvalJsonlRunDataSource::deserialize(deserializer)?;
        Ok(Self { source })
    }
}
impl serde::Serialize for CreateEvalJsonlRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `jsonl`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalJsonlRunDataSourceType {
            #[default]
            #[serde(rename = "jsonl")]
            Jsonl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalJsonlRunDataSource<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalJsonlRunDataSourceType,
            #[serde(rename = "source")]
            source: &'a CreateEvalJsonlRunDataSourceSource,
        }
        let Self { source } = self;
        CreateEvalJsonlRunDataSource {
            type_: &Default::default(),
            source,
        }
        .serialize(serializer)
    }
}
#[doc = "A JsonlRunDataSource object with that specifies a JSONL file that matches the eval \n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalJsonlRunDataSource {
    #[doc = "Determines what populates the `item` namespace in the data source."]
    pub source: CreateEvalJsonlRunDataSourceSource,
}
impl<'de> serde::Deserialize<'de> for CreateEvalLabelModelGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `label_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalLabelModelGraderType {
            #[default]
            #[serde(rename = "label_model")]
            LabelModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalLabelModelGrader {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalLabelModelGraderType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Vec<CreateEvalItem>,
            #[serde(rename = "labels")]
            #[allow(dead_code)]
            labels: Vec<String>,
            #[serde(rename = "passing_labels")]
            #[allow(dead_code)]
            passing_labels: Vec<String>,
        }
        let CreateEvalLabelModelGrader {
            name,
            model,
            input,
            labels,
            passing_labels,
            ..
        } = CreateEvalLabelModelGrader::deserialize(deserializer)?;
        Ok(Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        })
    }
}
impl serde::Serialize for CreateEvalLabelModelGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `label_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalLabelModelGraderType {
            #[default]
            #[serde(rename = "label_model")]
            LabelModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalLabelModelGrader<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalLabelModelGraderType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a Vec<CreateEvalItem>,
            #[serde(rename = "labels")]
            labels: &'a Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: &'a Vec<String>,
        }
        let Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        } = self;
        CreateEvalLabelModelGrader {
            type_: &Default::default(),
            name,
            model,
            input,
            labels,
            passing_labels,
        }
        .serialize(serializer)
    }
}
#[doc = "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalLabelModelGrader {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation. Must support structured outputs."]
    pub model: String,
    #[doc = "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."]
    pub input: Vec<CreateEvalItem>,
    #[doc = "The labels to classify to each item in the evaluation."]
    pub labels: Vec<String>,
    #[doc = "The labels that indicate a passing result. Must be a subset of labels."]
    pub passing_labels: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalLogsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalLogsDataSourceConfigType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalLogsDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalLogsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let CreateEvalLogsDataSourceConfig { metadata, .. } =
            CreateEvalLogsDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { metadata })
    }
}
impl serde::Serialize for CreateEvalLogsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalLogsDataSourceConfigType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalLogsDataSourceConfig<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalLogsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self { metadata } = self;
        CreateEvalLogsDataSourceConfig {
            type_: &Default::default(),
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "A data source config which specifies the metadata property of your logs query.\nThis is usually metadata like `usecase=chatbot` or `prompt-version=v2`, etc.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateEvalLogsDataSourceConfig {
    #[doc = "Metadata filters for the logs data source."]
    #[builder(default)]
    pub metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalRequestDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalRequestDataSourceConfig {
            Custom(#[allow(dead_code)] CreateEvalCustomDataSourceConfig),
            Logs(#[allow(dead_code)] CreateEvalLogsDataSourceConfig),
            StoredCompletions(#[allow(dead_code)] CreateEvalStoredCompletionsDataSourceConfig),
        }
        Ok(
            match CreateEvalRequestDataSourceConfig::deserialize(deserializer)? {
                CreateEvalRequestDataSourceConfig::Custom(_v) => Self::Custom(_v),
                CreateEvalRequestDataSourceConfig::Logs(_v) => Self::Logs(_v),
                CreateEvalRequestDataSourceConfig::StoredCompletions(_v) => {
                    Self::StoredCompletions(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateEvalRequestDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalRequestDataSourceConfig<'a> {
            Custom(#[allow(dead_code)] &'a CreateEvalCustomDataSourceConfig),
            Logs(#[allow(dead_code)] &'a CreateEvalLogsDataSourceConfig),
            StoredCompletions(#[allow(dead_code)] &'a CreateEvalStoredCompletionsDataSourceConfig),
        }
        match self {
            Self::Custom(_v) => CreateEvalRequestDataSourceConfig::Custom(_v).serialize(serializer),
            Self::Logs(_v) => CreateEvalRequestDataSourceConfig::Logs(_v).serialize(serializer),
            Self::StoredCompletions(_v) => {
                CreateEvalRequestDataSourceConfig::StoredCompletions(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The configuration for the data source used for the evaluation runs. Dictates the schema of the data used in the evaluation."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalRequestDataSourceConfig {
    Custom(CreateEvalCustomDataSourceConfig),
    Logs(CreateEvalLogsDataSourceConfig),
    StoredCompletions(CreateEvalStoredCompletionsDataSourceConfig),
}
impl<'de> serde::Deserialize<'de> for CreateEvalRequestTestingCriteria {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalRequestTestingCriteria {
            LabelModel(#[allow(dead_code)] CreateEvalLabelModelGrader),
            StringCheck(#[allow(dead_code)] EvalGraderStringCheck),
            TextSimilarity(#[allow(dead_code)] EvalGraderTextSimilarity),
            Python(#[allow(dead_code)] EvalGraderPython),
            ScoreModel(#[allow(dead_code)] EvalGraderScoreModel),
        }
        Ok(
            match CreateEvalRequestTestingCriteria::deserialize(deserializer)? {
                CreateEvalRequestTestingCriteria::LabelModel(_v) => Self::LabelModel(_v),
                CreateEvalRequestTestingCriteria::StringCheck(_v) => Self::StringCheck(_v),
                CreateEvalRequestTestingCriteria::TextSimilarity(_v) => Self::TextSimilarity(_v),
                CreateEvalRequestTestingCriteria::Python(_v) => Self::Python(_v),
                CreateEvalRequestTestingCriteria::ScoreModel(_v) => Self::ScoreModel(_v),
            },
        )
    }
}
impl serde::Serialize for CreateEvalRequestTestingCriteria {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalRequestTestingCriteria<'a> {
            LabelModel(#[allow(dead_code)] &'a CreateEvalLabelModelGrader),
            StringCheck(#[allow(dead_code)] &'a EvalGraderStringCheck),
            TextSimilarity(#[allow(dead_code)] &'a EvalGraderTextSimilarity),
            Python(#[allow(dead_code)] &'a EvalGraderPython),
            ScoreModel(#[allow(dead_code)] &'a EvalGraderScoreModel),
        }
        match self {
            Self::LabelModel(_v) => {
                CreateEvalRequestTestingCriteria::LabelModel(_v).serialize(serializer)
            }
            Self::StringCheck(_v) => {
                CreateEvalRequestTestingCriteria::StringCheck(_v).serialize(serializer)
            }
            Self::TextSimilarity(_v) => {
                CreateEvalRequestTestingCriteria::TextSimilarity(_v).serialize(serializer)
            }
            Self::Python(_v) => CreateEvalRequestTestingCriteria::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => {
                CreateEvalRequestTestingCriteria::ScoreModel(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalRequestTestingCriteria {
    LabelModel(CreateEvalLabelModelGrader),
    StringCheck(EvalGraderStringCheck),
    TextSimilarity(EvalGraderTextSimilarity),
    Python(EvalGraderPython),
    ScoreModel(EvalGraderScoreModel),
}
impl<'de> serde::Deserialize<'de> for CreateEvalRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalRequest {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "data_source_config")]
            #[allow(dead_code)]
            data_source_config: CreateEvalRequestDataSourceConfig,
            #[serde(rename = "testing_criteria")]
            #[allow(dead_code)]
            testing_criteria: Vec<CreateEvalRequestTestingCriteria>,
        }
        let CreateEvalRequest {
            name,
            metadata,
            data_source_config,
            testing_criteria,
            ..
        } = CreateEvalRequest::deserialize(deserializer)?;
        Ok(Self {
            name,
            metadata,
            data_source_config,
            testing_criteria,
        })
    }
}
impl serde::Serialize for CreateEvalRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalRequest<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "data_source_config")]
            data_source_config: &'a CreateEvalRequestDataSourceConfig,
            #[serde(rename = "testing_criteria")]
            testing_criteria: &'a Vec<CreateEvalRequestTestingCriteria>,
        }
        let Self {
            name,
            metadata,
            data_source_config,
            testing_criteria,
        } = self;
        CreateEvalRequest {
            name,
            metadata,
            data_source_config,
            testing_criteria,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalRequest {
    #[doc = "The name of the evaluation."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "The configuration for the data source used for the evaluation runs. Dictates the schema of the data used in the evaluation."]
    pub data_source_config: CreateEvalRequestDataSourceConfig,
    #[doc = "A list of graders for all eval runs in this group. Graders can reference variables in the data source using double curly braces notation, like `{{item.variable_name}}`. To reference the model's output, use the `sample` namespace (ie, `{{sample.output_text}}`)."]
    pub testing_criteria: Vec<CreateEvalRequestTestingCriteria>,
}
impl<'de> serde::Deserialize<'de>
    for CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: String,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: String,
        }
        let CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 {
            role, content, ..
        } = CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0::deserialize(
            deserializer,
        )?;
        Ok(Self { role, content })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0<'a> {
            #[serde(rename = "role")]
            role: &'a String,
            #[serde(rename = "content")]
            content: &'a String,
        }
        let Self { role, content } = self;
        CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 { role, content }
            .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0 {
    #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
    pub role: String,
    #[doc = "The content of the message."]
    pub content: String,
}
impl<'de> serde::Deserialize<'de>
    for CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate {
            _0(#[allow(dead_code)] CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0),
            EvalItem(#[allow(dead_code)] EvalItem),
        }
        Ok(
            match CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate::deserialize(
                deserializer,
            )? {
                CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate::_0(_v) => {
                    Self::_0(_v)
                }
                CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate::EvalItem(_v) => {
                    Self::EvalItem(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate<'a> {
            _0(
                #[allow(dead_code)]
                &'a CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0,
            ),
            EvalItem(#[allow(dead_code)] &'a EvalItem),
        }
        match self {
            Self::_0(_v) => CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate::_0(_v)
                .serialize(serializer),
            Self::EvalItem(_v) => {
                CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate::EvalItem(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate {
    _0(CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate0),
    EvalItem(EvalItem),
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceInputMessagesTemplate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of input messages. Always `template`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceInputMessagesTemplateType {
            #[default]
            #[serde(rename = "template")]
            Template,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalResponsesRunDataSourceInputMessagesTemplate {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalResponsesRunDataSourceInputMessagesTemplateType,
            #[serde(rename = "template")]
            #[allow(dead_code)]
            template: Vec<CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate>,
        }
        let CreateEvalResponsesRunDataSourceInputMessagesTemplate { template, .. } =
            CreateEvalResponsesRunDataSourceInputMessagesTemplate::deserialize(deserializer)?;
        Ok(Self { template })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessagesTemplate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of input messages. Always `template`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceInputMessagesTemplateType {
            #[default]
            #[serde(rename = "template")]
            Template,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalResponsesRunDataSourceInputMessagesTemplate<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalResponsesRunDataSourceInputMessagesTemplateType,
            #[serde(rename = "template")]
            template: &'a Vec<CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate>,
        }
        let Self { template } = self;
        CreateEvalResponsesRunDataSourceInputMessagesTemplate {
            type_: &Default::default(),
            template,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceInputMessagesTemplate {
    #[doc = "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."]
    pub template: Vec<CreateEvalResponsesRunDataSourceInputMessagesTemplateTemplate>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceInputMessagesItemReference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of input messages. Always `item_reference`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceInputMessagesItemReferenceType {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalResponsesRunDataSourceInputMessagesItemReference {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalResponsesRunDataSourceInputMessagesItemReferenceType,
            #[serde(rename = "item_reference")]
            #[allow(dead_code)]
            item_reference: String,
        }
        let CreateEvalResponsesRunDataSourceInputMessagesItemReference { item_reference, .. } =
            CreateEvalResponsesRunDataSourceInputMessagesItemReference::deserialize(deserializer)?;
        Ok(Self { item_reference })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessagesItemReference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of input messages. Always `item_reference`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceInputMessagesItemReferenceType {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalResponsesRunDataSourceInputMessagesItemReference<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalResponsesRunDataSourceInputMessagesItemReferenceType,
            #[serde(rename = "item_reference")]
            item_reference: &'a String,
        }
        let Self { item_reference } = self;
        CreateEvalResponsesRunDataSourceInputMessagesItemReference {
            type_: &Default::default(),
            item_reference,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceInputMessagesItemReference {
    #[doc = "A reference to a variable in the `item` namespace. Ie, \"item.name\""]
    pub item_reference: String,
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalResponsesRunDataSourceInputMessages {
            Template(#[allow(dead_code)] CreateEvalResponsesRunDataSourceInputMessagesTemplate),
            ItemReference(
                #[allow(dead_code)] CreateEvalResponsesRunDataSourceInputMessagesItemReference,
            ),
        }
        Ok(
            match CreateEvalResponsesRunDataSourceInputMessages::deserialize(deserializer)? {
                CreateEvalResponsesRunDataSourceInputMessages::Template(_v) => Self::Template(_v),
                CreateEvalResponsesRunDataSourceInputMessages::ItemReference(_v) => {
                    Self::ItemReference(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalResponsesRunDataSourceInputMessages<'a> {
            Template(#[allow(dead_code)] &'a CreateEvalResponsesRunDataSourceInputMessagesTemplate),
            ItemReference(
                #[allow(dead_code)] &'a CreateEvalResponsesRunDataSourceInputMessagesItemReference,
            ),
        }
        match self {
            Self::Template(_v) => {
                CreateEvalResponsesRunDataSourceInputMessages::Template(_v).serialize(serializer)
            }
            Self::ItemReference(_v) => {
                CreateEvalResponsesRunDataSourceInputMessages::ItemReference(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalResponsesRunDataSourceInputMessages {
    Template(CreateEvalResponsesRunDataSourceInputMessagesTemplate),
    ItemReference(CreateEvalResponsesRunDataSourceInputMessagesItemReference),
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceSamplingParamsText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalResponsesRunDataSourceSamplingParamsText {
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: Option<TextResponseFormatConfiguration>,
        }
        let CreateEvalResponsesRunDataSourceSamplingParamsText { format, .. } =
            CreateEvalResponsesRunDataSourceSamplingParamsText::deserialize(deserializer)?;
        Ok(Self { format })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceSamplingParamsText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalResponsesRunDataSourceSamplingParamsText<'a> {
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            format: &'a Option<TextResponseFormatConfiguration>,
        }
        let Self { format } = self;
        CreateEvalResponsesRunDataSourceSamplingParamsText { format }.serialize(serializer)
    }
}
#[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceSamplingParamsText {
    #[builder(default)]
    pub format: Option<TextResponseFormatConfiguration>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceSamplingParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalResponsesRunDataSourceSamplingParams {
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<Tool>>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<CreateEvalResponsesRunDataSourceSamplingParamsText>,
        }
        let CreateEvalResponsesRunDataSourceSamplingParams {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            tools,
            text,
            ..
        } = CreateEvalResponsesRunDataSourceSamplingParams::deserialize(deserializer)?;
        Ok(Self {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            tools,
            text,
        })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceSamplingParams {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalResponsesRunDataSourceSamplingParams<'a> {
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<Tool>>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<CreateEvalResponsesRunDataSourceSamplingParamsText>,
        }
        let Self {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            tools,
            text,
        } = self;
        CreateEvalResponsesRunDataSourceSamplingParams {
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            tools,
            text,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSourceSamplingParams {
    #[doc = "A higher temperature increases randomness in the outputs."]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "The maximum number of tokens in the generated output."]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[doc = "An alternative to temperature for nucleus sampling; 1.0 includes all tokens."]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "A seed value to initialize the randomness, during sampling."]
    #[builder(default)]
    pub seed: Option<u64>,
    #[doc = "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nThe two categories of tools you can provide the model are:\n\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code. Learn more about\n  [function calling](https://platform.openai.com/docs/guides/function-calling).\n"]
    #[builder(default)]
    pub tools: Option<Vec<Tool>>,
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
    #[builder(default)]
    pub text: Option<CreateEvalResponsesRunDataSourceSamplingParamsText>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSourceSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalResponsesRunDataSourceSource {
            FileContent(#[allow(dead_code)] EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] EvalJsonlFileIdSource),
            Responses(#[allow(dead_code)] EvalResponsesSource),
        }
        Ok(
            match CreateEvalResponsesRunDataSourceSource::deserialize(deserializer)? {
                CreateEvalResponsesRunDataSourceSource::FileContent(_v) => Self::FileContent(_v),
                CreateEvalResponsesRunDataSourceSource::FileId(_v) => Self::FileId(_v),
                CreateEvalResponsesRunDataSourceSource::Responses(_v) => Self::Responses(_v),
            },
        )
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSourceSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalResponsesRunDataSourceSource<'a> {
            FileContent(#[allow(dead_code)] &'a EvalJsonlFileContentSource),
            FileId(#[allow(dead_code)] &'a EvalJsonlFileIdSource),
            Responses(#[allow(dead_code)] &'a EvalResponsesSource),
        }
        match self {
            Self::FileContent(_v) => {
                CreateEvalResponsesRunDataSourceSource::FileContent(_v).serialize(serializer)
            }
            Self::FileId(_v) => {
                CreateEvalResponsesRunDataSourceSource::FileId(_v).serialize(serializer)
            }
            Self::Responses(_v) => {
                CreateEvalResponsesRunDataSourceSource::Responses(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Determines what populates the `item` namespace in this run's data source."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalResponsesRunDataSourceSource {
    FileContent(EvalJsonlFileContentSource),
    FileId(EvalJsonlFileIdSource),
    Responses(EvalResponsesSource),
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of run data source. Always `responses`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceType {
            #[default]
            #[serde(rename = "responses")]
            Responses,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalResponsesRunDataSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalResponsesRunDataSourceType,
            #[serde(rename = "input_messages")]
            #[allow(dead_code)]
            input_messages: Option<CreateEvalResponsesRunDataSourceInputMessages>,
            #[serde(rename = "sampling_params")]
            #[allow(dead_code)]
            sampling_params: Option<CreateEvalResponsesRunDataSourceSamplingParams>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: CreateEvalResponsesRunDataSourceSource,
        }
        let CreateEvalResponsesRunDataSource {
            input_messages,
            sampling_params,
            model,
            source,
            ..
        } = CreateEvalResponsesRunDataSource::deserialize(deserializer)?;
        Ok(Self {
            input_messages,
            sampling_params,
            model,
            source,
        })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of run data source. Always `responses`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalResponsesRunDataSourceType {
            #[default]
            #[serde(rename = "responses")]
            Responses,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalResponsesRunDataSource<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalResponsesRunDataSourceType,
            #[serde(rename = "input_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_messages: &'a Option<CreateEvalResponsesRunDataSourceInputMessages>,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params: &'a Option<CreateEvalResponsesRunDataSourceSamplingParams>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "source")]
            source: &'a CreateEvalResponsesRunDataSourceSource,
        }
        let Self {
            input_messages,
            sampling_params,
            model,
            source,
        } = self;
        CreateEvalResponsesRunDataSource {
            type_: &Default::default(),
            input_messages,
            sampling_params,
            model,
            source,
        }
        .serialize(serializer)
    }
}
#[doc = "A ResponsesRunDataSource object describing a model sampling configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSource {
    #[doc = "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."]
    #[builder(default)]
    pub input_messages: Option<CreateEvalResponsesRunDataSourceInputMessages>,
    #[builder(default)]
    pub sampling_params: Option<CreateEvalResponsesRunDataSourceSamplingParams>,
    #[doc = "The name of the model to use for generating completions (e.g. \"o3-mini\")."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Determines what populates the `item` namespace in this run's data source."]
    pub source: CreateEvalResponsesRunDataSourceSource,
}
impl<'de> serde::Deserialize<'de> for CreateEvalRunRequestDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateEvalRunRequestDataSource {
            Jsonl(#[allow(dead_code)] CreateEvalJsonlRunDataSource),
            Completions(#[allow(dead_code)] CreateEvalCompletionsRunDataSource),
            Responses(#[allow(dead_code)] CreateEvalResponsesRunDataSource),
        }
        Ok(
            match CreateEvalRunRequestDataSource::deserialize(deserializer)? {
                CreateEvalRunRequestDataSource::Jsonl(_v) => Self::Jsonl(_v),
                CreateEvalRunRequestDataSource::Completions(_v) => Self::Completions(_v),
                CreateEvalRunRequestDataSource::Responses(_v) => Self::Responses(_v),
            },
        )
    }
}
impl serde::Serialize for CreateEvalRunRequestDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateEvalRunRequestDataSource<'a> {
            Jsonl(#[allow(dead_code)] &'a CreateEvalJsonlRunDataSource),
            Completions(#[allow(dead_code)] &'a CreateEvalCompletionsRunDataSource),
            Responses(#[allow(dead_code)] &'a CreateEvalResponsesRunDataSource),
        }
        match self {
            Self::Jsonl(_v) => CreateEvalRunRequestDataSource::Jsonl(_v).serialize(serializer),
            Self::Completions(_v) => {
                CreateEvalRunRequestDataSource::Completions(_v).serialize(serializer)
            }
            Self::Responses(_v) => {
                CreateEvalRunRequestDataSource::Responses(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Details about the run's data source."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalRunRequestDataSource {
    Jsonl(CreateEvalJsonlRunDataSource),
    Completions(CreateEvalCompletionsRunDataSource),
    Responses(CreateEvalResponsesRunDataSource),
}
impl<'de> serde::Deserialize<'de> for CreateEvalRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalRunRequest {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "data_source")]
            #[allow(dead_code)]
            data_source: CreateEvalRunRequestDataSource,
        }
        let CreateEvalRunRequest {
            name,
            metadata,
            data_source,
            ..
        } = CreateEvalRunRequest::deserialize(deserializer)?;
        Ok(Self {
            name,
            metadata,
            data_source,
        })
    }
}
impl serde::Serialize for CreateEvalRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalRunRequest<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "data_source")]
            data_source: &'a CreateEvalRunRequestDataSource,
        }
        let Self {
            name,
            metadata,
            data_source,
        } = self;
        CreateEvalRunRequest {
            name,
            metadata,
            data_source,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalRunRequest {
    #[doc = "The name of the run."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "Details about the run's data source."]
    pub data_source: CreateEvalRunRequestDataSource,
}
impl<'de> serde::Deserialize<'de> for CreateEvalStoredCompletionsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalStoredCompletionsDataSourceConfigType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalStoredCompletionsDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateEvalStoredCompletionsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let CreateEvalStoredCompletionsDataSourceConfig { metadata, .. } =
            CreateEvalStoredCompletionsDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { metadata })
    }
}
impl serde::Serialize for CreateEvalStoredCompletionsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateEvalStoredCompletionsDataSourceConfigType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalStoredCompletionsDataSourceConfig<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateEvalStoredCompletionsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self { metadata } = self;
        CreateEvalStoredCompletionsDataSourceConfig {
            type_: &Default::default(),
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Deprecated in favor of LogsDataSourceConfig.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateEvalStoredCompletionsDataSourceConfig {
    #[doc = "Metadata filters for the stored completions data source."]
    #[builder(default)]
    pub metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for CreateFileRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateFileRequest {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Vec<u8>,
            #[serde(rename = "purpose")]
            #[allow(dead_code)]
            purpose: FilePurpose,
        }
        let CreateFileRequest { file, purpose, .. } = CreateFileRequest::deserialize(deserializer)?;
        Ok(Self { file, purpose })
    }
}
impl serde::Serialize for CreateFileRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateFileRequest<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            file: &'a Vec<u8>,
            #[serde(rename = "purpose")]
            purpose: &'a FilePurpose,
        }
        let Self { file, purpose } = self;
        CreateFileRequest { file, purpose }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFileRequest {
    #[doc = "The File object (not file name) to be uploaded.\n"]
    pub file: Vec<u8>,
    pub purpose: FilePurpose,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningCheckpointPermissionRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateFineTuningCheckpointPermissionRequest {
            #[serde(rename = "project_ids")]
            #[allow(dead_code)]
            project_ids: Vec<String>,
        }
        let CreateFineTuningCheckpointPermissionRequest { project_ids, .. } =
            CreateFineTuningCheckpointPermissionRequest::deserialize(deserializer)?;
        Ok(Self { project_ids })
    }
}
impl serde::Serialize for CreateFineTuningCheckpointPermissionRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateFineTuningCheckpointPermissionRequest<'a> {
            #[serde(rename = "project_ids")]
            project_ids: &'a Vec<String>,
        }
        let Self { project_ids } = self;
        CreateFineTuningCheckpointPermissionRequest { project_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningCheckpointPermissionRequest {
    #[doc = "The project identifiers to grant access to."]
    pub project_ids: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateFineTuningJobRequestHyperparametersBatchSize {
            Auto(#[allow(dead_code)] CreateFineTuningJobRequestHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match CreateFineTuningJobRequestHyperparametersBatchSize::deserialize(deserializer)? {
                CreateFineTuningJobRequestHyperparametersBatchSize::Auto(_) => Self::Auto,
                CreateFineTuningJobRequestHyperparametersBatchSize::Integer(_v) => {
                    Self::Integer(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateFineTuningJobRequestHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateFineTuningJobRequestHyperparametersBatchSize<'a> {
            Auto(#[allow(dead_code)] &'a CreateFineTuningJobRequestHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => {
                CreateFineTuningJobRequestHyperparametersBatchSize::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Integer(_v) => CreateFineTuningJobRequestHyperparametersBatchSize::Integer(_v)
                .serialize(serializer),
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de>
    for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
            Auto(
                #[allow(dead_code)]
                CreateFineTuningJobRequestHyperparametersLearningRateMultiplierAuto,
            ),
            Number(#[allow(dead_code)] f64),
        }
        Ok(
            match CreateFineTuningJobRequestHyperparametersLearningRateMultiplier::deserialize(
                deserializer,
            )? {
                CreateFineTuningJobRequestHyperparametersLearningRateMultiplier::Auto(_) => {
                    Self::Auto
                }
                CreateFineTuningJobRequestHyperparametersLearningRateMultiplier::Number(_v) => {
                    Self::Number(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplier<'a> {
            Auto(
                #[allow(dead_code)]
                &'a CreateFineTuningJobRequestHyperparametersLearningRateMultiplierAuto,
            ),
            Number(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => CreateFineTuningJobRequestHyperparametersLearningRateMultiplier::Auto(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Number(_v) => {
                CreateFineTuningJobRequestHyperparametersLearningRateMultiplier::Number(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Number(f64),
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateFineTuningJobRequestHyperparametersNEpochs {
            Auto(#[allow(dead_code)] CreateFineTuningJobRequestHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match CreateFineTuningJobRequestHyperparametersNEpochs::deserialize(deserializer)? {
                CreateFineTuningJobRequestHyperparametersNEpochs::Auto(_) => Self::Auto,
                CreateFineTuningJobRequestHyperparametersNEpochs::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for CreateFineTuningJobRequestHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateFineTuningJobRequestHyperparametersNEpochs<'a> {
            Auto(#[allow(dead_code)] &'a CreateFineTuningJobRequestHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => {
                CreateFineTuningJobRequestHyperparametersNEpochs::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Integer(_v) => {
                CreateFineTuningJobRequestHyperparametersNEpochs::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateFineTuningJobRequestHyperparameters {
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<CreateFineTuningJobRequestHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier:
                Option<CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<CreateFineTuningJobRequestHyperparametersNEpochs>,
        }
        let CreateFineTuningJobRequestHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            ..
        } = CreateFineTuningJobRequestHyperparameters::deserialize(deserializer)?;
        Ok(Self {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateFineTuningJobRequestHyperparameters<'a> {
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<CreateFineTuningJobRequestHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier:
                &'a Option<CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<CreateFineTuningJobRequestHyperparametersNEpochs>,
        }
        let Self {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        } = self;
        CreateFineTuningJobRequestHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the fine-tuning job.\nThis value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequestHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<CreateFineTuningJobRequestHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier:
        Option<CreateFineTuningJobRequestHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<CreateFineTuningJobRequestHyperparametersNEpochs>,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestIntegrationType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestIntegrationTypeWandb {
            #[default]
            #[serde(rename = "wandb")]
            Wandb,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateFineTuningJobRequestIntegrationType {
            Wandb(#[allow(dead_code)] CreateFineTuningJobRequestIntegrationTypeWandb),
        }
        Ok(
            match CreateFineTuningJobRequestIntegrationType::deserialize(deserializer)? {
                CreateFineTuningJobRequestIntegrationType::Wandb(_) => Self::Wandb,
            },
        )
    }
}
impl serde::Serialize for CreateFineTuningJobRequestIntegrationType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateFineTuningJobRequestIntegrationTypeWandb {
            #[default]
            #[serde(rename = "wandb")]
            Wandb,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateFineTuningJobRequestIntegrationType<'a> {
            Wandb(#[allow(dead_code)] &'a CreateFineTuningJobRequestIntegrationTypeWandb),
        }
        match self {
            Self::Wandb => CreateFineTuningJobRequestIntegrationType::Wandb(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The type of integration to enable. Currently, only \"wandb\" (Weights and Biases) is supported.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateFineTuningJobRequestIntegrationType {
    #[doc = "wandb"]
    Wandb,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestIntegrationWandb {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateFineTuningJobRequestIntegrationWandb {
            #[serde(rename = "project")]
            #[allow(dead_code)]
            project: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "entity")]
            #[allow(dead_code)]
            entity: Option<String>,
            #[serde(rename = "tags")]
            #[allow(dead_code)]
            tags: Option<Vec<String>>,
        }
        let CreateFineTuningJobRequestIntegrationWandb {
            project,
            name,
            entity,
            tags,
            ..
        } = CreateFineTuningJobRequestIntegrationWandb::deserialize(deserializer)?;
        Ok(Self {
            project,
            name,
            entity,
            tags,
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestIntegrationWandb {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateFineTuningJobRequestIntegrationWandb<'a> {
            #[serde(rename = "project")]
            project: &'a String,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "entity")]
            #[serde(skip_serializing_if = "Option::is_none")]
            entity: &'a Option<String>,
            #[serde(rename = "tags")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tags: &'a Option<Vec<String>>,
        }
        let Self {
            project,
            name,
            entity,
            tags,
        } = self;
        CreateFineTuningJobRequestIntegrationWandb {
            project,
            name,
            entity,
            tags,
        }
        .serialize(serializer)
    }
}
#[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequestIntegrationWandb {
    #[doc = "The name of the project that the new run will be created under.\n"]
    pub project: String,
    #[doc = "A display name to set for the run. If not set, we will use the Job ID as the name.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The entity to use for the run. This allows you to set the team or username of the WandB user that you would\nlike associated with the run. If not set, the default entity for the registered WandB API key is used.\n"]
    #[builder(default)]
    pub entity: Option<String>,
    #[doc = "A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some\ndefault tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n"]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequestIntegration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateFineTuningJobRequestIntegration {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateFineTuningJobRequestIntegrationType,
            #[serde(rename = "wandb")]
            #[allow(dead_code)]
            wandb: CreateFineTuningJobRequestIntegrationWandb,
        }
        let CreateFineTuningJobRequestIntegration { type_, wandb, .. } =
            CreateFineTuningJobRequestIntegration::deserialize(deserializer)?;
        Ok(Self { type_, wandb })
    }
}
impl serde::Serialize for CreateFineTuningJobRequestIntegration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateFineTuningJobRequestIntegration<'a> {
            #[serde(rename = "type")]
            type_: &'a CreateFineTuningJobRequestIntegrationType,
            #[serde(rename = "wandb")]
            wandb: &'a CreateFineTuningJobRequestIntegrationWandb,
        }
        let Self { type_, wandb } = self;
        CreateFineTuningJobRequestIntegration { type_, wandb }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequestIntegration {
    #[doc = "The type of integration to enable. Currently, only \"wandb\" (Weights and Biases) is supported.\n"]
    pub type_: CreateFineTuningJobRequestIntegrationType,
    #[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
    pub wandb: CreateFineTuningJobRequestIntegrationWandb,
}
impl<'de> serde::Deserialize<'de> for CreateFineTuningJobRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateFineTuningJobRequest {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "training_file")]
            #[allow(dead_code)]
            training_file: String,
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: Option<CreateFineTuningJobRequestHyperparameters>,
            #[serde(rename = "suffix")]
            #[allow(dead_code)]
            suffix: Option<String>,
            #[serde(rename = "validation_file")]
            #[allow(dead_code)]
            validation_file: Option<String>,
            #[serde(rename = "integrations")]
            #[allow(dead_code)]
            integrations: Option<Vec<CreateFineTuningJobRequestIntegration>>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: Option<u64>,
            #[serde(rename = "method")]
            #[allow(dead_code)]
            method: Option<FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let CreateFineTuningJobRequest {
            model,
            training_file,
            hyperparameters,
            suffix,
            validation_file,
            integrations,
            seed,
            method,
            metadata,
            ..
        } = CreateFineTuningJobRequest::deserialize(deserializer)?;
        Ok(Self {
            model,
            training_file,
            hyperparameters,
            suffix,
            validation_file,
            integrations,
            seed,
            method,
            metadata,
        })
    }
}
impl serde::Serialize for CreateFineTuningJobRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateFineTuningJobRequest<'a> {
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "training_file")]
            training_file: &'a String,
            #[serde(rename = "hyperparameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            hyperparameters: &'a Option<CreateFineTuningJobRequestHyperparameters>,
            #[serde(rename = "suffix")]
            #[serde(skip_serializing_if = "Option::is_none")]
            suffix: &'a Option<String>,
            #[serde(rename = "validation_file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            validation_file: &'a Option<String>,
            #[serde(rename = "integrations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            integrations: &'a Option<Vec<CreateFineTuningJobRequestIntegration>>,
            #[serde(rename = "seed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seed: &'a Option<u64>,
            #[serde(rename = "method")]
            #[serde(skip_serializing_if = "Option::is_none")]
            method: &'a Option<FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            model,
            training_file,
            hyperparameters,
            suffix,
            validation_file,
            integrations,
            seed,
            method,
            metadata,
        } = self;
        CreateFineTuningJobRequest {
            model,
            training_file,
            hyperparameters,
            suffix,
            validation_file,
            integrations,
            seed,
            method,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequest {
    #[doc = "The name of the model to fine-tune. You can select one of the\n[supported models](https://platform.openai.com/docs/guides/fine-tuning#which-models-can-be-fine-tuned).\n"]
    pub model: String,
    #[doc = "The ID of an uploaded file that contains training data.\n\nSee [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.\n\nYour dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.\n\nThe contents of the file should differ depending on if the model uses the [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input), [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](https://platform.openai.com/docs/api-reference/fine-tuning/preference-input) format.\n\nSee the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.\n"]
    pub training_file: String,
    #[doc = "The hyperparameters used for the fine-tuning job.\nThis value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.\n"]
    #[builder(default)]
    pub hyperparameters: Option<CreateFineTuningJobRequestHyperparameters>,
    #[doc = "A string of up to 64 characters that will be added to your fine-tuned model name.\n\nFor example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.\n"]
    #[builder(default)]
    pub suffix: Option<String>,
    #[doc = "The ID of an uploaded file that contains validation data.\n\nIf you provide this file, the data is used to generate validation\nmetrics periodically during fine-tuning. These metrics can be viewed in\nthe fine-tuning results file.\nThe same data should not be present in both train and validation files.\n\nYour dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.\n\nSee the [fine-tuning guide](https://platform.openai.com/docs/guides/fine-tuning) for more details.\n"]
    #[builder(default)]
    pub validation_file: Option<String>,
    #[doc = "A list of integrations to enable for your fine-tuning job."]
    #[builder(default)]
    pub integrations: Option<Vec<CreateFineTuningJobRequestIntegration>>,
    #[doc = "The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.\nIf a seed is not specified, one will be generated for you.\n"]
    #[builder(default)]
    pub seed: Option<u64>,
    #[builder(default)]
    pub method: Option<FineTuneMethod>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageEditRequestImage {
            Bytes(
                #[serde_as(as = "serde_with::base64::Base64")]
                #[allow(dead_code)]
                Vec<u8>,
            ),
            Array(
                #[serde_as(as = "Vec<serde_with::base64::Base64>")]
                #[allow(dead_code)]
                Vec<Vec<u8>>,
            ),
        }
        Ok(
            match CreateImageEditRequestImage::deserialize(deserializer)? {
                CreateImageEditRequestImage::Bytes(_v) => Self::Bytes(_v),
                CreateImageEditRequestImage::Array(_v) => Self::Array(_v),
            },
        )
    }
}
impl serde::Serialize for CreateImageEditRequestImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageEditRequestImage<'a> {
            Bytes(
                #[serde_as(as = "serde_with::base64::Base64")]
                #[allow(dead_code)]
                &'a Vec<u8>,
            ),
            Array(
                #[serde_as(as = "Vec<serde_with::base64::Base64>")]
                #[allow(dead_code)]
                &'a Vec<Vec<u8>>,
            ),
        }
        match self {
            Self::Bytes(_v) => CreateImageEditRequestImage::Bytes(_v).serialize(serializer),
            Self::Array(_v) => CreateImageEditRequestImage::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The image(s) to edit. Must be a supported image file or an array of images.\n\nFor `gpt-image-1`, each image should be a `png`, `webp`, or `jpg` file less \nthan 50MB. You can provide up to 16 images.\n\nFor `dall-e-2`, you can only provide one image, and it should be a square \n`png` file less than 4MB.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestImage {
    Bytes(Vec<u8>),
    Array(Vec<Vec<u8>>),
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestBackground {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestBackgroundTransparent {
            #[default]
            #[serde(rename = "transparent")]
            Transparent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestBackgroundOpaque {
            #[default]
            #[serde(rename = "opaque")]
            Opaque,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestBackgroundAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageEditRequestBackground {
            Transparent(#[allow(dead_code)] CreateImageEditRequestBackgroundTransparent),
            Opaque(#[allow(dead_code)] CreateImageEditRequestBackgroundOpaque),
            Auto(#[allow(dead_code)] CreateImageEditRequestBackgroundAuto),
        }
        Ok(
            match CreateImageEditRequestBackground::deserialize(deserializer)? {
                CreateImageEditRequestBackground::Transparent(_) => Self::Transparent,
                CreateImageEditRequestBackground::Opaque(_) => Self::Opaque,
                CreateImageEditRequestBackground::Auto(_) => Self::Auto,
            },
        )
    }
}
impl serde::Serialize for CreateImageEditRequestBackground {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestBackgroundTransparent {
            #[default]
            #[serde(rename = "transparent")]
            Transparent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestBackgroundOpaque {
            #[default]
            #[serde(rename = "opaque")]
            Opaque,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestBackgroundAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageEditRequestBackground<'a> {
            Transparent(#[allow(dead_code)] &'a CreateImageEditRequestBackgroundTransparent),
            Opaque(#[allow(dead_code)] &'a CreateImageEditRequestBackgroundOpaque),
            Auto(#[allow(dead_code)] &'a CreateImageEditRequestBackgroundAuto),
        }
        match self {
            Self::Transparent => CreateImageEditRequestBackground::Transparent(&Default::default())
                .serialize(serializer),
            Self::Opaque => {
                CreateImageEditRequestBackground::Opaque(&Default::default()).serialize(serializer)
            }
            Self::Auto => {
                CreateImageEditRequestBackground::Auto(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestBackground {
    #[doc = "transparent"]
    Transparent,
    #[doc = "opaque"]
    Opaque,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageEditRequestSize {
            _256x256(#[allow(dead_code)] CreateImageEditRequestSize256x256),
            _512x512(#[allow(dead_code)] CreateImageEditRequestSize512x512),
            _1024x1024(#[allow(dead_code)] CreateImageEditRequestSize1024x1024),
            _1536x1024(#[allow(dead_code)] CreateImageEditRequestSize1536x1024),
            _1024x1536(#[allow(dead_code)] CreateImageEditRequestSize1024x1536),
            Auto(#[allow(dead_code)] CreateImageEditRequestSizeAuto),
        }
        Ok(
            match CreateImageEditRequestSize::deserialize(deserializer)? {
                CreateImageEditRequestSize::_256x256(_) => Self::_256x256,
                CreateImageEditRequestSize::_512x512(_) => Self::_512x512,
                CreateImageEditRequestSize::_1024x1024(_) => Self::_1024x1024,
                CreateImageEditRequestSize::_1536x1024(_) => Self::_1536x1024,
                CreateImageEditRequestSize::_1024x1536(_) => Self::_1024x1536,
                CreateImageEditRequestSize::Auto(_) => Self::Auto,
            },
        )
    }
}
impl serde::Serialize for CreateImageEditRequestSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageEditRequestSize<'a> {
            _256x256(#[allow(dead_code)] &'a CreateImageEditRequestSize256x256),
            _512x512(#[allow(dead_code)] &'a CreateImageEditRequestSize512x512),
            _1024x1024(#[allow(dead_code)] &'a CreateImageEditRequestSize1024x1024),
            _1536x1024(#[allow(dead_code)] &'a CreateImageEditRequestSize1536x1024),
            _1024x1536(#[allow(dead_code)] &'a CreateImageEditRequestSize1024x1536),
            Auto(#[allow(dead_code)] &'a CreateImageEditRequestSizeAuto),
        }
        match self {
            Self::_256x256 => {
                CreateImageEditRequestSize::_256x256(&Default::default()).serialize(serializer)
            }
            Self::_512x512 => {
                CreateImageEditRequestSize::_512x512(&Default::default()).serialize(serializer)
            }
            Self::_1024x1024 => {
                CreateImageEditRequestSize::_1024x1024(&Default::default()).serialize(serializer)
            }
            Self::_1536x1024 => {
                CreateImageEditRequestSize::_1536x1024(&Default::default()).serialize(serializer)
            }
            Self::_1024x1536 => {
                CreateImageEditRequestSize::_1024x1536(&Default::default()).serialize(serializer)
            }
            Self::Auto => {
                CreateImageEditRequestSize::Auto(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, and one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestSize {
    #[doc = "256x256"]
    _256x256,
    #[doc = "512x512"]
    _512x512,
    #[doc = "1024x1024"]
    #[default]
    _1024x1024,
    #[doc = "1536x1024"]
    _1536x1024,
    #[doc = "1024x1536"]
    _1024x1536,
    #[doc = "auto"]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageEditRequestResponseFormat {
            Url(#[allow(dead_code)] CreateImageEditRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] CreateImageEditRequestResponseFormatB64Json),
        }
        Ok(
            match CreateImageEditRequestResponseFormat::deserialize(deserializer)? {
                CreateImageEditRequestResponseFormat::Url(_) => Self::Url,
                CreateImageEditRequestResponseFormat::B64Json(_) => Self::B64Json,
            },
        )
    }
}
impl serde::Serialize for CreateImageEditRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageEditRequestResponseFormat<'a> {
            Url(#[allow(dead_code)] &'a CreateImageEditRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] &'a CreateImageEditRequestResponseFormatB64Json),
        }
        match self {
            Self::Url => {
                CreateImageEditRequestResponseFormat::Url(&Default::default()).serialize(serializer)
            }
            Self::B64Json => CreateImageEditRequestResponseFormat::B64Json(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter is only supported for `dall-e-2`, as `gpt-image-1` will always return base64-encoded images."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestResponseFormat {
    #[doc = "url"]
    #[default]
    Url,
    #[doc = "b64_json"]
    B64Json,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequestQuality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityStandard {
            #[default]
            #[serde(rename = "standard")]
            Standard,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageEditRequestQuality {
            Standard(#[allow(dead_code)] CreateImageEditRequestQualityStandard),
            Low(#[allow(dead_code)] CreateImageEditRequestQualityLow),
            Medium(#[allow(dead_code)] CreateImageEditRequestQualityMedium),
            High(#[allow(dead_code)] CreateImageEditRequestQualityHigh),
            Auto(#[allow(dead_code)] CreateImageEditRequestQualityAuto),
        }
        Ok(
            match CreateImageEditRequestQuality::deserialize(deserializer)? {
                CreateImageEditRequestQuality::Standard(_) => Self::Standard,
                CreateImageEditRequestQuality::Low(_) => Self::Low,
                CreateImageEditRequestQuality::Medium(_) => Self::Medium,
                CreateImageEditRequestQuality::High(_) => Self::High,
                CreateImageEditRequestQuality::Auto(_) => Self::Auto,
            },
        )
    }
}
impl serde::Serialize for CreateImageEditRequestQuality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityStandard {
            #[default]
            #[serde(rename = "standard")]
            Standard,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageEditRequestQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageEditRequestQuality<'a> {
            Standard(#[allow(dead_code)] &'a CreateImageEditRequestQualityStandard),
            Low(#[allow(dead_code)] &'a CreateImageEditRequestQualityLow),
            Medium(#[allow(dead_code)] &'a CreateImageEditRequestQualityMedium),
            High(#[allow(dead_code)] &'a CreateImageEditRequestQualityHigh),
            Auto(#[allow(dead_code)] &'a CreateImageEditRequestQualityAuto),
        }
        match self {
            Self::Standard => {
                CreateImageEditRequestQuality::Standard(&Default::default()).serialize(serializer)
            }
            Self::Low => {
                CreateImageEditRequestQuality::Low(&Default::default()).serialize(serializer)
            }
            Self::Medium => {
                CreateImageEditRequestQuality::Medium(&Default::default()).serialize(serializer)
            }
            Self::High => {
                CreateImageEditRequestQuality::High(&Default::default()).serialize(serializer)
            }
            Self::Auto => {
                CreateImageEditRequestQuality::Auto(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The quality of the image that will be generated. `high`, `medium` and `low` are only supported for `gpt-image-1`. `dall-e-2` only supports `standard` quality. Defaults to `auto`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageEditRequestQuality {
    #[doc = "standard"]
    Standard,
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageEditRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateImageEditRequest {
            #[serde(rename = "image")]
            #[allow(dead_code)]
            image: CreateImageEditRequestImage,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: String,
            #[serde_as(as = "Option<serde_with::base64::Base64>")]
            #[serde(rename = "mask")]
            #[allow(dead_code)]
            mask: Option<Vec<u8>>,
            #[serde(rename = "background")]
            #[allow(dead_code)]
            background: Option<CreateImageEditRequestBackground>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<CreateImageEditRequestSize>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateImageEditRequestResponseFormat>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
            #[serde(rename = "quality")]
            #[allow(dead_code)]
            quality: Option<CreateImageEditRequestQuality>,
        }
        let CreateImageEditRequest {
            image,
            prompt,
            mask,
            background,
            model,
            n,
            size,
            response_format,
            user,
            quality,
            ..
        } = CreateImageEditRequest::deserialize(deserializer)?;
        Ok(Self {
            image,
            prompt,
            mask,
            background,
            model,
            n,
            size,
            response_format,
            user,
            quality,
        })
    }
}
impl serde::Serialize for CreateImageEditRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateImageEditRequest<'a> {
            #[serde(rename = "image")]
            image: &'a CreateImageEditRequestImage,
            #[serde(rename = "prompt")]
            prompt: &'a String,
            #[serde_as(as = "Option<serde_with::base64::Base64>")]
            #[serde(rename = "mask")]
            #[serde(skip_serializing_if = "Option::is_none")]
            mask: &'a Option<Vec<u8>>,
            #[serde(rename = "background")]
            #[serde(skip_serializing_if = "Option::is_none")]
            background: &'a Option<CreateImageEditRequestBackground>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<CreateImageEditRequestSize>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateImageEditRequestResponseFormat>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            quality: &'a Option<CreateImageEditRequestQuality>,
        }
        let Self {
            image,
            prompt,
            mask,
            background,
            model,
            n,
            size,
            response_format,
            user,
            quality,
        } = self;
        CreateImageEditRequest {
            image,
            prompt,
            mask,
            background,
            model,
            n,
            size,
            response_format,
            user,
            quality,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateImageEditRequest {
    #[doc = "The image(s) to edit. Must be a supported image file or an array of images.\n\nFor `gpt-image-1`, each image should be a `png`, `webp`, or `jpg` file less \nthan 50MB. You can provide up to 16 images.\n\nFor `dall-e-2`, you can only provide one image, and it should be a square \n`png` file less than 4MB.\n"]
    pub image: CreateImageEditRequestImage,
    #[doc = "A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2`, and 32000 characters for `gpt-image-1`."]
    pub prompt: String,
    #[doc = "An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where `image` should be edited. If there are multiple images provided, the mask will be applied on the first image. Must be a valid PNG file, less than 4MB, and have the same dimensions as `image`."]
    #[builder(default)]
    pub mask: Option<Vec<u8>>,
    #[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
    #[builder(default)]
    pub background: Option<CreateImageEditRequestBackground>,
    #[doc = "The model to use for image generation. Only `dall-e-2` and `gpt-image-1` are supported. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The number of images to generate. Must be between 1 and 10."]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, and one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`."]
    #[builder(default)]
    pub size: Option<CreateImageEditRequestSize>,
    #[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter is only supported for `dall-e-2`, as `gpt-image-1` will always return base64-encoded images."]
    #[builder(default)]
    pub response_format: Option<CreateImageEditRequestResponseFormat>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
    #[doc = "The quality of the image that will be generated. `high`, `medium` and `low` are only supported for `gpt-image-1`. `dall-e-2` only supports `standard` quality. Defaults to `auto`.\n"]
    #[builder(default)]
    pub quality: Option<CreateImageEditRequestQuality>,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestQuality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityStandard {
            #[default]
            #[serde(rename = "standard")]
            Standard,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityHd {
            #[default]
            #[serde(rename = "hd")]
            Hd,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageRequestQuality {
            Standard(#[allow(dead_code)] CreateImageRequestQualityStandard),
            Hd(#[allow(dead_code)] CreateImageRequestQualityHd),
            Low(#[allow(dead_code)] CreateImageRequestQualityLow),
            Medium(#[allow(dead_code)] CreateImageRequestQualityMedium),
            High(#[allow(dead_code)] CreateImageRequestQualityHigh),
            Auto(#[allow(dead_code)] CreateImageRequestQualityAuto),
        }
        Ok(
            match CreateImageRequestQuality::deserialize(deserializer)? {
                CreateImageRequestQuality::Standard(_) => Self::Standard,
                CreateImageRequestQuality::Hd(_) => Self::Hd,
                CreateImageRequestQuality::Low(_) => Self::Low,
                CreateImageRequestQuality::Medium(_) => Self::Medium,
                CreateImageRequestQuality::High(_) => Self::High,
                CreateImageRequestQuality::Auto(_) => Self::Auto,
            },
        )
    }
}
impl serde::Serialize for CreateImageRequestQuality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityStandard {
            #[default]
            #[serde(rename = "standard")]
            Standard,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityHd {
            #[default]
            #[serde(rename = "hd")]
            Hd,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageRequestQuality<'a> {
            Standard(#[allow(dead_code)] &'a CreateImageRequestQualityStandard),
            Hd(#[allow(dead_code)] &'a CreateImageRequestQualityHd),
            Low(#[allow(dead_code)] &'a CreateImageRequestQualityLow),
            Medium(#[allow(dead_code)] &'a CreateImageRequestQualityMedium),
            High(#[allow(dead_code)] &'a CreateImageRequestQualityHigh),
            Auto(#[allow(dead_code)] &'a CreateImageRequestQualityAuto),
        }
        match self {
            Self::Standard => {
                CreateImageRequestQuality::Standard(&Default::default()).serialize(serializer)
            }
            Self::Hd => CreateImageRequestQuality::Hd(&Default::default()).serialize(serializer),
            Self::Low => CreateImageRequestQuality::Low(&Default::default()).serialize(serializer),
            Self::Medium => {
                CreateImageRequestQuality::Medium(&Default::default()).serialize(serializer)
            }
            Self::High => {
                CreateImageRequestQuality::High(&Default::default()).serialize(serializer)
            }
            Self::Auto => {
                CreateImageRequestQuality::Auto(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The quality of the image that will be generated. \n\n- `auto` (default value) will automatically select the best quality for the given model.\n- `high`, `medium` and `low` are supported for `gpt-image-1`.\n- `hd` and `standard` are supported for `dall-e-3`.\n- `standard` is the only option for `dall-e-2`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestQuality {
    #[doc = "standard"]
    Standard,
    #[doc = "hd"]
    Hd,
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageRequestResponseFormat {
            Url(#[allow(dead_code)] CreateImageRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] CreateImageRequestResponseFormatB64Json),
        }
        Ok(
            match CreateImageRequestResponseFormat::deserialize(deserializer)? {
                CreateImageRequestResponseFormat::Url(_) => Self::Url,
                CreateImageRequestResponseFormat::B64Json(_) => Self::B64Json,
            },
        )
    }
}
impl serde::Serialize for CreateImageRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageRequestResponseFormat<'a> {
            Url(#[allow(dead_code)] &'a CreateImageRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] &'a CreateImageRequestResponseFormatB64Json),
        }
        match self {
            Self::Url => {
                CreateImageRequestResponseFormat::Url(&Default::default()).serialize(serializer)
            }
            Self::B64Json => {
                CreateImageRequestResponseFormat::B64Json(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestResponseFormat {
    #[doc = "url"]
    #[default]
    Url,
    #[doc = "b64_json"]
    B64Json,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestOutputFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatPng {
            #[default]
            #[serde(rename = "png")]
            Png,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatJpeg {
            #[default]
            #[serde(rename = "jpeg")]
            Jpeg,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatWebp {
            #[default]
            #[serde(rename = "webp")]
            Webp,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageRequestOutputFormat {
            Png(#[allow(dead_code)] CreateImageRequestOutputFormatPng),
            Jpeg(#[allow(dead_code)] CreateImageRequestOutputFormatJpeg),
            Webp(#[allow(dead_code)] CreateImageRequestOutputFormatWebp),
        }
        Ok(
            match CreateImageRequestOutputFormat::deserialize(deserializer)? {
                CreateImageRequestOutputFormat::Png(_) => Self::Png,
                CreateImageRequestOutputFormat::Jpeg(_) => Self::Jpeg,
                CreateImageRequestOutputFormat::Webp(_) => Self::Webp,
            },
        )
    }
}
impl serde::Serialize for CreateImageRequestOutputFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatPng {
            #[default]
            #[serde(rename = "png")]
            Png,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatJpeg {
            #[default]
            #[serde(rename = "jpeg")]
            Jpeg,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestOutputFormatWebp {
            #[default]
            #[serde(rename = "webp")]
            Webp,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageRequestOutputFormat<'a> {
            Png(#[allow(dead_code)] &'a CreateImageRequestOutputFormatPng),
            Jpeg(#[allow(dead_code)] &'a CreateImageRequestOutputFormatJpeg),
            Webp(#[allow(dead_code)] &'a CreateImageRequestOutputFormatWebp),
        }
        match self {
            Self::Png => {
                CreateImageRequestOutputFormat::Png(&Default::default()).serialize(serializer)
            }
            Self::Jpeg => {
                CreateImageRequestOutputFormat::Jpeg(&Default::default()).serialize(serializer)
            }
            Self::Webp => {
                CreateImageRequestOutputFormat::Webp(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The format in which the generated images are returned. This parameter is only supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestOutputFormat {
    #[doc = "png"]
    #[default]
    Png,
    #[doc = "jpeg"]
    Jpeg,
    #[doc = "webp"]
    Webp,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1792x1024 {
            #[default]
            #[serde(rename = "1792x1024")]
            _1792x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1792 {
            #[default]
            #[serde(rename = "1024x1792")]
            _1024x1792,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageRequestSize {
            Auto(#[allow(dead_code)] CreateImageRequestSizeAuto),
            _1024x1024(#[allow(dead_code)] CreateImageRequestSize1024x1024),
            _1536x1024(#[allow(dead_code)] CreateImageRequestSize1536x1024),
            _1024x1536(#[allow(dead_code)] CreateImageRequestSize1024x1536),
            _256x256(#[allow(dead_code)] CreateImageRequestSize256x256),
            _512x512(#[allow(dead_code)] CreateImageRequestSize512x512),
            _1792x1024(#[allow(dead_code)] CreateImageRequestSize1792x1024),
            _1024x1792(#[allow(dead_code)] CreateImageRequestSize1024x1792),
        }
        Ok(match CreateImageRequestSize::deserialize(deserializer)? {
            CreateImageRequestSize::Auto(_) => Self::Auto,
            CreateImageRequestSize::_1024x1024(_) => Self::_1024x1024,
            CreateImageRequestSize::_1536x1024(_) => Self::_1536x1024,
            CreateImageRequestSize::_1024x1536(_) => Self::_1024x1536,
            CreateImageRequestSize::_256x256(_) => Self::_256x256,
            CreateImageRequestSize::_512x512(_) => Self::_512x512,
            CreateImageRequestSize::_1792x1024(_) => Self::_1792x1024,
            CreateImageRequestSize::_1024x1792(_) => Self::_1024x1792,
        })
    }
}
impl serde::Serialize for CreateImageRequestSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1792x1024 {
            #[default]
            #[serde(rename = "1792x1024")]
            _1792x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestSize1024x1792 {
            #[default]
            #[serde(rename = "1024x1792")]
            _1024x1792,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageRequestSize<'a> {
            Auto(#[allow(dead_code)] &'a CreateImageRequestSizeAuto),
            _1024x1024(#[allow(dead_code)] &'a CreateImageRequestSize1024x1024),
            _1536x1024(#[allow(dead_code)] &'a CreateImageRequestSize1536x1024),
            _1024x1536(#[allow(dead_code)] &'a CreateImageRequestSize1024x1536),
            _256x256(#[allow(dead_code)] &'a CreateImageRequestSize256x256),
            _512x512(#[allow(dead_code)] &'a CreateImageRequestSize512x512),
            _1792x1024(#[allow(dead_code)] &'a CreateImageRequestSize1792x1024),
            _1024x1792(#[allow(dead_code)] &'a CreateImageRequestSize1024x1792),
        }
        match self {
            Self::Auto => CreateImageRequestSize::Auto(&Default::default()).serialize(serializer),
            Self::_1024x1024 => {
                CreateImageRequestSize::_1024x1024(&Default::default()).serialize(serializer)
            }
            Self::_1536x1024 => {
                CreateImageRequestSize::_1536x1024(&Default::default()).serialize(serializer)
            }
            Self::_1024x1536 => {
                CreateImageRequestSize::_1024x1536(&Default::default()).serialize(serializer)
            }
            Self::_256x256 => {
                CreateImageRequestSize::_256x256(&Default::default()).serialize(serializer)
            }
            Self::_512x512 => {
                CreateImageRequestSize::_512x512(&Default::default()).serialize(serializer)
            }
            Self::_1792x1024 => {
                CreateImageRequestSize::_1792x1024(&Default::default()).serialize(serializer)
            }
            Self::_1024x1792 => {
                CreateImageRequestSize::_1024x1792(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestSize {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "1024x1024"]
    _1024x1024,
    #[doc = "1536x1024"]
    _1536x1024,
    #[doc = "1024x1536"]
    _1024x1536,
    #[doc = "256x256"]
    _256x256,
    #[doc = "512x512"]
    _512x512,
    #[doc = "1792x1024"]
    _1792x1024,
    #[doc = "1024x1792"]
    _1024x1792,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestModeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestModerationLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestModerationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageRequestModeration {
            Low(#[allow(dead_code)] CreateImageRequestModerationLow),
            Auto(#[allow(dead_code)] CreateImageRequestModerationAuto),
        }
        Ok(
            match CreateImageRequestModeration::deserialize(deserializer)? {
                CreateImageRequestModeration::Low(_) => Self::Low,
                CreateImageRequestModeration::Auto(_) => Self::Auto,
            },
        )
    }
}
impl serde::Serialize for CreateImageRequestModeration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestModerationLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestModerationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageRequestModeration<'a> {
            Low(#[allow(dead_code)] &'a CreateImageRequestModerationLow),
            Auto(#[allow(dead_code)] &'a CreateImageRequestModerationAuto),
        }
        match self {
            Self::Low => {
                CreateImageRequestModeration::Low(&Default::default()).serialize(serializer)
            }
            Self::Auto => {
                CreateImageRequestModeration::Auto(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` for less restrictive filtering or `auto` (default value)."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestModeration {
    #[doc = "low"]
    Low,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestBackground {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundTransparent {
            #[default]
            #[serde(rename = "transparent")]
            Transparent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundOpaque {
            #[default]
            #[serde(rename = "opaque")]
            Opaque,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageRequestBackground {
            Transparent(#[allow(dead_code)] CreateImageRequestBackgroundTransparent),
            Opaque(#[allow(dead_code)] CreateImageRequestBackgroundOpaque),
            Auto(#[allow(dead_code)] CreateImageRequestBackgroundAuto),
        }
        Ok(
            match CreateImageRequestBackground::deserialize(deserializer)? {
                CreateImageRequestBackground::Transparent(_) => Self::Transparent,
                CreateImageRequestBackground::Opaque(_) => Self::Opaque,
                CreateImageRequestBackground::Auto(_) => Self::Auto,
            },
        )
    }
}
impl serde::Serialize for CreateImageRequestBackground {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundTransparent {
            #[default]
            #[serde(rename = "transparent")]
            Transparent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundOpaque {
            #[default]
            #[serde(rename = "opaque")]
            Opaque,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestBackgroundAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageRequestBackground<'a> {
            Transparent(#[allow(dead_code)] &'a CreateImageRequestBackgroundTransparent),
            Opaque(#[allow(dead_code)] &'a CreateImageRequestBackgroundOpaque),
            Auto(#[allow(dead_code)] &'a CreateImageRequestBackgroundAuto),
        }
        match self {
            Self::Transparent => {
                CreateImageRequestBackground::Transparent(&Default::default()).serialize(serializer)
            }
            Self::Opaque => {
                CreateImageRequestBackground::Opaque(&Default::default()).serialize(serializer)
            }
            Self::Auto => {
                CreateImageRequestBackground::Auto(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestBackground {
    #[doc = "transparent"]
    Transparent,
    #[doc = "opaque"]
    Opaque,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequestStyle {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestStyleVivid {
            #[default]
            #[serde(rename = "vivid")]
            Vivid,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestStyleNatural {
            #[default]
            #[serde(rename = "natural")]
            Natural,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageRequestStyle {
            Vivid(#[allow(dead_code)] CreateImageRequestStyleVivid),
            Natural(#[allow(dead_code)] CreateImageRequestStyleNatural),
        }
        Ok(match CreateImageRequestStyle::deserialize(deserializer)? {
            CreateImageRequestStyle::Vivid(_) => Self::Vivid,
            CreateImageRequestStyle::Natural(_) => Self::Natural,
        })
    }
}
impl serde::Serialize for CreateImageRequestStyle {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestStyleVivid {
            #[default]
            #[serde(rename = "vivid")]
            Vivid,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageRequestStyleNatural {
            #[default]
            #[serde(rename = "natural")]
            Natural,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageRequestStyle<'a> {
            Vivid(#[allow(dead_code)] &'a CreateImageRequestStyleVivid),
            Natural(#[allow(dead_code)] &'a CreateImageRequestStyleNatural),
        }
        match self {
            Self::Vivid => {
                CreateImageRequestStyle::Vivid(&Default::default()).serialize(serializer)
            }
            Self::Natural => {
                CreateImageRequestStyle::Natural(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageRequestStyle {
    #[doc = "vivid"]
    #[default]
    Vivid,
    #[doc = "natural"]
    Natural,
}
impl<'de> serde::Deserialize<'de> for CreateImageRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateImageRequest {
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "quality")]
            #[allow(dead_code)]
            quality: Option<CreateImageRequestQuality>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateImageRequestResponseFormat>,
            #[serde(rename = "output_format")]
            #[allow(dead_code)]
            output_format: Option<CreateImageRequestOutputFormat>,
            #[serde(rename = "output_compression")]
            #[allow(dead_code)]
            output_compression: Option<u64>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<CreateImageRequestSize>,
            #[serde(rename = "moderation")]
            #[allow(dead_code)]
            moderation: Option<CreateImageRequestModeration>,
            #[serde(rename = "background")]
            #[allow(dead_code)]
            background: Option<CreateImageRequestBackground>,
            #[serde(rename = "style")]
            #[allow(dead_code)]
            style: Option<CreateImageRequestStyle>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let CreateImageRequest {
            prompt,
            model,
            n,
            quality,
            response_format,
            output_format,
            output_compression,
            size,
            moderation,
            background,
            style,
            user,
            ..
        } = CreateImageRequest::deserialize(deserializer)?;
        Ok(Self {
            prompt,
            model,
            n,
            quality,
            response_format,
            output_format,
            output_compression,
            size,
            moderation,
            background,
            style,
            user,
        })
    }
}
impl serde::Serialize for CreateImageRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateImageRequest<'a> {
            #[serde(rename = "prompt")]
            prompt: &'a String,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            quality: &'a Option<CreateImageRequestQuality>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateImageRequestResponseFormat>,
            #[serde(rename = "output_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_format: &'a Option<CreateImageRequestOutputFormat>,
            #[serde(rename = "output_compression")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_compression: &'a Option<u64>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<CreateImageRequestSize>,
            #[serde(rename = "moderation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            moderation: &'a Option<CreateImageRequestModeration>,
            #[serde(rename = "background")]
            #[serde(skip_serializing_if = "Option::is_none")]
            background: &'a Option<CreateImageRequestBackground>,
            #[serde(rename = "style")]
            #[serde(skip_serializing_if = "Option::is_none")]
            style: &'a Option<CreateImageRequestStyle>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let Self {
            prompt,
            model,
            n,
            quality,
            response_format,
            output_format,
            output_compression,
            size,
            moderation,
            background,
            style,
            user,
        } = self;
        CreateImageRequest {
            prompt,
            model,
            n,
            quality,
            response_format,
            output_format,
            output_compression,
            size,
            moderation,
            background,
            style,
            user,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateImageRequest {
    #[doc = "A text description of the desired image(s). The maximum length is 32000 characters for `gpt-image-1`, 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`."]
    pub prompt: String,
    #[doc = "The model to use for image generation. One of `dall-e-2`, `dall-e-3`, or `gpt-image-1`. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported."]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "The quality of the image that will be generated. \n\n- `auto` (default value) will automatically select the best quality for the given model.\n- `high`, `medium` and `low` are supported for `gpt-image-1`.\n- `hd` and `standard` are supported for `dall-e-3`.\n- `standard` is the only option for `dall-e-2`.\n"]
    #[builder(default)]
    pub quality: Option<CreateImageRequestQuality>,
    #[doc = "The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."]
    #[builder(default)]
    pub response_format: Option<CreateImageRequestResponseFormat>,
    #[doc = "The format in which the generated images are returned. This parameter is only supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`."]
    #[builder(default)]
    pub output_format: Option<CreateImageRequestOutputFormat>,
    #[doc = "The compression level (0-100%) for the generated images. This parameter is only supported for `gpt-image-1` with the `webp` or `jpeg` output formats, and defaults to 100."]
    #[builder(default)]
    pub output_compression: Option<u64>,
    #[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`."]
    #[builder(default)]
    pub size: Option<CreateImageRequestSize>,
    #[doc = "Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` for less restrictive filtering or `auto` (default value)."]
    #[builder(default)]
    pub moderation: Option<CreateImageRequestModeration>,
    #[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
    #[builder(default)]
    pub background: Option<CreateImageRequestBackground>,
    #[doc = "The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images."]
    #[builder(default)]
    pub style: Option<CreateImageRequestStyle>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateImageVariationRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageVariationRequestResponseFormat {
            Url(#[allow(dead_code)] CreateImageVariationRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] CreateImageVariationRequestResponseFormatB64Json),
        }
        Ok(
            match CreateImageVariationRequestResponseFormat::deserialize(deserializer)? {
                CreateImageVariationRequestResponseFormat::Url(_) => Self::Url,
                CreateImageVariationRequestResponseFormat::B64Json(_) => Self::B64Json,
            },
        )
    }
}
impl serde::Serialize for CreateImageVariationRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestResponseFormatUrl {
            #[default]
            #[serde(rename = "url")]
            Url,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestResponseFormatB64Json {
            #[default]
            #[serde(rename = "b64_json")]
            B64Json,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageVariationRequestResponseFormat<'a> {
            Url(#[allow(dead_code)] &'a CreateImageVariationRequestResponseFormatUrl),
            B64Json(#[allow(dead_code)] &'a CreateImageVariationRequestResponseFormatB64Json),
        }
        match self {
            Self::Url => CreateImageVariationRequestResponseFormat::Url(&Default::default())
                .serialize(serializer),
            Self::B64Json => {
                CreateImageVariationRequestResponseFormat::B64Json(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageVariationRequestResponseFormat {
    #[doc = "url"]
    #[default]
    Url,
    #[doc = "b64_json"]
    B64Json,
}
impl<'de> serde::Deserialize<'de> for CreateImageVariationRequestSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateImageVariationRequestSize {
            _256x256(#[allow(dead_code)] CreateImageVariationRequestSize256x256),
            _512x512(#[allow(dead_code)] CreateImageVariationRequestSize512x512),
            _1024x1024(#[allow(dead_code)] CreateImageVariationRequestSize1024x1024),
        }
        Ok(
            match CreateImageVariationRequestSize::deserialize(deserializer)? {
                CreateImageVariationRequestSize::_256x256(_) => Self::_256x256,
                CreateImageVariationRequestSize::_512x512(_) => Self::_512x512,
                CreateImageVariationRequestSize::_1024x1024(_) => Self::_1024x1024,
            },
        )
    }
}
impl serde::Serialize for CreateImageVariationRequestSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize256x256 {
            #[default]
            #[serde(rename = "256x256")]
            _256x256,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize512x512 {
            #[default]
            #[serde(rename = "512x512")]
            _512x512,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateImageVariationRequestSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateImageVariationRequestSize<'a> {
            _256x256(#[allow(dead_code)] &'a CreateImageVariationRequestSize256x256),
            _512x512(#[allow(dead_code)] &'a CreateImageVariationRequestSize512x512),
            _1024x1024(#[allow(dead_code)] &'a CreateImageVariationRequestSize1024x1024),
        }
        match self {
            Self::_256x256 => {
                CreateImageVariationRequestSize::_256x256(&Default::default()).serialize(serializer)
            }
            Self::_512x512 => {
                CreateImageVariationRequestSize::_512x512(&Default::default()).serialize(serializer)
            }
            Self::_1024x1024 => CreateImageVariationRequestSize::_1024x1024(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateImageVariationRequestSize {
    #[doc = "256x256"]
    _256x256,
    #[doc = "512x512"]
    _512x512,
    #[doc = "1024x1024"]
    #[default]
    _1024x1024,
}
impl<'de> serde::Deserialize<'de> for CreateImageVariationRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateImageVariationRequest {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "image")]
            #[allow(dead_code)]
            image: Vec<u8>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "n")]
            #[allow(dead_code)]
            n: Option<u64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateImageVariationRequestResponseFormat>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<CreateImageVariationRequestSize>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let CreateImageVariationRequest {
            image,
            model,
            n,
            response_format,
            size,
            user,
            ..
        } = CreateImageVariationRequest::deserialize(deserializer)?;
        Ok(Self {
            image,
            model,
            n,
            response_format,
            size,
            user,
        })
    }
}
impl serde::Serialize for CreateImageVariationRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateImageVariationRequest<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "image")]
            image: &'a Vec<u8>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "n")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n: &'a Option<u64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateImageVariationRequestResponseFormat>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<CreateImageVariationRequestSize>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let Self {
            image,
            model,
            n,
            response_format,
            size,
            user,
        } = self;
        CreateImageVariationRequest {
            image,
            model,
            n,
            response_format,
            size,
            user,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateImageVariationRequest {
    #[doc = "The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square."]
    pub image: Vec<u8>,
    #[doc = "The model to use for image generation. Only `dall-e-2` is supported at this time."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The number of images to generate. Must be between 1 and 10."]
    #[builder(default)]
    pub n: Option<u64>,
    #[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."]
    #[builder(default)]
    pub response_format: Option<CreateImageVariationRequestResponseFormat>,
    #[doc = "The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."]
    #[builder(default)]
    pub size: Option<CreateImageVariationRequestSize>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateMessageRequestRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateMessageRequestRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateMessageRequestRole {
            User(#[allow(dead_code)] CreateMessageRequestRoleUser),
            Assistant(#[allow(dead_code)] CreateMessageRequestRoleAssistant),
        }
        Ok(match CreateMessageRequestRole::deserialize(deserializer)? {
            CreateMessageRequestRole::User(_) => Self::User,
            CreateMessageRequestRole::Assistant(_) => Self::Assistant,
        })
    }
}
impl serde::Serialize for CreateMessageRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateMessageRequestRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateMessageRequestRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateMessageRequestRole<'a> {
            User(#[allow(dead_code)] &'a CreateMessageRequestRoleUser),
            Assistant(#[allow(dead_code)] &'a CreateMessageRequestRoleAssistant),
        }
        match self {
            Self::User => CreateMessageRequestRole::User(&Default::default()).serialize(serializer),
            Self::Assistant => {
                CreateMessageRequestRole::Assistant(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The role of the entity that is creating the message. Allowed values include:\n- `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.\n- `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateMessageRequestRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestContentArray {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateMessageRequestContentArray {
            ImageFile(#[allow(dead_code)] MessageContentImageFileObject),
            ImageUrl(#[allow(dead_code)] MessageContentImageUrlObject),
            Text(#[allow(dead_code)] MessageRequestContentTextObject),
        }
        Ok(
            match CreateMessageRequestContentArray::deserialize(deserializer)? {
                CreateMessageRequestContentArray::ImageFile(_v) => Self::ImageFile(_v),
                CreateMessageRequestContentArray::ImageUrl(_v) => Self::ImageUrl(_v),
                CreateMessageRequestContentArray::Text(_v) => Self::Text(_v),
            },
        )
    }
}
impl serde::Serialize for CreateMessageRequestContentArray {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateMessageRequestContentArray<'a> {
            ImageFile(#[allow(dead_code)] &'a MessageContentImageFileObject),
            ImageUrl(#[allow(dead_code)] &'a MessageContentImageUrlObject),
            Text(#[allow(dead_code)] &'a MessageRequestContentTextObject),
        }
        match self {
            Self::ImageFile(_v) => {
                CreateMessageRequestContentArray::ImageFile(_v).serialize(serializer)
            }
            Self::ImageUrl(_v) => {
                CreateMessageRequestContentArray::ImageUrl(_v).serialize(serializer)
            }
            Self::Text(_v) => CreateMessageRequestContentArray::Text(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateMessageRequestContentArray {
    ImageFile(MessageContentImageFileObject),
    ImageUrl(MessageContentImageUrlObject),
    Text(MessageRequestContentTextObject),
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateMessageRequestContent {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<CreateMessageRequestContentArray>),
        }
        Ok(
            match CreateMessageRequestContent::deserialize(deserializer)? {
                CreateMessageRequestContent::String(_v) => Self::String(_v),
                CreateMessageRequestContent::Array(_v) => Self::Array(_v),
            },
        )
    }
}
impl serde::Serialize for CreateMessageRequestContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateMessageRequestContent<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<CreateMessageRequestContentArray>),
        }
        match self {
            Self::String(_v) => CreateMessageRequestContent::String(_v).serialize(serializer),
            Self::Array(_v) => CreateMessageRequestContent::Array(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateMessageRequestContent {
    #[doc = "The text contents of the message."]
    String(String),
    #[doc = "An array of content parts with a defined type, each can be of type `text` or images can be passed with `image_url` or `image_file`. Image types are only supported on [Vision-compatible models](https://platform.openai.com/docs/models)."]
    Array(Vec<CreateMessageRequestContentArray>),
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestAttachmentsTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateMessageRequestAttachmentsTool {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearchTypeOnly),
        }
        Ok(
            match CreateMessageRequestAttachmentsTool::deserialize(deserializer)? {
                CreateMessageRequestAttachmentsTool::CodeInterpreter(_v) => {
                    Self::CodeInterpreter(_v)
                }
                CreateMessageRequestAttachmentsTool::FileSearch(_v) => Self::FileSearch(_v),
            },
        )
    }
}
impl serde::Serialize for CreateMessageRequestAttachmentsTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateMessageRequestAttachmentsTool<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearchTypeOnly),
        }
        match self {
            Self::CodeInterpreter(_v) => {
                CreateMessageRequestAttachmentsTool::CodeInterpreter(_v).serialize(serializer)
            }
            Self::FileSearch(_v) => {
                CreateMessageRequestAttachmentsTool::FileSearch(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateMessageRequestAttachmentsTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearchTypeOnly),
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequestAttachments {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateMessageRequestAttachments {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Vec<CreateMessageRequestAttachmentsTool>,
        }
        let CreateMessageRequestAttachments { file_id, tools, .. } =
            CreateMessageRequestAttachments::deserialize(deserializer)?;
        Ok(Self { file_id, tools })
    }
}
impl serde::Serialize for CreateMessageRequestAttachments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateMessageRequestAttachments<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "tools")]
            tools: &'a Vec<CreateMessageRequestAttachmentsTool>,
        }
        let Self { file_id, tools } = self;
        CreateMessageRequestAttachments { file_id, tools }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateMessageRequestAttachments {
    #[doc = "The ID of the file to attach to the message."]
    pub file_id: String,
    #[doc = "The tools to add this file to."]
    pub tools: Vec<CreateMessageRequestAttachmentsTool>,
}
impl<'de> serde::Deserialize<'de> for CreateMessageRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateMessageRequest {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: CreateMessageRequestRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: CreateMessageRequestContent,
            #[serde(rename = "attachments")]
            #[allow(dead_code)]
            attachments: Option<Vec<CreateMessageRequestAttachments>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let CreateMessageRequest {
            role,
            content,
            attachments,
            metadata,
            ..
        } = CreateMessageRequest::deserialize(deserializer)?;
        Ok(Self {
            role,
            content,
            attachments,
            metadata,
        })
    }
}
impl serde::Serialize for CreateMessageRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateMessageRequest<'a> {
            #[serde(rename = "role")]
            role: &'a CreateMessageRequestRole,
            #[serde(rename = "content")]
            content: &'a CreateMessageRequestContent,
            #[serde(rename = "attachments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attachments: &'a Option<Vec<CreateMessageRequestAttachments>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            role,
            content,
            attachments,
            metadata,
        } = self;
        CreateMessageRequest {
            role,
            content,
            attachments,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateMessageRequest {
    #[doc = "The role of the entity that is creating the message. Allowed values include:\n- `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.\n- `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.\n"]
    pub role: CreateMessageRequestRole,
    pub content: CreateMessageRequestContent,
    #[doc = "A list of files attached to the message, and the tools they should be added to."]
    #[builder(default)]
    pub attachments: Option<Vec<CreateMessageRequestAttachments>>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
pub type CreateModelResponseProperties = ModelResponseProperties;
impl<'de> serde::Deserialize<'de> for CreateModerationRequestInput2 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateModerationRequestInput2 {
            ImageUrl(#[allow(dead_code)] ModerationImageUrlInput),
            Text(#[allow(dead_code)] ModerationTextInput),
        }
        Ok(
            match CreateModerationRequestInput2::deserialize(deserializer)? {
                CreateModerationRequestInput2::ImageUrl(_v) => Self::ImageUrl(_v),
                CreateModerationRequestInput2::Text(_v) => Self::Text(_v),
            },
        )
    }
}
impl serde::Serialize for CreateModerationRequestInput2 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateModerationRequestInput2<'a> {
            ImageUrl(#[allow(dead_code)] &'a ModerationImageUrlInput),
            Text(#[allow(dead_code)] &'a ModerationTextInput),
        }
        match self {
            Self::ImageUrl(_v) => CreateModerationRequestInput2::ImageUrl(_v).serialize(serializer),
            Self::Text(_v) => CreateModerationRequestInput2::Text(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationRequestInput2 {
    ImageUrl(ModerationImageUrlInput),
    Text(ModerationTextInput),
}
impl<'de> serde::Deserialize<'de> for CreateModerationRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateModerationRequestInput {
            String(#[allow(dead_code)] String),
            ArrayOfString(#[allow(dead_code)] Vec<String>),
            _2(#[allow(dead_code)] Vec<CreateModerationRequestInput2>),
        }
        Ok(
            match CreateModerationRequestInput::deserialize(deserializer)? {
                CreateModerationRequestInput::String(_v) => Self::String(_v),
                CreateModerationRequestInput::ArrayOfString(_v) => Self::ArrayOfString(_v),
                CreateModerationRequestInput::_2(_v) => Self::_2(_v),
            },
        )
    }
}
impl serde::Serialize for CreateModerationRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateModerationRequestInput<'a> {
            String(#[allow(dead_code)] &'a String),
            ArrayOfString(#[allow(dead_code)] &'a Vec<String>),
            _2(#[allow(dead_code)] &'a Vec<CreateModerationRequestInput2>),
        }
        match self {
            Self::String(_v) => CreateModerationRequestInput::String(_v).serialize(serializer),
            Self::ArrayOfString(_v) => {
                CreateModerationRequestInput::ArrayOfString(_v).serialize(serializer)
            }
            Self::_2(_v) => CreateModerationRequestInput::_2(_v).serialize(serializer),
        }
    }
}
#[doc = "Input (or inputs) to classify. Can be a single string, an array of strings, or\nan array of multi-modal input objects similar to other models.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationRequestInput {
    #[doc = "A string of text to classify for moderation."]
    String(String),
    #[doc = "An array of strings to classify for moderation."]
    ArrayOfString(Vec<String>),
    #[doc = "An array of multi-modal inputs to the moderation model."]
    _2(Vec<CreateModerationRequestInput2>),
}
impl<'de> serde::Deserialize<'de> for CreateModerationRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateModerationRequest {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: CreateModerationRequestInput,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let CreateModerationRequest { input, model, .. } =
            CreateModerationRequest::deserialize(deserializer)?;
        Ok(Self { input, model })
    }
}
impl serde::Serialize for CreateModerationRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateModerationRequest<'a> {
            #[serde(rename = "input")]
            input: &'a CreateModerationRequestInput,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self { input, model } = self;
        CreateModerationRequest { input, model }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationRequest {
    #[doc = "Input (or inputs) to classify. Can be a single string, an array of strings, or\nan array of multi-modal input objects similar to other models.\n"]
    pub input: CreateModerationRequestInput,
    #[doc = "The content moderation model you would like to use. Learn more in\n[the moderation guide](https://platform.openai.com/docs/guides/moderation), and learn about\navailable models [here](https://platform.openai.com/docs/models#moderation).\n"]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponseResultCategories {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateModerationResponseResultCategories {
            #[serde(rename = "hate")]
            #[allow(dead_code)]
            hate: bool,
            #[serde(rename = "hate/threatening")]
            #[allow(dead_code)]
            hate_threatening: bool,
            #[serde(rename = "harassment")]
            #[allow(dead_code)]
            harassment: bool,
            #[serde(rename = "harassment/threatening")]
            #[allow(dead_code)]
            harassment_threatening: bool,
            #[serde(rename = "illicit")]
            #[allow(dead_code)]
            illicit: Option<bool>,
            #[serde(rename = "illicit/violent")]
            #[allow(dead_code)]
            illicit_violent: Option<bool>,
            #[serde(rename = "self-harm")]
            #[allow(dead_code)]
            self_harm: bool,
            #[serde(rename = "self-harm/intent")]
            #[allow(dead_code)]
            self_harm_intent: bool,
            #[serde(rename = "self-harm/instructions")]
            #[allow(dead_code)]
            self_harm_instructions: bool,
            #[serde(rename = "sexual")]
            #[allow(dead_code)]
            sexual: bool,
            #[serde(rename = "sexual/minors")]
            #[allow(dead_code)]
            sexual_minors: bool,
            #[serde(rename = "violence")]
            #[allow(dead_code)]
            violence: bool,
            #[serde(rename = "violence/graphic")]
            #[allow(dead_code)]
            violence_graphic: bool,
        }
        let CreateModerationResponseResultCategories {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
            ..
        } = CreateModerationResponseResultCategories::deserialize(deserializer)?;
        Ok(Self {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategories {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateModerationResponseResultCategories<'a> {
            #[serde(rename = "hate")]
            hate: &'a bool,
            #[serde(rename = "hate/threatening")]
            hate_threatening: &'a bool,
            #[serde(rename = "harassment")]
            harassment: &'a bool,
            #[serde(rename = "harassment/threatening")]
            harassment_threatening: &'a bool,
            #[serde(rename = "illicit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            illicit: &'a Option<bool>,
            #[serde(rename = "illicit/violent")]
            #[serde(skip_serializing_if = "Option::is_none")]
            illicit_violent: &'a Option<bool>,
            #[serde(rename = "self-harm")]
            self_harm: &'a bool,
            #[serde(rename = "self-harm/intent")]
            self_harm_intent: &'a bool,
            #[serde(rename = "self-harm/instructions")]
            self_harm_instructions: &'a bool,
            #[serde(rename = "sexual")]
            sexual: &'a bool,
            #[serde(rename = "sexual/minors")]
            sexual_minors: &'a bool,
            #[serde(rename = "violence")]
            violence: &'a bool,
            #[serde(rename = "violence/graphic")]
            violence_graphic: &'a bool,
        }
        let Self {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        } = self;
        CreateModerationResponseResultCategories {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of the categories, and whether they are flagged or not."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponseResultCategories {
    #[doc = "Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment."]
    pub hate: bool,
    #[doc = "Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste."]
    pub hate_threatening: bool,
    #[doc = "Content that expresses, incites, or promotes harassing language towards any target."]
    pub harassment: bool,
    #[doc = "Harassment content that also includes violence or serious harm towards any target."]
    pub harassment_threatening: bool,
    #[doc = "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \"how to shoplift\" would fit this category."]
    #[builder(default)]
    pub illicit: Option<bool>,
    #[doc = "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon."]
    #[builder(default)]
    pub illicit_violent: Option<bool>,
    #[doc = "Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders."]
    pub self_harm: bool,
    #[doc = "Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders."]
    pub self_harm_intent: bool,
    #[doc = "Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts."]
    pub self_harm_instructions: bool,
    #[doc = "Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness)."]
    pub sexual: bool,
    #[doc = "Sexual content that includes an individual who is under 18 years old."]
    pub sexual_minors: bool,
    #[doc = "Content that depicts death, violence, or physical injury."]
    pub violence: bool,
    #[doc = "Content that depicts death, violence, or physical injury in graphic detail."]
    pub violence_graphic: bool,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponseResultCategoryScores {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateModerationResponseResultCategoryScores {
            #[serde(rename = "hate")]
            #[allow(dead_code)]
            hate: f64,
            #[serde(rename = "hate/threatening")]
            #[allow(dead_code)]
            hate_threatening: f64,
            #[serde(rename = "harassment")]
            #[allow(dead_code)]
            harassment: f64,
            #[serde(rename = "harassment/threatening")]
            #[allow(dead_code)]
            harassment_threatening: f64,
            #[serde(rename = "illicit")]
            #[allow(dead_code)]
            illicit: f64,
            #[serde(rename = "illicit/violent")]
            #[allow(dead_code)]
            illicit_violent: f64,
            #[serde(rename = "self-harm")]
            #[allow(dead_code)]
            self_harm: f64,
            #[serde(rename = "self-harm/intent")]
            #[allow(dead_code)]
            self_harm_intent: f64,
            #[serde(rename = "self-harm/instructions")]
            #[allow(dead_code)]
            self_harm_instructions: f64,
            #[serde(rename = "sexual")]
            #[allow(dead_code)]
            sexual: f64,
            #[serde(rename = "sexual/minors")]
            #[allow(dead_code)]
            sexual_minors: f64,
            #[serde(rename = "violence")]
            #[allow(dead_code)]
            violence: f64,
            #[serde(rename = "violence/graphic")]
            #[allow(dead_code)]
            violence_graphic: f64,
        }
        let CreateModerationResponseResultCategoryScores {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
            ..
        } = CreateModerationResponseResultCategoryScores::deserialize(deserializer)?;
        Ok(Self {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryScores {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateModerationResponseResultCategoryScores<'a> {
            #[serde(rename = "hate")]
            hate: &'a f64,
            #[serde(rename = "hate/threatening")]
            hate_threatening: &'a f64,
            #[serde(rename = "harassment")]
            harassment: &'a f64,
            #[serde(rename = "harassment/threatening")]
            harassment_threatening: &'a f64,
            #[serde(rename = "illicit")]
            illicit: &'a f64,
            #[serde(rename = "illicit/violent")]
            illicit_violent: &'a f64,
            #[serde(rename = "self-harm")]
            self_harm: &'a f64,
            #[serde(rename = "self-harm/intent")]
            self_harm_intent: &'a f64,
            #[serde(rename = "self-harm/instructions")]
            self_harm_instructions: &'a f64,
            #[serde(rename = "sexual")]
            sexual: &'a f64,
            #[serde(rename = "sexual/minors")]
            sexual_minors: &'a f64,
            #[serde(rename = "violence")]
            violence: &'a f64,
            #[serde(rename = "violence/graphic")]
            violence_graphic: &'a f64,
        }
        let Self {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        } = self;
        CreateModerationResponseResultCategoryScores {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of the categories along with their scores as predicted by model."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponseResultCategoryScores {
    #[doc = "The score for the category 'hate'."]
    pub hate: f64,
    #[doc = "The score for the category 'hate/threatening'."]
    pub hate_threatening: f64,
    #[doc = "The score for the category 'harassment'."]
    pub harassment: f64,
    #[doc = "The score for the category 'harassment/threatening'."]
    pub harassment_threatening: f64,
    #[doc = "The score for the category 'illicit'."]
    pub illicit: f64,
    #[doc = "The score for the category 'illicit/violent'."]
    pub illicit_violent: f64,
    #[doc = "The score for the category 'self-harm'."]
    pub self_harm: f64,
    #[doc = "The score for the category 'self-harm/intent'."]
    pub self_harm_intent: f64,
    #[doc = "The score for the category 'self-harm/instructions'."]
    pub self_harm_instructions: f64,
    #[doc = "The score for the category 'sexual'."]
    pub sexual: f64,
    #[doc = "The score for the category 'sexual/minors'."]
    pub sexual_minors: f64,
    #[doc = "The score for the category 'violence'."]
    pub violence: f64,
    #[doc = "The score for the category 'violence/graphic'."]
    pub violence_graphic: f64,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesHate {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesHateThreatening {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesHarassment {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesHarassmentThreatening {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesIllicit {
    #[default]
    #[serde(rename = "text")]
    Text,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesIllicitViolent {
    #[default]
    #[serde(rename = "text")]
    Text,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmImage,
            ),
        }
        Ok(
            match CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm::deserialize(
                deserializer,
            )? {
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm::Text(_) => {
                    Self::Text
                }
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm::Image(_) => {
                    Self::Image
                }
            },
        )
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmImage,
            ),
        }
        match self {
            Self::Text => CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm::Text(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Image => CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm::Image(
                &Default::default(),
            )
            .serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentImage,
            ),
        }
        Ok (match CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent :: deserialize (deserializer) ? { CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent :: Text (_) => Self :: Text , CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent :: Image (_) => Self :: Image })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntentImage,
            ),
        }
        match self {
            Self::Text => {
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent::Text(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::Image => {
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent::Image(
                    &Default::default(),
                )
                .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsImage,
            ),
        }
        Ok (match CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions :: deserialize (deserializer) ? { CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions :: Text (_) => Self :: Text , CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions :: Image (_) => Self :: Image })
    }
}
impl serde::Serialize
    for CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions<'a> {
            Text (# [allow (dead_code)] & 'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsText) , Image (# [allow (dead_code)] & 'a CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructionsImage) }
        match self {
            Self::Text => {
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions::Text(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::Image => {
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions::Image(
                    &Default::default(),
                )
                .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesSexual
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexualText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexualImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexual {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSexualText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesSexualImage,
            ),
        }
        Ok(
            match CreateModerationResponseResultCategoryAppliedInputTypesSexual::deserialize(
                deserializer,
            )? {
                CreateModerationResponseResultCategoryAppliedInputTypesSexual::Text(_) => {
                    Self::Text
                }
                CreateModerationResponseResultCategoryAppliedInputTypesSexual::Image(_) => {
                    Self::Image
                }
            },
        )
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesSexual {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexualText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexualImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesSexual<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSexualText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesSexualImage,
            ),
        }
        match self {
            Self::Text => CreateModerationResponseResultCategoryAppliedInputTypesSexual::Text(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Image => CreateModerationResponseResultCategoryAppliedInputTypesSexual::Image(
                &Default::default(),
            )
            .serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSexual {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesSexualMinors {
    #[default]
    #[serde(rename = "text")]
    Text,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesViolence
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolence {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceImage,
            ),
        }
        Ok(
            match CreateModerationResponseResultCategoryAppliedInputTypesViolence::deserialize(
                deserializer,
            )? {
                CreateModerationResponseResultCategoryAppliedInputTypesViolence::Text(_) => {
                    Self::Text
                }
                CreateModerationResponseResultCategoryAppliedInputTypesViolence::Image(_) => {
                    Self::Image
                }
            },
        )
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesViolence {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolence<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesViolenceText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesViolenceImage,
            ),
        }
        match self {
            Self::Text => CreateModerationResponseResultCategoryAppliedInputTypesViolence::Text(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Image => CreateModerationResponseResultCategoryAppliedInputTypesViolence::Image(
                &Default::default(),
            )
            .serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesViolence {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de>
    for CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic {
            Text(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicText,
            ),
            Image(
                #[allow(dead_code)]
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicImage,
            ),
        }
        Ok (match CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic :: deserialize (deserializer) ? { CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic :: Text (_) => Self :: Text , CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic :: Image (_) => Self :: Image })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicImage {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic<'a> {
            Text(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicText,
            ),
            Image(
                #[allow(dead_code)]
                &'a CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphicImage,
            ),
        }
        match self {
            Self::Text => {
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic::Text(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::Image => {
                CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic::Image(
                    &Default::default(),
                )
                .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic {
    #[doc = "text"]
    Text,
    #[doc = "image"]
    Image,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponseResultCategoryAppliedInputTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateModerationResponseResultCategoryAppliedInputTypes {
            #[serde(rename = "hate")]
            #[allow(dead_code)]
            hate: Vec<CreateModerationResponseResultCategoryAppliedInputTypesHate>,
            #[serde(rename = "hate/threatening")]
            #[allow(dead_code)]
            hate_threatening:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesHateThreatening>,
            #[serde(rename = "harassment")]
            #[allow(dead_code)]
            harassment: Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassment>,
            #[serde(rename = "harassment/threatening")]
            #[allow(dead_code)]
            harassment_threatening:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassmentThreatening>,
            #[serde(rename = "illicit")]
            #[allow(dead_code)]
            illicit: Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicit>,
            #[serde(rename = "illicit/violent")]
            #[allow(dead_code)]
            illicit_violent:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicitViolent>,
            #[serde(rename = "self-harm")]
            #[allow(dead_code)]
            self_harm: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm>,
            #[serde(rename = "self-harm/intent")]
            #[allow(dead_code)]
            self_harm_intent:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent>,
            #[serde(rename = "self-harm/instructions")]
            #[allow(dead_code)]
            self_harm_instructions:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions>,
            #[serde(rename = "sexual")]
            #[allow(dead_code)]
            sexual: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexual>,
            #[serde(rename = "sexual/minors")]
            #[allow(dead_code)]
            sexual_minors: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexualMinors>,
            #[serde(rename = "violence")]
            #[allow(dead_code)]
            violence: Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolence>,
            #[serde(rename = "violence/graphic")]
            #[allow(dead_code)]
            violence_graphic:
                Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic>,
        }
        let CreateModerationResponseResultCategoryAppliedInputTypes {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
            ..
        } = CreateModerationResponseResultCategoryAppliedInputTypes::deserialize(deserializer)?;
        Ok(Self {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResultCategoryAppliedInputTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateModerationResponseResultCategoryAppliedInputTypes<'a> {
            #[serde(rename = "hate")]
            hate: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesHate>,
            #[serde(rename = "hate/threatening")]
            hate_threatening:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesHateThreatening>,
            #[serde(rename = "harassment")]
            harassment: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassment>,
            #[serde(rename = "harassment/threatening")]
            harassment_threatening: &'a Vec<
                CreateModerationResponseResultCategoryAppliedInputTypesHarassmentThreatening,
            >,
            #[serde(rename = "illicit")]
            illicit: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicit>,
            #[serde(rename = "illicit/violent")]
            illicit_violent:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicitViolent>,
            #[serde(rename = "self-harm")]
            self_harm: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm>,
            #[serde(rename = "self-harm/intent")]
            self_harm_intent:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent>,
            #[serde(rename = "self-harm/instructions")]
            self_harm_instructions: &'a Vec<
                CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions,
            >,
            #[serde(rename = "sexual")]
            sexual: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexual>,
            #[serde(rename = "sexual/minors")]
            sexual_minors:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexualMinors>,
            #[serde(rename = "violence")]
            violence: &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolence>,
            #[serde(rename = "violence/graphic")]
            violence_graphic:
                &'a Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic>,
        }
        let Self {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        } = self;
        CreateModerationResponseResultCategoryAppliedInputTypes {
            hate,
            hate_threatening,
            harassment,
            harassment_threatening,
            illicit,
            illicit_violent,
            self_harm,
            self_harm_intent,
            self_harm_instructions,
            sexual,
            sexual_minors,
            violence,
            violence_graphic,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of the categories along with the input type(s) that the score applies to."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponseResultCategoryAppliedInputTypes {
    #[doc = "The applied input type(s) for the category 'hate'."]
    pub hate: Vec<CreateModerationResponseResultCategoryAppliedInputTypesHate>,
    #[doc = "The applied input type(s) for the category 'hate/threatening'."]
    pub hate_threatening:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesHateThreatening>,
    #[doc = "The applied input type(s) for the category 'harassment'."]
    pub harassment: Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassment>,
    #[doc = "The applied input type(s) for the category 'harassment/threatening'."]
    pub harassment_threatening:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesHarassmentThreatening>,
    #[doc = "The applied input type(s) for the category 'illicit'."]
    pub illicit: Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicit>,
    #[doc = "The applied input type(s) for the category 'illicit/violent'."]
    pub illicit_violent: Vec<CreateModerationResponseResultCategoryAppliedInputTypesIllicitViolent>,
    #[doc = "The applied input type(s) for the category 'self-harm'."]
    pub self_harm: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarm>,
    #[doc = "The applied input type(s) for the category 'self-harm/intent'."]
    pub self_harm_intent:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmIntent>,
    #[doc = "The applied input type(s) for the category 'self-harm/instructions'."]
    pub self_harm_instructions:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesSelfHarmInstructions>,
    #[doc = "The applied input type(s) for the category 'sexual'."]
    pub sexual: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexual>,
    #[doc = "The applied input type(s) for the category 'sexual/minors'."]
    pub sexual_minors: Vec<CreateModerationResponseResultCategoryAppliedInputTypesSexualMinors>,
    #[doc = "The applied input type(s) for the category 'violence'."]
    pub violence: Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolence>,
    #[doc = "The applied input type(s) for the category 'violence/graphic'."]
    pub violence_graphic:
        Vec<CreateModerationResponseResultCategoryAppliedInputTypesViolenceGraphic>,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponseResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateModerationResponseResult {
            #[serde(rename = "flagged")]
            #[allow(dead_code)]
            flagged: bool,
            #[serde(rename = "categories")]
            #[allow(dead_code)]
            categories: CreateModerationResponseResultCategories,
            #[serde(rename = "category_scores")]
            #[allow(dead_code)]
            category_scores: CreateModerationResponseResultCategoryScores,
            #[serde(rename = "category_applied_input_types")]
            #[allow(dead_code)]
            category_applied_input_types: CreateModerationResponseResultCategoryAppliedInputTypes,
        }
        let CreateModerationResponseResult {
            flagged,
            categories,
            category_scores,
            category_applied_input_types,
            ..
        } = CreateModerationResponseResult::deserialize(deserializer)?;
        Ok(Self {
            flagged,
            categories,
            category_scores,
            category_applied_input_types,
        })
    }
}
impl serde::Serialize for CreateModerationResponseResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateModerationResponseResult<'a> {
            #[serde(rename = "flagged")]
            flagged: &'a bool,
            #[serde(rename = "categories")]
            categories: &'a CreateModerationResponseResultCategories,
            #[serde(rename = "category_scores")]
            category_scores: &'a CreateModerationResponseResultCategoryScores,
            #[serde(rename = "category_applied_input_types")]
            category_applied_input_types:
                &'a CreateModerationResponseResultCategoryAppliedInputTypes,
        }
        let Self {
            flagged,
            categories,
            category_scores,
            category_applied_input_types,
        } = self;
        CreateModerationResponseResult {
            flagged,
            categories,
            category_scores,
            category_applied_input_types,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponseResult {
    #[doc = "Whether any of the below categories are flagged."]
    pub flagged: bool,
    #[doc = "A list of the categories, and whether they are flagged or not."]
    pub categories: CreateModerationResponseResultCategories,
    #[doc = "A list of the categories along with their scores as predicted by model."]
    pub category_scores: CreateModerationResponseResultCategoryScores,
    #[doc = "A list of the categories along with the input type(s) that the score applies to."]
    pub category_applied_input_types: CreateModerationResponseResultCategoryAppliedInputTypes,
}
impl<'de> serde::Deserialize<'de> for CreateModerationResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateModerationResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Vec<CreateModerationResponseResult>,
        }
        let CreateModerationResponse {
            id, model, results, ..
        } = CreateModerationResponse::deserialize(deserializer)?;
        Ok(Self { id, model, results })
    }
}
impl serde::Serialize for CreateModerationResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateModerationResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "results")]
            results: &'a Vec<CreateModerationResponseResult>,
        }
        let Self { id, model, results } = self;
        CreateModerationResponse { id, model, results }.serialize(serializer)
    }
}
#[doc = "Represents if a given text input is potentially harmful."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponse {
    #[doc = "The unique identifier for the moderation request."]
    pub id: String,
    #[doc = "The model used to generate the moderation results."]
    pub model: String,
    #[doc = "A list of moderation objects."]
    pub results: Vec<CreateModerationResponseResult>,
}
impl<'de> serde::Deserialize<'de> for CreateResponseInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateResponseInput {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<InputItem>),
        }
        Ok(match CreateResponseInput::deserialize(deserializer)? {
            CreateResponseInput::String(_v) => Self::String(_v),
            CreateResponseInput::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for CreateResponseInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateResponseInput<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<InputItem>),
        }
        match self {
            Self::String(_v) => CreateResponseInput::String(_v).serialize(serializer),
            Self::Array(_v) => CreateResponseInput::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "Text, image, or file inputs to the model, used to generate a response.\n\nLearn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Image inputs](https://platform.openai.com/docs/guides/images)\n- [File inputs](https://platform.openai.com/docs/guides/pdf-files)\n- [Conversation state](https://platform.openai.com/docs/guides/conversation-state)\n- [Function calling](https://platform.openai.com/docs/guides/function-calling)\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateResponseInput {
    #[doc = "A text input to the model, equivalent to a text input with the \n`user` role.\n"]
    String(String),
    #[doc = "A list of one or many input items to the model, containing \ndifferent content types.\n"]
    Array(Vec<InputItem>),
}
impl<'de> serde::Deserialize<'de> for CreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateResponse {
            #[serde(flatten)]
            #[allow(dead_code)]
            create_model_response_properties: CreateModelResponseProperties,
            #[serde(flatten)]
            #[allow(dead_code)]
            response_properties: ResponseProperties,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: CreateResponseInput,
            #[serde(rename = "include")]
            #[allow(dead_code)]
            include: Option<Vec<Includable>>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<bool>,
            #[serde(rename = "store")]
            #[allow(dead_code)]
            store: Option<bool>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
        }
        let CreateResponse {
            create_model_response_properties,
            response_properties,
            input,
            include,
            parallel_tool_calls,
            store,
            stream,
            ..
        } = CreateResponse::deserialize(deserializer)?;
        Ok(Self {
            create_model_response_properties,
            response_properties,
            input,
            include,
            parallel_tool_calls,
            store,
            stream,
        })
    }
}
impl serde::Serialize for CreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateResponse<'a> {
            #[serde(flatten)]
            create_model_response_properties: &'a CreateModelResponseProperties,
            #[serde(flatten)]
            response_properties: &'a ResponseProperties,
            #[serde(rename = "input")]
            input: &'a CreateResponseInput,
            #[serde(rename = "include")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include: &'a Option<Vec<Includable>>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<bool>,
            #[serde(rename = "store")]
            #[serde(skip_serializing_if = "Option::is_none")]
            store: &'a Option<bool>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
        }
        let Self {
            create_model_response_properties,
            response_properties,
            input,
            include,
            parallel_tool_calls,
            store,
            stream,
        } = self;
        CreateResponse {
            create_model_response_properties,
            response_properties,
            input,
            include,
            parallel_tool_calls,
            store,
            stream,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateResponse {
    #[builder(default)]
    pub create_model_response_properties: CreateModelResponseProperties,
    #[builder(default)]
    pub response_properties: ResponseProperties,
    #[doc = "Text, image, or file inputs to the model, used to generate a response.\n\nLearn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Image inputs](https://platform.openai.com/docs/guides/images)\n- [File inputs](https://platform.openai.com/docs/guides/pdf-files)\n- [Conversation state](https://platform.openai.com/docs/guides/conversation-state)\n- [Function calling](https://platform.openai.com/docs/guides/function-calling)\n"]
    pub input: CreateResponseInput,
    #[doc = "Specify additional output data to include in the model response. Currently\nsupported values are:\n- `file_search_call.results`: Include the search results of\n  the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n- `reasoning.encrypted_content`: Includes an encrypted version of reasoning\n  tokens in reasoning item outputs. This enables reasoning items to be used in\n  multi-turn conversations when using the Responses API statelessly (like\n  when the `store` parameter is set to `false`, or when an organization is\n  enrolled in the zero data retention program).\n- `code_interpreter_call.outputs`: Includes the outputs of python code execution\n  in code interpreter tool call items.\n"]
    #[builder(default)]
    pub include: Option<Vec<Includable>>,
    #[doc = "Whether to allow the model to run tool calls in parallel.\n"]
    #[builder(default)]
    pub parallel_tool_calls: Option<bool>,
    #[doc = "Whether to store the generated model response for later retrieval via\nAPI.\n"]
    #[builder(default)]
    pub store: Option<bool>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](https://platform.openai.com/docs/api-reference/responses-streaming)\nfor more information.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for CreateRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateRunRequest {
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "additional_instructions")]
            #[allow(dead_code)]
            additional_instructions: Option<String>,
            #[serde(rename = "additional_messages")]
            #[allow(dead_code)]
            additional_messages: Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<AssistantTool>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "max_prompt_tokens")]
            #[allow(dead_code)]
            max_prompt_tokens: Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[allow(dead_code)]
            truncation_strategy: Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let CreateRunRequest {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = CreateRunRequest::deserialize(deserializer)?;
        Ok(Self {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for CreateRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateRunRequest<'a> {
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "additional_instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            additional_instructions: &'a Option<String>,
            #[serde(rename = "additional_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            additional_messages: &'a Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<AssistantTool>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let Self {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        CreateRunRequest {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateRunRequest {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    pub assistant_id: String,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[builder(default)]
    pub model: Option<String>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions."]
    #[builder(default)]
    pub additional_instructions: Option<String>,
    #[doc = "Adds additional messages to the thread before creating the run."]
    #[builder(default)]
    pub additional_messages: Option<Vec<CreateMessageRequest>>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub tools: Option<Vec<AssistantTool>>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<u64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[builder(default)]
    pub truncation_strategy: Option<TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<AssistantsApiToolChoiceOption>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for CreateSpeechRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatOpus {
            #[default]
            #[serde(rename = "opus")]
            Opus,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatAac {
            #[default]
            #[serde(rename = "aac")]
            Aac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatFlac {
            #[default]
            #[serde(rename = "flac")]
            Flac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatPcm {
            #[default]
            #[serde(rename = "pcm")]
            Pcm,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateSpeechRequestResponseFormat {
            Mp3(#[allow(dead_code)] CreateSpeechRequestResponseFormatMp3),
            Opus(#[allow(dead_code)] CreateSpeechRequestResponseFormatOpus),
            Aac(#[allow(dead_code)] CreateSpeechRequestResponseFormatAac),
            Flac(#[allow(dead_code)] CreateSpeechRequestResponseFormatFlac),
            Wav(#[allow(dead_code)] CreateSpeechRequestResponseFormatWav),
            Pcm(#[allow(dead_code)] CreateSpeechRequestResponseFormatPcm),
        }
        Ok(
            match CreateSpeechRequestResponseFormat::deserialize(deserializer)? {
                CreateSpeechRequestResponseFormat::Mp3(_) => Self::Mp3,
                CreateSpeechRequestResponseFormat::Opus(_) => Self::Opus,
                CreateSpeechRequestResponseFormat::Aac(_) => Self::Aac,
                CreateSpeechRequestResponseFormat::Flac(_) => Self::Flac,
                CreateSpeechRequestResponseFormat::Wav(_) => Self::Wav,
                CreateSpeechRequestResponseFormat::Pcm(_) => Self::Pcm,
            },
        )
    }
}
impl serde::Serialize for CreateSpeechRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatOpus {
            #[default]
            #[serde(rename = "opus")]
            Opus,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatAac {
            #[default]
            #[serde(rename = "aac")]
            Aac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatFlac {
            #[default]
            #[serde(rename = "flac")]
            Flac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateSpeechRequestResponseFormatPcm {
            #[default]
            #[serde(rename = "pcm")]
            Pcm,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateSpeechRequestResponseFormat<'a> {
            Mp3(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatMp3),
            Opus(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatOpus),
            Aac(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatAac),
            Flac(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatFlac),
            Wav(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatWav),
            Pcm(#[allow(dead_code)] &'a CreateSpeechRequestResponseFormatPcm),
        }
        match self {
            Self::Mp3 => {
                CreateSpeechRequestResponseFormat::Mp3(&Default::default()).serialize(serializer)
            }
            Self::Opus => {
                CreateSpeechRequestResponseFormat::Opus(&Default::default()).serialize(serializer)
            }
            Self::Aac => {
                CreateSpeechRequestResponseFormat::Aac(&Default::default()).serialize(serializer)
            }
            Self::Flac => {
                CreateSpeechRequestResponseFormat::Flac(&Default::default()).serialize(serializer)
            }
            Self::Wav => {
                CreateSpeechRequestResponseFormat::Wav(&Default::default()).serialize(serializer)
            }
            Self::Pcm => {
                CreateSpeechRequestResponseFormat::Pcm(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateSpeechRequestResponseFormat {
    #[doc = "mp3"]
    #[default]
    Mp3,
    #[doc = "opus"]
    Opus,
    #[doc = "aac"]
    Aac,
    #[doc = "flac"]
    Flac,
    #[doc = "wav"]
    Wav,
    #[doc = "pcm"]
    Pcm,
}
impl<'de> serde::Deserialize<'de> for CreateSpeechRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateSpeechRequest {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: String,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: VoiceIdsShared,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateSpeechRequestResponseFormat>,
            #[serde(rename = "speed")]
            #[allow(dead_code)]
            speed: Option<f64>,
        }
        let CreateSpeechRequest {
            model,
            input,
            instructions,
            voice,
            response_format,
            speed,
            ..
        } = CreateSpeechRequest::deserialize(deserializer)?;
        Ok(Self {
            model,
            input,
            instructions,
            voice,
            response_format,
            speed,
        })
    }
}
impl serde::Serialize for CreateSpeechRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateSpeechRequest<'a> {
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            voice: &'a VoiceIdsShared,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateSpeechRequestResponseFormat>,
            #[serde(rename = "speed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            speed: &'a Option<f64>,
        }
        let Self {
            model,
            input,
            instructions,
            voice,
            response_format,
            speed,
        } = self;
        CreateSpeechRequest {
            model,
            input,
            instructions,
            voice,
            response_format,
            speed,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateSpeechRequest {
    #[doc = "One of the available [TTS models](https://platform.openai.com/docs/models#tts): `tts-1`, `tts-1-hd` or `gpt-4o-mini-tts`.\n"]
    pub model: String,
    #[doc = "The text to generate audio for. The maximum length is 4096 characters."]
    pub input: String,
    #[doc = "Control the voice of your generated audio with additional instructions. Does not work with `tts-1` or `tts-1-hd`."]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice to use when generating the audio. Supported voices are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`, `onyx`, `nova`, `sage`, `shimmer`, and `verse`. Previews of the voices are available in the [Text to speech guide](https://platform.openai.com/docs/guides/text-to-speech#voice-options)."]
    pub voice: VoiceIdsShared,
    #[doc = "The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`."]
    #[builder(default)]
    pub response_format: Option<CreateSpeechRequestResponseFormat>,
    #[doc = "The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default. Does not work with `gpt-4o-mini-tts`."]
    #[builder(default)]
    pub speed: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadAndRunRequestToolResourcesCodeInterpreter {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let CreateThreadAndRunRequestToolResourcesCodeInterpreter { file_ids, .. } =
            CreateThreadAndRunRequestToolResourcesCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadAndRunRequestToolResourcesCodeInterpreter<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        CreateThreadAndRunRequestToolResourcesCodeInterpreter { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadAndRunRequestToolResourcesFileSearch {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let CreateThreadAndRunRequestToolResourcesFileSearch {
            vector_store_ids, ..
        } = CreateThreadAndRunRequestToolResourcesFileSearch::deserialize(deserializer)?;
        Ok(Self { vector_store_ids })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadAndRunRequestToolResourcesFileSearch<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let Self { vector_store_ids } = self;
        CreateThreadAndRunRequestToolResourcesFileSearch { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestToolResourcesFileSearch {
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadAndRunRequestToolResources {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<CreateThreadAndRunRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<CreateThreadAndRunRequestToolResourcesFileSearch>,
        }
        let CreateThreadAndRunRequestToolResources {
            code_interpreter,
            file_search,
            ..
        } = CreateThreadAndRunRequestToolResources::deserialize(deserializer)?;
        Ok(Self {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadAndRunRequestToolResources<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<CreateThreadAndRunRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<CreateThreadAndRunRequestToolResourcesFileSearch>,
        }
        let Self {
            code_interpreter,
            file_search,
        } = self;
        CreateThreadAndRunRequestToolResources {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<CreateThreadAndRunRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<CreateThreadAndRunRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadAndRunRequest {
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "thread")]
            #[allow(dead_code)]
            thread: Option<CreateThreadRequest>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<AssistantTool>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<CreateThreadAndRunRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "max_prompt_tokens")]
            #[allow(dead_code)]
            max_prompt_tokens: Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[allow(dead_code)]
            truncation_strategy: Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let CreateThreadAndRunRequest {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = CreateThreadAndRunRequest::deserialize(deserializer)?;
        Ok(Self {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for CreateThreadAndRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadAndRunRequest<'a> {
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "thread")]
            #[serde(skip_serializing_if = "Option::is_none")]
            thread: &'a Option<CreateThreadRequest>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<AssistantTool>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<CreateThreadAndRunRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let Self {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        CreateThreadAndRunRequest {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            stream,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequest {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    pub assistant_id: String,
    #[builder(default)]
    pub thread: Option<CreateThreadRequest>,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub tools: Option<Vec<AssistantTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<CreateThreadAndRunRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<u64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[builder(default)]
    pub truncation_strategy: Option<TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<AssistantsApiToolChoiceOption>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesCodeInterpreter {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let CreateThreadRequestToolResourcesCodeInterpreter { file_ids, .. } =
            CreateThreadRequestToolResourcesCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesCodeInterpreter<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        CreateThreadRequestToolResourcesCodeInterpreter { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType,
        }
        let CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto { .. } = CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto :: deserialize (deserializer) ? ;
        Ok(Self {})
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto<'a> {
            #[serde(rename = "type")]
            type_:
                &'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAutoType,
        }
        let Self {} = self;
        CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto {}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic { max_chunk_size_tokens , chunk_overlap_tokens , .. } = CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic :: deserialize (deserializer) ? ;
        Ok(Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        })
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic<
            'a,
        > {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType,
            #[serde(rename = "static")]
            #[allow(dead_code)]
            static_:
                CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic,
        }
        let CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic { static_ , .. } = CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic :: deserialize (deserializer) ? ;
        Ok(Self { static_ })
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic < 'a > { # [serde (rename = "type")] type_ : & 'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] static_ : & 'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic }
        let Self { static_ } = self;
        CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic {
    pub static_: CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStaticStatic,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy {
            Auto(
                #[allow(dead_code)]
                CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic,
            ),
        }
        Ok (match CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy :: deserialize (deserializer) ? { CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy :: Auto (_v) => Self :: Auto (_v) , CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy :: Static (_v) => Self :: Static (_v) })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy<'a> {
            Auto(
                #[allow(dead_code)]
                &'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                &'a CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic,
            ),
        }
        match self {
            Self::Auto(_v) => {
                CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy::Auto(_v)
                    .serialize(serializer)
            }
            Self::Static(_v) => {
                CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy::Static(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy {
    #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
    Auto(CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyAuto),
    Static(CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategyStatic),
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch0VectorStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch0VectorStore {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy:
                Option<CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let CreateThreadRequestToolResourcesFileSearch0VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
            ..
        } = CreateThreadRequestToolResourcesFileSearch0VectorStore::deserialize(deserializer)?;
        Ok(Self {
            file_ids,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch0VectorStore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch0VectorStore<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy:
                &'a Option<CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            file_ids,
            chunking_strategy,
            metadata,
        } = self;
        CreateThreadRequestToolResourcesFileSearch0VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0VectorStore {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
    #[builder(default)]
    pub chunking_strategy:
        Option<CreateThreadRequestToolResourcesFileSearch0VectorStoreChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch0 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch0 {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Vec<String>,
            #[serde(rename = "vector_stores")]
            #[allow(dead_code)]
            vector_stores: Option<Vec<CreateThreadRequestToolResourcesFileSearch0VectorStore>>,
        }
        let CreateThreadRequestToolResourcesFileSearch0 {
            vector_store_ids,
            vector_stores,
            ..
        } = CreateThreadRequestToolResourcesFileSearch0::deserialize(deserializer)?;
        Ok(Self {
            vector_store_ids,
            vector_stores,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch0<'a> {
            #[serde(rename = "vector_store_ids")]
            vector_store_ids: &'a Vec<String>,
            #[serde(rename = "vector_stores")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_stores: &'a Option<Vec<CreateThreadRequestToolResourcesFileSearch0VectorStore>>,
        }
        let Self {
            vector_store_ids,
            vector_stores,
        } = self;
        CreateThreadRequestToolResourcesFileSearch0 {
            vector_store_ids,
            vector_stores,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch0 {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    pub vector_store_ids: Vec<String>,
    #[doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    #[builder(default)]
    pub vector_stores: Option<Vec<CreateThreadRequestToolResourcesFileSearch0VectorStore>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType,
        }
        let CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto { .. } = CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto :: deserialize (deserializer) ? ;
        Ok(Self {})
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `auto`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto<'a> {
            #[serde(rename = "type")]
            type_:
                &'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAutoType,
        }
        let Self {} = self;
        CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto {}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic { max_chunk_size_tokens , chunk_overlap_tokens , .. } = CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic :: deserialize (deserializer) ? ;
        Ok(Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        })
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic<
            'a,
        > {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType,
            #[serde(rename = "static")]
            #[allow(dead_code)]
            static_:
                CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic,
        }
        let CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic { static_ , .. } = CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic :: deserialize (deserializer) ? ;
        Ok(Self { static_ })
    }
}
impl serde::Serialize
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic < 'a > { # [serde (rename = "type")] type_ : & 'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticType , # [serde (rename = "static")] static_ : & 'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic }
        let Self { static_ } = self;
        CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic {
    pub static_: CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStaticStatic,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy {
            Auto(
                #[allow(dead_code)]
                CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic,
            ),
        }
        Ok (match CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy :: deserialize (deserializer) ? { CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy :: Auto (_v) => Self :: Auto (_v) , CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy :: Static (_v) => Self :: Static (_v) })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy<'a> {
            Auto(
                #[allow(dead_code)]
                &'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto,
            ),
            Static(
                #[allow(dead_code)]
                &'a CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic,
            ),
        }
        match self {
            Self::Auto(_v) => {
                CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy::Auto(_v)
                    .serialize(serializer)
            }
            Self::Static(_v) => {
                CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy::Static(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy {
    #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
    Auto(CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyAuto),
    Static(CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategyStatic),
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch1VectorStore {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch1VectorStore {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy:
                Option<CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let CreateThreadRequestToolResourcesFileSearch1VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
            ..
        } = CreateThreadRequestToolResourcesFileSearch1VectorStore::deserialize(deserializer)?;
        Ok(Self {
            file_ids,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch1VectorStore {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch1VectorStore<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy:
                &'a Option<CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            file_ids,
            chunking_strategy,
            metadata,
        } = self;
        CreateThreadRequestToolResourcesFileSearch1VectorStore {
            file_ids,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1VectorStore {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
    #[builder(default)]
    pub chunking_strategy:
        Option<CreateThreadRequestToolResourcesFileSearch1VectorStoreChunkingStrategy>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResourcesFileSearch1 {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
            #[serde(rename = "vector_stores")]
            #[allow(dead_code)]
            vector_stores: Vec<CreateThreadRequestToolResourcesFileSearch1VectorStore>,
        }
        let CreateThreadRequestToolResourcesFileSearch1 {
            vector_store_ids,
            vector_stores,
            ..
        } = CreateThreadRequestToolResourcesFileSearch1::deserialize(deserializer)?;
        Ok(Self {
            vector_store_ids,
            vector_stores,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch1 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResourcesFileSearch1<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
            #[serde(rename = "vector_stores")]
            vector_stores: &'a Vec<CreateThreadRequestToolResourcesFileSearch1VectorStore>,
        }
        let Self {
            vector_store_ids,
            vector_stores,
        } = self;
        CreateThreadRequestToolResourcesFileSearch1 {
            vector_store_ids,
            vector_stores,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResourcesFileSearch1 {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
    #[doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    pub vector_stores: Vec<CreateThreadRequestToolResourcesFileSearch1VectorStore>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateThreadRequestToolResourcesFileSearch {
            _0(#[allow(dead_code)] CreateThreadRequestToolResourcesFileSearch0),
            _1(#[allow(dead_code)] CreateThreadRequestToolResourcesFileSearch1),
        }
        Ok(
            match CreateThreadRequestToolResourcesFileSearch::deserialize(deserializer)? {
                CreateThreadRequestToolResourcesFileSearch::_0(_v) => Self::_0(_v),
                CreateThreadRequestToolResourcesFileSearch::_1(_v) => Self::_1(_v),
            },
        )
    }
}
impl serde::Serialize for CreateThreadRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateThreadRequestToolResourcesFileSearch<'a> {
            _0(#[allow(dead_code)] &'a CreateThreadRequestToolResourcesFileSearch0),
            _1(#[allow(dead_code)] &'a CreateThreadRequestToolResourcesFileSearch1),
        }
        match self {
            Self::_0(_v) => {
                CreateThreadRequestToolResourcesFileSearch::_0(_v).serialize(serializer)
            }
            Self::_1(_v) => {
                CreateThreadRequestToolResourcesFileSearch::_1(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateThreadRequestToolResourcesFileSearch {
    _0(CreateThreadRequestToolResourcesFileSearch0),
    _1(CreateThreadRequestToolResourcesFileSearch1),
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequestToolResources {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<CreateThreadRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<CreateThreadRequestToolResourcesFileSearch>,
        }
        let CreateThreadRequestToolResources {
            code_interpreter,
            file_search,
            ..
        } = CreateThreadRequestToolResources::deserialize(deserializer)?;
        Ok(Self {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for CreateThreadRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequestToolResources<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<CreateThreadRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<CreateThreadRequestToolResourcesFileSearch>,
        }
        let Self {
            code_interpreter,
            file_search,
        } = self;
        CreateThreadRequestToolResources {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<CreateThreadRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<CreateThreadRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadRequest {
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<CreateThreadRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let CreateThreadRequest {
            messages,
            tool_resources,
            metadata,
            ..
        } = CreateThreadRequest::deserialize(deserializer)?;
        Ok(Self {
            messages,
            tool_resources,
            metadata,
        })
    }
}
impl serde::Serialize for CreateThreadRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadRequest<'a> {
            #[serde(rename = "messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            messages: &'a Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<CreateThreadRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            messages,
            tool_resources,
            metadata,
        } = self;
        CreateThreadRequest {
            messages,
            tool_resources,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Options to create a new thread. If no thread is provided when running a \nrequest, an empty thread will be created.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequest {
    #[doc = "A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with."]
    #[builder(default)]
    pub messages: Option<Vec<CreateMessageRequest>>,
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<CreateThreadRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionRequestTimestampGranularities {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranscriptionRequestTimestampGranularitiesWord {
            #[default]
            #[serde(rename = "word")]
            Word,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranscriptionRequestTimestampGranularitiesSegment {
            #[default]
            #[serde(rename = "segment")]
            Segment,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateTranscriptionRequestTimestampGranularities {
            Word(#[allow(dead_code)] CreateTranscriptionRequestTimestampGranularitiesWord),
            Segment(#[allow(dead_code)] CreateTranscriptionRequestTimestampGranularitiesSegment),
        }
        Ok(
            match CreateTranscriptionRequestTimestampGranularities::deserialize(deserializer)? {
                CreateTranscriptionRequestTimestampGranularities::Word(_) => Self::Word,
                CreateTranscriptionRequestTimestampGranularities::Segment(_) => Self::Segment,
            },
        )
    }
}
impl serde::Serialize for CreateTranscriptionRequestTimestampGranularities {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranscriptionRequestTimestampGranularitiesWord {
            #[default]
            #[serde(rename = "word")]
            Word,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranscriptionRequestTimestampGranularitiesSegment {
            #[default]
            #[serde(rename = "segment")]
            Segment,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateTranscriptionRequestTimestampGranularities<'a> {
            Word(#[allow(dead_code)] &'a CreateTranscriptionRequestTimestampGranularitiesWord),
            Segment(
                #[allow(dead_code)] &'a CreateTranscriptionRequestTimestampGranularitiesSegment,
            ),
        }
        match self {
            Self::Word => {
                CreateTranscriptionRequestTimestampGranularities::Word(&Default::default())
                    .serialize(serializer)
            }
            Self::Segment => {
                CreateTranscriptionRequestTimestampGranularities::Segment(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateTranscriptionRequestTimestampGranularities {
    #[doc = "word"]
    Word,
    #[doc = "segment"]
    Segment,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateTranscriptionRequest {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Vec<u8>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AudioResponseFormat>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<TranscriptionChunkingStrategy>,
            #[serde(rename = "timestamp_granularities")]
            #[allow(dead_code)]
            timestamp_granularities: Option<Vec<CreateTranscriptionRequestTimestampGranularities>>,
            #[serde(rename = "include")]
            #[allow(dead_code)]
            include: Option<Vec<TranscriptionInclude>>,
        }
        let CreateTranscriptionRequest {
            file,
            model,
            language,
            prompt,
            response_format,
            temperature,
            stream,
            chunking_strategy,
            timestamp_granularities,
            include,
            ..
        } = CreateTranscriptionRequest::deserialize(deserializer)?;
        Ok(Self {
            file,
            model,
            language,
            prompt,
            response_format,
            temperature,
            stream,
            chunking_strategy,
            timestamp_granularities,
            include,
        })
    }
}
impl serde::Serialize for CreateTranscriptionRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateTranscriptionRequest<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            file: &'a Vec<u8>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AudioResponseFormat>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<TranscriptionChunkingStrategy>,
            #[serde(rename = "timestamp_granularities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timestamp_granularities:
                &'a Option<Vec<CreateTranscriptionRequestTimestampGranularities>>,
            #[serde(rename = "include")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include: &'a Option<Vec<TranscriptionInclude>>,
        }
        let Self {
            file,
            model,
            language,
            prompt,
            response_format,
            temperature,
            stream,
            chunking_strategy,
            timestamp_granularities,
            include,
        } = self;
        CreateTranscriptionRequest {
            file,
            model,
            language,
            prompt,
            response_format,
            temperature,
            stream,
            chunking_strategy,
            timestamp_granularities,
            include,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionRequest {
    #[doc = "The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n"]
    pub file: Vec<u8>,
    #[doc = "ID of the model to use. The options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1` (which is powered by our open source Whisper V2 model).\n"]
    pub model: String,
    #[doc = "The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format will improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio segment. The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting) should match the audio language.\n"]
    #[builder(default)]
    pub prompt: Option<String>,
    #[builder(default)]
    pub response_format: Option<AudioResponseFormat>,
    #[doc = "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format). \nSee the [Streaming section of the Speech-to-Text guide](https://platform.openai.com/docs/guides/speech-to-text?lang=curl#streaming-transcriptions)\nfor more information.\n\nNote: Streaming is not supported for the `whisper-1` model and will be ignored.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
    #[builder(default)]
    pub chunking_strategy: Option<TranscriptionChunkingStrategy>,
    #[doc = "The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.\n"]
    #[builder(default)]
    pub timestamp_granularities: Option<Vec<CreateTranscriptionRequestTimestampGranularities>>,
    #[doc = "Additional information to include in the transcription response. \n`logprobs` will return the log probabilities of the tokens in the \nresponse to understand the model's confidence in the transcription. \n`logprobs` only works with response_format set to `json` and only with \nthe models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe`.\n"]
    #[builder(default)]
    pub include: Option<Vec<TranscriptionInclude>>,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionResponseJsonLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateTranscriptionResponseJsonLogprob {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: Option<String>,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: Option<f64>,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<f64>>,
        }
        let CreateTranscriptionResponseJsonLogprob {
            token,
            logprob,
            bytes,
            ..
        } = CreateTranscriptionResponseJsonLogprob::deserialize(deserializer)?;
        Ok(Self {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for CreateTranscriptionResponseJsonLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateTranscriptionResponseJsonLogprob<'a> {
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token: &'a Option<String>,
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprob: &'a Option<f64>,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<f64>>,
        }
        let Self {
            token,
            logprob,
            bytes,
        } = self;
        CreateTranscriptionResponseJsonLogprob {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionResponseJsonLogprob {
    #[doc = "The token in the transcription."]
    #[builder(default)]
    pub token: Option<String>,
    #[doc = "The log probability of the token."]
    #[builder(default)]
    pub logprob: Option<f64>,
    #[doc = "The bytes of the token."]
    #[builder(default)]
    pub bytes: Option<Vec<f64>>,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionResponseJson {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateTranscriptionResponseJson {
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<CreateTranscriptionResponseJsonLogprob>>,
        }
        let CreateTranscriptionResponseJson { text, logprobs, .. } =
            CreateTranscriptionResponseJson::deserialize(deserializer)?;
        Ok(Self { text, logprobs })
    }
}
impl serde::Serialize for CreateTranscriptionResponseJson {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateTranscriptionResponseJson<'a> {
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<CreateTranscriptionResponseJsonLogprob>>,
        }
        let Self { text, logprobs } = self;
        CreateTranscriptionResponseJson { text, logprobs }.serialize(serializer)
    }
}
#[doc = "Represents a transcription response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionResponseJson {
    #[doc = "The transcribed text."]
    pub text: String,
    #[doc = "The log probabilities of the tokens in the transcription. Only returned with the models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe` if `logprobs` is added to the `include` array.\n"]
    #[builder(default)]
    pub logprobs: Option<Vec<CreateTranscriptionResponseJsonLogprob>>,
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionResponseStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateTranscriptionResponseStreamEvent {
            TranscriptTextDelta(#[allow(dead_code)] TranscriptTextDeltaEvent),
            TranscriptTextDone(#[allow(dead_code)] TranscriptTextDoneEvent),
        }
        Ok(
            match CreateTranscriptionResponseStreamEvent::deserialize(deserializer)? {
                CreateTranscriptionResponseStreamEvent::TranscriptTextDelta(_v) => {
                    Self::TranscriptTextDelta(_v)
                }
                CreateTranscriptionResponseStreamEvent::TranscriptTextDone(_v) => {
                    Self::TranscriptTextDone(_v)
                }
            },
        )
    }
}
impl serde::Serialize for CreateTranscriptionResponseStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateTranscriptionResponseStreamEvent<'a> {
            TranscriptTextDelta(#[allow(dead_code)] &'a TranscriptTextDeltaEvent),
            TranscriptTextDone(#[allow(dead_code)] &'a TranscriptTextDoneEvent),
        }
        match self {
            Self::TranscriptTextDelta(_v) => {
                CreateTranscriptionResponseStreamEvent::TranscriptTextDelta(_v)
                    .serialize(serializer)
            }
            Self::TranscriptTextDone(_v) => {
                CreateTranscriptionResponseStreamEvent::TranscriptTextDone(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum CreateTranscriptionResponseStreamEvent {
    TranscriptTextDelta(TranscriptTextDeltaEvent),
    TranscriptTextDone(TranscriptTextDoneEvent),
}
impl<'de> serde::Deserialize<'de> for CreateTranscriptionResponseVerboseJson {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateTranscriptionResponseVerboseJson {
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: String,
            #[serde(rename = "duration")]
            #[allow(dead_code)]
            duration: f64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "words")]
            #[allow(dead_code)]
            words: Option<Vec<TranscriptionWord>>,
            #[serde(rename = "segments")]
            #[allow(dead_code)]
            segments: Option<Vec<TranscriptionSegment>>,
        }
        let CreateTranscriptionResponseVerboseJson {
            language,
            duration,
            text,
            words,
            segments,
            ..
        } = CreateTranscriptionResponseVerboseJson::deserialize(deserializer)?;
        Ok(Self {
            language,
            duration,
            text,
            words,
            segments,
        })
    }
}
impl serde::Serialize for CreateTranscriptionResponseVerboseJson {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateTranscriptionResponseVerboseJson<'a> {
            #[serde(rename = "language")]
            language: &'a String,
            #[serde(rename = "duration")]
            duration: &'a f64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "words")]
            #[serde(skip_serializing_if = "Option::is_none")]
            words: &'a Option<Vec<TranscriptionWord>>,
            #[serde(rename = "segments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            segments: &'a Option<Vec<TranscriptionSegment>>,
        }
        let Self {
            language,
            duration,
            text,
            words,
            segments,
        } = self;
        CreateTranscriptionResponseVerboseJson {
            language,
            duration,
            text,
            words,
            segments,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a verbose json transcription response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionResponseVerboseJson {
    #[doc = "The language of the input audio."]
    pub language: String,
    #[doc = "The duration of the input audio."]
    pub duration: f64,
    #[doc = "The transcribed text."]
    pub text: String,
    #[doc = "Extracted words and their corresponding timestamps."]
    #[builder(default)]
    pub words: Option<Vec<TranscriptionWord>>,
    #[doc = "Segments of the transcribed text and their corresponding details."]
    #[builder(default)]
    pub segments: Option<Vec<TranscriptionSegment>>,
}
impl<'de> serde::Deserialize<'de> for CreateTranslationRequestResponseFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatJson {
            #[default]
            #[serde(rename = "json")]
            Json,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatSrt {
            #[default]
            #[serde(rename = "srt")]
            Srt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatVerboseJson {
            #[default]
            #[serde(rename = "verbose_json")]
            VerboseJson,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatVtt {
            #[default]
            #[serde(rename = "vtt")]
            Vtt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateTranslationRequestResponseFormat {
            Json(#[allow(dead_code)] CreateTranslationRequestResponseFormatJson),
            Text(#[allow(dead_code)] CreateTranslationRequestResponseFormatText),
            Srt(#[allow(dead_code)] CreateTranslationRequestResponseFormatSrt),
            VerboseJson(#[allow(dead_code)] CreateTranslationRequestResponseFormatVerboseJson),
            Vtt(#[allow(dead_code)] CreateTranslationRequestResponseFormatVtt),
        }
        Ok(
            match CreateTranslationRequestResponseFormat::deserialize(deserializer)? {
                CreateTranslationRequestResponseFormat::Json(_) => Self::Json,
                CreateTranslationRequestResponseFormat::Text(_) => Self::Text,
                CreateTranslationRequestResponseFormat::Srt(_) => Self::Srt,
                CreateTranslationRequestResponseFormat::VerboseJson(_) => Self::VerboseJson,
                CreateTranslationRequestResponseFormat::Vtt(_) => Self::Vtt,
            },
        )
    }
}
impl serde::Serialize for CreateTranslationRequestResponseFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatJson {
            #[default]
            #[serde(rename = "json")]
            Json,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatSrt {
            #[default]
            #[serde(rename = "srt")]
            Srt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatVerboseJson {
            #[default]
            #[serde(rename = "verbose_json")]
            VerboseJson,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateTranslationRequestResponseFormatVtt {
            #[default]
            #[serde(rename = "vtt")]
            Vtt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateTranslationRequestResponseFormat<'a> {
            Json(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatJson),
            Text(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatText),
            Srt(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatSrt),
            VerboseJson(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatVerboseJson),
            Vtt(#[allow(dead_code)] &'a CreateTranslationRequestResponseFormatVtt),
        }
        match self {
            Self::Json => CreateTranslationRequestResponseFormat::Json(&Default::default())
                .serialize(serializer),
            Self::Text => CreateTranslationRequestResponseFormat::Text(&Default::default())
                .serialize(serializer),
            Self::Srt => CreateTranslationRequestResponseFormat::Srt(&Default::default())
                .serialize(serializer),
            Self::VerboseJson => {
                CreateTranslationRequestResponseFormat::VerboseJson(&Default::default())
                    .serialize(serializer)
            }
            Self::Vtt => CreateTranslationRequestResponseFormat::Vtt(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum CreateTranslationRequestResponseFormat {
    #[doc = "json"]
    #[default]
    Json,
    #[doc = "text"]
    Text,
    #[doc = "srt"]
    Srt,
    #[doc = "verbose_json"]
    VerboseJson,
    #[doc = "vtt"]
    Vtt,
}
impl<'de> serde::Deserialize<'de> for CreateTranslationRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateTranslationRequest {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Vec<u8>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<CreateTranslationRequestResponseFormat>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
        }
        let CreateTranslationRequest {
            file,
            model,
            prompt,
            response_format,
            temperature,
            ..
        } = CreateTranslationRequest::deserialize(deserializer)?;
        Ok(Self {
            file,
            model,
            prompt,
            response_format,
            temperature,
        })
    }
}
impl serde::Serialize for CreateTranslationRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateTranslationRequest<'a> {
            #[serde_as(as = "serde_with::base64::Base64")]
            #[serde(rename = "file")]
            file: &'a Vec<u8>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<CreateTranslationRequestResponseFormat>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
        }
        let Self {
            file,
            model,
            prompt,
            response_format,
            temperature,
        } = self;
        CreateTranslationRequest {
            file,
            model,
            prompt,
            response_format,
            temperature,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranslationRequest {
    #[doc = "The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n"]
    pub file: Vec<u8>,
    #[doc = "ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.\n"]
    pub model: String,
    #[doc = "An optional text to guide the model's style or continue a previous audio segment. The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting) should be in English.\n"]
    #[builder(default)]
    pub prompt: Option<String>,
    #[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.\n"]
    #[builder(default)]
    pub response_format: Option<CreateTranslationRequestResponseFormat>,
    #[doc = "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for CreateTranslationResponseJson {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateTranslationResponseJson {
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let CreateTranslationResponseJson { text, .. } =
            CreateTranslationResponseJson::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for CreateTranslationResponseJson {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateTranslationResponseJson<'a> {
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        CreateTranslationResponseJson { text }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranslationResponseJson {
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for CreateTranslationResponseVerboseJson {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateTranslationResponseVerboseJson {
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: String,
            #[serde(rename = "duration")]
            #[allow(dead_code)]
            duration: f64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "segments")]
            #[allow(dead_code)]
            segments: Option<Vec<TranscriptionSegment>>,
        }
        let CreateTranslationResponseVerboseJson {
            language,
            duration,
            text,
            segments,
            ..
        } = CreateTranslationResponseVerboseJson::deserialize(deserializer)?;
        Ok(Self {
            language,
            duration,
            text,
            segments,
        })
    }
}
impl serde::Serialize for CreateTranslationResponseVerboseJson {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateTranslationResponseVerboseJson<'a> {
            #[serde(rename = "language")]
            language: &'a String,
            #[serde(rename = "duration")]
            duration: &'a f64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "segments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            segments: &'a Option<Vec<TranscriptionSegment>>,
        }
        let Self {
            language,
            duration,
            text,
            segments,
        } = self;
        CreateTranslationResponseVerboseJson {
            language,
            duration,
            text,
            segments,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateTranslationResponseVerboseJson {
    #[doc = "The language of the output translation (always `english`)."]
    pub language: String,
    #[doc = "The duration of the input audio."]
    pub duration: f64,
    #[doc = "The translated text."]
    pub text: String,
    #[doc = "Segments of the translated text and their corresponding details."]
    #[builder(default)]
    pub segments: Option<Vec<TranscriptionSegment>>,
}
impl<'de> serde::Deserialize<'de> for CreateUploadRequestPurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum CreateUploadRequestPurpose {
            Assistants(#[allow(dead_code)] CreateUploadRequestPurposeAssistants),
            Batch(#[allow(dead_code)] CreateUploadRequestPurposeBatch),
            FineTune(#[allow(dead_code)] CreateUploadRequestPurposeFineTune),
            Vision(#[allow(dead_code)] CreateUploadRequestPurposeVision),
        }
        Ok(
            match CreateUploadRequestPurpose::deserialize(deserializer)? {
                CreateUploadRequestPurpose::Assistants(_) => Self::Assistants,
                CreateUploadRequestPurpose::Batch(_) => Self::Batch,
                CreateUploadRequestPurpose::FineTune(_) => Self::FineTune,
                CreateUploadRequestPurpose::Vision(_) => Self::Vision,
            },
        )
    }
}
impl serde::Serialize for CreateUploadRequestPurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum CreateUploadRequestPurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum CreateUploadRequestPurpose<'a> {
            Assistants(#[allow(dead_code)] &'a CreateUploadRequestPurposeAssistants),
            Batch(#[allow(dead_code)] &'a CreateUploadRequestPurposeBatch),
            FineTune(#[allow(dead_code)] &'a CreateUploadRequestPurposeFineTune),
            Vision(#[allow(dead_code)] &'a CreateUploadRequestPurposeVision),
        }
        match self {
            Self::Assistants => {
                CreateUploadRequestPurpose::Assistants(&Default::default()).serialize(serializer)
            }
            Self::Batch => {
                CreateUploadRequestPurpose::Batch(&Default::default()).serialize(serializer)
            }
            Self::FineTune => {
                CreateUploadRequestPurpose::FineTune(&Default::default()).serialize(serializer)
            }
            Self::Vision => {
                CreateUploadRequestPurpose::Vision(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The intended purpose of the uploaded file.\n\nSee the [documentation on File purposes](https://platform.openai.com/docs/api-reference/files/create#files-create-purpose).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum CreateUploadRequestPurpose {
    #[doc = "assistants"]
    Assistants,
    #[doc = "batch"]
    Batch,
    #[doc = "fine-tune"]
    FineTune,
    #[doc = "vision"]
    Vision,
}
impl<'de> serde::Deserialize<'de> for CreateUploadRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateUploadRequest {
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: String,
            #[serde(rename = "purpose")]
            #[allow(dead_code)]
            purpose: CreateUploadRequestPurpose,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: u64,
            #[serde(rename = "mime_type")]
            #[allow(dead_code)]
            mime_type: String,
        }
        let CreateUploadRequest {
            filename,
            purpose,
            bytes,
            mime_type,
            ..
        } = CreateUploadRequest::deserialize(deserializer)?;
        Ok(Self {
            filename,
            purpose,
            bytes,
            mime_type,
        })
    }
}
impl serde::Serialize for CreateUploadRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateUploadRequest<'a> {
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "purpose")]
            purpose: &'a CreateUploadRequestPurpose,
            #[serde(rename = "bytes")]
            bytes: &'a u64,
            #[serde(rename = "mime_type")]
            mime_type: &'a String,
        }
        let Self {
            filename,
            purpose,
            bytes,
            mime_type,
        } = self;
        CreateUploadRequest {
            filename,
            purpose,
            bytes,
            mime_type,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateUploadRequest {
    #[doc = "The name of the file to upload.\n"]
    pub filename: String,
    #[doc = "The intended purpose of the uploaded file.\n\nSee the [documentation on File purposes](https://platform.openai.com/docs/api-reference/files/create#files-create-purpose).\n"]
    pub purpose: CreateUploadRequestPurpose,
    #[doc = "The number of bytes in the file you are uploading.\n"]
    pub bytes: u64,
    #[doc = "The MIME type of the file.\n\nThis must fall within the supported MIME types for your file purpose. See the supported MIME types for assistants and vision.\n"]
    pub mime_type: String,
}
impl<'de> serde::Deserialize<'de> for CreateVectorStoreFileBatchRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateVectorStoreFileBatchRequest {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Vec<String>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
        }
        let CreateVectorStoreFileBatchRequest {
            file_ids,
            chunking_strategy,
            attributes,
            ..
        } = CreateVectorStoreFileBatchRequest::deserialize(deserializer)?;
        Ok(Self {
            file_ids,
            chunking_strategy,
            attributes,
        })
    }
}
impl serde::Serialize for CreateVectorStoreFileBatchRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateVectorStoreFileBatchRequest<'a> {
            #[serde(rename = "file_ids")]
            file_ids: &'a Vec<String>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
        }
        let Self {
            file_ids,
            chunking_strategy,
            attributes,
        } = self;
        CreateVectorStoreFileBatchRequest {
            file_ids,
            chunking_strategy,
            attributes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreFileBatchRequest {
    #[doc = "A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files."]
    pub file_ids: Vec<String>,
    #[builder(default)]
    pub chunking_strategy: Option<ChunkingStrategyRequestParam>,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
}
impl<'de> serde::Deserialize<'de> for CreateVectorStoreFileRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateVectorStoreFileRequest {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
        }
        let CreateVectorStoreFileRequest {
            file_id,
            chunking_strategy,
            attributes,
            ..
        } = CreateVectorStoreFileRequest::deserialize(deserializer)?;
        Ok(Self {
            file_id,
            chunking_strategy,
            attributes,
        })
    }
}
impl serde::Serialize for CreateVectorStoreFileRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateVectorStoreFileRequest<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
        }
        let Self {
            file_id,
            chunking_strategy,
            attributes,
        } = self;
        CreateVectorStoreFileRequest {
            file_id,
            chunking_strategy,
            attributes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreFileRequest {
    #[doc = "A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files."]
    pub file_id: String,
    #[builder(default)]
    pub chunking_strategy: Option<ChunkingStrategyRequestParam>,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
}
impl<'de> serde::Deserialize<'de> for CreateVectorStoreRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateVectorStoreRequest {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "expires_after")]
            #[allow(dead_code)]
            expires_after: Option<VectorStoreExpirationAfter>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let CreateVectorStoreRequest {
            file_ids,
            name,
            expires_after,
            chunking_strategy,
            metadata,
            ..
        } = CreateVectorStoreRequest::deserialize(deserializer)?;
        Ok(Self {
            file_ids,
            name,
            expires_after,
            chunking_strategy,
            metadata,
        })
    }
}
impl serde::Serialize for CreateVectorStoreRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateVectorStoreRequest<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<VectorStoreExpirationAfter>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<ChunkingStrategyRequestParam>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            file_ids,
            name,
            expires_after,
            chunking_strategy,
            metadata,
        } = self;
        CreateVectorStoreRequest {
            file_ids,
            name,
            expires_after,
            chunking_strategy,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreRequest {
    #[doc = "A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files."]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The name of the vector store."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub expires_after: Option<VectorStoreExpirationAfter>,
    #[builder(default)]
    pub chunking_strategy: Option<ChunkingStrategyRequestParam>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for DeleteAssistantResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteAssistantResponseObject {
            #[default]
            #[serde(rename = "assistant.deleted")]
            AssistantDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteAssistantResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteAssistantResponseObject,
        }
        let DeleteAssistantResponse { id, deleted, .. } =
            DeleteAssistantResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteAssistantResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteAssistantResponseObject {
            #[default]
            #[serde(rename = "assistant.deleted")]
            AssistantDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteAssistantResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteAssistantResponseObject,
        }
        let Self { id, deleted } = self;
        DeleteAssistantResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteAssistantResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteCertificateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, must be `certificate.deleted`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteCertificateResponseObject {
            #[default]
            #[serde(rename = "certificate.deleted")]
            CertificateDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteCertificateResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteCertificateResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let DeleteCertificateResponse { id, .. } =
            DeleteCertificateResponse::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for DeleteCertificateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, must be `certificate.deleted`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteCertificateResponseObject {
            #[default]
            #[serde(rename = "certificate.deleted")]
            CertificateDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteCertificateResponse<'a> {
            #[serde(rename = "object")]
            object: &'a DeleteCertificateResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self { id } = self;
        DeleteCertificateResponse {
            object: &Default::default(),
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteCertificateResponse {
    #[doc = "The ID of the certificate that was deleted."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for DeleteFileResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteFileResponseObject {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteFileResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteFileResponseObject,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let DeleteFileResponse { id, deleted, .. } = DeleteFileResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteFileResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteFileResponseObject {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteFileResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a DeleteFileResponseObject,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        DeleteFileResponse {
            id,
            object: &Default::default(),
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteFileResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteFineTuningCheckpointPermissionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"checkpoint.permission\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteFineTuningCheckpointPermissionResponseObject {
            #[default]
            #[serde(rename = "checkpoint.permission")]
            CheckpointPermission,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteFineTuningCheckpointPermissionResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteFineTuningCheckpointPermissionResponseObject,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let DeleteFineTuningCheckpointPermissionResponse { id, deleted, .. } =
            DeleteFineTuningCheckpointPermissionResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteFineTuningCheckpointPermissionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"checkpoint.permission\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteFineTuningCheckpointPermissionResponseObject {
            #[default]
            #[serde(rename = "checkpoint.permission")]
            CheckpointPermission,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteFineTuningCheckpointPermissionResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a DeleteFineTuningCheckpointPermissionResponseObject,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        DeleteFineTuningCheckpointPermissionResponse {
            id,
            object: &Default::default(),
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteFineTuningCheckpointPermissionResponse {
    #[doc = "The ID of the fine-tuned model checkpoint permission that was deleted."]
    pub id: String,
    #[doc = "Whether the fine-tuned model checkpoint permission was successfully deleted."]
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteMessageResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteMessageResponseObject {
            #[default]
            #[serde(rename = "thread.message.deleted")]
            ThreadMessageDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteMessageResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteMessageResponseObject,
        }
        let DeleteMessageResponse { id, deleted, .. } =
            DeleteMessageResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteMessageResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteMessageResponseObject {
            #[default]
            #[serde(rename = "thread.message.deleted")]
            ThreadMessageDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteMessageResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteMessageResponseObject,
        }
        let Self { id, deleted } = self;
        DeleteMessageResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteMessageResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteModelResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteModelResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
        }
        let DeleteModelResponse {
            id,
            deleted,
            object,
            ..
        } = DeleteModelResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            deleted,
            object,
        })
    }
}
impl serde::Serialize for DeleteModelResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteModelResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a String,
        }
        let Self {
            id,
            deleted,
            object,
        } = self;
        DeleteModelResponse {
            id,
            deleted,
            object,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteModelResponse {
    pub id: String,
    pub deleted: bool,
    pub object: String,
}
impl<'de> serde::Deserialize<'de> for DeleteThreadResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteThreadResponseObject {
            #[default]
            #[serde(rename = "thread.deleted")]
            ThreadDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteThreadResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteThreadResponseObject,
        }
        let DeleteThreadResponse { id, deleted, .. } =
            DeleteThreadResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteThreadResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteThreadResponseObject {
            #[default]
            #[serde(rename = "thread.deleted")]
            ThreadDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteThreadResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteThreadResponseObject,
        }
        let Self { id, deleted } = self;
        DeleteThreadResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteThreadResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteVectorStoreFileResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteVectorStoreFileResponseObject {
            #[default]
            #[serde(rename = "vector_store.file.deleted")]
            VectorStoreFileDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteVectorStoreFileResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteVectorStoreFileResponseObject,
        }
        let DeleteVectorStoreFileResponse { id, deleted, .. } =
            DeleteVectorStoreFileResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteVectorStoreFileResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteVectorStoreFileResponseObject {
            #[default]
            #[serde(rename = "vector_store.file.deleted")]
            VectorStoreFileDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteVectorStoreFileResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteVectorStoreFileResponseObject,
        }
        let Self { id, deleted } = self;
        DeleteVectorStoreFileResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteVectorStoreFileResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteVectorStoreResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteVectorStoreResponseObject {
            #[default]
            #[serde(rename = "vector_store.deleted")]
            VectorStoreDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteVectorStoreResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: DeleteVectorStoreResponseObject,
        }
        let DeleteVectorStoreResponse { id, deleted, .. } =
            DeleteVectorStoreResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteVectorStoreResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DeleteVectorStoreResponseObject {
            #[default]
            #[serde(rename = "vector_store.deleted")]
            VectorStoreDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteVectorStoreResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a DeleteVectorStoreResponseObject,
        }
        let Self { id, deleted } = self;
        DeleteVectorStoreResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteVectorStoreResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoneEventEvent {
            #[default]
            #[serde(rename = "done")]
            Done,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoneEventData {
            #[default]
            #[serde(rename = "[DONE]")]
            Done,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DoneEvent {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: DoneEventEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: DoneEventData,
        }
        let DoneEvent { .. } = DoneEvent::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for DoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoneEventEvent {
            #[default]
            #[serde(rename = "done")]
            Done,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoneEventData {
            #[default]
            #[serde(rename = "[DONE]")]
            Done,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DoneEvent<'a> {
            #[serde(rename = "event")]
            event: &'a DoneEventEvent,
            #[serde(rename = "data")]
            data: &'a DoneEventData,
        }
        let Self {} = self;
        DoneEvent {
            event: &Default::default(),
            data: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a stream ends."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct DoneEvent {}
impl<'de> serde::Deserialize<'de> for DoubleClick {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a double click action, this property is \nalways set to `double_click`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoubleClickType {
            #[default]
            #[serde(rename = "double_click")]
            DoubleClick,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DoubleClick {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: DoubleClickType,
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
        }
        let DoubleClick { x, y, .. } = DoubleClick::deserialize(deserializer)?;
        Ok(Self { x, y })
    }
}
impl serde::Serialize for DoubleClick {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a double click action, this property is \nalways set to `double_click`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DoubleClickType {
            #[default]
            #[serde(rename = "double_click")]
            DoubleClick,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DoubleClick<'a> {
            #[serde(rename = "type")]
            type_: &'a DoubleClickType,
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
        }
        let Self { x, y } = self;
        DoubleClick {
            type_: &Default::default(),
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[doc = "A double click action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct DoubleClick {
    #[doc = "The x-coordinate where the double click occurred.\n"]
    pub x: u64,
    #[doc = "The y-coordinate where the double click occurred.\n"]
    pub y: u64,
}
impl<'de> serde::Deserialize<'de> for Drag {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a drag action, this property is \nalways set to `drag`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DragType {
            #[default]
            #[serde(rename = "drag")]
            Drag,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Drag {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: DragType,
            #[serde(rename = "path")]
            #[allow(dead_code)]
            path: Vec<Coordinate>,
        }
        let Drag { path, .. } = Drag::deserialize(deserializer)?;
        Ok(Self { path })
    }
}
impl serde::Serialize for Drag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a drag action, this property is \nalways set to `drag`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum DragType {
            #[default]
            #[serde(rename = "drag")]
            Drag,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Drag<'a> {
            #[serde(rename = "type")]
            type_: &'a DragType,
            #[serde(rename = "path")]
            path: &'a Vec<Coordinate>,
        }
        let Self { path } = self;
        Drag {
            type_: &Default::default(),
            path,
        }
        .serialize(serializer)
    }
}
#[doc = "A drag action.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Drag {
    #[doc = "An array of coordinates representing the path of the drag action. Coordinates will appear as an array\nof objects, eg\n```\n[\n  { x: 100, y: 200 },\n  { x: 200, y: 300 }\n]\n```\n"]
    pub path: Vec<Coordinate>,
}
impl<'de> serde::Deserialize<'de> for EasyInputMessageRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum EasyInputMessageRole {
            User(#[allow(dead_code)] EasyInputMessageRoleUser),
            Assistant(#[allow(dead_code)] EasyInputMessageRoleAssistant),
            System(#[allow(dead_code)] EasyInputMessageRoleSystem),
            Developer(#[allow(dead_code)] EasyInputMessageRoleDeveloper),
        }
        Ok(match EasyInputMessageRole::deserialize(deserializer)? {
            EasyInputMessageRole::User(_) => Self::User,
            EasyInputMessageRole::Assistant(_) => Self::Assistant,
            EasyInputMessageRole::System(_) => Self::System,
            EasyInputMessageRole::Developer(_) => Self::Developer,
        })
    }
}
impl serde::Serialize for EasyInputMessageRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EasyInputMessageRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum EasyInputMessageRole<'a> {
            User(#[allow(dead_code)] &'a EasyInputMessageRoleUser),
            Assistant(#[allow(dead_code)] &'a EasyInputMessageRoleAssistant),
            System(#[allow(dead_code)] &'a EasyInputMessageRoleSystem),
            Developer(#[allow(dead_code)] &'a EasyInputMessageRoleDeveloper),
        }
        match self {
            Self::User => EasyInputMessageRole::User(&Default::default()).serialize(serializer),
            Self::Assistant => {
                EasyInputMessageRole::Assistant(&Default::default()).serialize(serializer)
            }
            Self::System => EasyInputMessageRole::System(&Default::default()).serialize(serializer),
            Self::Developer => {
                EasyInputMessageRole::Developer(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum EasyInputMessageRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "system"]
    System,
    #[doc = "developer"]
    Developer,
}
impl<'de> serde::Deserialize<'de> for EasyInputMessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum EasyInputMessageContent {
            Other(#[allow(dead_code)] String),
            InputMessageContentList(#[allow(dead_code)] InputMessageContentList),
        }
        Ok(match EasyInputMessageContent::deserialize(deserializer)? {
            EasyInputMessageContent::Other(_v) => Self::Other(_v),
            EasyInputMessageContent::InputMessageContentList(_v) => {
                Self::InputMessageContentList(_v)
            }
        })
    }
}
impl serde::Serialize for EasyInputMessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum EasyInputMessageContent<'a> {
            Other(#[allow(dead_code)] &'a String),
            InputMessageContentList(#[allow(dead_code)] &'a InputMessageContentList),
        }
        match self {
            Self::Other(_v) => EasyInputMessageContent::Other(_v).serialize(serializer),
            Self::InputMessageContentList(_v) => {
                EasyInputMessageContent::InputMessageContentList(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EasyInputMessageContent {
    #[doc = "A text input to the model.\n"]
    Other(String),
    InputMessageContentList(InputMessageContentList),
}
#[doc = "The type of the message input. Always `message`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum EasyInputMessageType {
    #[default]
    #[serde(rename = "message")]
    Message,
}
impl<'de> serde::Deserialize<'de> for EasyInputMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EasyInputMessage {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: EasyInputMessageRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: EasyInputMessageContent,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<EasyInputMessageType>,
        }
        let EasyInputMessage {
            role,
            content,
            type_,
            ..
        } = EasyInputMessage::deserialize(deserializer)?;
        Ok(Self {
            role,
            content,
            type_,
        })
    }
}
impl serde::Serialize for EasyInputMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EasyInputMessage<'a> {
            #[serde(rename = "role")]
            role: &'a EasyInputMessageRole,
            #[serde(rename = "content")]
            content: &'a EasyInputMessageContent,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<EasyInputMessageType>,
        }
        let Self {
            role,
            content,
            type_,
        } = self;
        EasyInputMessage {
            role,
            content,
            type_,
        }
        .serialize(serializer)
    }
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EasyInputMessage {
    #[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
    pub role: EasyInputMessageRole,
    #[doc = "Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n"]
    pub content: EasyInputMessageContent,
    #[doc = "The type of the message input. Always `message`.\n"]
    #[builder(default)]
    pub type_: Option<EasyInputMessageType>,
}
impl<'de> serde::Deserialize<'de> for Embedding {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"embedding\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EmbeddingObject {
            #[default]
            #[serde(rename = "embedding")]
            Embedding,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Embedding {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "embedding")]
            #[allow(dead_code)]
            embedding: Vec<f64>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EmbeddingObject,
        }
        let Embedding {
            index, embedding, ..
        } = Embedding::deserialize(deserializer)?;
        Ok(Self { index, embedding })
    }
}
impl serde::Serialize for Embedding {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"embedding\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EmbeddingObject {
            #[default]
            #[serde(rename = "embedding")]
            Embedding,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Embedding<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "embedding")]
            embedding: &'a Vec<f64>,
            #[serde(rename = "object")]
            object: &'a EmbeddingObject,
        }
        let Self { index, embedding } = self;
        Embedding {
            index,
            embedding,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an embedding vector returned by embedding endpoint.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Embedding {
    #[doc = "The index of the embedding in the list of embeddings."]
    pub index: u64,
    #[doc = "The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).\n"]
    pub embedding: Vec<f64>,
}
impl<'de> serde::Deserialize<'de> for Error {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Error {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: String,
        }
        let Error {
            code,
            message,
            param,
            type_,
            ..
        } = Error::deserialize(deserializer)?;
        Ok(Self {
            code,
            message,
            param,
            type_,
        })
    }
}
impl serde::Serialize for Error {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Error<'a> {
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a String,
        }
        let Self {
            code,
            message,
            param,
            type_,
        } = self;
        Error {
            code,
            message,
            param,
            type_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Error {
    #[builder(default)]
    pub code: Option<String>,
    pub message: String,
    #[builder(default)]
    pub param: Option<String>,
    pub type_: String,
}
impl<'de> serde::Deserialize<'de> for ErrorEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ErrorEventEvent {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ErrorEvent {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: ErrorEventEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Error,
        }
        let ErrorEvent { data, .. } = ErrorEvent::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for ErrorEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ErrorEventEvent {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ErrorEvent<'a> {
            #[serde(rename = "event")]
            event: &'a ErrorEventEvent,
            #[serde(rename = "data")]
            data: &'a Error,
        }
        let Self { data } = self;
        ErrorEvent {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when an [error](https://platform.openai.com/docs/guides/error-codes#api-errors) occurs. This can happen due to an internal server error or a timeout."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ErrorEvent {
    pub data: Error,
}
impl<'de> serde::Deserialize<'de> for ErrorResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ErrorResponse {
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Error,
        }
        let ErrorResponse { error, .. } = ErrorResponse::deserialize(deserializer)?;
        Ok(Self { error })
    }
}
impl serde::Serialize for ErrorResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ErrorResponse<'a> {
            #[serde(rename = "error")]
            error: &'a Error,
        }
        let Self { error } = self;
        ErrorResponse { error }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ErrorResponse {
    pub error: Error,
}
impl<'de> serde::Deserialize<'de> for EvalDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum EvalDataSourceConfig {
            Custom(#[allow(dead_code)] EvalCustomDataSourceConfig),
            Logs(#[allow(dead_code)] EvalLogsDataSourceConfig),
            StoredCompletions(#[allow(dead_code)] EvalStoredCompletionsDataSourceConfig),
        }
        Ok(match EvalDataSourceConfig::deserialize(deserializer)? {
            EvalDataSourceConfig::Custom(_v) => Self::Custom(_v),
            EvalDataSourceConfig::Logs(_v) => Self::Logs(_v),
            EvalDataSourceConfig::StoredCompletions(_v) => Self::StoredCompletions(_v),
        })
    }
}
impl serde::Serialize for EvalDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum EvalDataSourceConfig<'a> {
            Custom(#[allow(dead_code)] &'a EvalCustomDataSourceConfig),
            Logs(#[allow(dead_code)] &'a EvalLogsDataSourceConfig),
            StoredCompletions(#[allow(dead_code)] &'a EvalStoredCompletionsDataSourceConfig),
        }
        match self {
            Self::Custom(_v) => EvalDataSourceConfig::Custom(_v).serialize(serializer),
            Self::Logs(_v) => EvalDataSourceConfig::Logs(_v).serialize(serializer),
            Self::StoredCompletions(_v) => {
                EvalDataSourceConfig::StoredCompletions(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Configuration of data sources used in runs of the evaluation."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EvalDataSourceConfig {
    Custom(EvalCustomDataSourceConfig),
    Logs(EvalLogsDataSourceConfig),
    StoredCompletions(EvalStoredCompletionsDataSourceConfig),
}
impl<'de> serde::Deserialize<'de> for EvalTestingCriteria {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum EvalTestingCriteria {
            LabelModel(#[allow(dead_code)] EvalGraderLabelModel),
            StringCheck(#[allow(dead_code)] EvalGraderStringCheck),
            TextSimilarity(#[allow(dead_code)] EvalGraderTextSimilarity),
            Python(#[allow(dead_code)] EvalGraderPython),
            ScoreModel(#[allow(dead_code)] EvalGraderScoreModel),
        }
        Ok(match EvalTestingCriteria::deserialize(deserializer)? {
            EvalTestingCriteria::LabelModel(_v) => Self::LabelModel(_v),
            EvalTestingCriteria::StringCheck(_v) => Self::StringCheck(_v),
            EvalTestingCriteria::TextSimilarity(_v) => Self::TextSimilarity(_v),
            EvalTestingCriteria::Python(_v) => Self::Python(_v),
            EvalTestingCriteria::ScoreModel(_v) => Self::ScoreModel(_v),
        })
    }
}
impl serde::Serialize for EvalTestingCriteria {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum EvalTestingCriteria<'a> {
            LabelModel(#[allow(dead_code)] &'a EvalGraderLabelModel),
            StringCheck(#[allow(dead_code)] &'a EvalGraderStringCheck),
            TextSimilarity(#[allow(dead_code)] &'a EvalGraderTextSimilarity),
            Python(#[allow(dead_code)] &'a EvalGraderPython),
            ScoreModel(#[allow(dead_code)] &'a EvalGraderScoreModel),
        }
        match self {
            Self::LabelModel(_v) => EvalTestingCriteria::LabelModel(_v).serialize(serializer),
            Self::StringCheck(_v) => EvalTestingCriteria::StringCheck(_v).serialize(serializer),
            Self::TextSimilarity(_v) => {
                EvalTestingCriteria::TextSimilarity(_v).serialize(serializer)
            }
            Self::Python(_v) => EvalTestingCriteria::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => EvalTestingCriteria::ScoreModel(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EvalTestingCriteria {
    LabelModel(EvalGraderLabelModel),
    StringCheck(EvalGraderStringCheck),
    TextSimilarity(EvalGraderTextSimilarity),
    Python(EvalGraderPython),
    ScoreModel(EvalGraderScoreModel),
}
impl<'de> serde::Deserialize<'de> for Eval {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalObject {
            #[default]
            #[serde(rename = "eval")]
            Eval,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Eval {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "data_source_config")]
            #[allow(dead_code)]
            data_source_config: EvalDataSourceConfig,
            #[serde(rename = "testing_criteria")]
            #[allow(dead_code)]
            testing_criteria: Vec<EvalTestingCriteria>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let Eval {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
            ..
        } = Eval::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        })
    }
}
impl serde::Serialize for Eval {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalObject {
            #[default]
            #[serde(rename = "eval")]
            Eval,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Eval<'a> {
            #[serde(rename = "object")]
            object: &'a EvalObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "data_source_config")]
            data_source_config: &'a EvalDataSourceConfig,
            #[serde(rename = "testing_criteria")]
            testing_criteria: &'a Vec<EvalTestingCriteria>,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        } = self;
        Eval {
            object: &Default::default(),
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "An Eval object with a data source config and testing criteria.\nAn Eval represents a task to be done for your LLM integration.\nLike:\n - Improve the quality of my chatbot\n - See how well my chatbot handles customer support\n - Check if o4-mini is better at my usecase than gpt-4o\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Eval {
    #[doc = "Unique identifier for the evaluation."]
    pub id: String,
    #[doc = "The name of the evaluation."]
    pub name: String,
    #[doc = "Configuration of data sources used in runs of the evaluation."]
    pub data_source_config: EvalDataSourceConfig,
    #[doc = "A list of testing criteria."]
    pub testing_criteria: Vec<EvalTestingCriteria>,
    #[doc = "The Unix timestamp (in seconds) for when the eval was created."]
    pub created_at: u64,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for EvalApiError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalApiError {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let EvalApiError { code, message, .. } = EvalApiError::deserialize(deserializer)?;
        Ok(Self { code, message })
    }
}
impl serde::Serialize for EvalApiError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalApiError<'a> {
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let Self { code, message } = self;
        EvalApiError { code, message }.serialize(serializer)
    }
}
#[doc = "An object representing an error response from the Eval API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalApiError {
    #[doc = "The error code."]
    pub code: String,
    #[doc = "The error message."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for EvalCustomDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `custom`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalCustomDataSourceConfigType {
            #[default]
            #[serde(rename = "custom")]
            Custom,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalCustomDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalCustomDataSourceConfigType,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: std::collections::HashMap<String, serde_json::Value>,
        }
        let EvalCustomDataSourceConfig { schema, .. } =
            EvalCustomDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { schema })
    }
}
impl serde::Serialize for EvalCustomDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `custom`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalCustomDataSourceConfigType {
            #[default]
            #[serde(rename = "custom")]
            Custom,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalCustomDataSourceConfig<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalCustomDataSourceConfigType,
            #[serde(rename = "schema")]
            schema: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let Self { schema } = self;
        EvalCustomDataSourceConfig {
            type_: &Default::default(),
            schema,
        }
        .serialize(serializer)
    }
}
#[doc = "A CustomDataSourceConfig which specifies the schema of your `item` and optionally `sample` namespaces.\nThe response schema defines the shape of the data that will be:\n- Used to define your testing criteria and\n- What data is required when creating a run\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalCustomDataSourceConfig {
    #[doc = "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
    pub schema: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for EvalGraderLabelModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderLabelModel {
            #[serde(flatten)]
            #[allow(dead_code)]
            grader_label_model: GraderLabelModel,
        }
        let EvalGraderLabelModel {
            grader_label_model, ..
        } = EvalGraderLabelModel::deserialize(deserializer)?;
        Ok(Self { grader_label_model })
    }
}
impl serde::Serialize for EvalGraderLabelModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderLabelModel<'a> {
            #[serde(flatten)]
            grader_label_model: &'a GraderLabelModel,
        }
        let Self { grader_label_model } = self;
        EvalGraderLabelModel { grader_label_model }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderLabelModel {
    pub grader_label_model: GraderLabelModel,
}
impl<'de> serde::Deserialize<'de> for EvalGraderPython {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderPython {
            #[serde(flatten)]
            #[allow(dead_code)]
            grader_python: GraderPython,
            #[serde(rename = "pass_threshold")]
            #[allow(dead_code)]
            pass_threshold: Option<f64>,
        }
        let EvalGraderPython {
            grader_python,
            pass_threshold,
            ..
        } = EvalGraderPython::deserialize(deserializer)?;
        Ok(Self {
            grader_python,
            pass_threshold,
        })
    }
}
impl serde::Serialize for EvalGraderPython {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderPython<'a> {
            #[serde(flatten)]
            grader_python: &'a GraderPython,
            #[serde(rename = "pass_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pass_threshold: &'a Option<f64>,
        }
        let Self {
            grader_python,
            pass_threshold,
        } = self;
        EvalGraderPython {
            grader_python,
            pass_threshold,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderPython {
    pub grader_python: GraderPython,
    #[doc = "The threshold for the score."]
    #[builder(default)]
    pub pass_threshold: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for EvalGraderScoreModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderScoreModel {
            #[serde(flatten)]
            #[allow(dead_code)]
            grader_score_model: GraderScoreModel,
            #[serde(rename = "pass_threshold")]
            #[allow(dead_code)]
            pass_threshold: Option<f64>,
        }
        let EvalGraderScoreModel {
            grader_score_model,
            pass_threshold,
            ..
        } = EvalGraderScoreModel::deserialize(deserializer)?;
        Ok(Self {
            grader_score_model,
            pass_threshold,
        })
    }
}
impl serde::Serialize for EvalGraderScoreModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderScoreModel<'a> {
            #[serde(flatten)]
            grader_score_model: &'a GraderScoreModel,
            #[serde(rename = "pass_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pass_threshold: &'a Option<f64>,
        }
        let Self {
            grader_score_model,
            pass_threshold,
        } = self;
        EvalGraderScoreModel {
            grader_score_model,
            pass_threshold,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderScoreModel {
    pub grader_score_model: GraderScoreModel,
    #[doc = "The threshold for the score."]
    #[builder(default)]
    pub pass_threshold: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for EvalGraderStringCheck {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderStringCheck {
            #[serde(flatten)]
            #[allow(dead_code)]
            grader_string_check: GraderStringCheck,
        }
        let EvalGraderStringCheck {
            grader_string_check,
            ..
        } = EvalGraderStringCheck::deserialize(deserializer)?;
        Ok(Self {
            grader_string_check,
        })
    }
}
impl serde::Serialize for EvalGraderStringCheck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderStringCheck<'a> {
            #[serde(flatten)]
            grader_string_check: &'a GraderStringCheck,
        }
        let Self {
            grader_string_check,
        } = self;
        EvalGraderStringCheck {
            grader_string_check,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderStringCheck {
    pub grader_string_check: GraderStringCheck,
}
impl<'de> serde::Deserialize<'de> for EvalGraderTextSimilarity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderTextSimilarity {
            #[serde(flatten)]
            #[allow(dead_code)]
            grader_text_similarity: GraderTextSimilarity,
            #[serde(rename = "pass_threshold")]
            #[allow(dead_code)]
            pass_threshold: f64,
        }
        let EvalGraderTextSimilarity {
            grader_text_similarity,
            pass_threshold,
            ..
        } = EvalGraderTextSimilarity::deserialize(deserializer)?;
        Ok(Self {
            grader_text_similarity,
            pass_threshold,
        })
    }
}
impl serde::Serialize for EvalGraderTextSimilarity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderTextSimilarity<'a> {
            #[serde(flatten)]
            grader_text_similarity: &'a GraderTextSimilarity,
            #[serde(rename = "pass_threshold")]
            pass_threshold: &'a f64,
        }
        let Self {
            grader_text_similarity,
            pass_threshold,
        } = self;
        EvalGraderTextSimilarity {
            grader_text_similarity,
            pass_threshold,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderTextSimilarity {
    pub grader_text_similarity: GraderTextSimilarity,
    #[doc = "The threshold for the score."]
    pub pass_threshold: f64,
}
impl<'de> serde::Deserialize<'de> for EvalItemRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum EvalItemRole {
            User(#[allow(dead_code)] EvalItemRoleUser),
            Assistant(#[allow(dead_code)] EvalItemRoleAssistant),
            System(#[allow(dead_code)] EvalItemRoleSystem),
            Developer(#[allow(dead_code)] EvalItemRoleDeveloper),
        }
        Ok(match EvalItemRole::deserialize(deserializer)? {
            EvalItemRole::User(_) => Self::User,
            EvalItemRole::Assistant(_) => Self::Assistant,
            EvalItemRole::System(_) => Self::System,
            EvalItemRole::Developer(_) => Self::Developer,
        })
    }
}
impl serde::Serialize for EvalItemRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum EvalItemRole<'a> {
            User(#[allow(dead_code)] &'a EvalItemRoleUser),
            Assistant(#[allow(dead_code)] &'a EvalItemRoleAssistant),
            System(#[allow(dead_code)] &'a EvalItemRoleSystem),
            Developer(#[allow(dead_code)] &'a EvalItemRoleDeveloper),
        }
        match self {
            Self::User => EvalItemRole::User(&Default::default()).serialize(serializer),
            Self::Assistant => EvalItemRole::Assistant(&Default::default()).serialize(serializer),
            Self::System => EvalItemRole::System(&Default::default()).serialize(serializer),
            Self::Developer => EvalItemRole::Developer(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum EvalItemRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "system"]
    System,
    #[doc = "developer"]
    Developer,
}
impl<'de> serde::Deserialize<'de> for EvalItemContentOutputText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the output text. Always `output_text`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemContentOutputTextType {
            #[default]
            #[serde(rename = "output_text")]
            OutputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalItemContentOutputText {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalItemContentOutputTextType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let EvalItemContentOutputText { text, .. } =
            EvalItemContentOutputText::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for EvalItemContentOutputText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the output text. Always `output_text`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalItemContentOutputTextType {
            #[default]
            #[serde(rename = "output_text")]
            OutputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalItemContentOutputText<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalItemContentOutputTextType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        EvalItemContentOutputText {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "A text output from the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalItemContentOutputText {
    #[doc = "The text output from the model.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for EvalItemContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum EvalItemContent {
            String(#[allow(dead_code)] String),
            InputText(#[allow(dead_code)] InputTextContent),
            OutputText(#[allow(dead_code)] EvalItemContentOutputText),
        }
        Ok(match EvalItemContent::deserialize(deserializer)? {
            EvalItemContent::String(_v) => Self::String(_v),
            EvalItemContent::InputText(_v) => Self::InputText(_v),
            EvalItemContent::OutputText(_v) => Self::OutputText(_v),
        })
    }
}
impl serde::Serialize for EvalItemContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum EvalItemContent<'a> {
            String(#[allow(dead_code)] &'a String),
            InputText(#[allow(dead_code)] &'a InputTextContent),
            OutputText(#[allow(dead_code)] &'a EvalItemContentOutputText),
        }
        match self {
            Self::String(_v) => EvalItemContent::String(_v).serialize(serializer),
            Self::InputText(_v) => EvalItemContent::InputText(_v).serialize(serializer),
            Self::OutputText(_v) => EvalItemContent::OutputText(_v).serialize(serializer),
        }
    }
}
#[doc = "Text inputs to the model - can contain template strings.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EvalItemContent {
    #[doc = "A text input to the model.\n"]
    String(String),
    InputText(InputTextContent),
    #[doc = "A text output from the model.\n"]
    OutputText(EvalItemContentOutputText),
}
#[doc = "The type of the message input. Always `message`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum EvalItemType {
    #[default]
    #[serde(rename = "message")]
    Message,
}
impl<'de> serde::Deserialize<'de> for EvalItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalItem {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: EvalItemRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: EvalItemContent,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<EvalItemType>,
        }
        let EvalItem {
            role,
            content,
            type_,
            ..
        } = EvalItem::deserialize(deserializer)?;
        Ok(Self {
            role,
            content,
            type_,
        })
    }
}
impl serde::Serialize for EvalItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalItem<'a> {
            #[serde(rename = "role")]
            role: &'a EvalItemRole,
            #[serde(rename = "content")]
            content: &'a EvalItemContent,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<EvalItemType>,
        }
        let Self {
            role,
            content,
            type_,
        } = self;
        EvalItem {
            role,
            content,
            type_,
        }
        .serialize(serializer)
    }
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalItem {
    #[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
    pub role: EvalItemRole,
    #[doc = "Text inputs to the model - can contain template strings.\n"]
    pub content: EvalItemContent,
    #[doc = "The type of the message input. Always `message`.\n"]
    #[builder(default)]
    pub type_: Option<EvalItemType>,
}
impl<'de> serde::Deserialize<'de> for EvalJsonlFileContentSourceContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalJsonlFileContentSourceContent {
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sample")]
            #[allow(dead_code)]
            sample: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let EvalJsonlFileContentSourceContent { item, sample, .. } =
            EvalJsonlFileContentSourceContent::deserialize(deserializer)?;
        Ok(Self { item, sample })
    }
}
impl serde::Serialize for EvalJsonlFileContentSourceContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalJsonlFileContentSourceContent<'a> {
            #[serde(rename = "item")]
            item: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sample")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sample: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self { item, sample } = self;
        EvalJsonlFileContentSourceContent { item, sample }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalJsonlFileContentSourceContent {
    pub item: std::collections::HashMap<String, serde_json::Value>,
    #[builder(default)]
    pub sample: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for EvalJsonlFileContentSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of jsonl source. Always `file_content`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalJsonlFileContentSourceType {
            #[default]
            #[serde(rename = "file_content")]
            FileContent,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalJsonlFileContentSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalJsonlFileContentSourceType,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Vec<EvalJsonlFileContentSourceContent>,
        }
        let EvalJsonlFileContentSource { content, .. } =
            EvalJsonlFileContentSource::deserialize(deserializer)?;
        Ok(Self { content })
    }
}
impl serde::Serialize for EvalJsonlFileContentSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of jsonl source. Always `file_content`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalJsonlFileContentSourceType {
            #[default]
            #[serde(rename = "file_content")]
            FileContent,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalJsonlFileContentSource<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalJsonlFileContentSourceType,
            #[serde(rename = "content")]
            content: &'a Vec<EvalJsonlFileContentSourceContent>,
        }
        let Self { content } = self;
        EvalJsonlFileContentSource {
            type_: &Default::default(),
            content,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalJsonlFileContentSource {
    #[doc = "The content of the jsonl file."]
    pub content: Vec<EvalJsonlFileContentSourceContent>,
}
impl<'de> serde::Deserialize<'de> for EvalJsonlFileIdSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of jsonl source. Always `file_id`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalJsonlFileIdSourceType {
            #[default]
            #[serde(rename = "file_id")]
            FileId,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalJsonlFileIdSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalJsonlFileIdSourceType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let EvalJsonlFileIdSource { id, .. } = EvalJsonlFileIdSource::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for EvalJsonlFileIdSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of jsonl source. Always `file_id`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalJsonlFileIdSourceType {
            #[default]
            #[serde(rename = "file_id")]
            FileId,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalJsonlFileIdSource<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalJsonlFileIdSourceType,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self { id } = self;
        EvalJsonlFileIdSource {
            type_: &Default::default(),
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalJsonlFileIdSource {
    #[doc = "The identifier of the file."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for EvalList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Eval>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let EvalList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = EvalList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalList<'a> {
            #[serde(rename = "object")]
            object: &'a EvalListObject,
            #[serde(rename = "data")]
            data: &'a Vec<Eval>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        EvalList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of evals.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalList {
    #[doc = "An array of eval objects.\n"]
    pub data: Vec<Eval>,
    #[doc = "The identifier of the first eval in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more evals available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalLogsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalLogsDataSourceConfigType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalLogsDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalLogsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: std::collections::HashMap<String, serde_json::Value>,
        }
        let EvalLogsDataSourceConfig {
            metadata, schema, ..
        } = EvalLogsDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { metadata, schema })
    }
}
impl serde::Serialize for EvalLogsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalLogsDataSourceConfigType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalLogsDataSourceConfig<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalLogsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "schema")]
            schema: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let Self { metadata, schema } = self;
        EvalLogsDataSourceConfig {
            type_: &Default::default(),
            metadata,
            schema,
        }
        .serialize(serializer)
    }
}
#[doc = "A LogsDataSourceConfig which specifies the metadata property of your logs query.\nThis is usually metadata like `usecase=chatbot` or `prompt-version=v2`, etc.\nThe schema returned by this data source config is used to defined what variables are available in your evals.\n`item` and `sample` are both defined when using this data source config.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalLogsDataSourceConfig {
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
    pub schema: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for EvalResponsesSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of run data source. Always `responses`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalResponsesSourceType {
            #[default]
            #[serde(rename = "responses")]
            Responses,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalResponsesSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalResponsesSourceType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "instructions_search")]
            #[allow(dead_code)]
            instructions_search: Option<String>,
            #[serde(rename = "created_after")]
            #[allow(dead_code)]
            created_after: Option<u64>,
            #[serde(rename = "created_before")]
            #[allow(dead_code)]
            created_before: Option<u64>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "users")]
            #[allow(dead_code)]
            users: Option<Vec<String>>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<String>>,
        }
        let EvalResponsesSource {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            reasoning_effort,
            temperature,
            top_p,
            users,
            tools,
            ..
        } = EvalResponsesSource::deserialize(deserializer)?;
        Ok(Self {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            reasoning_effort,
            temperature,
            top_p,
            users,
            tools,
        })
    }
}
impl serde::Serialize for EvalResponsesSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of run data source. Always `responses`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalResponsesSourceType {
            #[default]
            #[serde(rename = "responses")]
            Responses,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalResponsesSource<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalResponsesSourceType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "instructions_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions_search: &'a Option<String>,
            #[serde(rename = "created_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_after: &'a Option<u64>,
            #[serde(rename = "created_before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_before: &'a Option<u64>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "users")]
            #[serde(skip_serializing_if = "Option::is_none")]
            users: &'a Option<Vec<String>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<String>>,
        }
        let Self {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            reasoning_effort,
            temperature,
            top_p,
            users,
            tools,
        } = self;
        EvalResponsesSource {
            type_: &Default::default(),
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            reasoning_effort,
            temperature,
            top_p,
            users,
            tools,
        }
        .serialize(serializer)
    }
}
#[doc = "A EvalResponsesSource object describing a run data source configuration.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct EvalResponsesSource {
    #[doc = "Metadata filter for the responses. This is a query parameter used to select responses."]
    #[builder(default)]
    pub metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[doc = "The name of the model to find responses for. This is a query parameter used to select responses."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Optional string to search the 'instructions' field. This is a query parameter used to select responses."]
    #[builder(default)]
    pub instructions_search: Option<String>,
    #[doc = "Only include items created after this timestamp (inclusive). This is a query parameter used to select responses."]
    #[builder(default)]
    pub created_after: Option<u64>,
    #[doc = "Only include items created before this timestamp (inclusive). This is a query parameter used to select responses."]
    #[builder(default)]
    pub created_before: Option<u64>,
    #[doc = "Optional reasoning effort parameter. This is a query parameter used to select responses."]
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "Sampling temperature. This is a query parameter used to select responses."]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Nucleus sampling parameter. This is a query parameter used to select responses."]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "List of user identifiers. This is a query parameter used to select responses."]
    #[builder(default)]
    pub users: Option<Vec<String>>,
    #[doc = "List of tool names. This is a query parameter used to select responses."]
    #[builder(default)]
    pub tools: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for EvalRunResultCounts {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunResultCounts {
            #[serde(rename = "total")]
            #[allow(dead_code)]
            total: u64,
            #[serde(rename = "errored")]
            #[allow(dead_code)]
            errored: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
            #[serde(rename = "passed")]
            #[allow(dead_code)]
            passed: u64,
        }
        let EvalRunResultCounts {
            total,
            errored,
            failed,
            passed,
            ..
        } = EvalRunResultCounts::deserialize(deserializer)?;
        Ok(Self {
            total,
            errored,
            failed,
            passed,
        })
    }
}
impl serde::Serialize for EvalRunResultCounts {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunResultCounts<'a> {
            #[serde(rename = "total")]
            total: &'a u64,
            #[serde(rename = "errored")]
            errored: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
            #[serde(rename = "passed")]
            passed: &'a u64,
        }
        let Self {
            total,
            errored,
            failed,
            passed,
        } = self;
        EvalRunResultCounts {
            total,
            errored,
            failed,
            passed,
        }
        .serialize(serializer)
    }
}
#[doc = "Counters summarizing the outcomes of the evaluation run."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct EvalRunResultCounts {
    #[doc = "Total number of executed output items."]
    pub total: u64,
    #[doc = "Number of output items that resulted in an error."]
    pub errored: u64,
    #[doc = "Number of output items that failed to pass the evaluation."]
    pub failed: u64,
    #[doc = "Number of output items that passed the evaluation."]
    pub passed: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunPerModelUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunPerModelUsage {
            #[serde(rename = "model_name")]
            #[allow(dead_code)]
            model_name: String,
            #[serde(rename = "invocation_count")]
            #[allow(dead_code)]
            invocation_count: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: u64,
        }
        let EvalRunPerModelUsage {
            model_name,
            invocation_count,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            cached_tokens,
            ..
        } = EvalRunPerModelUsage::deserialize(deserializer)?;
        Ok(Self {
            model_name,
            invocation_count,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            cached_tokens,
        })
    }
}
impl serde::Serialize for EvalRunPerModelUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunPerModelUsage<'a> {
            #[serde(rename = "model_name")]
            model_name: &'a String,
            #[serde(rename = "invocation_count")]
            invocation_count: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
            #[serde(rename = "cached_tokens")]
            cached_tokens: &'a u64,
        }
        let Self {
            model_name,
            invocation_count,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            cached_tokens,
        } = self;
        EvalRunPerModelUsage {
            model_name,
            invocation_count,
            prompt_tokens,
            completion_tokens,
            total_tokens,
            cached_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunPerModelUsage {
    #[doc = "The name of the model."]
    pub model_name: String,
    #[doc = "The number of invocations."]
    pub invocation_count: u64,
    #[doc = "The number of prompt tokens used."]
    pub prompt_tokens: u64,
    #[doc = "The number of completion tokens generated."]
    pub completion_tokens: u64,
    #[doc = "The total number of tokens used."]
    pub total_tokens: u64,
    #[doc = "The number of tokens retrieved from cache."]
    pub cached_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunPerTestingCriteriaResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunPerTestingCriteriaResult {
            #[serde(rename = "testing_criteria")]
            #[allow(dead_code)]
            testing_criteria: String,
            #[serde(rename = "passed")]
            #[allow(dead_code)]
            passed: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
        }
        let EvalRunPerTestingCriteriaResult {
            testing_criteria,
            passed,
            failed,
            ..
        } = EvalRunPerTestingCriteriaResult::deserialize(deserializer)?;
        Ok(Self {
            testing_criteria,
            passed,
            failed,
        })
    }
}
impl serde::Serialize for EvalRunPerTestingCriteriaResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunPerTestingCriteriaResult<'a> {
            #[serde(rename = "testing_criteria")]
            testing_criteria: &'a String,
            #[serde(rename = "passed")]
            passed: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
        }
        let Self {
            testing_criteria,
            passed,
            failed,
        } = self;
        EvalRunPerTestingCriteriaResult {
            testing_criteria,
            passed,
            failed,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunPerTestingCriteriaResult {
    #[doc = "A description of the testing criteria."]
    pub testing_criteria: String,
    #[doc = "Number of tests passed for this criteria."]
    pub passed: u64,
    #[doc = "Number of tests failed for this criteria."]
    pub failed: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum EvalRunDataSource {
            Jsonl(#[allow(dead_code)] CreateEvalJsonlRunDataSource),
            Completions(#[allow(dead_code)] CreateEvalCompletionsRunDataSource),
            Responses(#[allow(dead_code)] CreateEvalResponsesRunDataSource),
        }
        Ok(match EvalRunDataSource::deserialize(deserializer)? {
            EvalRunDataSource::Jsonl(_v) => Self::Jsonl(_v),
            EvalRunDataSource::Completions(_v) => Self::Completions(_v),
            EvalRunDataSource::Responses(_v) => Self::Responses(_v),
        })
    }
}
impl serde::Serialize for EvalRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum EvalRunDataSource<'a> {
            Jsonl(#[allow(dead_code)] &'a CreateEvalJsonlRunDataSource),
            Completions(#[allow(dead_code)] &'a CreateEvalCompletionsRunDataSource),
            Responses(#[allow(dead_code)] &'a CreateEvalResponsesRunDataSource),
        }
        match self {
            Self::Jsonl(_v) => EvalRunDataSource::Jsonl(_v).serialize(serializer),
            Self::Completions(_v) => EvalRunDataSource::Completions(_v).serialize(serializer),
            Self::Responses(_v) => EvalRunDataSource::Responses(_v).serialize(serializer),
        }
    }
}
#[doc = "Information about the run's data source."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum EvalRunDataSource {
    Jsonl(CreateEvalJsonlRunDataSource),
    Completions(CreateEvalCompletionsRunDataSource),
    Responses(CreateEvalResponsesRunDataSource),
}
impl<'de> serde::Deserialize<'de> for EvalRun {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the object. Always \"eval.run\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunObject {
            #[default]
            #[serde(rename = "eval.run")]
            EvalRun,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRun {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalRunObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "eval_id")]
            #[allow(dead_code)]
            eval_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "report_url")]
            #[allow(dead_code)]
            report_url: String,
            #[serde(rename = "result_counts")]
            #[allow(dead_code)]
            result_counts: EvalRunResultCounts,
            #[serde(rename = "per_model_usage")]
            #[allow(dead_code)]
            per_model_usage: Vec<EvalRunPerModelUsage>,
            #[serde(rename = "per_testing_criteria_results")]
            #[allow(dead_code)]
            per_testing_criteria_results: Vec<EvalRunPerTestingCriteriaResult>,
            #[serde(rename = "data_source")]
            #[allow(dead_code)]
            data_source: EvalRunDataSource,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: EvalApiError,
        }
        let EvalRun {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
            ..
        } = EvalRun::deserialize(deserializer)?;
        Ok(Self {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        })
    }
}
impl serde::Serialize for EvalRun {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the object. Always \"eval.run\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunObject {
            #[default]
            #[serde(rename = "eval.run")]
            EvalRun,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRun<'a> {
            #[serde(rename = "object")]
            object: &'a EvalRunObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "eval_id")]
            eval_id: &'a String,
            #[serde(rename = "status")]
            status: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "report_url")]
            report_url: &'a String,
            #[serde(rename = "result_counts")]
            result_counts: &'a EvalRunResultCounts,
            #[serde(rename = "per_model_usage")]
            per_model_usage: &'a Vec<EvalRunPerModelUsage>,
            #[serde(rename = "per_testing_criteria_results")]
            per_testing_criteria_results: &'a Vec<EvalRunPerTestingCriteriaResult>,
            #[serde(rename = "data_source")]
            data_source: &'a EvalRunDataSource,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "error")]
            error: &'a EvalApiError,
        }
        let Self {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        } = self;
        EvalRun {
            object: &Default::default(),
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "A schema representing an evaluation run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRun {
    #[doc = "Unique identifier for the evaluation run."]
    pub id: String,
    #[doc = "The identifier of the associated evaluation."]
    pub eval_id: String,
    #[doc = "The status of the evaluation run."]
    pub status: String,
    #[doc = "The model that is evaluated, if applicable."]
    pub model: String,
    #[doc = "The name of the evaluation run."]
    pub name: String,
    #[doc = "Unix timestamp (in seconds) when the evaluation run was created."]
    pub created_at: u64,
    #[doc = "The URL to the rendered evaluation run report on the UI dashboard."]
    pub report_url: String,
    #[doc = "Counters summarizing the outcomes of the evaluation run."]
    pub result_counts: EvalRunResultCounts,
    #[doc = "Usage statistics for each model during the evaluation run."]
    pub per_model_usage: Vec<EvalRunPerModelUsage>,
    #[doc = "Results per testing criteria applied during the evaluation run."]
    pub per_testing_criteria_results: Vec<EvalRunPerTestingCriteriaResult>,
    #[doc = "Information about the run's data source."]
    pub data_source: EvalRunDataSource,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    pub error: EvalApiError,
}
impl<'de> serde::Deserialize<'de> for EvalRunList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalRunListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<EvalRun>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let EvalRunList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = EvalRunList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalRunList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunList<'a> {
            #[serde(rename = "object")]
            object: &'a EvalRunListObject,
            #[serde(rename = "data")]
            data: &'a Vec<EvalRun>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        EvalRunList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of runs for an evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunList {
    #[doc = "An array of eval run objects.\n"]
    pub data: Vec<EvalRun>,
    #[doc = "The identifier of the first eval run in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval run in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more evals available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemSampleInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunOutputItemSampleInput {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: String,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: String,
        }
        let EvalRunOutputItemSampleInput { role, content, .. } =
            EvalRunOutputItemSampleInput::deserialize(deserializer)?;
        Ok(Self { role, content })
    }
}
impl serde::Serialize for EvalRunOutputItemSampleInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunOutputItemSampleInput<'a> {
            #[serde(rename = "role")]
            role: &'a String,
            #[serde(rename = "content")]
            content: &'a String,
        }
        let Self { role, content } = self;
        EvalRunOutputItemSampleInput { role, content }.serialize(serializer)
    }
}
#[doc = "An input message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemSampleInput {
    #[doc = "The role of the message sender (e.g., system, user, developer)."]
    pub role: String,
    #[doc = "The content of the message."]
    pub content: String,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemSampleOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunOutputItemSampleOutput {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<String>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<String>,
        }
        let EvalRunOutputItemSampleOutput { role, content, .. } =
            EvalRunOutputItemSampleOutput::deserialize(deserializer)?;
        Ok(Self { role, content })
    }
}
impl serde::Serialize for EvalRunOutputItemSampleOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunOutputItemSampleOutput<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<String>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
        }
        let Self { role, content } = self;
        EvalRunOutputItemSampleOutput { role, content }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemSampleOutput {
    #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
    #[builder(default)]
    pub role: Option<String>,
    #[doc = "The content of the message."]
    #[builder(default)]
    pub content: Option<String>,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemSampleUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunOutputItemSampleUsage {
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: u64,
        }
        let EvalRunOutputItemSampleUsage {
            total_tokens,
            completion_tokens,
            prompt_tokens,
            cached_tokens,
            ..
        } = EvalRunOutputItemSampleUsage::deserialize(deserializer)?;
        Ok(Self {
            total_tokens,
            completion_tokens,
            prompt_tokens,
            cached_tokens,
        })
    }
}
impl serde::Serialize for EvalRunOutputItemSampleUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunOutputItemSampleUsage<'a> {
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "cached_tokens")]
            cached_tokens: &'a u64,
        }
        let Self {
            total_tokens,
            completion_tokens,
            prompt_tokens,
            cached_tokens,
        } = self;
        EvalRunOutputItemSampleUsage {
            total_tokens,
            completion_tokens,
            prompt_tokens,
            cached_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Token usage details for the sample."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemSampleUsage {
    #[doc = "The total number of tokens used."]
    pub total_tokens: u64,
    #[doc = "The number of completion tokens generated."]
    pub completion_tokens: u64,
    #[doc = "The number of prompt tokens used."]
    pub prompt_tokens: u64,
    #[doc = "The number of tokens retrieved from cache."]
    pub cached_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemSample {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunOutputItemSample {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Vec<EvalRunOutputItemSampleInput>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Vec<EvalRunOutputItemSampleOutput>,
            #[serde(rename = "finish_reason")]
            #[allow(dead_code)]
            finish_reason: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: EvalRunOutputItemSampleUsage,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: EvalApiError,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: f64,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: u64,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: f64,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: u64,
        }
        let EvalRunOutputItemSample {
            input,
            output,
            finish_reason,
            model,
            usage,
            error,
            temperature,
            max_completion_tokens,
            top_p,
            seed,
            ..
        } = EvalRunOutputItemSample::deserialize(deserializer)?;
        Ok(Self {
            input,
            output,
            finish_reason,
            model,
            usage,
            error,
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        })
    }
}
impl serde::Serialize for EvalRunOutputItemSample {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunOutputItemSample<'a> {
            #[serde(rename = "input")]
            input: &'a Vec<EvalRunOutputItemSampleInput>,
            #[serde(rename = "output")]
            output: &'a Vec<EvalRunOutputItemSampleOutput>,
            #[serde(rename = "finish_reason")]
            finish_reason: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "usage")]
            usage: &'a EvalRunOutputItemSampleUsage,
            #[serde(rename = "error")]
            error: &'a EvalApiError,
            #[serde(rename = "temperature")]
            temperature: &'a f64,
            #[serde(rename = "max_completion_tokens")]
            max_completion_tokens: &'a u64,
            #[serde(rename = "top_p")]
            top_p: &'a f64,
            #[serde(rename = "seed")]
            seed: &'a u64,
        }
        let Self {
            input,
            output,
            finish_reason,
            model,
            usage,
            error,
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        } = self;
        EvalRunOutputItemSample {
            input,
            output,
            finish_reason,
            model,
            usage,
            error,
            temperature,
            max_completion_tokens,
            top_p,
            seed,
        }
        .serialize(serializer)
    }
}
#[doc = "A sample containing the input and output of the evaluation run."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemSample {
    #[doc = "An array of input messages."]
    pub input: Vec<EvalRunOutputItemSampleInput>,
    #[doc = "An array of output messages."]
    pub output: Vec<EvalRunOutputItemSampleOutput>,
    #[doc = "The reason why the sample generation was finished."]
    pub finish_reason: String,
    #[doc = "The model used for generating the sample."]
    pub model: String,
    #[doc = "Token usage details for the sample."]
    pub usage: EvalRunOutputItemSampleUsage,
    pub error: EvalApiError,
    #[doc = "The sampling temperature used."]
    pub temperature: f64,
    #[doc = "The maximum number of tokens allowed for completion."]
    pub max_completion_tokens: u64,
    #[doc = "The top_p value used for sampling."]
    pub top_p: f64,
    #[doc = "The seed used for generating the sample."]
    pub seed: u64,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the object. Always \"eval.run.output_item\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunOutputItemObject {
            #[default]
            #[serde(rename = "eval.run.output_item")]
            EvalRunOutputItem,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunOutputItem {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalRunOutputItemObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "run_id")]
            #[allow(dead_code)]
            run_id: String,
            #[serde(rename = "eval_id")]
            #[allow(dead_code)]
            eval_id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: String,
            #[serde(rename = "datasource_item_id")]
            #[allow(dead_code)]
            datasource_item_id: u64,
            #[serde(rename = "datasource_item")]
            #[allow(dead_code)]
            datasource_item: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Vec<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "sample")]
            #[allow(dead_code)]
            sample: EvalRunOutputItemSample,
        }
        let EvalRunOutputItem {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
            ..
        } = EvalRunOutputItem::deserialize(deserializer)?;
        Ok(Self {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        })
    }
}
impl serde::Serialize for EvalRunOutputItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the object. Always \"eval.run.output_item\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunOutputItemObject {
            #[default]
            #[serde(rename = "eval.run.output_item")]
            EvalRunOutputItem,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunOutputItem<'a> {
            #[serde(rename = "object")]
            object: &'a EvalRunOutputItemObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "run_id")]
            run_id: &'a String,
            #[serde(rename = "eval_id")]
            eval_id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "status")]
            status: &'a String,
            #[serde(rename = "datasource_item_id")]
            datasource_item_id: &'a u64,
            #[serde(rename = "datasource_item")]
            datasource_item: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "results")]
            results: &'a Vec<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "sample")]
            sample: &'a EvalRunOutputItemSample,
        }
        let Self {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        } = self;
        EvalRunOutputItem {
            object: &Default::default(),
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        }
        .serialize(serializer)
    }
}
#[doc = "A schema representing an evaluation run output item.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItem {
    #[doc = "Unique identifier for the evaluation run output item."]
    pub id: String,
    #[doc = "The identifier of the evaluation run associated with this output item."]
    pub run_id: String,
    #[doc = "The identifier of the evaluation group."]
    pub eval_id: String,
    #[doc = "Unix timestamp (in seconds) when the evaluation run was created."]
    pub created_at: u64,
    #[doc = "The status of the evaluation run."]
    pub status: String,
    #[doc = "The identifier for the data source item."]
    pub datasource_item_id: u64,
    #[doc = "Details of the input data source item."]
    pub datasource_item: std::collections::HashMap<String, serde_json::Value>,
    #[doc = "A list of results from the evaluation run."]
    pub results: Vec<std::collections::HashMap<String, serde_json::Value>>,
    #[doc = "A sample containing the input and output of the evaluation run."]
    pub sample: EvalRunOutputItemSample,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunOutputItemListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunOutputItemList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: EvalRunOutputItemListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<EvalRunOutputItem>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let EvalRunOutputItemList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = EvalRunOutputItemList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalRunOutputItemList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of this object. It is always set to \"list\".\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalRunOutputItemListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunOutputItemList<'a> {
            #[serde(rename = "object")]
            object: &'a EvalRunOutputItemListObject,
            #[serde(rename = "data")]
            data: &'a Vec<EvalRunOutputItem>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        EvalRunOutputItemList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing a list of output items for an evaluation run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemList {
    #[doc = "An array of eval run output item objects.\n"]
    pub data: Vec<EvalRunOutputItem>,
    #[doc = "The identifier of the first eval run output item in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval run output item in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more eval run output items available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalStoredCompletionsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of data source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStoredCompletionsDataSourceConfigType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalStoredCompletionsDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalStoredCompletionsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: std::collections::HashMap<String, serde_json::Value>,
        }
        let EvalStoredCompletionsDataSourceConfig {
            metadata, schema, ..
        } = EvalStoredCompletionsDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { metadata, schema })
    }
}
impl serde::Serialize for EvalStoredCompletionsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of data source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStoredCompletionsDataSourceConfigType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalStoredCompletionsDataSourceConfig<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalStoredCompletionsDataSourceConfigType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "schema")]
            schema: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let Self { metadata, schema } = self;
        EvalStoredCompletionsDataSourceConfig {
            type_: &Default::default(),
            metadata,
            schema,
        }
        .serialize(serializer)
    }
}
#[doc = "Deprecated in favor of LogsDataSourceConfig.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalStoredCompletionsDataSourceConfig {
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
    pub schema: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for EvalStoredCompletionsSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStoredCompletionsSourceType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalStoredCompletionsSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: EvalStoredCompletionsSourceType,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "created_after")]
            #[allow(dead_code)]
            created_after: Option<u64>,
            #[serde(rename = "created_before")]
            #[allow(dead_code)]
            created_before: Option<u64>,
            #[serde(rename = "limit")]
            #[allow(dead_code)]
            limit: Option<u64>,
        }
        let EvalStoredCompletionsSource {
            metadata,
            model,
            created_after,
            created_before,
            limit,
            ..
        } = EvalStoredCompletionsSource::deserialize(deserializer)?;
        Ok(Self {
            metadata,
            model,
            created_after,
            created_before,
            limit,
        })
    }
}
impl serde::Serialize for EvalStoredCompletionsSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of source. Always `stored_completions`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum EvalStoredCompletionsSourceType {
            #[default]
            #[serde(rename = "stored_completions")]
            StoredCompletions,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalStoredCompletionsSource<'a> {
            #[serde(rename = "type")]
            type_: &'a EvalStoredCompletionsSourceType,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "created_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_after: &'a Option<u64>,
            #[serde(rename = "created_before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_before: &'a Option<u64>,
            #[serde(rename = "limit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            limit: &'a Option<u64>,
        }
        let Self {
            metadata,
            model,
            created_after,
            created_before,
            limit,
        } = self;
        EvalStoredCompletionsSource {
            type_: &Default::default(),
            metadata,
            model,
            created_after,
            created_before,
            limit,
        }
        .serialize(serializer)
    }
}
#[doc = "A StoredCompletionsRunDataSource configuration describing a set of filters\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct EvalStoredCompletionsSource {
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "An optional model to filter by (e.g., 'gpt-4o')."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "An optional Unix timestamp to filter items created after this time."]
    #[builder(default)]
    pub created_after: Option<u64>,
    #[doc = "An optional Unix timestamp to filter items created before this time."]
    #[builder(default)]
    pub created_before: Option<u64>,
    #[doc = "An optional maximum number of items to return."]
    #[builder(default)]
    pub limit: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for FilePath {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the file path. Always `file_path`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePathType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FilePath {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FilePathType,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
        }
        let FilePath { file_id, index, .. } = FilePath::deserialize(deserializer)?;
        Ok(Self { file_id, index })
    }
}
impl serde::Serialize for FilePath {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the file path. Always `file_path`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePathType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FilePath<'a> {
            #[serde(rename = "type")]
            type_: &'a FilePathType,
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "index")]
            index: &'a u64,
        }
        let Self { file_id, index } = self;
        FilePath {
            type_: &Default::default(),
            file_id,
            index,
        }
        .serialize(serializer)
    }
}
#[doc = "A path to a file.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FilePath {
    #[doc = "The ID of the file.\n"]
    pub file_id: String,
    #[doc = "The index of the file in the list of files.\n"]
    pub index: u64,
}
impl<'de> serde::Deserialize<'de> for FileSearchRanker {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchRankerDefault2024_08_21 {
            #[default]
            #[serde(rename = "default_2024_08_21")]
            Default2024_08_21,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FileSearchRanker {
            Auto(#[allow(dead_code)] FileSearchRankerAuto),
            Default2024_08_21(#[allow(dead_code)] FileSearchRankerDefault2024_08_21),
        }
        Ok(match FileSearchRanker::deserialize(deserializer)? {
            FileSearchRanker::Auto(_) => Self::Auto,
            FileSearchRanker::Default2024_08_21(_) => Self::Default2024_08_21,
        })
    }
}
impl serde::Serialize for FileSearchRanker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchRankerDefault2024_08_21 {
            #[default]
            #[serde(rename = "default_2024_08_21")]
            Default2024_08_21,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FileSearchRanker<'a> {
            Auto(#[allow(dead_code)] &'a FileSearchRankerAuto),
            Default2024_08_21(#[allow(dead_code)] &'a FileSearchRankerDefault2024_08_21),
        }
        match self {
            Self::Auto => FileSearchRanker::Auto(&Default::default()).serialize(serializer),
            Self::Default2024_08_21 => {
                FileSearchRanker::Default2024_08_21(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The ranker to use for the file search. If not specified will use the `auto` ranker."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FileSearchRanker {
    #[doc = "auto"]
    Auto,
    #[doc = "default_2024_08_21"]
    Default2024_08_21,
}
impl<'de> serde::Deserialize<'de> for FileSearchRankingOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileSearchRankingOptions {
            #[serde(rename = "ranker")]
            #[allow(dead_code)]
            ranker: Option<FileSearchRanker>,
            #[serde(rename = "score_threshold")]
            #[allow(dead_code)]
            score_threshold: f64,
        }
        let FileSearchRankingOptions {
            ranker,
            score_threshold,
            ..
        } = FileSearchRankingOptions::deserialize(deserializer)?;
        Ok(Self {
            ranker,
            score_threshold,
        })
    }
}
impl serde::Serialize for FileSearchRankingOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileSearchRankingOptions<'a> {
            #[serde(rename = "ranker")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranker: &'a Option<FileSearchRanker>,
            #[serde(rename = "score_threshold")]
            score_threshold: &'a f64,
        }
        let Self {
            ranker,
            score_threshold,
        } = self;
        FileSearchRankingOptions {
            ranker,
            score_threshold,
        }
        .serialize(serializer)
    }
}
#[doc = "The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.\n\nSee the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct FileSearchRankingOptions {
    #[builder(default)]
    pub ranker: Option<FileSearchRanker>,
    #[doc = "The score threshold for the file search. All values must be a floating point number between 0 and 1."]
    pub score_threshold: f64,
}
impl<'de> serde::Deserialize<'de> for FileSearchToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusSearching {
            #[default]
            #[serde(rename = "searching")]
            Searching,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FileSearchToolCallStatus {
            InProgress(#[allow(dead_code)] FileSearchToolCallStatusInProgress),
            Searching(#[allow(dead_code)] FileSearchToolCallStatusSearching),
            Completed(#[allow(dead_code)] FileSearchToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] FileSearchToolCallStatusIncomplete),
            Failed(#[allow(dead_code)] FileSearchToolCallStatusFailed),
        }
        Ok(match FileSearchToolCallStatus::deserialize(deserializer)? {
            FileSearchToolCallStatus::InProgress(_) => Self::InProgress,
            FileSearchToolCallStatus::Searching(_) => Self::Searching,
            FileSearchToolCallStatus::Completed(_) => Self::Completed,
            FileSearchToolCallStatus::Incomplete(_) => Self::Incomplete,
            FileSearchToolCallStatus::Failed(_) => Self::Failed,
        })
    }
}
impl serde::Serialize for FileSearchToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusSearching {
            #[default]
            #[serde(rename = "searching")]
            Searching,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FileSearchToolCallStatus<'a> {
            InProgress(#[allow(dead_code)] &'a FileSearchToolCallStatusInProgress),
            Searching(#[allow(dead_code)] &'a FileSearchToolCallStatusSearching),
            Completed(#[allow(dead_code)] &'a FileSearchToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a FileSearchToolCallStatusIncomplete),
            Failed(#[allow(dead_code)] &'a FileSearchToolCallStatusFailed),
        }
        match self {
            Self::InProgress => {
                FileSearchToolCallStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Searching => {
                FileSearchToolCallStatus::Searching(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                FileSearchToolCallStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                FileSearchToolCallStatus::Incomplete(&Default::default()).serialize(serializer)
            }
            Self::Failed => {
                FileSearchToolCallStatus::Failed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the file search tool call. One of `in_progress`, \n`searching`, `incomplete` or `failed`,\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FileSearchToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "searching"]
    Searching,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for FileSearchToolCallResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileSearchToolCallResult {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: Option<String>,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
            #[serde(rename = "score")]
            #[allow(dead_code)]
            score: Option<f64>,
        }
        let FileSearchToolCallResult {
            file_id,
            text,
            filename,
            attributes,
            score,
            ..
        } = FileSearchToolCallResult::deserialize(deserializer)?;
        Ok(Self {
            file_id,
            text,
            filename,
            attributes,
            score,
        })
    }
}
impl serde::Serialize for FileSearchToolCallResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileSearchToolCallResult<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "filename")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filename: &'a Option<String>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
            #[serde(rename = "score")]
            #[serde(skip_serializing_if = "Option::is_none")]
            score: &'a Option<f64>,
        }
        let Self {
            file_id,
            text,
            filename,
            attributes,
            score,
        } = self;
        FileSearchToolCallResult {
            file_id,
            text,
            filename,
            attributes,
            score,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FileSearchToolCallResult {
    #[doc = "The unique ID of the file.\n"]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The text that was retrieved from the file.\n"]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "The name of the file.\n"]
    #[builder(default)]
    pub filename: Option<String>,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
    #[doc = "The relevance score of the file - a value between 0 and 1.\n"]
    #[builder(default)]
    pub score: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for FileSearchToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the file search tool call. Always `file_search_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallType {
            #[default]
            #[serde(rename = "file_search_call")]
            FileSearchCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileSearchToolCall {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FileSearchToolCallType,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: FileSearchToolCallStatus,
            #[serde(rename = "queries")]
            #[allow(dead_code)]
            queries: Vec<String>,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Option<Vec<FileSearchToolCallResult>>,
        }
        let FileSearchToolCall {
            id,
            status,
            queries,
            results,
            ..
        } = FileSearchToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            status,
            queries,
            results,
        })
    }
}
impl serde::Serialize for FileSearchToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the file search tool call. Always `file_search_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolCallType {
            #[default]
            #[serde(rename = "file_search_call")]
            FileSearchCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileSearchToolCall<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a FileSearchToolCallType,
            #[serde(rename = "status")]
            status: &'a FileSearchToolCallStatus,
            #[serde(rename = "queries")]
            queries: &'a Vec<String>,
            #[serde(rename = "results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            results: &'a Option<Vec<FileSearchToolCallResult>>,
        }
        let Self {
            id,
            status,
            queries,
            results,
        } = self;
        FileSearchToolCall {
            id,
            type_: &Default::default(),
            status,
            queries,
            results,
        }
        .serialize(serializer)
    }
}
#[doc = "The results of a file search tool call. See the \n[file search guide](https://platform.openai.com/docs/guides/tools-file-search) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileSearchToolCall {
    #[doc = "The unique ID of the file search tool call.\n"]
    pub id: String,
    #[doc = "The status of the file search tool call. One of `in_progress`, \n`searching`, `incomplete` or `failed`,\n"]
    pub status: FileSearchToolCallStatus,
    #[doc = "The queries used to search for files.\n"]
    pub queries: Vec<String>,
    #[doc = "The results of the file search tool call.\n"]
    #[builder(default)]
    pub results: Option<Vec<FileSearchToolCallResult>>,
}
impl<'de> serde::Deserialize<'de> for FineTuneChatCompletionRequestAssistantMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneChatCompletionRequestAssistantMessage {
            #[serde(rename = "weight")]
            #[allow(dead_code)]
            weight: Option<u64>,
            #[serde(flatten)]
            #[allow(dead_code)]
            chat_completion_request_assistant_message: ChatCompletionRequestAssistantMessage,
        }
        let FineTuneChatCompletionRequestAssistantMessage {
            weight,
            chat_completion_request_assistant_message,
            ..
        } = FineTuneChatCompletionRequestAssistantMessage::deserialize(deserializer)?;
        Ok(Self {
            weight,
            chat_completion_request_assistant_message,
        })
    }
}
impl serde::Serialize for FineTuneChatCompletionRequestAssistantMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneChatCompletionRequestAssistantMessage<'a> {
            #[serde(rename = "weight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            weight: &'a Option<u64>,
            #[serde(flatten)]
            chat_completion_request_assistant_message: &'a ChatCompletionRequestAssistantMessage,
        }
        let Self {
            weight,
            chat_completion_request_assistant_message,
        } = self;
        FineTuneChatCompletionRequestAssistantMessage {
            weight,
            chat_completion_request_assistant_message,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneChatCompletionRequestAssistantMessage {
    #[doc = "Controls whether the assistant message is trained against (0 or 1)"]
    #[builder(default)]
    pub weight: Option<u64>,
    #[builder(default)]
    pub chat_completion_request_assistant_message: ChatCompletionRequestAssistantMessage,
}
impl<'de> serde::Deserialize<'de> for FineTuneChatRequestInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneChatRequestInputMessages {
            System(#[allow(dead_code)] ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] ChatCompletionRequestFunctionMessage),
        }
        Ok(
            match FineTuneChatRequestInputMessages::deserialize(deserializer)? {
                FineTuneChatRequestInputMessages::System(_v) => Self::System(_v),
                FineTuneChatRequestInputMessages::User(_v) => Self::User(_v),
                FineTuneChatRequestInputMessages::Assistant(_v) => Self::Assistant(_v),
                FineTuneChatRequestInputMessages::Tool(_v) => Self::Tool(_v),
                FineTuneChatRequestInputMessages::Function(_v) => Self::Function(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneChatRequestInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneChatRequestInputMessages<'a> {
            System(#[allow(dead_code)] &'a ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] &'a ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] &'a FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] &'a ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] &'a ChatCompletionRequestFunctionMessage),
        }
        match self {
            Self::System(_v) => FineTuneChatRequestInputMessages::System(_v).serialize(serializer),
            Self::User(_v) => FineTuneChatRequestInputMessages::User(_v).serialize(serializer),
            Self::Assistant(_v) => {
                FineTuneChatRequestInputMessages::Assistant(_v).serialize(serializer)
            }
            Self::Tool(_v) => FineTuneChatRequestInputMessages::Tool(_v).serialize(serializer),
            Self::Function(_v) => {
                FineTuneChatRequestInputMessages::Function(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneChatRequestInputMessages {
    System(ChatCompletionRequestSystemMessage),
    User(ChatCompletionRequestUserMessage),
    Assistant(FineTuneChatCompletionRequestAssistantMessage),
    Tool(ChatCompletionRequestToolMessage),
    Function(ChatCompletionRequestFunctionMessage),
}
impl<'de> serde::Deserialize<'de> for FineTuneChatRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneChatRequestInput {
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Option<Vec<FineTuneChatRequestInputMessages>>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "functions")]
            #[allow(dead_code)]
            functions: Option<Vec<ChatCompletionFunctions>>,
        }
        let FineTuneChatRequestInput {
            messages,
            tools,
            parallel_tool_calls,
            functions,
            ..
        } = FineTuneChatRequestInput::deserialize(deserializer)?;
        Ok(Self {
            messages,
            tools,
            parallel_tool_calls,
            functions,
        })
    }
}
impl serde::Serialize for FineTuneChatRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneChatRequestInput<'a> {
            #[serde(rename = "messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            messages: &'a Option<Vec<FineTuneChatRequestInputMessages>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "functions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            functions: &'a Option<Vec<ChatCompletionFunctions>>,
        }
        let Self {
            messages,
            tools,
            parallel_tool_calls,
            functions,
        } = self;
        FineTuneChatRequestInput {
            messages,
            tools,
            parallel_tool_calls,
            functions,
        }
        .serialize(serializer)
    }
}
#[doc = "The per-line training example of a fine-tuning input file for chat models using the supervised method."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneChatRequestInput {
    #[builder(default)]
    pub messages: Option<Vec<FineTuneChatRequestInputMessages>>,
    #[doc = "A list of tools the model may generate JSON inputs for."]
    #[builder(default)]
    pub tools: Option<Vec<ChatCompletionTool>>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[doc = "A list of functions the model may generate JSON inputs for."]
    #[builder(default)]
    pub functions: Option<Vec<ChatCompletionFunctions>>,
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoHyperparametersBeta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoHyperparametersBetaAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneDpoHyperparametersBeta {
            Auto(#[allow(dead_code)] FineTuneDpoHyperparametersBetaAuto),
            Number(#[allow(dead_code)] f64),
        }
        Ok(
            match FineTuneDpoHyperparametersBeta::deserialize(deserializer)? {
                FineTuneDpoHyperparametersBeta::Auto(_) => Self::Auto,
                FineTuneDpoHyperparametersBeta::Number(_v) => Self::Number(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneDpoHyperparametersBeta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoHyperparametersBetaAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneDpoHyperparametersBeta<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneDpoHyperparametersBetaAuto),
            Number(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => {
                FineTuneDpoHyperparametersBeta::Auto(&Default::default()).serialize(serializer)
            }
            Self::Number(_v) => FineTuneDpoHyperparametersBeta::Number(_v).serialize(serializer),
        }
    }
}
#[doc = "The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneDpoHyperparametersBeta {
    #[doc = "auto"]
    Auto,
    Number(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneDpoHyperparametersBatchSize {
            Auto(#[allow(dead_code)] FineTuneDpoHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuneDpoHyperparametersBatchSize::deserialize(deserializer)? {
                FineTuneDpoHyperparametersBatchSize::Auto(_) => Self::Auto,
                FineTuneDpoHyperparametersBatchSize::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneDpoHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneDpoHyperparametersBatchSize<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneDpoHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => {
                FineTuneDpoHyperparametersBatchSize::Auto(&Default::default()).serialize(serializer)
            }
            Self::Integer(_v) => {
                FineTuneDpoHyperparametersBatchSize::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneDpoHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoHyperparametersLearningRateMultiplier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneDpoHyperparametersLearningRateMultiplier {
            Auto(#[allow(dead_code)] FineTuneDpoHyperparametersLearningRateMultiplierAuto),
            Number(#[allow(dead_code)] f64),
        }
        Ok(
            match FineTuneDpoHyperparametersLearningRateMultiplier::deserialize(deserializer)? {
                FineTuneDpoHyperparametersLearningRateMultiplier::Auto(_) => Self::Auto,
                FineTuneDpoHyperparametersLearningRateMultiplier::Number(_v) => Self::Number(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneDpoHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneDpoHyperparametersLearningRateMultiplier<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneDpoHyperparametersLearningRateMultiplierAuto),
            Number(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => {
                FineTuneDpoHyperparametersLearningRateMultiplier::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Number(_v) => {
                FineTuneDpoHyperparametersLearningRateMultiplier::Number(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneDpoHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Number(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneDpoHyperparametersNEpochs {
            Auto(#[allow(dead_code)] FineTuneDpoHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuneDpoHyperparametersNEpochs::deserialize(deserializer)? {
                FineTuneDpoHyperparametersNEpochs::Auto(_) => Self::Auto,
                FineTuneDpoHyperparametersNEpochs::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneDpoHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneDpoHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneDpoHyperparametersNEpochs<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneDpoHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => {
                FineTuneDpoHyperparametersNEpochs::Auto(&Default::default()).serialize(serializer)
            }
            Self::Integer(_v) => {
                FineTuneDpoHyperparametersNEpochs::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneDpoHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneDpoHyperparameters {
            #[serde(rename = "beta")]
            #[allow(dead_code)]
            beta: Option<FineTuneDpoHyperparametersBeta>,
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<FineTuneDpoHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier: Option<FineTuneDpoHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<FineTuneDpoHyperparametersNEpochs>,
        }
        let FineTuneDpoHyperparameters {
            beta,
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            ..
        } = FineTuneDpoHyperparameters::deserialize(deserializer)?;
        Ok(Self {
            beta,
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        })
    }
}
impl serde::Serialize for FineTuneDpoHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneDpoHyperparameters<'a> {
            #[serde(rename = "beta")]
            #[serde(skip_serializing_if = "Option::is_none")]
            beta: &'a Option<FineTuneDpoHyperparametersBeta>,
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<FineTuneDpoHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier: &'a Option<FineTuneDpoHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<FineTuneDpoHyperparametersNEpochs>,
        }
        let Self {
            beta,
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        } = self;
        FineTuneDpoHyperparameters {
            beta,
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the DPO fine-tuning job."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneDpoHyperparameters {
    #[doc = "The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model.\n"]
    #[builder(default)]
    pub beta: Option<FineTuneDpoHyperparametersBeta>,
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<FineTuneDpoHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier: Option<FineTuneDpoHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<FineTuneDpoHyperparametersNEpochs>,
}
impl<'de> serde::Deserialize<'de> for FineTuneDpoMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneDpoMethod {
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: Option<FineTuneDpoHyperparameters>,
        }
        let FineTuneDpoMethod {
            hyperparameters, ..
        } = FineTuneDpoMethod::deserialize(deserializer)?;
        Ok(Self { hyperparameters })
    }
}
impl serde::Serialize for FineTuneDpoMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneDpoMethod<'a> {
            #[serde(rename = "hyperparameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            hyperparameters: &'a Option<FineTuneDpoHyperparameters>,
        }
        let Self { hyperparameters } = self;
        FineTuneDpoMethod { hyperparameters }.serialize(serializer)
    }
}
#[doc = "Configuration for the DPO fine-tuning method."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneDpoMethod {
    #[builder(default)]
    pub hyperparameters: Option<FineTuneDpoHyperparameters>,
}
impl<'de> serde::Deserialize<'de> for FineTuneMethodType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeSupervised {
            #[default]
            #[serde(rename = "supervised")]
            Supervised,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeDpo {
            #[default]
            #[serde(rename = "dpo")]
            Dpo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeReinforcement {
            #[default]
            #[serde(rename = "reinforcement")]
            Reinforcement,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneMethodType {
            Supervised(#[allow(dead_code)] FineTuneMethodTypeSupervised),
            Dpo(#[allow(dead_code)] FineTuneMethodTypeDpo),
            Reinforcement(#[allow(dead_code)] FineTuneMethodTypeReinforcement),
        }
        Ok(match FineTuneMethodType::deserialize(deserializer)? {
            FineTuneMethodType::Supervised(_) => Self::Supervised,
            FineTuneMethodType::Dpo(_) => Self::Dpo,
            FineTuneMethodType::Reinforcement(_) => Self::Reinforcement,
        })
    }
}
impl serde::Serialize for FineTuneMethodType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeSupervised {
            #[default]
            #[serde(rename = "supervised")]
            Supervised,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeDpo {
            #[default]
            #[serde(rename = "dpo")]
            Dpo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneMethodTypeReinforcement {
            #[default]
            #[serde(rename = "reinforcement")]
            Reinforcement,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneMethodType<'a> {
            Supervised(#[allow(dead_code)] &'a FineTuneMethodTypeSupervised),
            Dpo(#[allow(dead_code)] &'a FineTuneMethodTypeDpo),
            Reinforcement(#[allow(dead_code)] &'a FineTuneMethodTypeReinforcement),
        }
        match self {
            Self::Supervised => {
                FineTuneMethodType::Supervised(&Default::default()).serialize(serializer)
            }
            Self::Dpo => FineTuneMethodType::Dpo(&Default::default()).serialize(serializer),
            Self::Reinforcement => {
                FineTuneMethodType::Reinforcement(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of method. Is either `supervised`, `dpo`, or `reinforcement`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneMethodType {
    #[doc = "supervised"]
    Supervised,
    #[doc = "dpo"]
    Dpo,
    #[doc = "reinforcement"]
    Reinforcement,
}
impl<'de> serde::Deserialize<'de> for FineTuneMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneMethod {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FineTuneMethodType,
            #[serde(rename = "supervised")]
            #[allow(dead_code)]
            supervised: Option<FineTuneSupervisedMethod>,
            #[serde(rename = "dpo")]
            #[allow(dead_code)]
            dpo: Option<FineTuneDpoMethod>,
            #[serde(rename = "reinforcement")]
            #[allow(dead_code)]
            reinforcement: Option<FineTuneReinforcementMethod>,
        }
        let FineTuneMethod {
            type_,
            supervised,
            dpo,
            reinforcement,
            ..
        } = FineTuneMethod::deserialize(deserializer)?;
        Ok(Self {
            type_,
            supervised,
            dpo,
            reinforcement,
        })
    }
}
impl serde::Serialize for FineTuneMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneMethod<'a> {
            #[serde(rename = "type")]
            type_: &'a FineTuneMethodType,
            #[serde(rename = "supervised")]
            #[serde(skip_serializing_if = "Option::is_none")]
            supervised: &'a Option<FineTuneSupervisedMethod>,
            #[serde(rename = "dpo")]
            #[serde(skip_serializing_if = "Option::is_none")]
            dpo: &'a Option<FineTuneDpoMethod>,
            #[serde(rename = "reinforcement")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reinforcement: &'a Option<FineTuneReinforcementMethod>,
        }
        let Self {
            type_,
            supervised,
            dpo,
            reinforcement,
        } = self;
        FineTuneMethod {
            type_,
            supervised,
            dpo,
            reinforcement,
        }
        .serialize(serializer)
    }
}
#[doc = "The method used for fine-tuning."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuneMethod {
    #[doc = "The type of method. Is either `supervised`, `dpo`, or `reinforcement`."]
    pub type_: FineTuneMethodType,
    #[builder(default)]
    pub supervised: Option<FineTuneSupervisedMethod>,
    #[builder(default)]
    pub dpo: Option<FineTuneDpoMethod>,
    #[builder(default)]
    pub reinforcement: Option<FineTuneReinforcementMethod>,
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInputInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTunePreferenceRequestInputInputMessages {
            System(#[allow(dead_code)] ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] ChatCompletionRequestFunctionMessage),
        }
        Ok(
            match FineTunePreferenceRequestInputInputMessages::deserialize(deserializer)? {
                FineTunePreferenceRequestInputInputMessages::System(_v) => Self::System(_v),
                FineTunePreferenceRequestInputInputMessages::User(_v) => Self::User(_v),
                FineTunePreferenceRequestInputInputMessages::Assistant(_v) => Self::Assistant(_v),
                FineTunePreferenceRequestInputInputMessages::Tool(_v) => Self::Tool(_v),
                FineTunePreferenceRequestInputInputMessages::Function(_v) => Self::Function(_v),
            },
        )
    }
}
impl serde::Serialize for FineTunePreferenceRequestInputInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTunePreferenceRequestInputInputMessages<'a> {
            System(#[allow(dead_code)] &'a ChatCompletionRequestSystemMessage),
            User(#[allow(dead_code)] &'a ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] &'a FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] &'a ChatCompletionRequestToolMessage),
            Function(#[allow(dead_code)] &'a ChatCompletionRequestFunctionMessage),
        }
        match self {
            Self::System(_v) => {
                FineTunePreferenceRequestInputInputMessages::System(_v).serialize(serializer)
            }
            Self::User(_v) => {
                FineTunePreferenceRequestInputInputMessages::User(_v).serialize(serializer)
            }
            Self::Assistant(_v) => {
                FineTunePreferenceRequestInputInputMessages::Assistant(_v).serialize(serializer)
            }
            Self::Tool(_v) => {
                FineTunePreferenceRequestInputInputMessages::Tool(_v).serialize(serializer)
            }
            Self::Function(_v) => {
                FineTunePreferenceRequestInputInputMessages::Function(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTunePreferenceRequestInputInputMessages {
    System(ChatCompletionRequestSystemMessage),
    User(ChatCompletionRequestUserMessage),
    Assistant(FineTuneChatCompletionRequestAssistantMessage),
    Tool(ChatCompletionRequestToolMessage),
    Function(ChatCompletionRequestFunctionMessage),
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInputInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTunePreferenceRequestInputInput {
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Option<Vec<FineTunePreferenceRequestInputInputMessages>>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
        }
        let FineTunePreferenceRequestInputInput {
            messages,
            tools,
            parallel_tool_calls,
            ..
        } = FineTunePreferenceRequestInputInput::deserialize(deserializer)?;
        Ok(Self {
            messages,
            tools,
            parallel_tool_calls,
        })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInputInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTunePreferenceRequestInputInput<'a> {
            #[serde(rename = "messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            messages: &'a Option<Vec<FineTunePreferenceRequestInputInputMessages>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ChatCompletionTool>>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
        }
        let Self {
            messages,
            tools,
            parallel_tool_calls,
        } = self;
        FineTunePreferenceRequestInputInput {
            messages,
            tools,
            parallel_tool_calls,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTunePreferenceRequestInputInput {
    #[builder(default)]
    pub messages: Option<Vec<FineTunePreferenceRequestInputInputMessages>>,
    #[doc = "A list of tools the model may generate JSON inputs for."]
    #[builder(default)]
    pub tools: Option<Vec<ChatCompletionTool>>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInputPreferredOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTunePreferenceRequestInputPreferredOutput {
            ChatCompletionRequestAssistantMessage(
                #[allow(dead_code)] ChatCompletionRequestAssistantMessage,
            ),
        }
        Ok (match FineTunePreferenceRequestInputPreferredOutput :: deserialize (deserializer) ? { FineTunePreferenceRequestInputPreferredOutput :: ChatCompletionRequestAssistantMessage (_v) => Self :: ChatCompletionRequestAssistantMessage (_v) })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInputPreferredOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTunePreferenceRequestInputPreferredOutput<'a> {
            ChatCompletionRequestAssistantMessage(
                #[allow(dead_code)] &'a ChatCompletionRequestAssistantMessage,
            ),
        }
        match self { Self :: ChatCompletionRequestAssistantMessage (_v) => { FineTunePreferenceRequestInputPreferredOutput :: ChatCompletionRequestAssistantMessage (_v) . serialize (serializer) } }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTunePreferenceRequestInputPreferredOutput {
    ChatCompletionRequestAssistantMessage(ChatCompletionRequestAssistantMessage),
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInputNonPreferredOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTunePreferenceRequestInputNonPreferredOutput {
            ChatCompletionRequestAssistantMessage(
                #[allow(dead_code)] ChatCompletionRequestAssistantMessage,
            ),
        }
        Ok (match FineTunePreferenceRequestInputNonPreferredOutput :: deserialize (deserializer) ? { FineTunePreferenceRequestInputNonPreferredOutput :: ChatCompletionRequestAssistantMessage (_v) => Self :: ChatCompletionRequestAssistantMessage (_v) })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInputNonPreferredOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTunePreferenceRequestInputNonPreferredOutput<'a> {
            ChatCompletionRequestAssistantMessage(
                #[allow(dead_code)] &'a ChatCompletionRequestAssistantMessage,
            ),
        }
        match self { Self :: ChatCompletionRequestAssistantMessage (_v) => { FineTunePreferenceRequestInputNonPreferredOutput :: ChatCompletionRequestAssistantMessage (_v) . serialize (serializer) } }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTunePreferenceRequestInputNonPreferredOutput {
    ChatCompletionRequestAssistantMessage(ChatCompletionRequestAssistantMessage),
}
impl<'de> serde::Deserialize<'de> for FineTunePreferenceRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTunePreferenceRequestInput {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Option<FineTunePreferenceRequestInputInput>,
            #[serde(rename = "preferred_output")]
            #[allow(dead_code)]
            preferred_output: Option<Vec<FineTunePreferenceRequestInputPreferredOutput>>,
            #[serde(rename = "non_preferred_output")]
            #[allow(dead_code)]
            non_preferred_output: Option<Vec<FineTunePreferenceRequestInputNonPreferredOutput>>,
        }
        let FineTunePreferenceRequestInput {
            input,
            preferred_output,
            non_preferred_output,
            ..
        } = FineTunePreferenceRequestInput::deserialize(deserializer)?;
        Ok(Self {
            input,
            preferred_output,
            non_preferred_output,
        })
    }
}
impl serde::Serialize for FineTunePreferenceRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTunePreferenceRequestInput<'a> {
            #[serde(rename = "input")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input: &'a Option<FineTunePreferenceRequestInputInput>,
            #[serde(rename = "preferred_output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            preferred_output: &'a Option<Vec<FineTunePreferenceRequestInputPreferredOutput>>,
            #[serde(rename = "non_preferred_output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            non_preferred_output: &'a Option<Vec<FineTunePreferenceRequestInputNonPreferredOutput>>,
        }
        let Self {
            input,
            preferred_output,
            non_preferred_output,
        } = self;
        FineTunePreferenceRequestInput {
            input,
            preferred_output,
            non_preferred_output,
        }
        .serialize(serializer)
    }
}
#[doc = "The per-line training example of a fine-tuning input file for chat models using the dpo method."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct FineTunePreferenceRequestInput {
    #[builder(default)]
    pub input: Option<FineTunePreferenceRequestInputInput>,
    #[doc = "The preferred completion message for the output."]
    #[builder(default)]
    pub preferred_output: Option<Vec<FineTunePreferenceRequestInputPreferredOutput>>,
    #[doc = "The non-preferred completion message for the output."]
    #[builder(default)]
    pub non_preferred_output: Option<Vec<FineTunePreferenceRequestInputNonPreferredOutput>>,
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementHyperparametersBatchSize {
            Auto(#[allow(dead_code)] FineTuneReinforcementHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuneReinforcementHyperparametersBatchSize::deserialize(deserializer)? {
                FineTuneReinforcementHyperparametersBatchSize::Auto(_) => Self::Auto,
                FineTuneReinforcementHyperparametersBatchSize::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementHyperparametersBatchSize<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneReinforcementHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => FineTuneReinforcementHyperparametersBatchSize::Auto(&Default::default())
                .serialize(serializer),
            Self::Integer(_v) => {
                FineTuneReinforcementHyperparametersBatchSize::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementHyperparametersLearningRateMultiplier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementHyperparametersLearningRateMultiplier {
            Auto(
                #[allow(dead_code)] FineTuneReinforcementHyperparametersLearningRateMultiplierAuto,
            ),
            Number(#[allow(dead_code)] f64),
        }
        Ok(
            match FineTuneReinforcementHyperparametersLearningRateMultiplier::deserialize(
                deserializer,
            )? {
                FineTuneReinforcementHyperparametersLearningRateMultiplier::Auto(_) => Self::Auto,
                FineTuneReinforcementHyperparametersLearningRateMultiplier::Number(_v) => {
                    Self::Number(_v)
                }
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementHyperparametersLearningRateMultiplier<'a> {
            Auto(
                #[allow(dead_code)]
                &'a FineTuneReinforcementHyperparametersLearningRateMultiplierAuto,
            ),
            Number(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => FineTuneReinforcementHyperparametersLearningRateMultiplier::Auto(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Number(_v) => {
                FineTuneReinforcementHyperparametersLearningRateMultiplier::Number(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Number(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementHyperparametersNEpochs {
            Auto(#[allow(dead_code)] FineTuneReinforcementHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuneReinforcementHyperparametersNEpochs::deserialize(deserializer)? {
                FineTuneReinforcementHyperparametersNEpochs::Auto(_) => Self::Auto,
                FineTuneReinforcementHyperparametersNEpochs::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementHyperparametersNEpochs<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneReinforcementHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => FineTuneReinforcementHyperparametersNEpochs::Auto(&Default::default())
                .serialize(serializer),
            Self::Integer(_v) => {
                FineTuneReinforcementHyperparametersNEpochs::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementHyperparametersReasoningEffort {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersReasoningEffortDefault {
            #[default]
            #[serde(rename = "default")]
            Default,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersReasoningEffortLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersReasoningEffortMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersReasoningEffortHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementHyperparametersReasoningEffort {
            Default(#[allow(dead_code)] FineTuneReinforcementHyperparametersReasoningEffortDefault),
            Low(#[allow(dead_code)] FineTuneReinforcementHyperparametersReasoningEffortLow),
            Medium(#[allow(dead_code)] FineTuneReinforcementHyperparametersReasoningEffortMedium),
            High(#[allow(dead_code)] FineTuneReinforcementHyperparametersReasoningEffortHigh),
        }
        Ok(
            match FineTuneReinforcementHyperparametersReasoningEffort::deserialize(deserializer)? {
                FineTuneReinforcementHyperparametersReasoningEffort::Default(_) => Self::Default,
                FineTuneReinforcementHyperparametersReasoningEffort::Low(_) => Self::Low,
                FineTuneReinforcementHyperparametersReasoningEffort::Medium(_) => Self::Medium,
                FineTuneReinforcementHyperparametersReasoningEffort::High(_) => Self::High,
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementHyperparametersReasoningEffort {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersReasoningEffortDefault {
            #[default]
            #[serde(rename = "default")]
            Default,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersReasoningEffortLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersReasoningEffortMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersReasoningEffortHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementHyperparametersReasoningEffort<'a> {
            Default(
                #[allow(dead_code)] &'a FineTuneReinforcementHyperparametersReasoningEffortDefault,
            ),
            Low(#[allow(dead_code)] &'a FineTuneReinforcementHyperparametersReasoningEffortLow),
            Medium(
                #[allow(dead_code)] &'a FineTuneReinforcementHyperparametersReasoningEffortMedium,
            ),
            High(#[allow(dead_code)] &'a FineTuneReinforcementHyperparametersReasoningEffortHigh),
        }
        match self {
            Self::Default => {
                FineTuneReinforcementHyperparametersReasoningEffort::Default(&Default::default())
                    .serialize(serializer)
            }
            Self::Low => {
                FineTuneReinforcementHyperparametersReasoningEffort::Low(&Default::default())
                    .serialize(serializer)
            }
            Self::Medium => {
                FineTuneReinforcementHyperparametersReasoningEffort::Medium(&Default::default())
                    .serialize(serializer)
            }
            Self::High => {
                FineTuneReinforcementHyperparametersReasoningEffort::High(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Level of reasoning effort.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementHyperparametersReasoningEffort {
    #[doc = "default"]
    #[default]
    Default,
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementHyperparametersComputeMultiplier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersComputeMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementHyperparametersComputeMultiplier {
            Auto(#[allow(dead_code)] FineTuneReinforcementHyperparametersComputeMultiplierAuto),
            Number(#[allow(dead_code)] f64),
        }
        Ok(
            match FineTuneReinforcementHyperparametersComputeMultiplier::deserialize(deserializer)?
            {
                FineTuneReinforcementHyperparametersComputeMultiplier::Auto(_) => Self::Auto,
                FineTuneReinforcementHyperparametersComputeMultiplier::Number(_v) => {
                    Self::Number(_v)
                }
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementHyperparametersComputeMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersComputeMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementHyperparametersComputeMultiplier<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneReinforcementHyperparametersComputeMultiplierAuto),
            Number(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => {
                FineTuneReinforcementHyperparametersComputeMultiplier::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Number(_v) => FineTuneReinforcementHyperparametersComputeMultiplier::Number(_v)
                .serialize(serializer),
        }
    }
}
#[doc = "Multiplier on amount of compute used for exploring search space during training.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementHyperparametersComputeMultiplier {
    #[doc = "auto"]
    Auto,
    Number(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementHyperparametersEvalInterval {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersEvalIntervalAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementHyperparametersEvalInterval {
            Auto(#[allow(dead_code)] FineTuneReinforcementHyperparametersEvalIntervalAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuneReinforcementHyperparametersEvalInterval::deserialize(deserializer)? {
                FineTuneReinforcementHyperparametersEvalInterval::Auto(_) => Self::Auto,
                FineTuneReinforcementHyperparametersEvalInterval::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementHyperparametersEvalInterval {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersEvalIntervalAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementHyperparametersEvalInterval<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneReinforcementHyperparametersEvalIntervalAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => {
                FineTuneReinforcementHyperparametersEvalInterval::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Integer(_v) => {
                FineTuneReinforcementHyperparametersEvalInterval::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The number of training steps between evaluation runs.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementHyperparametersEvalInterval {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementHyperparametersEvalSamples {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersEvalSamplesAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementHyperparametersEvalSamples {
            Auto(#[allow(dead_code)] FineTuneReinforcementHyperparametersEvalSamplesAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuneReinforcementHyperparametersEvalSamples::deserialize(deserializer)? {
                FineTuneReinforcementHyperparametersEvalSamples::Auto(_) => Self::Auto,
                FineTuneReinforcementHyperparametersEvalSamples::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementHyperparametersEvalSamples {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneReinforcementHyperparametersEvalSamplesAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementHyperparametersEvalSamples<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneReinforcementHyperparametersEvalSamplesAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => {
                FineTuneReinforcementHyperparametersEvalSamples::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Integer(_v) => {
                FineTuneReinforcementHyperparametersEvalSamples::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Number of evaluation samples to generate per training step.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementHyperparametersEvalSamples {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneReinforcementHyperparameters {
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<FineTuneReinforcementHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier:
                Option<FineTuneReinforcementHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<FineTuneReinforcementHyperparametersNEpochs>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<FineTuneReinforcementHyperparametersReasoningEffort>,
            #[serde(rename = "compute_multiplier")]
            #[allow(dead_code)]
            compute_multiplier: Option<FineTuneReinforcementHyperparametersComputeMultiplier>,
            #[serde(rename = "eval_interval")]
            #[allow(dead_code)]
            eval_interval: Option<FineTuneReinforcementHyperparametersEvalInterval>,
            #[serde(rename = "eval_samples")]
            #[allow(dead_code)]
            eval_samples: Option<FineTuneReinforcementHyperparametersEvalSamples>,
        }
        let FineTuneReinforcementHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            reasoning_effort,
            compute_multiplier,
            eval_interval,
            eval_samples,
            ..
        } = FineTuneReinforcementHyperparameters::deserialize(deserializer)?;
        Ok(Self {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            reasoning_effort,
            compute_multiplier,
            eval_interval,
            eval_samples,
        })
    }
}
impl serde::Serialize for FineTuneReinforcementHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneReinforcementHyperparameters<'a> {
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<FineTuneReinforcementHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier:
                &'a Option<FineTuneReinforcementHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<FineTuneReinforcementHyperparametersNEpochs>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<FineTuneReinforcementHyperparametersReasoningEffort>,
            #[serde(rename = "compute_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            compute_multiplier: &'a Option<FineTuneReinforcementHyperparametersComputeMultiplier>,
            #[serde(rename = "eval_interval")]
            #[serde(skip_serializing_if = "Option::is_none")]
            eval_interval: &'a Option<FineTuneReinforcementHyperparametersEvalInterval>,
            #[serde(rename = "eval_samples")]
            #[serde(skip_serializing_if = "Option::is_none")]
            eval_samples: &'a Option<FineTuneReinforcementHyperparametersEvalSamples>,
        }
        let Self {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            reasoning_effort,
            compute_multiplier,
            eval_interval,
            eval_samples,
        } = self;
        FineTuneReinforcementHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            reasoning_effort,
            compute_multiplier,
            eval_interval,
            eval_samples,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the reinforcement fine-tuning job."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneReinforcementHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<FineTuneReinforcementHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier:
        Option<FineTuneReinforcementHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<FineTuneReinforcementHyperparametersNEpochs>,
    #[doc = "Level of reasoning effort.\n"]
    #[builder(default)]
    pub reasoning_effort: Option<FineTuneReinforcementHyperparametersReasoningEffort>,
    #[doc = "Multiplier on amount of compute used for exploring search space during training.\n"]
    #[builder(default)]
    pub compute_multiplier: Option<FineTuneReinforcementHyperparametersComputeMultiplier>,
    #[doc = "The number of training steps between evaluation runs.\n"]
    #[builder(default)]
    pub eval_interval: Option<FineTuneReinforcementHyperparametersEvalInterval>,
    #[doc = "Number of evaluation samples to generate per training step.\n"]
    #[builder(default)]
    pub eval_samples: Option<FineTuneReinforcementHyperparametersEvalSamples>,
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementMethodGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementMethodGrader {
            StringCheck(#[allow(dead_code)] GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] GraderTextSimilarity),
            Python(#[allow(dead_code)] GraderPython),
            ScoreModel(#[allow(dead_code)] GraderScoreModel),
            Multi(#[allow(dead_code)] GraderMulti),
        }
        Ok(
            match FineTuneReinforcementMethodGrader::deserialize(deserializer)? {
                FineTuneReinforcementMethodGrader::StringCheck(_v) => Self::StringCheck(_v),
                FineTuneReinforcementMethodGrader::TextSimilarity(_v) => Self::TextSimilarity(_v),
                FineTuneReinforcementMethodGrader::Python(_v) => Self::Python(_v),
                FineTuneReinforcementMethodGrader::ScoreModel(_v) => Self::ScoreModel(_v),
                FineTuneReinforcementMethodGrader::Multi(_v) => Self::Multi(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementMethodGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementMethodGrader<'a> {
            StringCheck(#[allow(dead_code)] &'a GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] &'a GraderTextSimilarity),
            Python(#[allow(dead_code)] &'a GraderPython),
            ScoreModel(#[allow(dead_code)] &'a GraderScoreModel),
            Multi(#[allow(dead_code)] &'a GraderMulti),
        }
        match self {
            Self::StringCheck(_v) => {
                FineTuneReinforcementMethodGrader::StringCheck(_v).serialize(serializer)
            }
            Self::TextSimilarity(_v) => {
                FineTuneReinforcementMethodGrader::TextSimilarity(_v).serialize(serializer)
            }
            Self::Python(_v) => FineTuneReinforcementMethodGrader::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => {
                FineTuneReinforcementMethodGrader::ScoreModel(_v).serialize(serializer)
            }
            Self::Multi(_v) => FineTuneReinforcementMethodGrader::Multi(_v).serialize(serializer),
        }
    }
}
#[doc = "The grader used for the fine-tuning job."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementMethodGrader {
    StringCheck(GraderStringCheck),
    TextSimilarity(GraderTextSimilarity),
    Python(GraderPython),
    ScoreModel(GraderScoreModel),
    Multi(GraderMulti),
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneReinforcementMethod {
            #[serde(rename = "grader")]
            #[allow(dead_code)]
            grader: FineTuneReinforcementMethodGrader,
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: Option<FineTuneReinforcementHyperparameters>,
        }
        let FineTuneReinforcementMethod {
            grader,
            hyperparameters,
            ..
        } = FineTuneReinforcementMethod::deserialize(deserializer)?;
        Ok(Self {
            grader,
            hyperparameters,
        })
    }
}
impl serde::Serialize for FineTuneReinforcementMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneReinforcementMethod<'a> {
            #[serde(rename = "grader")]
            grader: &'a FineTuneReinforcementMethodGrader,
            #[serde(rename = "hyperparameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            hyperparameters: &'a Option<FineTuneReinforcementHyperparameters>,
        }
        let Self {
            grader,
            hyperparameters,
        } = self;
        FineTuneReinforcementMethod {
            grader,
            hyperparameters,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for the reinforcement fine-tuning method."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuneReinforcementMethod {
    #[doc = "The grader used for the fine-tuning job."]
    pub grader: FineTuneReinforcementMethodGrader,
    #[builder(default)]
    pub hyperparameters: Option<FineTuneReinforcementHyperparameters>,
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementRequestInputMessages {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneReinforcementRequestInputMessages {
            Developer(#[allow(dead_code)] ChatCompletionRequestDeveloperMessage),
            User(#[allow(dead_code)] ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] ChatCompletionRequestToolMessage),
        }
        Ok(
            match FineTuneReinforcementRequestInputMessages::deserialize(deserializer)? {
                FineTuneReinforcementRequestInputMessages::Developer(_v) => Self::Developer(_v),
                FineTuneReinforcementRequestInputMessages::User(_v) => Self::User(_v),
                FineTuneReinforcementRequestInputMessages::Assistant(_v) => Self::Assistant(_v),
                FineTuneReinforcementRequestInputMessages::Tool(_v) => Self::Tool(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneReinforcementRequestInputMessages {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneReinforcementRequestInputMessages<'a> {
            Developer(#[allow(dead_code)] &'a ChatCompletionRequestDeveloperMessage),
            User(#[allow(dead_code)] &'a ChatCompletionRequestUserMessage),
            Assistant(#[allow(dead_code)] &'a FineTuneChatCompletionRequestAssistantMessage),
            Tool(#[allow(dead_code)] &'a ChatCompletionRequestToolMessage),
        }
        match self {
            Self::Developer(_v) => {
                FineTuneReinforcementRequestInputMessages::Developer(_v).serialize(serializer)
            }
            Self::User(_v) => {
                FineTuneReinforcementRequestInputMessages::User(_v).serialize(serializer)
            }
            Self::Assistant(_v) => {
                FineTuneReinforcementRequestInputMessages::Assistant(_v).serialize(serializer)
            }
            Self::Tool(_v) => {
                FineTuneReinforcementRequestInputMessages::Tool(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneReinforcementRequestInputMessages {
    Developer(ChatCompletionRequestDeveloperMessage),
    User(ChatCompletionRequestUserMessage),
    Assistant(FineTuneChatCompletionRequestAssistantMessage),
    Tool(ChatCompletionRequestToolMessage),
}
impl<'de> serde::Deserialize<'de> for FineTuneReinforcementRequestInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneReinforcementRequestInput {
            #[serde(rename = "messages")]
            #[allow(dead_code)]
            messages: Vec<FineTuneReinforcementRequestInputMessages>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<ChatCompletionTool>>,
        }
        let FineTuneReinforcementRequestInput {
            messages, tools, ..
        } = FineTuneReinforcementRequestInput::deserialize(deserializer)?;
        Ok(Self { messages, tools })
    }
}
impl serde::Serialize for FineTuneReinforcementRequestInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneReinforcementRequestInput<'a> {
            #[serde(rename = "messages")]
            messages: &'a Vec<FineTuneReinforcementRequestInputMessages>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<ChatCompletionTool>>,
        }
        let Self { messages, tools } = self;
        FineTuneReinforcementRequestInput { messages, tools }.serialize(serializer)
    }
}
#[doc = "Per-line training example for reinforcement fine-tuning. Note that `messages` and `tools` are the only reserved keywords. Any other arbitrary key-value data can be included on training datapoints and will be available to reference during grading under the `{{ item.XXX }}` template variable."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuneReinforcementRequestInput {
    pub messages: Vec<FineTuneReinforcementRequestInputMessages>,
    #[doc = "A list of tools the model may generate JSON inputs for."]
    #[builder(default)]
    pub tools: Option<Vec<ChatCompletionTool>>,
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneSupervisedHyperparametersBatchSize {
            Auto(#[allow(dead_code)] FineTuneSupervisedHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuneSupervisedHyperparametersBatchSize::deserialize(deserializer)? {
                FineTuneSupervisedHyperparametersBatchSize::Auto(_) => Self::Auto,
                FineTuneSupervisedHyperparametersBatchSize::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneSupervisedHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneSupervisedHyperparametersBatchSize<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneSupervisedHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => FineTuneSupervisedHyperparametersBatchSize::Auto(&Default::default())
                .serialize(serializer),
            Self::Integer(_v) => {
                FineTuneSupervisedHyperparametersBatchSize::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneSupervisedHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedHyperparametersLearningRateMultiplier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneSupervisedHyperparametersLearningRateMultiplier {
            Auto(#[allow(dead_code)] FineTuneSupervisedHyperparametersLearningRateMultiplierAuto),
            Number(#[allow(dead_code)] f64),
        }
        Ok(
            match FineTuneSupervisedHyperparametersLearningRateMultiplier::deserialize(
                deserializer,
            )? {
                FineTuneSupervisedHyperparametersLearningRateMultiplier::Auto(_) => Self::Auto,
                FineTuneSupervisedHyperparametersLearningRateMultiplier::Number(_v) => {
                    Self::Number(_v)
                }
            },
        )
    }
}
impl serde::Serialize for FineTuneSupervisedHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneSupervisedHyperparametersLearningRateMultiplier<'a> {
            Auto(
                #[allow(dead_code)] &'a FineTuneSupervisedHyperparametersLearningRateMultiplierAuto,
            ),
            Number(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => {
                FineTuneSupervisedHyperparametersLearningRateMultiplier::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Number(_v) => FineTuneSupervisedHyperparametersLearningRateMultiplier::Number(_v)
                .serialize(serializer),
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneSupervisedHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Number(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuneSupervisedHyperparametersNEpochs {
            Auto(#[allow(dead_code)] FineTuneSupervisedHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuneSupervisedHyperparametersNEpochs::deserialize(deserializer)? {
                FineTuneSupervisedHyperparametersNEpochs::Auto(_) => Self::Auto,
                FineTuneSupervisedHyperparametersNEpochs::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuneSupervisedHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuneSupervisedHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuneSupervisedHyperparametersNEpochs<'a> {
            Auto(#[allow(dead_code)] &'a FineTuneSupervisedHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => FineTuneSupervisedHyperparametersNEpochs::Auto(&Default::default())
                .serialize(serializer),
            Self::Integer(_v) => {
                FineTuneSupervisedHyperparametersNEpochs::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuneSupervisedHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneSupervisedHyperparameters {
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<FineTuneSupervisedHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier:
                Option<FineTuneSupervisedHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<FineTuneSupervisedHyperparametersNEpochs>,
        }
        let FineTuneSupervisedHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            ..
        } = FineTuneSupervisedHyperparameters::deserialize(deserializer)?;
        Ok(Self {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        })
    }
}
impl serde::Serialize for FineTuneSupervisedHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneSupervisedHyperparameters<'a> {
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<FineTuneSupervisedHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier:
                &'a Option<FineTuneSupervisedHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<FineTuneSupervisedHyperparametersNEpochs>,
        }
        let Self {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        } = self;
        FineTuneSupervisedHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the fine-tuning job."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneSupervisedHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<FineTuneSupervisedHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier: Option<FineTuneSupervisedHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<FineTuneSupervisedHyperparametersNEpochs>,
}
impl<'de> serde::Deserialize<'de> for FineTuneSupervisedMethod {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneSupervisedMethod {
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: Option<FineTuneSupervisedHyperparameters>,
        }
        let FineTuneSupervisedMethod {
            hyperparameters, ..
        } = FineTuneSupervisedMethod::deserialize(deserializer)?;
        Ok(Self { hyperparameters })
    }
}
impl serde::Serialize for FineTuneSupervisedMethod {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneSupervisedMethod<'a> {
            #[serde(rename = "hyperparameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            hyperparameters: &'a Option<FineTuneSupervisedHyperparameters>,
        }
        let Self { hyperparameters } = self;
        FineTuneSupervisedMethod { hyperparameters }.serialize(serializer)
    }
}
#[doc = "Configuration for the supervised fine-tuning method."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuneSupervisedMethod {
    #[builder(default)]
    pub hyperparameters: Option<FineTuneSupervisedHyperparameters>,
}
impl<'de> serde::Deserialize<'de> for FineTuningCheckpointPermission {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"checkpoint.permission\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningCheckpointPermissionObject {
            #[default]
            #[serde(rename = "checkpoint.permission")]
            CheckpointPermission,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningCheckpointPermission {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: FineTuningCheckpointPermissionObject,
        }
        let FineTuningCheckpointPermission {
            id,
            created_at,
            project_id,
            ..
        } = FineTuningCheckpointPermission::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            project_id,
        })
    }
}
impl serde::Serialize for FineTuningCheckpointPermission {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"checkpoint.permission\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningCheckpointPermissionObject {
            #[default]
            #[serde(rename = "checkpoint.permission")]
            CheckpointPermission,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningCheckpointPermission<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "project_id")]
            project_id: &'a String,
            #[serde(rename = "object")]
            object: &'a FineTuningCheckpointPermissionObject,
        }
        let Self {
            id,
            created_at,
            project_id,
        } = self;
        FineTuningCheckpointPermission {
            id,
            created_at,
            project_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The `checkpoint.permission` object represents a permission for a fine-tuned model checkpoint.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningCheckpointPermission {
    #[doc = "The permission identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the permission was created."]
    pub created_at: u64,
    #[doc = "The project identifier that the permission is for."]
    pub project_id: String,
}
impl<'de> serde::Deserialize<'de> for FineTuningIntegrationWandb {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningIntegrationWandb {
            #[serde(rename = "project")]
            #[allow(dead_code)]
            project: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "entity")]
            #[allow(dead_code)]
            entity: Option<String>,
            #[serde(rename = "tags")]
            #[allow(dead_code)]
            tags: Option<Vec<String>>,
        }
        let FineTuningIntegrationWandb {
            project,
            name,
            entity,
            tags,
            ..
        } = FineTuningIntegrationWandb::deserialize(deserializer)?;
        Ok(Self {
            project,
            name,
            entity,
            tags,
        })
    }
}
impl serde::Serialize for FineTuningIntegrationWandb {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningIntegrationWandb<'a> {
            #[serde(rename = "project")]
            project: &'a String,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "entity")]
            #[serde(skip_serializing_if = "Option::is_none")]
            entity: &'a Option<String>,
            #[serde(rename = "tags")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tags: &'a Option<Vec<String>>,
        }
        let Self {
            project,
            name,
            entity,
            tags,
        } = self;
        FineTuningIntegrationWandb {
            project,
            name,
            entity,
            tags,
        }
        .serialize(serializer)
    }
}
#[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningIntegrationWandb {
    #[doc = "The name of the project that the new run will be created under.\n"]
    pub project: String,
    #[doc = "A display name to set for the run. If not set, we will use the Job ID as the name.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The entity to use for the run. This allows you to set the team or username of the WandB user that you would\nlike associated with the run. If not set, the default entity for the registered WandB API key is used.\n"]
    #[builder(default)]
    pub entity: Option<String>,
    #[doc = "A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some\ndefault tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n"]
    #[builder(default)]
    pub tags: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for FineTuningIntegration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the integration being enabled for the fine-tuning job"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningIntegrationType {
            #[default]
            #[serde(rename = "wandb")]
            Wandb,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningIntegration {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FineTuningIntegrationType,
            #[serde(rename = "wandb")]
            #[allow(dead_code)]
            wandb: FineTuningIntegrationWandb,
        }
        let FineTuningIntegration { wandb, .. } = FineTuningIntegration::deserialize(deserializer)?;
        Ok(Self { wandb })
    }
}
impl serde::Serialize for FineTuningIntegration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the integration being enabled for the fine-tuning job"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningIntegrationType {
            #[default]
            #[serde(rename = "wandb")]
            Wandb,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningIntegration<'a> {
            #[serde(rename = "type")]
            type_: &'a FineTuningIntegrationType,
            #[serde(rename = "wandb")]
            wandb: &'a FineTuningIntegrationWandb,
        }
        let Self { wandb } = self;
        FineTuningIntegration {
            type_: &Default::default(),
            wandb,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningIntegration {
    #[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
    pub wandb: FineTuningIntegrationWandb,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJobError {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
        }
        let FineTuningJobError {
            code,
            message,
            param,
            ..
        } = FineTuningJobError::deserialize(deserializer)?;
        Ok(Self {
            code,
            message,
            param,
        })
    }
}
impl serde::Serialize for FineTuningJobError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJobError<'a> {
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
        }
        let Self {
            code,
            message,
            param,
        } = self;
        FineTuningJobError {
            code,
            message,
            param,
        }
        .serialize(serializer)
    }
}
#[doc = "For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJobError {
    #[doc = "A machine-readable error code."]
    pub code: String,
    #[doc = "A human-readable error message."]
    pub message: String,
    #[doc = "The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific."]
    #[builder(default)]
    pub param: Option<String>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobHyperparametersBatchSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuningJobHyperparametersBatchSize {
            Auto(#[allow(dead_code)] FineTuningJobHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuningJobHyperparametersBatchSize::deserialize(deserializer)? {
                FineTuningJobHyperparametersBatchSize::Auto(_) => Self::Auto,
                FineTuningJobHyperparametersBatchSize::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuningJobHyperparametersBatchSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersBatchSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuningJobHyperparametersBatchSize<'a> {
            Auto(#[allow(dead_code)] &'a FineTuningJobHyperparametersBatchSizeAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => FineTuningJobHyperparametersBatchSize::Auto(&Default::default())
                .serialize(serializer),
            Self::Integer(_v) => {
                FineTuningJobHyperparametersBatchSize::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobHyperparametersBatchSize {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuningJobHyperparametersLearningRateMultiplier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuningJobHyperparametersLearningRateMultiplier {
            Auto(#[allow(dead_code)] FineTuningJobHyperparametersLearningRateMultiplierAuto),
            Number(#[allow(dead_code)] f64),
        }
        Ok(
            match FineTuningJobHyperparametersLearningRateMultiplier::deserialize(deserializer)? {
                FineTuningJobHyperparametersLearningRateMultiplier::Auto(_) => Self::Auto,
                FineTuningJobHyperparametersLearningRateMultiplier::Number(_v) => Self::Number(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuningJobHyperparametersLearningRateMultiplier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersLearningRateMultiplierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuningJobHyperparametersLearningRateMultiplier<'a> {
            Auto(#[allow(dead_code)] &'a FineTuningJobHyperparametersLearningRateMultiplierAuto),
            Number(#[allow(dead_code)] &'a f64),
        }
        match self {
            Self::Auto => {
                FineTuningJobHyperparametersLearningRateMultiplier::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Number(_v) => {
                FineTuningJobHyperparametersLearningRateMultiplier::Number(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobHyperparametersLearningRateMultiplier {
    #[doc = "auto"]
    Auto,
    Number(f64),
}
impl<'de> serde::Deserialize<'de> for FineTuningJobHyperparametersNEpochs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuningJobHyperparametersNEpochs {
            Auto(#[allow(dead_code)] FineTuningJobHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match FineTuningJobHyperparametersNEpochs::deserialize(deserializer)? {
                FineTuningJobHyperparametersNEpochs::Auto(_) => Self::Auto,
                FineTuningJobHyperparametersNEpochs::Integer(_v) => Self::Integer(_v),
            },
        )
    }
}
impl serde::Serialize for FineTuningJobHyperparametersNEpochs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobHyperparametersNEpochsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuningJobHyperparametersNEpochs<'a> {
            Auto(#[allow(dead_code)] &'a FineTuningJobHyperparametersNEpochsAuto),
            Integer(#[allow(dead_code)] &'a u64),
        }
        match self {
            Self::Auto => {
                FineTuningJobHyperparametersNEpochs::Auto(&Default::default()).serialize(serializer)
            }
            Self::Integer(_v) => {
                FineTuningJobHyperparametersNEpochs::Integer(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobHyperparametersNEpochs {
    #[doc = "auto"]
    Auto,
    Integer(u64),
}
impl<'de> serde::Deserialize<'de> for FineTuningJobHyperparameters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJobHyperparameters {
            #[serde(rename = "batch_size")]
            #[allow(dead_code)]
            batch_size: Option<FineTuningJobHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[allow(dead_code)]
            learning_rate_multiplier: Option<FineTuningJobHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[allow(dead_code)]
            n_epochs: Option<FineTuningJobHyperparametersNEpochs>,
        }
        let FineTuningJobHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
            ..
        } = FineTuningJobHyperparameters::deserialize(deserializer)?;
        Ok(Self {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        })
    }
}
impl serde::Serialize for FineTuningJobHyperparameters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJobHyperparameters<'a> {
            #[serde(rename = "batch_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_size: &'a Option<FineTuningJobHyperparametersBatchSize>,
            #[serde(rename = "learning_rate_multiplier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            learning_rate_multiplier:
                &'a Option<FineTuningJobHyperparametersLearningRateMultiplier>,
            #[serde(rename = "n_epochs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            n_epochs: &'a Option<FineTuningJobHyperparametersNEpochs>,
        }
        let Self {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        } = self;
        FineTuningJobHyperparameters {
            batch_size,
            learning_rate_multiplier,
            n_epochs,
        }
        .serialize(serializer)
    }
}
#[doc = "The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuningJobHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
    #[builder(default)]
    pub batch_size: Option<FineTuningJobHyperparametersBatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
    #[builder(default)]
    pub learning_rate_multiplier: Option<FineTuningJobHyperparametersLearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
    #[builder(default)]
    pub n_epochs: Option<FineTuningJobHyperparametersNEpochs>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusValidatingFiles {
            #[default]
            #[serde(rename = "validating_files")]
            ValidatingFiles,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusRunning {
            #[default]
            #[serde(rename = "running")]
            Running,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusSucceeded {
            #[default]
            #[serde(rename = "succeeded")]
            Succeeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuningJobStatus {
            ValidatingFiles(#[allow(dead_code)] FineTuningJobStatusValidatingFiles),
            Queued(#[allow(dead_code)] FineTuningJobStatusQueued),
            Running(#[allow(dead_code)] FineTuningJobStatusRunning),
            Succeeded(#[allow(dead_code)] FineTuningJobStatusSucceeded),
            Failed(#[allow(dead_code)] FineTuningJobStatusFailed),
            Cancelled(#[allow(dead_code)] FineTuningJobStatusCancelled),
        }
        Ok(match FineTuningJobStatus::deserialize(deserializer)? {
            FineTuningJobStatus::ValidatingFiles(_) => Self::ValidatingFiles,
            FineTuningJobStatus::Queued(_) => Self::Queued,
            FineTuningJobStatus::Running(_) => Self::Running,
            FineTuningJobStatus::Succeeded(_) => Self::Succeeded,
            FineTuningJobStatus::Failed(_) => Self::Failed,
            FineTuningJobStatus::Cancelled(_) => Self::Cancelled,
        })
    }
}
impl serde::Serialize for FineTuningJobStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusValidatingFiles {
            #[default]
            #[serde(rename = "validating_files")]
            ValidatingFiles,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusRunning {
            #[default]
            #[serde(rename = "running")]
            Running,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusSucceeded {
            #[default]
            #[serde(rename = "succeeded")]
            Succeeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuningJobStatus<'a> {
            ValidatingFiles(#[allow(dead_code)] &'a FineTuningJobStatusValidatingFiles),
            Queued(#[allow(dead_code)] &'a FineTuningJobStatusQueued),
            Running(#[allow(dead_code)] &'a FineTuningJobStatusRunning),
            Succeeded(#[allow(dead_code)] &'a FineTuningJobStatusSucceeded),
            Failed(#[allow(dead_code)] &'a FineTuningJobStatusFailed),
            Cancelled(#[allow(dead_code)] &'a FineTuningJobStatusCancelled),
        }
        match self {
            Self::ValidatingFiles => {
                FineTuningJobStatus::ValidatingFiles(&Default::default()).serialize(serializer)
            }
            Self::Queued => FineTuningJobStatus::Queued(&Default::default()).serialize(serializer),
            Self::Running => {
                FineTuningJobStatus::Running(&Default::default()).serialize(serializer)
            }
            Self::Succeeded => {
                FineTuningJobStatus::Succeeded(&Default::default()).serialize(serializer)
            }
            Self::Failed => FineTuningJobStatus::Failed(&Default::default()).serialize(serializer),
            Self::Cancelled => {
                FineTuningJobStatus::Cancelled(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobStatus {
    #[doc = "validating_files"]
    ValidatingFiles,
    #[doc = "queued"]
    Queued,
    #[doc = "running"]
    Running,
    #[doc = "succeeded"]
    Succeeded,
    #[doc = "failed"]
    Failed,
    #[doc = "cancelled"]
    Cancelled,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobIntegration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuningJobIntegration {
            FineTuningIntegration(#[allow(dead_code)] FineTuningIntegration),
        }
        Ok(match FineTuningJobIntegration::deserialize(deserializer)? {
            FineTuningJobIntegration::FineTuningIntegration(_v) => Self::FineTuningIntegration(_v),
        })
    }
}
impl serde::Serialize for FineTuningJobIntegration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuningJobIntegration<'a> {
            FineTuningIntegration(#[allow(dead_code)] &'a FineTuningIntegration),
        }
        match self {
            Self::FineTuningIntegration(_v) => {
                FineTuningJobIntegration::FineTuningIntegration(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobIntegration {
    FineTuningIntegration(FineTuningIntegration),
}
impl<'de> serde::Deserialize<'de> for FineTuningJob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"fine_tuning.job\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobObject {
            #[default]
            #[serde(rename = "fine_tuning.job")]
            FineTuningJob,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJob {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<FineTuningJobError>,
            #[serde(rename = "fine_tuned_model")]
            #[allow(dead_code)]
            fine_tuned_model: Option<String>,
            #[serde(rename = "finished_at")]
            #[allow(dead_code)]
            finished_at: Option<u64>,
            #[serde(rename = "hyperparameters")]
            #[allow(dead_code)]
            hyperparameters: FineTuningJobHyperparameters,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: FineTuningJobObject,
            #[serde(rename = "organization_id")]
            #[allow(dead_code)]
            organization_id: String,
            #[serde(rename = "result_files")]
            #[allow(dead_code)]
            result_files: Vec<String>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: FineTuningJobStatus,
            #[serde(rename = "trained_tokens")]
            #[allow(dead_code)]
            trained_tokens: Option<u64>,
            #[serde(rename = "training_file")]
            #[allow(dead_code)]
            training_file: String,
            #[serde(rename = "validation_file")]
            #[allow(dead_code)]
            validation_file: Option<String>,
            #[serde(rename = "integrations")]
            #[allow(dead_code)]
            integrations: Option<Vec<FineTuningJobIntegration>>,
            #[serde(rename = "seed")]
            #[allow(dead_code)]
            seed: u64,
            #[serde(rename = "estimated_finish")]
            #[allow(dead_code)]
            estimated_finish: Option<u64>,
            #[serde(rename = "method")]
            #[allow(dead_code)]
            method: Option<FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let FineTuningJob {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
            ..
        } = FineTuningJob::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        })
    }
}
impl serde::Serialize for FineTuningJob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"fine_tuning.job\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobObject {
            #[default]
            #[serde(rename = "fine_tuning.job")]
            FineTuningJob,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJob<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<FineTuningJobError>,
            #[serde(rename = "fine_tuned_model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            fine_tuned_model: &'a Option<String>,
            #[serde(rename = "finished_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            finished_at: &'a Option<u64>,
            #[serde(rename = "hyperparameters")]
            hyperparameters: &'a FineTuningJobHyperparameters,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "object")]
            object: &'a FineTuningJobObject,
            #[serde(rename = "organization_id")]
            organization_id: &'a String,
            #[serde(rename = "result_files")]
            result_files: &'a Vec<String>,
            #[serde(rename = "status")]
            status: &'a FineTuningJobStatus,
            #[serde(rename = "trained_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            trained_tokens: &'a Option<u64>,
            #[serde(rename = "training_file")]
            training_file: &'a String,
            #[serde(rename = "validation_file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            validation_file: &'a Option<String>,
            #[serde(rename = "integrations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            integrations: &'a Option<Vec<FineTuningJobIntegration>>,
            #[serde(rename = "seed")]
            seed: &'a u64,
            #[serde(rename = "estimated_finish")]
            #[serde(skip_serializing_if = "Option::is_none")]
            estimated_finish: &'a Option<u64>,
            #[serde(rename = "method")]
            #[serde(skip_serializing_if = "Option::is_none")]
            method: &'a Option<FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        } = self;
        FineTuningJob {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            object: &Default::default(),
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "The `fine_tuning.job` object represents a fine-tuning job that has been created through the API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJob {
    #[doc = "The object identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was created."]
    pub created_at: u64,
    #[doc = "For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure."]
    #[builder(default)]
    pub error: Option<FineTuningJobError>,
    #[doc = "The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub fine_tuned_model: Option<String>,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub finished_at: Option<u64>,
    #[doc = "The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs."]
    #[builder(default)]
    pub hyperparameters: FineTuningJobHyperparameters,
    #[doc = "The base model that is being fine-tuned."]
    pub model: String,
    #[doc = "The organization that owns the fine-tuning job."]
    pub organization_id: String,
    #[doc = "The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    pub result_files: Vec<String>,
    #[doc = "The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`."]
    pub status: FineTuningJobStatus,
    #[doc = "The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub trained_tokens: Option<u64>,
    #[doc = "The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    pub training_file: String,
    #[doc = "The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    #[builder(default)]
    pub validation_file: Option<String>,
    #[doc = "A list of integrations to enable for this fine-tuning job."]
    #[builder(default)]
    pub integrations: Option<Vec<FineTuningJobIntegration>>,
    #[doc = "The seed used for the fine-tuning job."]
    pub seed: u64,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running."]
    #[builder(default)]
    pub estimated_finish: Option<u64>,
    #[builder(default)]
    pub method: Option<FineTuneMethod>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobCheckpointMetrics {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJobCheckpointMetrics {
            #[serde(rename = "step")]
            #[allow(dead_code)]
            step: Option<f64>,
            #[serde(rename = "train_loss")]
            #[allow(dead_code)]
            train_loss: Option<f64>,
            #[serde(rename = "train_mean_token_accuracy")]
            #[allow(dead_code)]
            train_mean_token_accuracy: Option<f64>,
            #[serde(rename = "valid_loss")]
            #[allow(dead_code)]
            valid_loss: Option<f64>,
            #[serde(rename = "valid_mean_token_accuracy")]
            #[allow(dead_code)]
            valid_mean_token_accuracy: Option<f64>,
            #[serde(rename = "full_valid_loss")]
            #[allow(dead_code)]
            full_valid_loss: Option<f64>,
            #[serde(rename = "full_valid_mean_token_accuracy")]
            #[allow(dead_code)]
            full_valid_mean_token_accuracy: Option<f64>,
        }
        let FineTuningJobCheckpointMetrics {
            step,
            train_loss,
            train_mean_token_accuracy,
            valid_loss,
            valid_mean_token_accuracy,
            full_valid_loss,
            full_valid_mean_token_accuracy,
            ..
        } = FineTuningJobCheckpointMetrics::deserialize(deserializer)?;
        Ok(Self {
            step,
            train_loss,
            train_mean_token_accuracy,
            valid_loss,
            valid_mean_token_accuracy,
            full_valid_loss,
            full_valid_mean_token_accuracy,
        })
    }
}
impl serde::Serialize for FineTuningJobCheckpointMetrics {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJobCheckpointMetrics<'a> {
            #[serde(rename = "step")]
            #[serde(skip_serializing_if = "Option::is_none")]
            step: &'a Option<f64>,
            #[serde(rename = "train_loss")]
            #[serde(skip_serializing_if = "Option::is_none")]
            train_loss: &'a Option<f64>,
            #[serde(rename = "train_mean_token_accuracy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            train_mean_token_accuracy: &'a Option<f64>,
            #[serde(rename = "valid_loss")]
            #[serde(skip_serializing_if = "Option::is_none")]
            valid_loss: &'a Option<f64>,
            #[serde(rename = "valid_mean_token_accuracy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            valid_mean_token_accuracy: &'a Option<f64>,
            #[serde(rename = "full_valid_loss")]
            #[serde(skip_serializing_if = "Option::is_none")]
            full_valid_loss: &'a Option<f64>,
            #[serde(rename = "full_valid_mean_token_accuracy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            full_valid_mean_token_accuracy: &'a Option<f64>,
        }
        let Self {
            step,
            train_loss,
            train_mean_token_accuracy,
            valid_loss,
            valid_mean_token_accuracy,
            full_valid_loss,
            full_valid_mean_token_accuracy,
        } = self;
        FineTuningJobCheckpointMetrics {
            step,
            train_loss,
            train_mean_token_accuracy,
            valid_loss,
            valid_mean_token_accuracy,
            full_valid_loss,
            full_valid_mean_token_accuracy,
        }
        .serialize(serializer)
    }
}
#[doc = "Metrics at the step number during the fine-tuning job."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct FineTuningJobCheckpointMetrics {
    #[builder(default)]
    pub step: Option<f64>,
    #[builder(default)]
    pub train_loss: Option<f64>,
    #[builder(default)]
    pub train_mean_token_accuracy: Option<f64>,
    #[builder(default)]
    pub valid_loss: Option<f64>,
    #[builder(default)]
    pub valid_mean_token_accuracy: Option<f64>,
    #[builder(default)]
    pub full_valid_loss: Option<f64>,
    #[builder(default)]
    pub full_valid_mean_token_accuracy: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobCheckpoint {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"fine_tuning.job.checkpoint\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobCheckpointObject {
            #[default]
            #[serde(rename = "fine_tuning.job.checkpoint")]
            FineTuningJobCheckpoint,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJobCheckpoint {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            #[allow(dead_code)]
            fine_tuned_model_checkpoint: String,
            #[serde(rename = "step_number")]
            #[allow(dead_code)]
            step_number: u64,
            #[serde(rename = "metrics")]
            #[allow(dead_code)]
            metrics: FineTuningJobCheckpointMetrics,
            #[serde(rename = "fine_tuning_job_id")]
            #[allow(dead_code)]
            fine_tuning_job_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: FineTuningJobCheckpointObject,
        }
        let FineTuningJobCheckpoint {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
            ..
        } = FineTuningJobCheckpoint::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
        })
    }
}
impl serde::Serialize for FineTuningJobCheckpoint {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"fine_tuning.job.checkpoint\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobCheckpointObject {
            #[default]
            #[serde(rename = "fine_tuning.job.checkpoint")]
            FineTuningJobCheckpoint,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJobCheckpoint<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            fine_tuned_model_checkpoint: &'a String,
            #[serde(rename = "step_number")]
            step_number: &'a u64,
            #[serde(rename = "metrics")]
            metrics: &'a FineTuningJobCheckpointMetrics,
            #[serde(rename = "fine_tuning_job_id")]
            fine_tuning_job_id: &'a String,
            #[serde(rename = "object")]
            object: &'a FineTuningJobCheckpointObject,
        }
        let Self {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
        } = self;
        FineTuningJobCheckpoint {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJobCheckpoint {
    #[doc = "The checkpoint identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the checkpoint was created."]
    pub created_at: u64,
    #[doc = "The name of the fine-tuned checkpoint model that is created."]
    pub fine_tuned_model_checkpoint: String,
    #[doc = "The step number that the checkpoint was created at."]
    pub step_number: u64,
    #[doc = "Metrics at the step number during the fine-tuning job."]
    #[builder(default)]
    pub metrics: FineTuningJobCheckpointMetrics,
    #[doc = "The name of the fine-tuning job that this checkpoint was created from."]
    pub fine_tuning_job_id: String,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobEventLevel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelInfo {
            #[default]
            #[serde(rename = "info")]
            Info,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelWarn {
            #[default]
            #[serde(rename = "warn")]
            Warn,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelError {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuningJobEventLevel {
            Info(#[allow(dead_code)] FineTuningJobEventLevelInfo),
            Warn(#[allow(dead_code)] FineTuningJobEventLevelWarn),
            Error(#[allow(dead_code)] FineTuningJobEventLevelError),
        }
        Ok(match FineTuningJobEventLevel::deserialize(deserializer)? {
            FineTuningJobEventLevel::Info(_) => Self::Info,
            FineTuningJobEventLevel::Warn(_) => Self::Warn,
            FineTuningJobEventLevel::Error(_) => Self::Error,
        })
    }
}
impl serde::Serialize for FineTuningJobEventLevel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelInfo {
            #[default]
            #[serde(rename = "info")]
            Info,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelWarn {
            #[default]
            #[serde(rename = "warn")]
            Warn,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventLevelError {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuningJobEventLevel<'a> {
            Info(#[allow(dead_code)] &'a FineTuningJobEventLevelInfo),
            Warn(#[allow(dead_code)] &'a FineTuningJobEventLevelWarn),
            Error(#[allow(dead_code)] &'a FineTuningJobEventLevelError),
        }
        match self {
            Self::Info => FineTuningJobEventLevel::Info(&Default::default()).serialize(serializer),
            Self::Warn => FineTuningJobEventLevel::Warn(&Default::default()).serialize(serializer),
            Self::Error => {
                FineTuningJobEventLevel::Error(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The log level of the event."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobEventLevel {
    #[doc = "info"]
    Info,
    #[doc = "warn"]
    Warn,
    #[doc = "error"]
    Error,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobEventType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventTypeMetrics {
            #[default]
            #[serde(rename = "metrics")]
            Metrics,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FineTuningJobEventType {
            Message(#[allow(dead_code)] FineTuningJobEventTypeMessage),
            Metrics(#[allow(dead_code)] FineTuningJobEventTypeMetrics),
        }
        Ok(match FineTuningJobEventType::deserialize(deserializer)? {
            FineTuningJobEventType::Message(_) => Self::Message,
            FineTuningJobEventType::Metrics(_) => Self::Metrics,
        })
    }
}
impl serde::Serialize for FineTuningJobEventType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventTypeMetrics {
            #[default]
            #[serde(rename = "metrics")]
            Metrics,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FineTuningJobEventType<'a> {
            Message(#[allow(dead_code)] &'a FineTuningJobEventTypeMessage),
            Metrics(#[allow(dead_code)] &'a FineTuningJobEventTypeMetrics),
        }
        match self {
            Self::Message => {
                FineTuningJobEventType::Message(&Default::default()).serialize(serializer)
            }
            Self::Metrics => {
                FineTuningJobEventType::Metrics(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of event."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FineTuningJobEventType {
    #[doc = "message"]
    Message,
    #[doc = "metrics"]
    Metrics,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"fine_tuning.job.event\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventObject {
            #[default]
            #[serde(rename = "fine_tuning.job.event")]
            FineTuningJobEvent,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJobEvent {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: FineTuningJobEventObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "level")]
            #[allow(dead_code)]
            level: FineTuningJobEventLevel,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<FineTuningJobEventType>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let FineTuningJobEvent {
            id,
            created_at,
            level,
            message,
            type_,
            data,
            ..
        } = FineTuningJobEvent::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            level,
            message,
            type_,
            data,
        })
    }
}
impl serde::Serialize for FineTuningJobEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"fine_tuning.job.event\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FineTuningJobEventObject {
            #[default]
            #[serde(rename = "fine_tuning.job.event")]
            FineTuningJobEvent,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJobEvent<'a> {
            #[serde(rename = "object")]
            object: &'a FineTuningJobEventObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "level")]
            level: &'a FineTuningJobEventLevel,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<FineTuningJobEventType>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            id,
            created_at,
            level,
            message,
            type_,
            data,
        } = self;
        FineTuningJobEvent {
            object: &Default::default(),
            id,
            created_at,
            level,
            message,
            type_,
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Fine-tuning job event object"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJobEvent {
    #[doc = "The object identifier."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was created."]
    pub created_at: u64,
    #[doc = "The log level of the event."]
    pub level: FineTuningJobEventLevel,
    #[doc = "The message of the event."]
    pub message: String,
    #[doc = "The type of event."]
    #[builder(default)]
    pub type_: Option<FineTuningJobEventType>,
    #[doc = "The data associated with the event."]
    #[builder(default)]
    pub data: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for FunctionObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionObject {
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<FunctionParameters>,
            #[serde(rename = "strict")]
            #[allow(dead_code)]
            strict: Option<bool>,
        }
        let FunctionObject {
            description,
            name,
            parameters,
            strict,
            ..
        } = FunctionObject::deserialize(deserializer)?;
        Ok(Self {
            description,
            name,
            parameters,
            strict,
        })
    }
}
impl serde::Serialize for FunctionObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionObject<'a> {
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<FunctionParameters>,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let Self {
            description,
            name,
            parameters,
            strict,
        } = self;
        FunctionObject {
            description,
            name,
            parameters,
            strict,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionObject {
    #[doc = "A description of what the function does, used by the model to choose when and how to call the function."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."]
    pub name: String,
    #[builder(default)]
    pub parameters: Option<FunctionParameters>,
    #[doc = "Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](docs/guides/function-calling)."]
    #[builder(default)]
    pub strict: Option<bool>,
}
#[doc = "The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format. \n\nOmitting `parameters` defines a function with an empty parameter list."]
pub type FunctionParameters = std::collections::HashMap<String, serde_json::Value>;
impl<'de> serde::Deserialize<'de> for FunctionToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FunctionToolCallStatus {
            InProgress(#[allow(dead_code)] FunctionToolCallStatusInProgress),
            Completed(#[allow(dead_code)] FunctionToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] FunctionToolCallStatusIncomplete),
        }
        Ok(match FunctionToolCallStatus::deserialize(deserializer)? {
            FunctionToolCallStatus::InProgress(_) => Self::InProgress,
            FunctionToolCallStatus::Completed(_) => Self::Completed,
            FunctionToolCallStatus::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for FunctionToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FunctionToolCallStatus<'a> {
            InProgress(#[allow(dead_code)] &'a FunctionToolCallStatusInProgress),
            Completed(#[allow(dead_code)] &'a FunctionToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a FunctionToolCallStatusIncomplete),
        }
        match self {
            Self::InProgress => {
                FunctionToolCallStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                FunctionToolCallStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                FunctionToolCallStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FunctionToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the function tool call. Always `function_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallType {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionToolCall {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FunctionToolCallType,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<FunctionToolCallStatus>,
        }
        let FunctionToolCall {
            id,
            call_id,
            name,
            arguments,
            status,
            ..
        } = FunctionToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            name,
            arguments,
            status,
        })
    }
}
impl serde::Serialize for FunctionToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the function tool call. Always `function_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallType {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionToolCall<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a FunctionToolCallType,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<FunctionToolCallStatus>,
        }
        let Self {
            id,
            call_id,
            name,
            arguments,
            status,
        } = self;
        FunctionToolCall {
            id,
            type_: &Default::default(),
            call_id,
            name,
            arguments,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool call to run a function. See the \n[function calling guide](https://platform.openai.com/docs/guides/function-calling) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCall {
    #[doc = "The unique ID of the function tool call.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model.\n"]
    pub call_id: String,
    #[doc = "The name of the function to run.\n"]
    pub name: String,
    #[doc = "A JSON string of the arguments to pass to the function.\n"]
    pub arguments: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<FunctionToolCallStatus>,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallOutputStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FunctionToolCallOutputStatus {
            InProgress(#[allow(dead_code)] FunctionToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] FunctionToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] FunctionToolCallOutputStatusIncomplete),
        }
        Ok(
            match FunctionToolCallOutputStatus::deserialize(deserializer)? {
                FunctionToolCallOutputStatus::InProgress(_) => Self::InProgress,
                FunctionToolCallOutputStatus::Completed(_) => Self::Completed,
                FunctionToolCallOutputStatus::Incomplete(_) => Self::Incomplete,
            },
        )
    }
}
impl serde::Serialize for FunctionToolCallOutputStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FunctionToolCallOutputStatus<'a> {
            InProgress(#[allow(dead_code)] &'a FunctionToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] &'a FunctionToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a FunctionToolCallOutputStatusIncomplete),
        }
        match self {
            Self::InProgress => {
                FunctionToolCallOutputStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                FunctionToolCallOutputStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                FunctionToolCallOutputStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FunctionToolCallOutputStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the function tool call output. Always `function_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputType {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionToolCallOutput {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FunctionToolCallOutputType,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<FunctionToolCallOutputStatus>,
        }
        let FunctionToolCallOutput {
            id,
            call_id,
            output,
            status,
            ..
        } = FunctionToolCallOutput::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            output,
            status,
        })
    }
}
impl serde::Serialize for FunctionToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the function tool call output. Always `function_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolCallOutputType {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionToolCallOutput<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a FunctionToolCallOutputType,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<FunctionToolCallOutputStatus>,
        }
        let Self {
            id,
            call_id,
            output,
            status,
        } = self;
        FunctionToolCallOutput {
            id,
            type_: &Default::default(),
            call_id,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a function tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallOutput {
    #[doc = "The unique ID of the function tool call output. Populated when this item\nis returned via API.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model.\n"]
    pub call_id: String,
    #[doc = "A JSON string of the output of the function tool call.\n"]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<FunctionToolCallOutputStatus>,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallOutputResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionToolCallOutputResource {
            #[serde(flatten)]
            #[allow(dead_code)]
            function_tool_call_output: FunctionToolCallOutput,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let FunctionToolCallOutputResource {
            function_tool_call_output,
            id,
            ..
        } = FunctionToolCallOutputResource::deserialize(deserializer)?;
        Ok(Self {
            function_tool_call_output,
            id,
        })
    }
}
impl serde::Serialize for FunctionToolCallOutputResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionToolCallOutputResource<'a> {
            #[serde(flatten)]
            function_tool_call_output: &'a FunctionToolCallOutput,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self {
            function_tool_call_output,
            id,
        } = self;
        FunctionToolCallOutputResource {
            function_tool_call_output,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallOutputResource {
    pub function_tool_call_output: FunctionToolCallOutput,
    #[doc = "The unique ID of the function call tool output.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionToolCallResource {
            #[serde(flatten)]
            #[allow(dead_code)]
            function_tool_call: FunctionToolCall,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let FunctionToolCallResource {
            function_tool_call,
            id,
            ..
        } = FunctionToolCallResource::deserialize(deserializer)?;
        Ok(Self {
            function_tool_call,
            id,
        })
    }
}
impl serde::Serialize for FunctionToolCallResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionToolCallResource<'a> {
            #[serde(flatten)]
            function_tool_call: &'a FunctionToolCall,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self {
            function_tool_call,
            id,
        } = self;
        FunctionToolCallResource {
            function_tool_call,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallResource {
    pub function_tool_call: FunctionToolCall,
    #[doc = "The unique ID of the function tool call.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for GraderLabelModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `label_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderLabelModelType {
            #[default]
            #[serde(rename = "label_model")]
            LabelModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderLabelModel {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: GraderLabelModelType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Vec<EvalItem>,
            #[serde(rename = "labels")]
            #[allow(dead_code)]
            labels: Vec<String>,
            #[serde(rename = "passing_labels")]
            #[allow(dead_code)]
            passing_labels: Vec<String>,
        }
        let GraderLabelModel {
            name,
            model,
            input,
            labels,
            passing_labels,
            ..
        } = GraderLabelModel::deserialize(deserializer)?;
        Ok(Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        })
    }
}
impl serde::Serialize for GraderLabelModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `label_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderLabelModelType {
            #[default]
            #[serde(rename = "label_model")]
            LabelModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderLabelModel<'a> {
            #[serde(rename = "type")]
            type_: &'a GraderLabelModelType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a Vec<EvalItem>,
            #[serde(rename = "labels")]
            labels: &'a Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: &'a Vec<String>,
        }
        let Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        } = self;
        GraderLabelModel {
            type_: &Default::default(),
            name,
            model,
            input,
            labels,
            passing_labels,
        }
        .serialize(serializer)
    }
}
#[doc = "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderLabelModel {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation. Must support structured outputs."]
    pub model: String,
    pub input: Vec<EvalItem>,
    #[doc = "The labels to assign to each item in the evaluation."]
    pub labels: Vec<String>,
    #[doc = "The labels that indicate a passing result. Must be a subset of labels."]
    pub passing_labels: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for GraderMultiGraders {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum GraderMultiGraders {
            StringCheck(#[allow(dead_code)] GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] GraderTextSimilarity),
            Python(#[allow(dead_code)] GraderPython),
            ScoreModel(#[allow(dead_code)] GraderScoreModel),
            LabelModel(#[allow(dead_code)] GraderLabelModel),
        }
        Ok(match GraderMultiGraders::deserialize(deserializer)? {
            GraderMultiGraders::StringCheck(_v) => Self::StringCheck(_v),
            GraderMultiGraders::TextSimilarity(_v) => Self::TextSimilarity(_v),
            GraderMultiGraders::Python(_v) => Self::Python(_v),
            GraderMultiGraders::ScoreModel(_v) => Self::ScoreModel(_v),
            GraderMultiGraders::LabelModel(_v) => Self::LabelModel(_v),
        })
    }
}
impl serde::Serialize for GraderMultiGraders {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum GraderMultiGraders<'a> {
            StringCheck(#[allow(dead_code)] &'a GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] &'a GraderTextSimilarity),
            Python(#[allow(dead_code)] &'a GraderPython),
            ScoreModel(#[allow(dead_code)] &'a GraderScoreModel),
            LabelModel(#[allow(dead_code)] &'a GraderLabelModel),
        }
        match self {
            Self::StringCheck(_v) => GraderMultiGraders::StringCheck(_v).serialize(serializer),
            Self::TextSimilarity(_v) => {
                GraderMultiGraders::TextSimilarity(_v).serialize(serializer)
            }
            Self::Python(_v) => GraderMultiGraders::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => GraderMultiGraders::ScoreModel(_v).serialize(serializer),
            Self::LabelModel(_v) => GraderMultiGraders::LabelModel(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum GraderMultiGraders {
    StringCheck(GraderStringCheck),
    TextSimilarity(GraderTextSimilarity),
    Python(GraderPython),
    ScoreModel(GraderScoreModel),
    LabelModel(GraderLabelModel),
}
impl<'de> serde::Deserialize<'de> for GraderMulti {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `multi`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderMultiType {
            #[default]
            #[serde(rename = "multi")]
            Multi,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderMulti {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: GraderMultiType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "graders")]
            #[allow(dead_code)]
            graders: GraderMultiGraders,
            #[serde(rename = "calculate_output")]
            #[allow(dead_code)]
            calculate_output: String,
        }
        let GraderMulti {
            name,
            graders,
            calculate_output,
            ..
        } = GraderMulti::deserialize(deserializer)?;
        Ok(Self {
            name,
            graders,
            calculate_output,
        })
    }
}
impl serde::Serialize for GraderMulti {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `multi`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderMultiType {
            #[default]
            #[serde(rename = "multi")]
            Multi,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderMulti<'a> {
            #[serde(rename = "type")]
            type_: &'a GraderMultiType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "graders")]
            graders: &'a GraderMultiGraders,
            #[serde(rename = "calculate_output")]
            calculate_output: &'a String,
        }
        let Self {
            name,
            graders,
            calculate_output,
        } = self;
        GraderMulti {
            type_: &Default::default(),
            name,
            graders,
            calculate_output,
        }
        .serialize(serializer)
    }
}
#[doc = "A MultiGrader object combines the output of multiple graders to produce a single score."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderMulti {
    #[doc = "The name of the grader."]
    pub name: String,
    pub graders: GraderMultiGraders,
    #[doc = "A formula to calculate the output based on grader results."]
    pub calculate_output: String,
}
impl<'de> serde::Deserialize<'de> for GraderPython {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `python`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderPythonType {
            #[default]
            #[serde(rename = "python")]
            Python,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderPython {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: GraderPythonType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: String,
            #[serde(rename = "image_tag")]
            #[allow(dead_code)]
            image_tag: Option<String>,
        }
        let GraderPython {
            name,
            source,
            image_tag,
            ..
        } = GraderPython::deserialize(deserializer)?;
        Ok(Self {
            name,
            source,
            image_tag,
        })
    }
}
impl serde::Serialize for GraderPython {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `python`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderPythonType {
            #[default]
            #[serde(rename = "python")]
            Python,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderPython<'a> {
            #[serde(rename = "type")]
            type_: &'a GraderPythonType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "source")]
            source: &'a String,
            #[serde(rename = "image_tag")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_tag: &'a Option<String>,
        }
        let Self {
            name,
            source,
            image_tag,
        } = self;
        GraderPython {
            type_: &Default::default(),
            name,
            source,
            image_tag,
        }
        .serialize(serializer)
    }
}
#[doc = "A PythonGrader object that runs a python script on the input.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderPython {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The source code of the python script."]
    pub source: String,
    #[doc = "The image tag to use for the python script."]
    #[builder(default)]
    pub image_tag: Option<String>,
}
impl<'de> serde::Deserialize<'de> for GraderScoreModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `score_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderScoreModelType {
            #[default]
            #[serde(rename = "score_model")]
            ScoreModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderScoreModel {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: GraderScoreModelType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "sampling_params")]
            #[allow(dead_code)]
            sampling_params: Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Vec<EvalItem>,
            #[serde(rename = "range")]
            #[allow(dead_code)]
            range: Option<Vec<f64>>,
        }
        let GraderScoreModel {
            name,
            model,
            sampling_params,
            input,
            range,
            ..
        } = GraderScoreModel::deserialize(deserializer)?;
        Ok(Self {
            name,
            model,
            sampling_params,
            input,
            range,
        })
    }
}
impl serde::Serialize for GraderScoreModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `score_model`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderScoreModelType {
            #[default]
            #[serde(rename = "score_model")]
            ScoreModel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderScoreModel<'a> {
            #[serde(rename = "type")]
            type_: &'a GraderScoreModelType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "input")]
            input: &'a Vec<EvalItem>,
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            range: &'a Option<Vec<f64>>,
        }
        let Self {
            name,
            model,
            sampling_params,
            input,
            range,
        } = self;
        GraderScoreModel {
            type_: &Default::default(),
            name,
            model,
            sampling_params,
            input,
            range,
        }
        .serialize(serializer)
    }
}
#[doc = "A ScoreModelGrader object that uses a model to assign a score to the input.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderScoreModel {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation."]
    pub model: String,
    #[doc = "The sampling parameters for the model."]
    #[builder(default)]
    pub sampling_params: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[doc = "The input text. This may include template strings."]
    pub input: Vec<EvalItem>,
    #[doc = "The range of the score. Defaults to `[0, 1]`."]
    #[builder(default)]
    pub range: Option<Vec<f64>>,
}
impl<'de> serde::Deserialize<'de> for GraderStringCheckOperation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckOperationEq {
            #[default]
            #[serde(rename = "eq")]
            Eq,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckOperationNe {
            #[default]
            #[serde(rename = "ne")]
            Ne,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckOperationLike {
            #[default]
            #[serde(rename = "like")]
            Like,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckOperationIlike {
            #[default]
            #[serde(rename = "ilike")]
            Ilike,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum GraderStringCheckOperation {
            Eq(#[allow(dead_code)] GraderStringCheckOperationEq),
            Ne(#[allow(dead_code)] GraderStringCheckOperationNe),
            Like(#[allow(dead_code)] GraderStringCheckOperationLike),
            Ilike(#[allow(dead_code)] GraderStringCheckOperationIlike),
        }
        Ok(
            match GraderStringCheckOperation::deserialize(deserializer)? {
                GraderStringCheckOperation::Eq(_) => Self::Eq,
                GraderStringCheckOperation::Ne(_) => Self::Ne,
                GraderStringCheckOperation::Like(_) => Self::Like,
                GraderStringCheckOperation::Ilike(_) => Self::Ilike,
            },
        )
    }
}
impl serde::Serialize for GraderStringCheckOperation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckOperationEq {
            #[default]
            #[serde(rename = "eq")]
            Eq,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckOperationNe {
            #[default]
            #[serde(rename = "ne")]
            Ne,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckOperationLike {
            #[default]
            #[serde(rename = "like")]
            Like,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckOperationIlike {
            #[default]
            #[serde(rename = "ilike")]
            Ilike,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum GraderStringCheckOperation<'a> {
            Eq(#[allow(dead_code)] &'a GraderStringCheckOperationEq),
            Ne(#[allow(dead_code)] &'a GraderStringCheckOperationNe),
            Like(#[allow(dead_code)] &'a GraderStringCheckOperationLike),
            Ilike(#[allow(dead_code)] &'a GraderStringCheckOperationIlike),
        }
        match self {
            Self::Eq => GraderStringCheckOperation::Eq(&Default::default()).serialize(serializer),
            Self::Ne => GraderStringCheckOperation::Ne(&Default::default()).serialize(serializer),
            Self::Like => {
                GraderStringCheckOperation::Like(&Default::default()).serialize(serializer)
            }
            Self::Ilike => {
                GraderStringCheckOperation::Ilike(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum GraderStringCheckOperation {
    #[doc = "eq"]
    Eq,
    #[doc = "ne"]
    Ne,
    #[doc = "like"]
    Like,
    #[doc = "ilike"]
    Ilike,
}
impl<'de> serde::Deserialize<'de> for GraderStringCheck {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `string_check`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckType {
            #[default]
            #[serde(rename = "string_check")]
            StringCheck,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderStringCheck {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: GraderStringCheckType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: String,
            #[serde(rename = "reference")]
            #[allow(dead_code)]
            reference: String,
            #[serde(rename = "operation")]
            #[allow(dead_code)]
            operation: GraderStringCheckOperation,
        }
        let GraderStringCheck {
            name,
            input,
            reference,
            operation,
            ..
        } = GraderStringCheck::deserialize(deserializer)?;
        Ok(Self {
            name,
            input,
            reference,
            operation,
        })
    }
}
impl serde::Serialize for GraderStringCheck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `string_check`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderStringCheckType {
            #[default]
            #[serde(rename = "string_check")]
            StringCheck,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderStringCheck<'a> {
            #[serde(rename = "type")]
            type_: &'a GraderStringCheckType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "reference")]
            reference: &'a String,
            #[serde(rename = "operation")]
            operation: &'a GraderStringCheckOperation,
        }
        let Self {
            name,
            input,
            reference,
            operation,
        } = self;
        GraderStringCheck {
            type_: &Default::default(),
            name,
            input,
            reference,
            operation,
        }
        .serialize(serializer)
    }
}
#[doc = "A StringCheckGrader object that performs a string comparison between input and reference using a specified operation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderStringCheck {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The input text. This may include template strings."]
    pub input: String,
    #[doc = "The reference text. This may include template strings."]
    pub reference: String,
    #[doc = "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."]
    pub operation: GraderStringCheckOperation,
}
impl<'de> serde::Deserialize<'de> for GraderTextSimilarityEvaluationMetric {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricFuzzyMatch {
            #[default]
            #[serde(rename = "fuzzy_match")]
            FuzzyMatch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricBleu {
            #[default]
            #[serde(rename = "bleu")]
            Bleu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricGleu {
            #[default]
            #[serde(rename = "gleu")]
            Gleu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricMeteor {
            #[default]
            #[serde(rename = "meteor")]
            Meteor,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge1 {
            #[default]
            #[serde(rename = "rouge_1")]
            Rouge1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge2 {
            #[default]
            #[serde(rename = "rouge_2")]
            Rouge2,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge3 {
            #[default]
            #[serde(rename = "rouge_3")]
            Rouge3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge4 {
            #[default]
            #[serde(rename = "rouge_4")]
            Rouge4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge5 {
            #[default]
            #[serde(rename = "rouge_5")]
            Rouge5,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRougeL {
            #[default]
            #[serde(rename = "rouge_l")]
            RougeL,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum GraderTextSimilarityEvaluationMetric {
            FuzzyMatch(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricFuzzyMatch),
            Bleu(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricBleu),
            Gleu(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricGleu),
            Meteor(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricMeteor),
            Rouge1(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricRouge1),
            Rouge2(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricRouge2),
            Rouge3(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricRouge3),
            Rouge4(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricRouge4),
            Rouge5(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricRouge5),
            RougeL(#[allow(dead_code)] GraderTextSimilarityEvaluationMetricRougeL),
        }
        Ok(
            match GraderTextSimilarityEvaluationMetric::deserialize(deserializer)? {
                GraderTextSimilarityEvaluationMetric::FuzzyMatch(_) => Self::FuzzyMatch,
                GraderTextSimilarityEvaluationMetric::Bleu(_) => Self::Bleu,
                GraderTextSimilarityEvaluationMetric::Gleu(_) => Self::Gleu,
                GraderTextSimilarityEvaluationMetric::Meteor(_) => Self::Meteor,
                GraderTextSimilarityEvaluationMetric::Rouge1(_) => Self::Rouge1,
                GraderTextSimilarityEvaluationMetric::Rouge2(_) => Self::Rouge2,
                GraderTextSimilarityEvaluationMetric::Rouge3(_) => Self::Rouge3,
                GraderTextSimilarityEvaluationMetric::Rouge4(_) => Self::Rouge4,
                GraderTextSimilarityEvaluationMetric::Rouge5(_) => Self::Rouge5,
                GraderTextSimilarityEvaluationMetric::RougeL(_) => Self::RougeL,
            },
        )
    }
}
impl serde::Serialize for GraderTextSimilarityEvaluationMetric {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricFuzzyMatch {
            #[default]
            #[serde(rename = "fuzzy_match")]
            FuzzyMatch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricBleu {
            #[default]
            #[serde(rename = "bleu")]
            Bleu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricGleu {
            #[default]
            #[serde(rename = "gleu")]
            Gleu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricMeteor {
            #[default]
            #[serde(rename = "meteor")]
            Meteor,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge1 {
            #[default]
            #[serde(rename = "rouge_1")]
            Rouge1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge2 {
            #[default]
            #[serde(rename = "rouge_2")]
            Rouge2,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge3 {
            #[default]
            #[serde(rename = "rouge_3")]
            Rouge3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge4 {
            #[default]
            #[serde(rename = "rouge_4")]
            Rouge4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRouge5 {
            #[default]
            #[serde(rename = "rouge_5")]
            Rouge5,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityEvaluationMetricRougeL {
            #[default]
            #[serde(rename = "rouge_l")]
            RougeL,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum GraderTextSimilarityEvaluationMetric<'a> {
            FuzzyMatch(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricFuzzyMatch),
            Bleu(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricBleu),
            Gleu(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricGleu),
            Meteor(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricMeteor),
            Rouge1(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricRouge1),
            Rouge2(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricRouge2),
            Rouge3(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricRouge3),
            Rouge4(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricRouge4),
            Rouge5(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricRouge5),
            RougeL(#[allow(dead_code)] &'a GraderTextSimilarityEvaluationMetricRougeL),
        }
        match self {
            Self::FuzzyMatch => {
                GraderTextSimilarityEvaluationMetric::FuzzyMatch(&Default::default())
                    .serialize(serializer)
            }
            Self::Bleu => GraderTextSimilarityEvaluationMetric::Bleu(&Default::default())
                .serialize(serializer),
            Self::Gleu => GraderTextSimilarityEvaluationMetric::Gleu(&Default::default())
                .serialize(serializer),
            Self::Meteor => GraderTextSimilarityEvaluationMetric::Meteor(&Default::default())
                .serialize(serializer),
            Self::Rouge1 => GraderTextSimilarityEvaluationMetric::Rouge1(&Default::default())
                .serialize(serializer),
            Self::Rouge2 => GraderTextSimilarityEvaluationMetric::Rouge2(&Default::default())
                .serialize(serializer),
            Self::Rouge3 => GraderTextSimilarityEvaluationMetric::Rouge3(&Default::default())
                .serialize(serializer),
            Self::Rouge4 => GraderTextSimilarityEvaluationMetric::Rouge4(&Default::default())
                .serialize(serializer),
            Self::Rouge5 => GraderTextSimilarityEvaluationMetric::Rouge5(&Default::default())
                .serialize(serializer),
            Self::RougeL => GraderTextSimilarityEvaluationMetric::RougeL(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The evaluation metric to use. One of `fuzzy_match`, `bleu`, `gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, or `rouge_l`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum GraderTextSimilarityEvaluationMetric {
    #[doc = "fuzzy_match"]
    FuzzyMatch,
    #[doc = "bleu"]
    Bleu,
    #[doc = "gleu"]
    Gleu,
    #[doc = "meteor"]
    Meteor,
    #[doc = "rouge_1"]
    Rouge1,
    #[doc = "rouge_2"]
    Rouge2,
    #[doc = "rouge_3"]
    Rouge3,
    #[doc = "rouge_4"]
    Rouge4,
    #[doc = "rouge_5"]
    Rouge5,
    #[doc = "rouge_l"]
    RougeL,
}
impl<'de> serde::Deserialize<'de> for GraderTextSimilarity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of grader."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityType {
            #[default]
            #[serde(rename = "text_similarity")]
            TextSimilarity,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderTextSimilarity {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: GraderTextSimilarityType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: String,
            #[serde(rename = "reference")]
            #[allow(dead_code)]
            reference: String,
            #[serde(rename = "evaluation_metric")]
            #[allow(dead_code)]
            evaluation_metric: GraderTextSimilarityEvaluationMetric,
        }
        let GraderTextSimilarity {
            name,
            input,
            reference,
            evaluation_metric,
            ..
        } = GraderTextSimilarity::deserialize(deserializer)?;
        Ok(Self {
            name,
            input,
            reference,
            evaluation_metric,
        })
    }
}
impl serde::Serialize for GraderTextSimilarity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of grader."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum GraderTextSimilarityType {
            #[default]
            #[serde(rename = "text_similarity")]
            TextSimilarity,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderTextSimilarity<'a> {
            #[serde(rename = "type")]
            type_: &'a GraderTextSimilarityType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "reference")]
            reference: &'a String,
            #[serde(rename = "evaluation_metric")]
            evaluation_metric: &'a GraderTextSimilarityEvaluationMetric,
        }
        let Self {
            name,
            input,
            reference,
            evaluation_metric,
        } = self;
        GraderTextSimilarity {
            type_: &Default::default(),
            name,
            input,
            reference,
            evaluation_metric,
        }
        .serialize(serializer)
    }
}
#[doc = "A TextSimilarityGrader object which grades text based on similarity metrics.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderTextSimilarity {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The text being graded."]
    pub input: String,
    #[doc = "The text being graded against."]
    pub reference: String,
    #[doc = "The evaluation metric to use. One of `fuzzy_match`, `bleu`, `gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, or `rouge_l`."]
    pub evaluation_metric: GraderTextSimilarityEvaluationMetric,
}
impl<'de> serde::Deserialize<'de> for Image {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Image {
            #[serde(rename = "b64_json")]
            #[allow(dead_code)]
            b64_json: Option<String>,
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: Option<String>,
            #[serde(rename = "revised_prompt")]
            #[allow(dead_code)]
            revised_prompt: Option<String>,
        }
        let Image {
            b64_json,
            url,
            revised_prompt,
            ..
        } = Image::deserialize(deserializer)?;
        Ok(Self {
            b64_json,
            url,
            revised_prompt,
        })
    }
}
impl serde::Serialize for Image {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Image<'a> {
            #[serde(rename = "b64_json")]
            #[serde(skip_serializing_if = "Option::is_none")]
            b64_json: &'a Option<String>,
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            url: &'a Option<String>,
            #[serde(rename = "revised_prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            revised_prompt: &'a Option<String>,
        }
        let Self {
            b64_json,
            url,
            revised_prompt,
        } = self;
        Image {
            b64_json,
            url,
            revised_prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents the content or the URL of an image generated by the OpenAI API."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct Image {
    #[doc = "The base64-encoded JSON of the generated image. Default value for `gpt-image-1`, and only present if `response_format` is set to `b64_json` for `dall-e-2` and `dall-e-3`."]
    #[builder(default)]
    pub b64_json: Option<String>,
    #[doc = "When using `dall-e-2` or `dall-e-3`, the URL of the generated image if `response_format` is set to `url` (default value). Unsupported for `gpt-image-1`."]
    #[builder(default)]
    pub url: Option<String>,
    #[doc = "For `dall-e-3` only, the revised prompt that was used to generate the image."]
    #[builder(default)]
    pub revised_prompt: Option<String>,
}
#[doc = "The image generation model to use. Default: `gpt-image-1`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum ImageGenToolModel {
    #[default]
    #[serde(rename = "gpt-image-1")]
    GptImage1,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolQuality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ImageGenToolQuality {
            Low(#[allow(dead_code)] ImageGenToolQualityLow),
            Medium(#[allow(dead_code)] ImageGenToolQualityMedium),
            High(#[allow(dead_code)] ImageGenToolQualityHigh),
            Auto(#[allow(dead_code)] ImageGenToolQualityAuto),
        }
        Ok(match ImageGenToolQuality::deserialize(deserializer)? {
            ImageGenToolQuality::Low(_) => Self::Low,
            ImageGenToolQuality::Medium(_) => Self::Medium,
            ImageGenToolQuality::High(_) => Self::High,
            ImageGenToolQuality::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for ImageGenToolQuality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolQualityLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolQualityMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolQualityHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolQualityAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ImageGenToolQuality<'a> {
            Low(#[allow(dead_code)] &'a ImageGenToolQualityLow),
            Medium(#[allow(dead_code)] &'a ImageGenToolQualityMedium),
            High(#[allow(dead_code)] &'a ImageGenToolQualityHigh),
            Auto(#[allow(dead_code)] &'a ImageGenToolQualityAuto),
        }
        match self {
            Self::Low => ImageGenToolQuality::Low(&Default::default()).serialize(serializer),
            Self::Medium => ImageGenToolQuality::Medium(&Default::default()).serialize(serializer),
            Self::High => ImageGenToolQuality::High(&Default::default()).serialize(serializer),
            Self::Auto => ImageGenToolQuality::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The quality of the generated image. One of `low`, `medium`, `high`, \nor `auto`. Default: `auto`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ImageGenToolQuality {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ImageGenToolSize {
            _1024x1024(#[allow(dead_code)] ImageGenToolSize1024x1024),
            _1024x1536(#[allow(dead_code)] ImageGenToolSize1024x1536),
            _1536x1024(#[allow(dead_code)] ImageGenToolSize1536x1024),
            Auto(#[allow(dead_code)] ImageGenToolSizeAuto),
        }
        Ok(match ImageGenToolSize::deserialize(deserializer)? {
            ImageGenToolSize::_1024x1024(_) => Self::_1024x1024,
            ImageGenToolSize::_1024x1536(_) => Self::_1024x1536,
            ImageGenToolSize::_1536x1024(_) => Self::_1536x1024,
            ImageGenToolSize::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for ImageGenToolSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolSize1024x1024 {
            #[default]
            #[serde(rename = "1024x1024")]
            _1024x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolSize1024x1536 {
            #[default]
            #[serde(rename = "1024x1536")]
            _1024x1536,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolSize1536x1024 {
            #[default]
            #[serde(rename = "1536x1024")]
            _1536x1024,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolSizeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ImageGenToolSize<'a> {
            _1024x1024(#[allow(dead_code)] &'a ImageGenToolSize1024x1024),
            _1024x1536(#[allow(dead_code)] &'a ImageGenToolSize1024x1536),
            _1536x1024(#[allow(dead_code)] &'a ImageGenToolSize1536x1024),
            Auto(#[allow(dead_code)] &'a ImageGenToolSizeAuto),
        }
        match self {
            Self::_1024x1024 => {
                ImageGenToolSize::_1024x1024(&Default::default()).serialize(serializer)
            }
            Self::_1024x1536 => {
                ImageGenToolSize::_1024x1536(&Default::default()).serialize(serializer)
            }
            Self::_1536x1024 => {
                ImageGenToolSize::_1536x1024(&Default::default()).serialize(serializer)
            }
            Self::Auto => ImageGenToolSize::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The size of the generated image. One of `1024x1024`, `1024x1536`, \n`1536x1024`, or `auto`. Default: `auto`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ImageGenToolSize {
    #[doc = "1024x1024"]
    _1024x1024,
    #[doc = "1024x1536"]
    _1024x1536,
    #[doc = "1536x1024"]
    _1536x1024,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolOutputFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolOutputFormatPng {
            #[default]
            #[serde(rename = "png")]
            Png,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolOutputFormatWebp {
            #[default]
            #[serde(rename = "webp")]
            Webp,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolOutputFormatJpeg {
            #[default]
            #[serde(rename = "jpeg")]
            Jpeg,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ImageGenToolOutputFormat {
            Png(#[allow(dead_code)] ImageGenToolOutputFormatPng),
            Webp(#[allow(dead_code)] ImageGenToolOutputFormatWebp),
            Jpeg(#[allow(dead_code)] ImageGenToolOutputFormatJpeg),
        }
        Ok(match ImageGenToolOutputFormat::deserialize(deserializer)? {
            ImageGenToolOutputFormat::Png(_) => Self::Png,
            ImageGenToolOutputFormat::Webp(_) => Self::Webp,
            ImageGenToolOutputFormat::Jpeg(_) => Self::Jpeg,
        })
    }
}
impl serde::Serialize for ImageGenToolOutputFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolOutputFormatPng {
            #[default]
            #[serde(rename = "png")]
            Png,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolOutputFormatWebp {
            #[default]
            #[serde(rename = "webp")]
            Webp,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolOutputFormatJpeg {
            #[default]
            #[serde(rename = "jpeg")]
            Jpeg,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ImageGenToolOutputFormat<'a> {
            Png(#[allow(dead_code)] &'a ImageGenToolOutputFormatPng),
            Webp(#[allow(dead_code)] &'a ImageGenToolOutputFormatWebp),
            Jpeg(#[allow(dead_code)] &'a ImageGenToolOutputFormatJpeg),
        }
        match self {
            Self::Png => ImageGenToolOutputFormat::Png(&Default::default()).serialize(serializer),
            Self::Webp => ImageGenToolOutputFormat::Webp(&Default::default()).serialize(serializer),
            Self::Jpeg => ImageGenToolOutputFormat::Jpeg(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The output format of the generated image. One of `png`, `webp`, or \n`jpeg`. Default: `png`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ImageGenToolOutputFormat {
    #[doc = "png"]
    #[default]
    Png,
    #[doc = "webp"]
    Webp,
    #[doc = "jpeg"]
    Jpeg,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolModeration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolModerationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolModerationLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ImageGenToolModeration {
            Auto(#[allow(dead_code)] ImageGenToolModerationAuto),
            Low(#[allow(dead_code)] ImageGenToolModerationLow),
        }
        Ok(match ImageGenToolModeration::deserialize(deserializer)? {
            ImageGenToolModeration::Auto(_) => Self::Auto,
            ImageGenToolModeration::Low(_) => Self::Low,
        })
    }
}
impl serde::Serialize for ImageGenToolModeration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolModerationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolModerationLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ImageGenToolModeration<'a> {
            Auto(#[allow(dead_code)] &'a ImageGenToolModerationAuto),
            Low(#[allow(dead_code)] &'a ImageGenToolModerationLow),
        }
        match self {
            Self::Auto => ImageGenToolModeration::Auto(&Default::default()).serialize(serializer),
            Self::Low => ImageGenToolModeration::Low(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Moderation level for the generated image. Default: `auto`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ImageGenToolModeration {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolBackground {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolBackgroundTransparent {
            #[default]
            #[serde(rename = "transparent")]
            Transparent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolBackgroundOpaque {
            #[default]
            #[serde(rename = "opaque")]
            Opaque,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolBackgroundAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ImageGenToolBackground {
            Transparent(#[allow(dead_code)] ImageGenToolBackgroundTransparent),
            Opaque(#[allow(dead_code)] ImageGenToolBackgroundOpaque),
            Auto(#[allow(dead_code)] ImageGenToolBackgroundAuto),
        }
        Ok(match ImageGenToolBackground::deserialize(deserializer)? {
            ImageGenToolBackground::Transparent(_) => Self::Transparent,
            ImageGenToolBackground::Opaque(_) => Self::Opaque,
            ImageGenToolBackground::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for ImageGenToolBackground {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolBackgroundTransparent {
            #[default]
            #[serde(rename = "transparent")]
            Transparent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolBackgroundOpaque {
            #[default]
            #[serde(rename = "opaque")]
            Opaque,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolBackgroundAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ImageGenToolBackground<'a> {
            Transparent(#[allow(dead_code)] &'a ImageGenToolBackgroundTransparent),
            Opaque(#[allow(dead_code)] &'a ImageGenToolBackgroundOpaque),
            Auto(#[allow(dead_code)] &'a ImageGenToolBackgroundAuto),
        }
        match self {
            Self::Transparent => {
                ImageGenToolBackground::Transparent(&Default::default()).serialize(serializer)
            }
            Self::Opaque => {
                ImageGenToolBackground::Opaque(&Default::default()).serialize(serializer)
            }
            Self::Auto => ImageGenToolBackground::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Background type for the generated image. One of `transparent`, \n`opaque`, or `auto`. Default: `auto`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ImageGenToolBackground {
    #[doc = "transparent"]
    Transparent,
    #[doc = "opaque"]
    Opaque,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolInputImageMask {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageGenToolInputImageMask {
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: Option<String>,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let ImageGenToolInputImageMask {
            image_url, file_id, ..
        } = ImageGenToolInputImageMask::deserialize(deserializer)?;
        Ok(Self { image_url, file_id })
    }
}
impl serde::Serialize for ImageGenToolInputImageMask {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageGenToolInputImageMask<'a> {
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let Self { image_url, file_id } = self;
        ImageGenToolInputImageMask { image_url, file_id }.serialize(serializer)
    }
}
#[doc = "Optional mask for inpainting. Contains `image_url` \n(string, optional) and `file_id` (string, optional).\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ImageGenToolInputImageMask {
    #[doc = "Base64-encoded mask image.\n"]
    #[builder(default)]
    pub image_url: Option<String>,
    #[doc = "File ID for the mask image.\n"]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ImageGenTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the image generation tool. Always `image_generation`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolType {
            #[default]
            #[serde(rename = "image_generation")]
            ImageGeneration,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageGenTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ImageGenToolType,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<ImageGenToolModel>,
            #[serde(rename = "quality")]
            #[allow(dead_code)]
            quality: Option<ImageGenToolQuality>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<ImageGenToolSize>,
            #[serde(rename = "output_format")]
            #[allow(dead_code)]
            output_format: Option<ImageGenToolOutputFormat>,
            #[serde(rename = "output_compression")]
            #[allow(dead_code)]
            output_compression: Option<u64>,
            #[serde(rename = "moderation")]
            #[allow(dead_code)]
            moderation: Option<ImageGenToolModeration>,
            #[serde(rename = "background")]
            #[allow(dead_code)]
            background: Option<ImageGenToolBackground>,
            #[serde(rename = "input_image_mask")]
            #[allow(dead_code)]
            input_image_mask: Option<ImageGenToolInputImageMask>,
            #[serde(rename = "partial_images")]
            #[allow(dead_code)]
            partial_images: Option<u64>,
        }
        let ImageGenTool {
            model,
            quality,
            size,
            output_format,
            output_compression,
            moderation,
            background,
            input_image_mask,
            partial_images,
            ..
        } = ImageGenTool::deserialize(deserializer)?;
        Ok(Self {
            model,
            quality,
            size,
            output_format,
            output_compression,
            moderation,
            background,
            input_image_mask,
            partial_images,
        })
    }
}
impl serde::Serialize for ImageGenTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the image generation tool. Always `image_generation`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolType {
            #[default]
            #[serde(rename = "image_generation")]
            ImageGeneration,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageGenTool<'a> {
            #[serde(rename = "type")]
            type_: &'a ImageGenToolType,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<ImageGenToolModel>,
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            quality: &'a Option<ImageGenToolQuality>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<ImageGenToolSize>,
            #[serde(rename = "output_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_format: &'a Option<ImageGenToolOutputFormat>,
            #[serde(rename = "output_compression")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_compression: &'a Option<u64>,
            #[serde(rename = "moderation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            moderation: &'a Option<ImageGenToolModeration>,
            #[serde(rename = "background")]
            #[serde(skip_serializing_if = "Option::is_none")]
            background: &'a Option<ImageGenToolBackground>,
            #[serde(rename = "input_image_mask")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_image_mask: &'a Option<ImageGenToolInputImageMask>,
            #[serde(rename = "partial_images")]
            #[serde(skip_serializing_if = "Option::is_none")]
            partial_images: &'a Option<u64>,
        }
        let Self {
            model,
            quality,
            size,
            output_format,
            output_compression,
            moderation,
            background,
            input_image_mask,
            partial_images,
        } = self;
        ImageGenTool {
            type_: &Default::default(),
            model,
            quality,
            size,
            output_format,
            output_compression,
            moderation,
            background,
            input_image_mask,
            partial_images,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool that generates images using a model like `gpt-image-1`.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ImageGenTool {
    #[doc = "The image generation model to use. Default: `gpt-image-1`.\n"]
    #[builder(default)]
    pub model: Option<ImageGenToolModel>,
    #[doc = "The quality of the generated image. One of `low`, `medium`, `high`, \nor `auto`. Default: `auto`.\n"]
    #[builder(default)]
    pub quality: Option<ImageGenToolQuality>,
    #[doc = "The size of the generated image. One of `1024x1024`, `1024x1536`, \n`1536x1024`, or `auto`. Default: `auto`.\n"]
    #[builder(default)]
    pub size: Option<ImageGenToolSize>,
    #[doc = "The output format of the generated image. One of `png`, `webp`, or \n`jpeg`. Default: `png`.\n"]
    #[builder(default)]
    pub output_format: Option<ImageGenToolOutputFormat>,
    #[doc = "Compression level for the output image. Default: 100.\n"]
    #[builder(default)]
    pub output_compression: Option<u64>,
    #[doc = "Moderation level for the generated image. Default: `auto`.\n"]
    #[builder(default)]
    pub moderation: Option<ImageGenToolModeration>,
    #[doc = "Background type for the generated image. One of `transparent`, \n`opaque`, or `auto`. Default: `auto`.\n"]
    #[builder(default)]
    pub background: Option<ImageGenToolBackground>,
    #[doc = "Optional mask for inpainting. Contains `image_url` \n(string, optional) and `file_id` (string, optional).\n"]
    #[builder(default)]
    pub input_image_mask: Option<ImageGenToolInputImageMask>,
    #[doc = "Number of partial images to generate in streaming mode, from 0 (default value) to 3.\n"]
    #[builder(default)]
    pub partial_images: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallStatusGenerating {
            #[default]
            #[serde(rename = "generating")]
            Generating,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ImageGenToolCallStatus {
            InProgress(#[allow(dead_code)] ImageGenToolCallStatusInProgress),
            Completed(#[allow(dead_code)] ImageGenToolCallStatusCompleted),
            Generating(#[allow(dead_code)] ImageGenToolCallStatusGenerating),
            Failed(#[allow(dead_code)] ImageGenToolCallStatusFailed),
        }
        Ok(match ImageGenToolCallStatus::deserialize(deserializer)? {
            ImageGenToolCallStatus::InProgress(_) => Self::InProgress,
            ImageGenToolCallStatus::Completed(_) => Self::Completed,
            ImageGenToolCallStatus::Generating(_) => Self::Generating,
            ImageGenToolCallStatus::Failed(_) => Self::Failed,
        })
    }
}
impl serde::Serialize for ImageGenToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallStatusGenerating {
            #[default]
            #[serde(rename = "generating")]
            Generating,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ImageGenToolCallStatus<'a> {
            InProgress(#[allow(dead_code)] &'a ImageGenToolCallStatusInProgress),
            Completed(#[allow(dead_code)] &'a ImageGenToolCallStatusCompleted),
            Generating(#[allow(dead_code)] &'a ImageGenToolCallStatusGenerating),
            Failed(#[allow(dead_code)] &'a ImageGenToolCallStatusFailed),
        }
        match self {
            Self::InProgress => {
                ImageGenToolCallStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                ImageGenToolCallStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Generating => {
                ImageGenToolCallStatus::Generating(&Default::default()).serialize(serializer)
            }
            Self::Failed => {
                ImageGenToolCallStatus::Failed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the image generation call.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ImageGenToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "generating"]
    Generating,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the image generation call. Always `image_generation_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallType {
            #[default]
            #[serde(rename = "image_generation_call")]
            ImageGenerationCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageGenToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ImageGenToolCallType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: ImageGenToolCallStatus,
            #[serde(rename = "result")]
            #[allow(dead_code)]
            result: Option<String>,
        }
        let ImageGenToolCall {
            id, status, result, ..
        } = ImageGenToolCall::deserialize(deserializer)?;
        Ok(Self { id, status, result })
    }
}
impl serde::Serialize for ImageGenToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the image generation call. Always `image_generation_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ImageGenToolCallType {
            #[default]
            #[serde(rename = "image_generation_call")]
            ImageGenerationCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageGenToolCall<'a> {
            #[serde(rename = "type")]
            type_: &'a ImageGenToolCallType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "status")]
            status: &'a ImageGenToolCallStatus,
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Option::is_none")]
            result: &'a Option<String>,
        }
        let Self { id, status, result } = self;
        ImageGenToolCall {
            type_: &Default::default(),
            id,
            status,
            result,
        }
        .serialize(serializer)
    }
}
#[doc = "An image generation request made by the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImageGenToolCall {
    #[doc = "The unique ID of the image generation call.\n"]
    pub id: String,
    #[doc = "The status of the image generation call.\n"]
    pub status: ImageGenToolCallStatus,
    #[doc = "The generated image encoded in base64.\n"]
    #[builder(default)]
    pub result: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ImagesResponseUsageInputTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImagesResponseUsageInputTokensDetails {
            #[serde(rename = "text_tokens")]
            #[allow(dead_code)]
            text_tokens: u64,
            #[serde(rename = "image_tokens")]
            #[allow(dead_code)]
            image_tokens: u64,
        }
        let ImagesResponseUsageInputTokensDetails {
            text_tokens,
            image_tokens,
            ..
        } = ImagesResponseUsageInputTokensDetails::deserialize(deserializer)?;
        Ok(Self {
            text_tokens,
            image_tokens,
        })
    }
}
impl serde::Serialize for ImagesResponseUsageInputTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImagesResponseUsageInputTokensDetails<'a> {
            #[serde(rename = "text_tokens")]
            text_tokens: &'a u64,
            #[serde(rename = "image_tokens")]
            image_tokens: &'a u64,
        }
        let Self {
            text_tokens,
            image_tokens,
        } = self;
        ImagesResponseUsageInputTokensDetails {
            text_tokens,
            image_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "The input tokens detailed information for the image generation."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ImagesResponseUsageInputTokensDetails {
    #[doc = "The number of text tokens in the input prompt."]
    pub text_tokens: u64,
    #[doc = "The number of image tokens in the input prompt."]
    pub image_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for ImagesResponseUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImagesResponseUsage {
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "output_tokens")]
            #[allow(dead_code)]
            output_tokens: u64,
            #[serde(rename = "input_tokens_details")]
            #[allow(dead_code)]
            input_tokens_details: ImagesResponseUsageInputTokensDetails,
        }
        let ImagesResponseUsage {
            total_tokens,
            input_tokens,
            output_tokens,
            input_tokens_details,
            ..
        } = ImagesResponseUsage::deserialize(deserializer)?;
        Ok(Self {
            total_tokens,
            input_tokens,
            output_tokens,
            input_tokens_details,
        })
    }
}
impl serde::Serialize for ImagesResponseUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImagesResponseUsage<'a> {
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "output_tokens")]
            output_tokens: &'a u64,
            #[serde(rename = "input_tokens_details")]
            input_tokens_details: &'a ImagesResponseUsageInputTokensDetails,
        }
        let Self {
            total_tokens,
            input_tokens,
            output_tokens,
            input_tokens_details,
        } = self;
        ImagesResponseUsage {
            total_tokens,
            input_tokens,
            output_tokens,
            input_tokens_details,
        }
        .serialize(serializer)
    }
}
#[doc = "For `gpt-image-1` only, the token usage information for the image generation.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ImagesResponseUsage {
    #[doc = "The total number of tokens (images and text) used for the image generation."]
    pub total_tokens: u64,
    #[doc = "The number of tokens (images and text) in the input prompt."]
    pub input_tokens: u64,
    #[doc = "The number of image tokens in the output image."]
    pub output_tokens: u64,
    #[doc = "The input tokens detailed information for the image generation."]
    pub input_tokens_details: ImagesResponseUsageInputTokensDetails,
}
impl<'de> serde::Deserialize<'de> for ImagesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImagesResponse {
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Option<Vec<Image>>,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<ImagesResponseUsage>,
        }
        let ImagesResponse {
            created,
            data,
            usage,
            ..
        } = ImagesResponse::deserialize(deserializer)?;
        Ok(Self {
            created,
            data,
            usage,
        })
    }
}
impl serde::Serialize for ImagesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImagesResponse<'a> {
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<Vec<Image>>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<ImagesResponseUsage>,
        }
        let Self {
            created,
            data,
            usage,
        } = self;
        ImagesResponse {
            created,
            data,
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "The response from the image generation endpoint."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImagesResponse {
    #[doc = "The Unix timestamp (in seconds) of when the image was created."]
    pub created: u64,
    #[doc = "The list of generated images."]
    #[builder(default)]
    pub data: Option<Vec<Image>>,
    #[doc = "For `gpt-image-1` only, the token usage information for the image generation.\n"]
    #[builder(default)]
    pub usage: Option<ImagesResponseUsage>,
}
impl<'de> serde::Deserialize<'de> for Includable {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableFileSearchCallResults {
            #[default]
            #[serde(rename = "file_search_call.results")]
            FileSearchCallResults,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableMessageInputImageImageUrl {
            #[default]
            #[serde(rename = "message.input_image.image_url")]
            MessageInputImageImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableComputerCallOutputOutputImageUrl {
            #[default]
            #[serde(rename = "computer_call_output.output.image_url")]
            ComputerCallOutputOutputImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableReasoningEncryptedContent {
            #[default]
            #[serde(rename = "reasoning.encrypted_content")]
            ReasoningEncryptedContent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableCodeInterpreterCallOutputs {
            #[default]
            #[serde(rename = "code_interpreter_call.outputs")]
            CodeInterpreterCallOutputs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum Includable {
            FileSearchCallResults(#[allow(dead_code)] IncludableFileSearchCallResults),
            MessageInputImageImageUrl(#[allow(dead_code)] IncludableMessageInputImageImageUrl),
            ComputerCallOutputOutputImageUrl(
                #[allow(dead_code)] IncludableComputerCallOutputOutputImageUrl,
            ),
            ReasoningEncryptedContent(#[allow(dead_code)] IncludableReasoningEncryptedContent),
            CodeInterpreterCallOutputs(#[allow(dead_code)] IncludableCodeInterpreterCallOutputs),
        }
        Ok(match Includable::deserialize(deserializer)? {
            Includable::FileSearchCallResults(_) => Self::FileSearchCallResults,
            Includable::MessageInputImageImageUrl(_) => Self::MessageInputImageImageUrl,
            Includable::ComputerCallOutputOutputImageUrl(_) => {
                Self::ComputerCallOutputOutputImageUrl
            }
            Includable::ReasoningEncryptedContent(_) => Self::ReasoningEncryptedContent,
            Includable::CodeInterpreterCallOutputs(_) => Self::CodeInterpreterCallOutputs,
        })
    }
}
impl serde::Serialize for Includable {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableFileSearchCallResults {
            #[default]
            #[serde(rename = "file_search_call.results")]
            FileSearchCallResults,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableMessageInputImageImageUrl {
            #[default]
            #[serde(rename = "message.input_image.image_url")]
            MessageInputImageImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableComputerCallOutputOutputImageUrl {
            #[default]
            #[serde(rename = "computer_call_output.output.image_url")]
            ComputerCallOutputOutputImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableReasoningEncryptedContent {
            #[default]
            #[serde(rename = "reasoning.encrypted_content")]
            ReasoningEncryptedContent,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum IncludableCodeInterpreterCallOutputs {
            #[default]
            #[serde(rename = "code_interpreter_call.outputs")]
            CodeInterpreterCallOutputs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum Includable<'a> {
            FileSearchCallResults(#[allow(dead_code)] &'a IncludableFileSearchCallResults),
            MessageInputImageImageUrl(#[allow(dead_code)] &'a IncludableMessageInputImageImageUrl),
            ComputerCallOutputOutputImageUrl(
                #[allow(dead_code)] &'a IncludableComputerCallOutputOutputImageUrl,
            ),
            ReasoningEncryptedContent(#[allow(dead_code)] &'a IncludableReasoningEncryptedContent),
            CodeInterpreterCallOutputs(
                #[allow(dead_code)] &'a IncludableCodeInterpreterCallOutputs,
            ),
        }
        match self {
            Self::FileSearchCallResults => {
                Includable::FileSearchCallResults(&Default::default()).serialize(serializer)
            }
            Self::MessageInputImageImageUrl => {
                Includable::MessageInputImageImageUrl(&Default::default()).serialize(serializer)
            }
            Self::ComputerCallOutputOutputImageUrl => {
                Includable::ComputerCallOutputOutputImageUrl(&Default::default())
                    .serialize(serializer)
            }
            Self::ReasoningEncryptedContent => {
                Includable::ReasoningEncryptedContent(&Default::default()).serialize(serializer)
            }
            Self::CodeInterpreterCallOutputs => {
                Includable::CodeInterpreterCallOutputs(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "Specify additional output data to include in the model response. Currently\nsupported values are:\n- `file_search_call.results`: Include the search results of\n  the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n- `reasoning.encrypted_content`: Includes an encrypted version of reasoning\n  tokens in reasoning item outputs. This enables reasoning items to be used in\n  multi-turn conversations when using the Responses API statelessly (like\n  when the `store` parameter is set to `false`, or when an organization is\n  enrolled in the zero data retention program).\n- `code_interpreter_call.outputs`: Includes the outputs of python code execution\n  in code interpreter tool call items.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum Includable {
    #[doc = "file_search_call.results"]
    FileSearchCallResults,
    #[doc = "message.input_image.image_url"]
    MessageInputImageImageUrl,
    #[doc = "computer_call_output.output.image_url"]
    ComputerCallOutputOutputImageUrl,
    #[doc = "reasoning.encrypted_content"]
    ReasoningEncryptedContent,
    #[doc = "code_interpreter_call.outputs"]
    CodeInterpreterCallOutputs,
}
impl<'de> serde::Deserialize<'de> for InputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InputAudioFormat {
            Mp3(#[allow(dead_code)] InputAudioFormatMp3),
            Wav(#[allow(dead_code)] InputAudioFormatWav),
        }
        Ok(match InputAudioFormat::deserialize(deserializer)? {
            InputAudioFormat::Mp3(_) => Self::Mp3,
            InputAudioFormat::Wav(_) => Self::Wav,
        })
    }
}
impl serde::Serialize for InputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioFormatMp3 {
            #[default]
            #[serde(rename = "mp3")]
            Mp3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioFormatWav {
            #[default]
            #[serde(rename = "wav")]
            Wav,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InputAudioFormat<'a> {
            Mp3(#[allow(dead_code)] &'a InputAudioFormatMp3),
            Wav(#[allow(dead_code)] &'a InputAudioFormatWav),
        }
        match self {
            Self::Mp3 => InputAudioFormat::Mp3(&Default::default()).serialize(serializer),
            Self::Wav => InputAudioFormat::Wav(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InputAudioFormat {
    #[doc = "mp3"]
    Mp3,
    #[doc = "wav"]
    Wav,
}
impl<'de> serde::Deserialize<'de> for InputAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the input item. Always `input_audio`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioType {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputAudio {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: InputAudioType,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: String,
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: InputAudioFormat,
        }
        let InputAudio { data, format, .. } = InputAudio::deserialize(deserializer)?;
        Ok(Self { data, format })
    }
}
impl serde::Serialize for InputAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the input item. Always `input_audio`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputAudioType {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputAudio<'a> {
            #[serde(rename = "type")]
            type_: &'a InputAudioType,
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "format")]
            format: &'a InputAudioFormat,
        }
        let Self { data, format } = self;
        InputAudio {
            type_: &Default::default(),
            data,
            format,
        }
        .serialize(serializer)
    }
}
#[doc = "An audio input to the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputAudio {
    #[doc = "Base64-encoded audio data.\n"]
    pub data: String,
    #[doc = "The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n"]
    pub format: InputAudioFormat,
}
impl<'de> serde::Deserialize<'de> for InputContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InputContent {
            InputText(#[allow(dead_code)] InputTextContent),
            InputImage(#[allow(dead_code)] InputImageContent),
            InputFile(#[allow(dead_code)] InputFileContent),
        }
        Ok(match InputContent::deserialize(deserializer)? {
            InputContent::InputText(_v) => Self::InputText(_v),
            InputContent::InputImage(_v) => Self::InputImage(_v),
            InputContent::InputFile(_v) => Self::InputFile(_v),
        })
    }
}
impl serde::Serialize for InputContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InputContent<'a> {
            InputText(#[allow(dead_code)] &'a InputTextContent),
            InputImage(#[allow(dead_code)] &'a InputImageContent),
            InputFile(#[allow(dead_code)] &'a InputFileContent),
        }
        match self {
            Self::InputText(_v) => InputContent::InputText(_v).serialize(serializer),
            Self::InputImage(_v) => InputContent::InputImage(_v).serialize(serializer),
            Self::InputFile(_v) => InputContent::InputFile(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum InputContent {
    InputText(InputTextContent),
    InputImage(InputImageContent),
    InputFile(InputFileContent),
}
impl<'de> serde::Deserialize<'de> for InputItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InputItem {
            EasyInputMessage(#[allow(dead_code)] EasyInputMessage),
            Item(#[allow(dead_code)] Item),
            ItemReferenceParam(#[allow(dead_code)] ItemReferenceParam),
        }
        Ok(match InputItem::deserialize(deserializer)? {
            InputItem::EasyInputMessage(_v) => Self::EasyInputMessage(_v),
            InputItem::Item(_v) => Self::Item(_v),
            InputItem::ItemReferenceParam(_v) => Self::ItemReferenceParam(_v),
        })
    }
}
impl serde::Serialize for InputItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InputItem<'a> {
            EasyInputMessage(#[allow(dead_code)] &'a EasyInputMessage),
            Item(#[allow(dead_code)] &'a Item),
            ItemReferenceParam(#[allow(dead_code)] &'a ItemReferenceParam),
        }
        match self {
            Self::EasyInputMessage(_v) => InputItem::EasyInputMessage(_v).serialize(serializer),
            Self::Item(_v) => InputItem::Item(_v).serialize(serializer),
            Self::ItemReferenceParam(_v) => InputItem::ItemReferenceParam(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum InputItem {
    EasyInputMessage(EasyInputMessage),
    #[doc = "An item representing part of the context for the response to be \ngenerated by the model. Can contain text, images, and audio inputs,\nas well as previous assistant responses and tool call outputs.\n"]
    Item(Item),
    ItemReferenceParam(ItemReferenceParam),
}
#[doc = "The type of the message input. Always set to `message`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum InputMessageType {
    #[default]
    #[serde(rename = "message")]
    Message,
}
impl<'de> serde::Deserialize<'de> for InputMessageRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InputMessageRole {
            User(#[allow(dead_code)] InputMessageRoleUser),
            System(#[allow(dead_code)] InputMessageRoleSystem),
            Developer(#[allow(dead_code)] InputMessageRoleDeveloper),
        }
        Ok(match InputMessageRole::deserialize(deserializer)? {
            InputMessageRole::User(_) => Self::User,
            InputMessageRole::System(_) => Self::System,
            InputMessageRole::Developer(_) => Self::Developer,
        })
    }
}
impl serde::Serialize for InputMessageRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageRoleDeveloper {
            #[default]
            #[serde(rename = "developer")]
            Developer,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InputMessageRole<'a> {
            User(#[allow(dead_code)] &'a InputMessageRoleUser),
            System(#[allow(dead_code)] &'a InputMessageRoleSystem),
            Developer(#[allow(dead_code)] &'a InputMessageRoleDeveloper),
        }
        match self {
            Self::User => InputMessageRole::User(&Default::default()).serialize(serializer),
            Self::System => InputMessageRole::System(&Default::default()).serialize(serializer),
            Self::Developer => {
                InputMessageRole::Developer(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The role of the message input. One of `user`, `system`, or `developer`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InputMessageRole {
    #[doc = "user"]
    User,
    #[doc = "system"]
    System,
    #[doc = "developer"]
    Developer,
}
impl<'de> serde::Deserialize<'de> for InputMessageStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InputMessageStatus {
            InProgress(#[allow(dead_code)] InputMessageStatusInProgress),
            Completed(#[allow(dead_code)] InputMessageStatusCompleted),
            Incomplete(#[allow(dead_code)] InputMessageStatusIncomplete),
        }
        Ok(match InputMessageStatus::deserialize(deserializer)? {
            InputMessageStatus::InProgress(_) => Self::InProgress,
            InputMessageStatus::Completed(_) => Self::Completed,
            InputMessageStatus::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for InputMessageStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputMessageStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InputMessageStatus<'a> {
            InProgress(#[allow(dead_code)] &'a InputMessageStatusInProgress),
            Completed(#[allow(dead_code)] &'a InputMessageStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a InputMessageStatusIncomplete),
        }
        match self {
            Self::InProgress => {
                InputMessageStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                InputMessageStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                InputMessageStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InputMessageStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for InputMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputMessage {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<InputMessageType>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: InputMessageRole,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<InputMessageStatus>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: InputMessageContentList,
        }
        let InputMessage {
            type_,
            role,
            status,
            content,
            ..
        } = InputMessage::deserialize(deserializer)?;
        Ok(Self {
            type_,
            role,
            status,
            content,
        })
    }
}
impl serde::Serialize for InputMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputMessage<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<InputMessageType>,
            #[serde(rename = "role")]
            role: &'a InputMessageRole,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<InputMessageStatus>,
            #[serde(rename = "content")]
            content: &'a InputMessageContentList,
        }
        let Self {
            type_,
            role,
            status,
            content,
        } = self;
        InputMessage {
            type_,
            role,
            status,
            content,
        }
        .serialize(serializer)
    }
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputMessage {
    #[doc = "The type of the message input. Always set to `message`.\n"]
    #[builder(default)]
    pub type_: Option<InputMessageType>,
    #[doc = "The role of the message input. One of `user`, `system`, or `developer`.\n"]
    pub role: InputMessageRole,
    #[doc = "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<InputMessageStatus>,
    pub content: InputMessageContentList,
}
#[doc = "A list of one or many input items to the model, containing different content \ntypes.\n"]
pub type InputMessageContentList = Vec<InputContent>;
impl<'de> serde::Deserialize<'de> for InputMessageResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputMessageResource {
            #[serde(flatten)]
            #[allow(dead_code)]
            input_message: InputMessage,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let InputMessageResource {
            input_message, id, ..
        } = InputMessageResource::deserialize(deserializer)?;
        Ok(Self { input_message, id })
    }
}
impl serde::Serialize for InputMessageResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputMessageResource<'a> {
            #[serde(flatten)]
            input_message: &'a InputMessage,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self { input_message, id } = self;
        InputMessageResource { input_message, id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputMessageResource {
    pub input_message: InputMessage,
    #[doc = "The unique ID of the message input.\n"]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for InviteRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InviteRole {
            Owner(#[allow(dead_code)] InviteRoleOwner),
            Reader(#[allow(dead_code)] InviteRoleReader),
        }
        Ok(match InviteRole::deserialize(deserializer)? {
            InviteRole::Owner(_) => Self::Owner,
            InviteRole::Reader(_) => Self::Reader,
        })
    }
}
impl serde::Serialize for InviteRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InviteRole<'a> {
            Owner(#[allow(dead_code)] &'a InviteRoleOwner),
            Reader(#[allow(dead_code)] &'a InviteRoleReader),
        }
        match self {
            Self::Owner => InviteRole::Owner(&Default::default()).serialize(serializer),
            Self::Reader => InviteRole::Reader(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `reader`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteRole {
    #[doc = "owner"]
    Owner,
    #[doc = "reader"]
    Reader,
}
impl<'de> serde::Deserialize<'de> for InviteStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusAccepted {
            #[default]
            #[serde(rename = "accepted")]
            Accepted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusPending {
            #[default]
            #[serde(rename = "pending")]
            Pending,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InviteStatus {
            Accepted(#[allow(dead_code)] InviteStatusAccepted),
            Expired(#[allow(dead_code)] InviteStatusExpired),
            Pending(#[allow(dead_code)] InviteStatusPending),
        }
        Ok(match InviteStatus::deserialize(deserializer)? {
            InviteStatus::Accepted(_) => Self::Accepted,
            InviteStatus::Expired(_) => Self::Expired,
            InviteStatus::Pending(_) => Self::Pending,
        })
    }
}
impl serde::Serialize for InviteStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusAccepted {
            #[default]
            #[serde(rename = "accepted")]
            Accepted,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteStatusPending {
            #[default]
            #[serde(rename = "pending")]
            Pending,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InviteStatus<'a> {
            Accepted(#[allow(dead_code)] &'a InviteStatusAccepted),
            Expired(#[allow(dead_code)] &'a InviteStatusExpired),
            Pending(#[allow(dead_code)] &'a InviteStatusPending),
        }
        match self {
            Self::Accepted => InviteStatus::Accepted(&Default::default()).serialize(serializer),
            Self::Expired => InviteStatus::Expired(&Default::default()).serialize(serializer),
            Self::Pending => InviteStatus::Pending(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`accepted`,`expired`, or `pending`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteStatus {
    #[doc = "accepted"]
    Accepted,
    #[doc = "expired"]
    Expired,
    #[doc = "pending"]
    Pending,
}
impl<'de> serde::Deserialize<'de> for InviteProjectsRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteProjectsRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteProjectsRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InviteProjectsRole {
            Member(#[allow(dead_code)] InviteProjectsRoleMember),
            Owner(#[allow(dead_code)] InviteProjectsRoleOwner),
        }
        Ok(match InviteProjectsRole::deserialize(deserializer)? {
            InviteProjectsRole::Member(_) => Self::Member,
            InviteProjectsRole::Owner(_) => Self::Owner,
        })
    }
}
impl serde::Serialize for InviteProjectsRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteProjectsRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteProjectsRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InviteProjectsRole<'a> {
            Member(#[allow(dead_code)] &'a InviteProjectsRoleMember),
            Owner(#[allow(dead_code)] &'a InviteProjectsRoleOwner),
        }
        match self {
            Self::Member => InviteProjectsRole::Member(&Default::default()).serialize(serializer),
            Self::Owner => InviteProjectsRole::Owner(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Project membership role"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteProjectsRole {
    #[doc = "member"]
    Member,
    #[doc = "owner"]
    Owner,
}
impl<'de> serde::Deserialize<'de> for InviteProjects {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InviteProjects {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<InviteProjectsRole>,
        }
        let InviteProjects { id, role, .. } = InviteProjects::deserialize(deserializer)?;
        Ok(Self { id, role })
    }
}
impl serde::Serialize for InviteProjects {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InviteProjects<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<InviteProjectsRole>,
        }
        let Self { id, role } = self;
        InviteProjects { id, role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct InviteProjects {
    #[doc = "Project's public ID"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "Project membership role"]
    #[builder(default)]
    pub role: Option<InviteProjectsRole>,
}
impl<'de> serde::Deserialize<'de> for Invite {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.invite`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteObject {
            #[default]
            #[serde(rename = "organization.invite")]
            OrganizationInvite,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Invite {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: InviteObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: InviteRole,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: InviteStatus,
            #[serde(rename = "invited_at")]
            #[allow(dead_code)]
            invited_at: u64,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
            #[serde(rename = "accepted_at")]
            #[allow(dead_code)]
            accepted_at: Option<u64>,
            #[serde(rename = "projects")]
            #[allow(dead_code)]
            projects: Option<Vec<InviteProjects>>,
        }
        let Invite {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
            ..
        } = Invite::deserialize(deserializer)?;
        Ok(Self {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        })
    }
}
impl serde::Serialize for Invite {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.invite`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteObject {
            #[default]
            #[serde(rename = "organization.invite")]
            OrganizationInvite,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Invite<'a> {
            #[serde(rename = "object")]
            object: &'a InviteObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a InviteRole,
            #[serde(rename = "status")]
            status: &'a InviteStatus,
            #[serde(rename = "invited_at")]
            invited_at: &'a u64,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
            #[serde(rename = "accepted_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            accepted_at: &'a Option<u64>,
            #[serde(rename = "projects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            projects: &'a Option<Vec<InviteProjects>>,
        }
        let Self {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        } = self;
        Invite {
            object: &Default::default(),
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual `invite` to the organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Invite {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The email address of the individual to whom the invite was sent"]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    pub role: InviteRole,
    #[doc = "`accepted`,`expired`, or `pending`"]
    pub status: InviteStatus,
    #[doc = "The Unix timestamp (in seconds) of when the invite was sent."]
    pub invited_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the invite expires."]
    pub expires_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the invite was accepted."]
    #[builder(default)]
    pub accepted_at: Option<u64>,
    #[doc = "The projects that were granted membership upon acceptance of the invite."]
    #[builder(default)]
    pub projects: Option<Vec<InviteProjects>>,
}
impl<'de> serde::Deserialize<'de> for InviteDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.invite.deleted`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.invite.deleted")]
            OrganizationInviteDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InviteDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: InviteDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let InviteDeleteResponse { id, deleted, .. } =
            InviteDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for InviteDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.invite.deleted`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.invite.deleted")]
            OrganizationInviteDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InviteDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a InviteDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        InviteDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for InviteListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `list`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InviteListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: InviteListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Invite>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: Option<bool>,
        }
        let InviteListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = InviteListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for InviteListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `list`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InviteListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a InviteListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<Invite>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            #[serde(skip_serializing_if = "Option::is_none")]
            has_more: &'a Option<bool>,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        InviteListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteListResponse {
    pub data: Vec<Invite>,
    #[doc = "The first `invite_id` in the retrieved `list`"]
    #[builder(default)]
    pub first_id: Option<String>,
    #[doc = "The last `invite_id` in the retrieved `list`"]
    #[builder(default)]
    pub last_id: Option<String>,
    #[doc = "The `has_more` property is used for pagination to indicate there are additional results."]
    #[builder(default)]
    pub has_more: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for InviteRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InviteRequestRole {
            Reader(#[allow(dead_code)] InviteRequestRoleReader),
            Owner(#[allow(dead_code)] InviteRequestRoleOwner),
        }
        Ok(match InviteRequestRole::deserialize(deserializer)? {
            InviteRequestRole::Reader(_) => Self::Reader,
            InviteRequestRole::Owner(_) => Self::Owner,
        })
    }
}
impl serde::Serialize for InviteRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InviteRequestRole<'a> {
            Reader(#[allow(dead_code)] &'a InviteRequestRoleReader),
            Owner(#[allow(dead_code)] &'a InviteRequestRoleOwner),
        }
        match self {
            Self::Reader => InviteRequestRole::Reader(&Default::default()).serialize(serializer),
            Self::Owner => InviteRequestRole::Owner(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `reader`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteRequestRole {
    #[doc = "reader"]
    Reader,
    #[doc = "owner"]
    Owner,
}
impl<'de> serde::Deserialize<'de> for InviteRequestProjectsRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestProjectsRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestProjectsRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InviteRequestProjectsRole {
            Member(#[allow(dead_code)] InviteRequestProjectsRoleMember),
            Owner(#[allow(dead_code)] InviteRequestProjectsRoleOwner),
        }
        Ok(
            match InviteRequestProjectsRole::deserialize(deserializer)? {
                InviteRequestProjectsRole::Member(_) => Self::Member,
                InviteRequestProjectsRole::Owner(_) => Self::Owner,
            },
        )
    }
}
impl serde::Serialize for InviteRequestProjectsRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestProjectsRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InviteRequestProjectsRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InviteRequestProjectsRole<'a> {
            Member(#[allow(dead_code)] &'a InviteRequestProjectsRoleMember),
            Owner(#[allow(dead_code)] &'a InviteRequestProjectsRoleOwner),
        }
        match self {
            Self::Member => {
                InviteRequestProjectsRole::Member(&Default::default()).serialize(serializer)
            }
            Self::Owner => {
                InviteRequestProjectsRole::Owner(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "Project membership role"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InviteRequestProjectsRole {
    #[doc = "member"]
    Member,
    #[doc = "owner"]
    Owner,
}
impl<'de> serde::Deserialize<'de> for InviteRequestProjects {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InviteRequestProjects {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: InviteRequestProjectsRole,
        }
        let InviteRequestProjects { id, role, .. } =
            InviteRequestProjects::deserialize(deserializer)?;
        Ok(Self { id, role })
    }
}
impl serde::Serialize for InviteRequestProjects {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InviteRequestProjects<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "role")]
            role: &'a InviteRequestProjectsRole,
        }
        let Self { id, role } = self;
        InviteRequestProjects { id, role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteRequestProjects {
    #[doc = "Project's public ID"]
    pub id: String,
    #[doc = "Project membership role"]
    pub role: InviteRequestProjectsRole,
}
impl<'de> serde::Deserialize<'de> for InviteRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InviteRequest {
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: InviteRequestRole,
            #[serde(rename = "projects")]
            #[allow(dead_code)]
            projects: Option<Vec<InviteRequestProjects>>,
        }
        let InviteRequest {
            email,
            role,
            projects,
            ..
        } = InviteRequest::deserialize(deserializer)?;
        Ok(Self {
            email,
            role,
            projects,
        })
    }
}
impl serde::Serialize for InviteRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InviteRequest<'a> {
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a InviteRequestRole,
            #[serde(rename = "projects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            projects: &'a Option<Vec<InviteRequestProjects>>,
        }
        let Self {
            email,
            role,
            projects,
        } = self;
        InviteRequest {
            email,
            role,
            projects,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteRequest {
    #[doc = "Send an email to this address"]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    pub role: InviteRequestRole,
    #[doc = "An array of projects to which membership is granted at the same time the org invite is accepted. If omitted, the user will be invited to the default project for compatibility with legacy behavior."]
    #[builder(default)]
    pub projects: Option<Vec<InviteRequestProjects>>,
}
impl<'de> serde::Deserialize<'de> for Item {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum Item {
            InputMessage(#[allow(dead_code)] InputMessage),
            OutputMessage(#[allow(dead_code)] OutputMessage),
            FileSearchToolCall(#[allow(dead_code)] FileSearchToolCall),
            ComputerToolCall(#[allow(dead_code)] ComputerToolCall),
            ComputerCallOutputItemParam(#[allow(dead_code)] ComputerCallOutputItemParam),
            WebSearchToolCall(#[allow(dead_code)] WebSearchToolCall),
            FunctionToolCall(#[allow(dead_code)] FunctionToolCall),
            FunctionCallOutputItemParam(#[allow(dead_code)] FunctionCallOutputItemParam),
            ReasoningItem(#[allow(dead_code)] ReasoningItem),
            ImageGenToolCall(#[allow(dead_code)] ImageGenToolCall),
            CodeInterpreterToolCall(#[allow(dead_code)] CodeInterpreterToolCall),
            LocalShellToolCall(#[allow(dead_code)] LocalShellToolCall),
            LocalShellToolCallOutput(#[allow(dead_code)] LocalShellToolCallOutput),
            McpListTools(#[allow(dead_code)] McpListTools),
            McpApprovalRequest(#[allow(dead_code)] McpApprovalRequest),
            McpApprovalResponse(#[allow(dead_code)] McpApprovalResponse),
            McpToolCall(#[allow(dead_code)] McpToolCall),
        }
        Ok(match Item::deserialize(deserializer)? {
            Item::InputMessage(_v) => Self::InputMessage(_v),
            Item::OutputMessage(_v) => Self::OutputMessage(_v),
            Item::FileSearchToolCall(_v) => Self::FileSearchToolCall(_v),
            Item::ComputerToolCall(_v) => Self::ComputerToolCall(_v),
            Item::ComputerCallOutputItemParam(_v) => Self::ComputerCallOutputItemParam(_v),
            Item::WebSearchToolCall(_v) => Self::WebSearchToolCall(_v),
            Item::FunctionToolCall(_v) => Self::FunctionToolCall(_v),
            Item::FunctionCallOutputItemParam(_v) => Self::FunctionCallOutputItemParam(_v),
            Item::ReasoningItem(_v) => Self::ReasoningItem(_v),
            Item::ImageGenToolCall(_v) => Self::ImageGenToolCall(_v),
            Item::CodeInterpreterToolCall(_v) => Self::CodeInterpreterToolCall(_v),
            Item::LocalShellToolCall(_v) => Self::LocalShellToolCall(_v),
            Item::LocalShellToolCallOutput(_v) => Self::LocalShellToolCallOutput(_v),
            Item::McpListTools(_v) => Self::McpListTools(_v),
            Item::McpApprovalRequest(_v) => Self::McpApprovalRequest(_v),
            Item::McpApprovalResponse(_v) => Self::McpApprovalResponse(_v),
            Item::McpToolCall(_v) => Self::McpToolCall(_v),
        })
    }
}
impl serde::Serialize for Item {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum Item<'a> {
            InputMessage(#[allow(dead_code)] &'a InputMessage),
            OutputMessage(#[allow(dead_code)] &'a OutputMessage),
            FileSearchToolCall(#[allow(dead_code)] &'a FileSearchToolCall),
            ComputerToolCall(#[allow(dead_code)] &'a ComputerToolCall),
            ComputerCallOutputItemParam(#[allow(dead_code)] &'a ComputerCallOutputItemParam),
            WebSearchToolCall(#[allow(dead_code)] &'a WebSearchToolCall),
            FunctionToolCall(#[allow(dead_code)] &'a FunctionToolCall),
            FunctionCallOutputItemParam(#[allow(dead_code)] &'a FunctionCallOutputItemParam),
            ReasoningItem(#[allow(dead_code)] &'a ReasoningItem),
            ImageGenToolCall(#[allow(dead_code)] &'a ImageGenToolCall),
            CodeInterpreterToolCall(#[allow(dead_code)] &'a CodeInterpreterToolCall),
            LocalShellToolCall(#[allow(dead_code)] &'a LocalShellToolCall),
            LocalShellToolCallOutput(#[allow(dead_code)] &'a LocalShellToolCallOutput),
            McpListTools(#[allow(dead_code)] &'a McpListTools),
            McpApprovalRequest(#[allow(dead_code)] &'a McpApprovalRequest),
            McpApprovalResponse(#[allow(dead_code)] &'a McpApprovalResponse),
            McpToolCall(#[allow(dead_code)] &'a McpToolCall),
        }
        match self {
            Self::InputMessage(_v) => Item::InputMessage(_v).serialize(serializer),
            Self::OutputMessage(_v) => Item::OutputMessage(_v).serialize(serializer),
            Self::FileSearchToolCall(_v) => Item::FileSearchToolCall(_v).serialize(serializer),
            Self::ComputerToolCall(_v) => Item::ComputerToolCall(_v).serialize(serializer),
            Self::ComputerCallOutputItemParam(_v) => {
                Item::ComputerCallOutputItemParam(_v).serialize(serializer)
            }
            Self::WebSearchToolCall(_v) => Item::WebSearchToolCall(_v).serialize(serializer),
            Self::FunctionToolCall(_v) => Item::FunctionToolCall(_v).serialize(serializer),
            Self::FunctionCallOutputItemParam(_v) => {
                Item::FunctionCallOutputItemParam(_v).serialize(serializer)
            }
            Self::ReasoningItem(_v) => Item::ReasoningItem(_v).serialize(serializer),
            Self::ImageGenToolCall(_v) => Item::ImageGenToolCall(_v).serialize(serializer),
            Self::CodeInterpreterToolCall(_v) => {
                Item::CodeInterpreterToolCall(_v).serialize(serializer)
            }
            Self::LocalShellToolCall(_v) => Item::LocalShellToolCall(_v).serialize(serializer),
            Self::LocalShellToolCallOutput(_v) => {
                Item::LocalShellToolCallOutput(_v).serialize(serializer)
            }
            Self::McpListTools(_v) => Item::McpListTools(_v).serialize(serializer),
            Self::McpApprovalRequest(_v) => Item::McpApprovalRequest(_v).serialize(serializer),
            Self::McpApprovalResponse(_v) => Item::McpApprovalResponse(_v).serialize(serializer),
            Self::McpToolCall(_v) => Item::McpToolCall(_v).serialize(serializer),
        }
    }
}
#[doc = "Content item used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Item {
    InputMessage(InputMessage),
    OutputMessage(OutputMessage),
    FileSearchToolCall(FileSearchToolCall),
    ComputerToolCall(ComputerToolCall),
    ComputerCallOutputItemParam(ComputerCallOutputItemParam),
    WebSearchToolCall(WebSearchToolCall),
    FunctionToolCall(FunctionToolCall),
    FunctionCallOutputItemParam(FunctionCallOutputItemParam),
    ReasoningItem(ReasoningItem),
    ImageGenToolCall(ImageGenToolCall),
    CodeInterpreterToolCall(CodeInterpreterToolCall),
    LocalShellToolCall(LocalShellToolCall),
    LocalShellToolCallOutput(LocalShellToolCallOutput),
    McpListTools(McpListTools),
    McpApprovalRequest(McpApprovalRequest),
    McpApprovalResponse(McpApprovalResponse),
    McpToolCall(McpToolCall),
}
impl<'de> serde::Deserialize<'de> for ItemResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ItemResource {
            InputMessageResource(#[allow(dead_code)] InputMessageResource),
            OutputMessage(#[allow(dead_code)] OutputMessage),
            FileSearchToolCall(#[allow(dead_code)] FileSearchToolCall),
            ComputerToolCall(#[allow(dead_code)] ComputerToolCall),
            ComputerToolCallOutputResource(#[allow(dead_code)] ComputerToolCallOutputResource),
            WebSearchToolCall(#[allow(dead_code)] WebSearchToolCall),
            FunctionToolCallResource(#[allow(dead_code)] FunctionToolCallResource),
            FunctionToolCallOutputResource(#[allow(dead_code)] FunctionToolCallOutputResource),
            ImageGenToolCall(#[allow(dead_code)] ImageGenToolCall),
            CodeInterpreterToolCall(#[allow(dead_code)] CodeInterpreterToolCall),
            LocalShellToolCall(#[allow(dead_code)] LocalShellToolCall),
            LocalShellToolCallOutput(#[allow(dead_code)] LocalShellToolCallOutput),
            McpListTools(#[allow(dead_code)] McpListTools),
            McpApprovalRequest(#[allow(dead_code)] McpApprovalRequest),
            McpApprovalResponseResource(#[allow(dead_code)] McpApprovalResponseResource),
            McpToolCall(#[allow(dead_code)] McpToolCall),
        }
        Ok(match ItemResource::deserialize(deserializer)? {
            ItemResource::InputMessageResource(_v) => Self::InputMessageResource(_v),
            ItemResource::OutputMessage(_v) => Self::OutputMessage(_v),
            ItemResource::FileSearchToolCall(_v) => Self::FileSearchToolCall(_v),
            ItemResource::ComputerToolCall(_v) => Self::ComputerToolCall(_v),
            ItemResource::ComputerToolCallOutputResource(_v) => {
                Self::ComputerToolCallOutputResource(_v)
            }
            ItemResource::WebSearchToolCall(_v) => Self::WebSearchToolCall(_v),
            ItemResource::FunctionToolCallResource(_v) => Self::FunctionToolCallResource(_v),
            ItemResource::FunctionToolCallOutputResource(_v) => {
                Self::FunctionToolCallOutputResource(_v)
            }
            ItemResource::ImageGenToolCall(_v) => Self::ImageGenToolCall(_v),
            ItemResource::CodeInterpreterToolCall(_v) => Self::CodeInterpreterToolCall(_v),
            ItemResource::LocalShellToolCall(_v) => Self::LocalShellToolCall(_v),
            ItemResource::LocalShellToolCallOutput(_v) => Self::LocalShellToolCallOutput(_v),
            ItemResource::McpListTools(_v) => Self::McpListTools(_v),
            ItemResource::McpApprovalRequest(_v) => Self::McpApprovalRequest(_v),
            ItemResource::McpApprovalResponseResource(_v) => Self::McpApprovalResponseResource(_v),
            ItemResource::McpToolCall(_v) => Self::McpToolCall(_v),
        })
    }
}
impl serde::Serialize for ItemResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ItemResource<'a> {
            InputMessageResource(#[allow(dead_code)] &'a InputMessageResource),
            OutputMessage(#[allow(dead_code)] &'a OutputMessage),
            FileSearchToolCall(#[allow(dead_code)] &'a FileSearchToolCall),
            ComputerToolCall(#[allow(dead_code)] &'a ComputerToolCall),
            ComputerToolCallOutputResource(#[allow(dead_code)] &'a ComputerToolCallOutputResource),
            WebSearchToolCall(#[allow(dead_code)] &'a WebSearchToolCall),
            FunctionToolCallResource(#[allow(dead_code)] &'a FunctionToolCallResource),
            FunctionToolCallOutputResource(#[allow(dead_code)] &'a FunctionToolCallOutputResource),
            ImageGenToolCall(#[allow(dead_code)] &'a ImageGenToolCall),
            CodeInterpreterToolCall(#[allow(dead_code)] &'a CodeInterpreterToolCall),
            LocalShellToolCall(#[allow(dead_code)] &'a LocalShellToolCall),
            LocalShellToolCallOutput(#[allow(dead_code)] &'a LocalShellToolCallOutput),
            McpListTools(#[allow(dead_code)] &'a McpListTools),
            McpApprovalRequest(#[allow(dead_code)] &'a McpApprovalRequest),
            McpApprovalResponseResource(#[allow(dead_code)] &'a McpApprovalResponseResource),
            McpToolCall(#[allow(dead_code)] &'a McpToolCall),
        }
        match self {
            Self::InputMessageResource(_v) => {
                ItemResource::InputMessageResource(_v).serialize(serializer)
            }
            Self::OutputMessage(_v) => ItemResource::OutputMessage(_v).serialize(serializer),
            Self::FileSearchToolCall(_v) => {
                ItemResource::FileSearchToolCall(_v).serialize(serializer)
            }
            Self::ComputerToolCall(_v) => ItemResource::ComputerToolCall(_v).serialize(serializer),
            Self::ComputerToolCallOutputResource(_v) => {
                ItemResource::ComputerToolCallOutputResource(_v).serialize(serializer)
            }
            Self::WebSearchToolCall(_v) => {
                ItemResource::WebSearchToolCall(_v).serialize(serializer)
            }
            Self::FunctionToolCallResource(_v) => {
                ItemResource::FunctionToolCallResource(_v).serialize(serializer)
            }
            Self::FunctionToolCallOutputResource(_v) => {
                ItemResource::FunctionToolCallOutputResource(_v).serialize(serializer)
            }
            Self::ImageGenToolCall(_v) => ItemResource::ImageGenToolCall(_v).serialize(serializer),
            Self::CodeInterpreterToolCall(_v) => {
                ItemResource::CodeInterpreterToolCall(_v).serialize(serializer)
            }
            Self::LocalShellToolCall(_v) => {
                ItemResource::LocalShellToolCall(_v).serialize(serializer)
            }
            Self::LocalShellToolCallOutput(_v) => {
                ItemResource::LocalShellToolCallOutput(_v).serialize(serializer)
            }
            Self::McpListTools(_v) => ItemResource::McpListTools(_v).serialize(serializer),
            Self::McpApprovalRequest(_v) => {
                ItemResource::McpApprovalRequest(_v).serialize(serializer)
            }
            Self::McpApprovalResponseResource(_v) => {
                ItemResource::McpApprovalResponseResource(_v).serialize(serializer)
            }
            Self::McpToolCall(_v) => ItemResource::McpToolCall(_v).serialize(serializer),
        }
    }
}
#[doc = "Content item used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ItemResource {
    InputMessageResource(InputMessageResource),
    OutputMessage(OutputMessage),
    FileSearchToolCall(FileSearchToolCall),
    ComputerToolCall(ComputerToolCall),
    ComputerToolCallOutputResource(ComputerToolCallOutputResource),
    WebSearchToolCall(WebSearchToolCall),
    FunctionToolCallResource(FunctionToolCallResource),
    FunctionToolCallOutputResource(FunctionToolCallOutputResource),
    ImageGenToolCall(ImageGenToolCall),
    CodeInterpreterToolCall(CodeInterpreterToolCall),
    LocalShellToolCall(LocalShellToolCall),
    LocalShellToolCallOutput(LocalShellToolCallOutput),
    McpListTools(McpListTools),
    McpApprovalRequest(McpApprovalRequest),
    McpApprovalResponseResource(McpApprovalResponseResource),
    McpToolCall(McpToolCall),
}
impl<'de> serde::Deserialize<'de> for KeyPress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a keypress action, this property is \nalways set to `keypress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum KeyPressType {
            #[default]
            #[serde(rename = "keypress")]
            Keypress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct KeyPress {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: KeyPressType,
            #[serde(rename = "keys")]
            #[allow(dead_code)]
            keys: Vec<String>,
        }
        let KeyPress { keys, .. } = KeyPress::deserialize(deserializer)?;
        Ok(Self { keys })
    }
}
impl serde::Serialize for KeyPress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a keypress action, this property is \nalways set to `keypress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum KeyPressType {
            #[default]
            #[serde(rename = "keypress")]
            Keypress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct KeyPress<'a> {
            #[serde(rename = "type")]
            type_: &'a KeyPressType,
            #[serde(rename = "keys")]
            keys: &'a Vec<String>,
        }
        let Self { keys } = self;
        KeyPress {
            type_: &Default::default(),
            keys,
        }
        .serialize(serializer)
    }
}
#[doc = "A collection of keypresses the model would like to perform.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct KeyPress {
    #[doc = "The combination of keys the model is requesting to be pressed. This is an\narray of strings, each representing a key.\n"]
    pub keys: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for ListAssistantsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListAssistantsResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<AssistantObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListAssistantsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListAssistantsResponse::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListAssistantsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListAssistantsResponse<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<AssistantObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListAssistantsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListAssistantsResponse {
    pub object: String,
    pub data: Vec<AssistantObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListAuditLogsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListAuditLogsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListAuditLogsResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListAuditLogsResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<AuditLog>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListAuditLogsResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListAuditLogsResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListAuditLogsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListAuditLogsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListAuditLogsResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ListAuditLogsResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<AuditLog>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListAuditLogsResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListAuditLogsResponse {
    pub data: Vec<AuditLog>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListBatchesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListBatchesResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListBatchesResponse {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Batch>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListBatchesResponseObject,
        }
        let ListBatchesResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListBatchesResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListBatchesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListBatchesResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListBatchesResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<Batch>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a ListBatchesResponseObject,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListBatchesResponse {
            data,
            first_id,
            last_id,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListBatchesResponse {
    pub data: Vec<Batch>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListCertificatesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListCertificatesResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListCertificatesResponse {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Certificate>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListCertificatesResponseObject,
        }
        let ListCertificatesResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListCertificatesResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListCertificatesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListCertificatesResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListCertificatesResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<Certificate>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a ListCertificatesResponseObject,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListCertificatesResponse {
            data,
            first_id,
            last_id,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListCertificatesResponse {
    pub data: Vec<Certificate>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFilesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListFilesResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<OpenAiFile>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListFilesResponse::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListFilesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListFilesResponse<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<OpenAiFile>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFilesResponse {
    pub object: String,
    pub data: Vec<OpenAiFile>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningCheckpointPermissionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningCheckpointPermissionResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListFineTuningCheckpointPermissionResponse {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<FineTuningCheckpointPermission>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListFineTuningCheckpointPermissionResponseObject,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListFineTuningCheckpointPermissionResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListFineTuningCheckpointPermissionResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListFineTuningCheckpointPermissionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningCheckpointPermissionResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListFineTuningCheckpointPermissionResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<FineTuningCheckpointPermission>,
            #[serde(rename = "object")]
            object: &'a ListFineTuningCheckpointPermissionResponseObject,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListFineTuningCheckpointPermissionResponse {
            data,
            object: &Default::default(),
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningCheckpointPermissionResponse {
    pub data: Vec<FineTuningCheckpointPermission>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningJobCheckpointsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningJobCheckpointsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListFineTuningJobCheckpointsResponse {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<FineTuningJobCheckpoint>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListFineTuningJobCheckpointsResponseObject,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListFineTuningJobCheckpointsResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListFineTuningJobCheckpointsResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListFineTuningJobCheckpointsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningJobCheckpointsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListFineTuningJobCheckpointsResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<FineTuningJobCheckpoint>,
            #[serde(rename = "object")]
            object: &'a ListFineTuningJobCheckpointsResponseObject,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListFineTuningJobCheckpointsResponse {
            data,
            object: &Default::default(),
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningJobCheckpointsResponse {
    pub data: Vec<FineTuningJobCheckpoint>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningJobEventsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningJobEventsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListFineTuningJobEventsResponse {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<FineTuningJobEvent>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListFineTuningJobEventsResponseObject,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListFineTuningJobEventsResponse { data, has_more, .. } =
            ListFineTuningJobEventsResponse::deserialize(deserializer)?;
        Ok(Self { data, has_more })
    }
}
impl serde::Serialize for ListFineTuningJobEventsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListFineTuningJobEventsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListFineTuningJobEventsResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<FineTuningJobEvent>,
            #[serde(rename = "object")]
            object: &'a ListFineTuningJobEventsResponseObject,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self { data, has_more } = self;
        ListFineTuningJobEventsResponse {
            data,
            object: &Default::default(),
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningJobEventsResponse {
    pub data: Vec<FineTuningJobEvent>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListMessagesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListMessagesResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<MessageObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListMessagesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListMessagesResponse::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListMessagesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListMessagesResponse<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<MessageObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListMessagesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListMessagesResponse {
    pub object: String,
    pub data: Vec<MessageObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListModelsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListModelsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListModelsResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListModelsResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Model>,
        }
        let ListModelsResponse { data, .. } = ListModelsResponse::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for ListModelsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListModelsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListModelsResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ListModelsResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<Model>,
        }
        let Self { data } = self;
        ListModelsResponse {
            object: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListModelsResponse {
    pub data: Vec<Model>,
}
impl<'de> serde::Deserialize<'de> for ListPaginatedFineTuningJobsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListPaginatedFineTuningJobsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListPaginatedFineTuningJobsResponse {
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<FineTuningJob>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ListPaginatedFineTuningJobsResponseObject,
        }
        let ListPaginatedFineTuningJobsResponse { data, has_more, .. } =
            ListPaginatedFineTuningJobsResponse::deserialize(deserializer)?;
        Ok(Self { data, has_more })
    }
}
impl serde::Serialize for ListPaginatedFineTuningJobsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ListPaginatedFineTuningJobsResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListPaginatedFineTuningJobsResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<FineTuningJob>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a ListPaginatedFineTuningJobsResponseObject,
        }
        let Self { data, has_more } = self;
        ListPaginatedFineTuningJobsResponse {
            data,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListPaginatedFineTuningJobsResponse {
    pub data: Vec<FineTuningJob>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListRunStepsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListRunStepsResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<RunStepObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListRunStepsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListRunStepsResponse::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListRunStepsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListRunStepsResponse<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<RunStepObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListRunStepsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListRunStepsResponse {
    pub object: String,
    pub data: Vec<RunStepObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListRunsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListRunsResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<RunObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListRunsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListRunsResponse::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListRunsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListRunsResponse<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<RunObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListRunsResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListRunsResponse {
    pub object: String,
    pub data: Vec<RunObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListVectorStoreFilesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListVectorStoreFilesResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<VectorStoreFileObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListVectorStoreFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListVectorStoreFilesResponse::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListVectorStoreFilesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListVectorStoreFilesResponse<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<VectorStoreFileObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListVectorStoreFilesResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListVectorStoreFilesResponse {
    pub object: String,
    pub data: Vec<VectorStoreFileObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListVectorStoresResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListVectorStoresResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<VectorStoreObject>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ListVectorStoresResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListVectorStoresResponse::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListVectorStoresResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListVectorStoresResponse<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<VectorStoreObject>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListVectorStoresResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListVectorStoresResponse {
    pub object: String,
    pub data: Vec<VectorStoreObject>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for LocalShellExecAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the local shell action. Always `exec`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellExecActionType {
            #[default]
            #[serde(rename = "exec")]
            Exec,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LocalShellExecAction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: LocalShellExecActionType,
            #[serde(rename = "command")]
            #[allow(dead_code)]
            command: Vec<String>,
            #[serde(rename = "timeout_ms")]
            #[allow(dead_code)]
            timeout_ms: Option<u64>,
            #[serde(rename = "working_directory")]
            #[allow(dead_code)]
            working_directory: Option<String>,
            #[serde(rename = "env")]
            #[allow(dead_code)]
            env: std::collections::HashMap<String, String>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
        }
        let LocalShellExecAction {
            command,
            timeout_ms,
            working_directory,
            env,
            user,
            ..
        } = LocalShellExecAction::deserialize(deserializer)?;
        Ok(Self {
            command,
            timeout_ms,
            working_directory,
            env,
            user,
        })
    }
}
impl serde::Serialize for LocalShellExecAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the local shell action. Always `exec`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellExecActionType {
            #[default]
            #[serde(rename = "exec")]
            Exec,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LocalShellExecAction<'a> {
            #[serde(rename = "type")]
            type_: &'a LocalShellExecActionType,
            #[serde(rename = "command")]
            command: &'a Vec<String>,
            #[serde(rename = "timeout_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timeout_ms: &'a Option<u64>,
            #[serde(rename = "working_directory")]
            #[serde(skip_serializing_if = "Option::is_none")]
            working_directory: &'a Option<String>,
            #[serde(rename = "env")]
            env: &'a std::collections::HashMap<String, String>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let Self {
            command,
            timeout_ms,
            working_directory,
            env,
            user,
        } = self;
        LocalShellExecAction {
            type_: &Default::default(),
            command,
            timeout_ms,
            working_directory,
            env,
            user,
        }
        .serialize(serializer)
    }
}
#[doc = "Execute a shell command on the server.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LocalShellExecAction {
    #[doc = "The command to run.\n"]
    pub command: Vec<String>,
    #[doc = "Optional timeout in milliseconds for the command.\n"]
    #[builder(default)]
    pub timeout_ms: Option<u64>,
    #[doc = "Optional working directory to run the command in.\n"]
    #[builder(default)]
    pub working_directory: Option<String>,
    #[doc = "Environment variables to set for the command.\n"]
    pub env: std::collections::HashMap<String, String>,
    #[doc = "Optional user to run the command as.\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for LocalShellTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the local shell tool. Always `local_shell`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolType {
            #[default]
            #[serde(rename = "local_shell")]
            LocalShell,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LocalShellTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: LocalShellToolType,
        }
        let LocalShellTool { .. } = LocalShellTool::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for LocalShellTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the local shell tool. Always `local_shell`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolType {
            #[default]
            #[serde(rename = "local_shell")]
            LocalShell,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LocalShellTool<'a> {
            #[serde(rename = "type")]
            type_: &'a LocalShellToolType,
        }
        let Self {} = self;
        LocalShellTool {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "A tool that allows the model to execute shell commands in a local environment.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct LocalShellTool {}
impl<'de> serde::Deserialize<'de> for LocalShellToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum LocalShellToolCallStatus {
            InProgress(#[allow(dead_code)] LocalShellToolCallStatusInProgress),
            Completed(#[allow(dead_code)] LocalShellToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] LocalShellToolCallStatusIncomplete),
        }
        Ok(match LocalShellToolCallStatus::deserialize(deserializer)? {
            LocalShellToolCallStatus::InProgress(_) => Self::InProgress,
            LocalShellToolCallStatus::Completed(_) => Self::Completed,
            LocalShellToolCallStatus::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for LocalShellToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum LocalShellToolCallStatus<'a> {
            InProgress(#[allow(dead_code)] &'a LocalShellToolCallStatusInProgress),
            Completed(#[allow(dead_code)] &'a LocalShellToolCallStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a LocalShellToolCallStatusIncomplete),
        }
        match self {
            Self::InProgress => {
                LocalShellToolCallStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                LocalShellToolCallStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                LocalShellToolCallStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the local shell call.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum LocalShellToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for LocalShellToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the local shell call. Always `local_shell_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallType {
            #[default]
            #[serde(rename = "local_shell_call")]
            LocalShellCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LocalShellToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: LocalShellToolCallType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "action")]
            #[allow(dead_code)]
            action: LocalShellExecAction,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: LocalShellToolCallStatus,
        }
        let LocalShellToolCall {
            id,
            call_id,
            action,
            status,
            ..
        } = LocalShellToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            action,
            status,
        })
    }
}
impl serde::Serialize for LocalShellToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the local shell call. Always `local_shell_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallType {
            #[default]
            #[serde(rename = "local_shell_call")]
            LocalShellCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LocalShellToolCall<'a> {
            #[serde(rename = "type")]
            type_: &'a LocalShellToolCallType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "action")]
            action: &'a LocalShellExecAction,
            #[serde(rename = "status")]
            status: &'a LocalShellToolCallStatus,
        }
        let Self {
            id,
            call_id,
            action,
            status,
        } = self;
        LocalShellToolCall {
            type_: &Default::default(),
            id,
            call_id,
            action,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool call to run a command on the local shell.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LocalShellToolCall {
    #[doc = "The unique ID of the local shell call.\n"]
    pub id: String,
    #[doc = "The unique ID of the local shell tool call generated by the model.\n"]
    pub call_id: String,
    pub action: LocalShellExecAction,
    #[doc = "The status of the local shell call.\n"]
    pub status: LocalShellToolCallStatus,
}
impl<'de> serde::Deserialize<'de> for LocalShellToolCallOutputStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum LocalShellToolCallOutputStatus {
            InProgress(#[allow(dead_code)] LocalShellToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] LocalShellToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] LocalShellToolCallOutputStatusIncomplete),
        }
        Ok(
            match LocalShellToolCallOutputStatus::deserialize(deserializer)? {
                LocalShellToolCallOutputStatus::InProgress(_) => Self::InProgress,
                LocalShellToolCallOutputStatus::Completed(_) => Self::Completed,
                LocalShellToolCallOutputStatus::Incomplete(_) => Self::Incomplete,
            },
        )
    }
}
impl serde::Serialize for LocalShellToolCallOutputStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallOutputStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallOutputStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallOutputStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum LocalShellToolCallOutputStatus<'a> {
            InProgress(#[allow(dead_code)] &'a LocalShellToolCallOutputStatusInProgress),
            Completed(#[allow(dead_code)] &'a LocalShellToolCallOutputStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a LocalShellToolCallOutputStatusIncomplete),
        }
        match self {
            Self::InProgress => LocalShellToolCallOutputStatus::InProgress(&Default::default())
                .serialize(serializer),
            Self::Completed => {
                LocalShellToolCallOutputStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => LocalShellToolCallOutputStatus::Incomplete(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum LocalShellToolCallOutputStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for LocalShellToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the local shell tool call output. Always `local_shell_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallOutputType {
            #[default]
            #[serde(rename = "local_shell_call_output")]
            LocalShellCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LocalShellToolCallOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: LocalShellToolCallOutputType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<LocalShellToolCallOutputStatus>,
        }
        let LocalShellToolCallOutput {
            id, output, status, ..
        } = LocalShellToolCallOutput::deserialize(deserializer)?;
        Ok(Self { id, output, status })
    }
}
impl serde::Serialize for LocalShellToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the local shell tool call output. Always `local_shell_call_output`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum LocalShellToolCallOutputType {
            #[default]
            #[serde(rename = "local_shell_call_output")]
            LocalShellCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LocalShellToolCallOutput<'a> {
            #[serde(rename = "type")]
            type_: &'a LocalShellToolCallOutputType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<LocalShellToolCallOutputStatus>,
        }
        let Self { id, output, status } = self;
        LocalShellToolCallOutput {
            type_: &Default::default(),
            id,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a local shell tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LocalShellToolCallOutput {
    #[doc = "The unique ID of the local shell tool call generated by the model.\n"]
    pub id: String,
    #[doc = "A JSON string of the output of the local shell tool call.\n"]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`.\n"]
    #[builder(default)]
    pub status: Option<LocalShellToolCallOutputStatus>,
}
impl<'de> serde::Deserialize<'de> for LogProbProperties {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LogProbProperties {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: String,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: f64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Vec<u64>,
        }
        let LogProbProperties {
            token,
            logprob,
            bytes,
            ..
        } = LogProbProperties::deserialize(deserializer)?;
        Ok(Self {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for LogProbProperties {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LogProbProperties<'a> {
            #[serde(rename = "token")]
            token: &'a String,
            #[serde(rename = "logprob")]
            logprob: &'a f64,
            #[serde(rename = "bytes")]
            bytes: &'a Vec<u64>,
        }
        let Self {
            token,
            logprob,
            bytes,
        } = self;
        LogProbProperties {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[doc = "A log probability object.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LogProbProperties {
    #[doc = "The token that was used to generate the log probability.\n"]
    pub token: String,
    #[doc = "The log probability of the token.\n"]
    pub logprob: f64,
    #[doc = "The bytes that were used to generate the log probability.\n"]
    pub bytes: Vec<u64>,
}
impl<'de> serde::Deserialize<'de> for McpApprovalRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the item. Always `mcp_approval_request`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpApprovalRequestType {
            #[default]
            #[serde(rename = "mcp_approval_request")]
            McpApprovalRequest,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpApprovalRequest {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: McpApprovalRequestType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "server_label")]
            #[allow(dead_code)]
            server_label: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let McpApprovalRequest {
            id,
            server_label,
            name,
            arguments,
            ..
        } = McpApprovalRequest::deserialize(deserializer)?;
        Ok(Self {
            id,
            server_label,
            name,
            arguments,
        })
    }
}
impl serde::Serialize for McpApprovalRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the item. Always `mcp_approval_request`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpApprovalRequestType {
            #[default]
            #[serde(rename = "mcp_approval_request")]
            McpApprovalRequest,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpApprovalRequest<'a> {
            #[serde(rename = "type")]
            type_: &'a McpApprovalRequestType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let Self {
            id,
            server_label,
            name,
            arguments,
        } = self;
        McpApprovalRequest {
            type_: &Default::default(),
            id,
            server_label,
            name,
            arguments,
        }
        .serialize(serializer)
    }
}
#[doc = "A request for human approval of a tool invocation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpApprovalRequest {
    #[doc = "The unique ID of the approval request.\n"]
    pub id: String,
    #[doc = "The label of the MCP server making the request.\n"]
    pub server_label: String,
    #[doc = "The name of the tool to run.\n"]
    pub name: String,
    #[doc = "A JSON string of arguments for the tool.\n"]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for McpApprovalResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the item. Always `mcp_approval_response`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpApprovalResponseType {
            #[default]
            #[serde(rename = "mcp_approval_response")]
            McpApprovalResponse,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpApprovalResponse {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: McpApprovalResponseType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "approval_request_id")]
            #[allow(dead_code)]
            approval_request_id: String,
            #[serde(rename = "approve")]
            #[allow(dead_code)]
            approve: bool,
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: Option<String>,
        }
        let McpApprovalResponse {
            id,
            approval_request_id,
            approve,
            reason,
            ..
        } = McpApprovalResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            approval_request_id,
            approve,
            reason,
        })
    }
}
impl serde::Serialize for McpApprovalResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the item. Always `mcp_approval_response`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpApprovalResponseType {
            #[default]
            #[serde(rename = "mcp_approval_response")]
            McpApprovalResponse,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpApprovalResponse<'a> {
            #[serde(rename = "type")]
            type_: &'a McpApprovalResponseType,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "approval_request_id")]
            approval_request_id: &'a String,
            #[serde(rename = "approve")]
            approve: &'a bool,
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<String>,
        }
        let Self {
            id,
            approval_request_id,
            approve,
            reason,
        } = self;
        McpApprovalResponse {
            type_: &Default::default(),
            id,
            approval_request_id,
            approve,
            reason,
        }
        .serialize(serializer)
    }
}
#[doc = "A response to an MCP approval request.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpApprovalResponse {
    #[doc = "The unique ID of the approval response\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The ID of the approval request being answered.\n"]
    pub approval_request_id: String,
    #[doc = "Whether the request was approved.\n"]
    pub approve: bool,
    #[doc = "Optional reason for the decision.\n"]
    #[builder(default)]
    pub reason: Option<String>,
}
impl<'de> serde::Deserialize<'de> for McpApprovalResponseResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the item. Always `mcp_approval_response`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpApprovalResponseResourceType {
            #[default]
            #[serde(rename = "mcp_approval_response")]
            McpApprovalResponse,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpApprovalResponseResource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: McpApprovalResponseResourceType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "approval_request_id")]
            #[allow(dead_code)]
            approval_request_id: String,
            #[serde(rename = "approve")]
            #[allow(dead_code)]
            approve: bool,
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: Option<String>,
        }
        let McpApprovalResponseResource {
            id,
            approval_request_id,
            approve,
            reason,
            ..
        } = McpApprovalResponseResource::deserialize(deserializer)?;
        Ok(Self {
            id,
            approval_request_id,
            approve,
            reason,
        })
    }
}
impl serde::Serialize for McpApprovalResponseResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the item. Always `mcp_approval_response`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpApprovalResponseResourceType {
            #[default]
            #[serde(rename = "mcp_approval_response")]
            McpApprovalResponse,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpApprovalResponseResource<'a> {
            #[serde(rename = "type")]
            type_: &'a McpApprovalResponseResourceType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "approval_request_id")]
            approval_request_id: &'a String,
            #[serde(rename = "approve")]
            approve: &'a bool,
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<String>,
        }
        let Self {
            id,
            approval_request_id,
            approve,
            reason,
        } = self;
        McpApprovalResponseResource {
            type_: &Default::default(),
            id,
            approval_request_id,
            approve,
            reason,
        }
        .serialize(serializer)
    }
}
#[doc = "A response to an MCP approval request.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpApprovalResponseResource {
    #[doc = "The unique ID of the approval response\n"]
    pub id: String,
    #[doc = "The ID of the approval request being answered.\n"]
    pub approval_request_id: String,
    #[doc = "Whether the request was approved.\n"]
    pub approve: bool,
    #[doc = "Optional reason for the decision.\n"]
    #[builder(default)]
    pub reason: Option<String>,
}
impl<'de> serde::Deserialize<'de> for McpListTools {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the item. Always `mcp_list_tools`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpListToolsType {
            #[default]
            #[serde(rename = "mcp_list_tools")]
            McpListTools,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpListTools {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: McpListToolsType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "server_label")]
            #[allow(dead_code)]
            server_label: String,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Vec<McpListToolsTool>,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<String>,
        }
        let McpListTools {
            id,
            server_label,
            tools,
            error,
            ..
        } = McpListTools::deserialize(deserializer)?;
        Ok(Self {
            id,
            server_label,
            tools,
            error,
        })
    }
}
impl serde::Serialize for McpListTools {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the item. Always `mcp_list_tools`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpListToolsType {
            #[default]
            #[serde(rename = "mcp_list_tools")]
            McpListTools,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpListTools<'a> {
            #[serde(rename = "type")]
            type_: &'a McpListToolsType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "tools")]
            tools: &'a Vec<McpListToolsTool>,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<String>,
        }
        let Self {
            id,
            server_label,
            tools,
            error,
        } = self;
        McpListTools {
            type_: &Default::default(),
            id,
            server_label,
            tools,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of tools available on an MCP server.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpListTools {
    #[doc = "The unique ID of the list.\n"]
    pub id: String,
    #[doc = "The label of the MCP server.\n"]
    pub server_label: String,
    #[doc = "The tools available on the server.\n"]
    pub tools: Vec<McpListToolsTool>,
    #[doc = "Error message if the server could not list tools.\n"]
    #[builder(default)]
    pub error: Option<String>,
}
impl<'de> serde::Deserialize<'de> for McpListToolsTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpListToolsTool {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "input_schema")]
            #[allow(dead_code)]
            input_schema: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let McpListToolsTool {
            name,
            description,
            input_schema,
            annotations,
            ..
        } = McpListToolsTool::deserialize(deserializer)?;
        Ok(Self {
            name,
            description,
            input_schema,
            annotations,
        })
    }
}
impl serde::Serialize for McpListToolsTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpListToolsTool<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "input_schema")]
            input_schema: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "annotations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            annotations: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            name,
            description,
            input_schema,
            annotations,
        } = self;
        McpListToolsTool {
            name,
            description,
            input_schema,
            annotations,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool available on an MCP server.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpListToolsTool {
    #[doc = "The name of the tool.\n"]
    pub name: String,
    #[doc = "The description of the tool.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The JSON schema describing the tool's input.\n"]
    pub input_schema: std::collections::HashMap<String, serde_json::Value>,
    #[doc = "Additional annotations about the tool.\n"]
    #[builder(default)]
    pub annotations: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for McpToolAllowedTools1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpToolAllowedTools1 {
            #[serde(rename = "tool_names")]
            #[allow(dead_code)]
            tool_names: Option<Vec<String>>,
        }
        let McpToolAllowedTools1 { tool_names, .. } =
            McpToolAllowedTools1::deserialize(deserializer)?;
        Ok(Self { tool_names })
    }
}
impl serde::Serialize for McpToolAllowedTools1 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpToolAllowedTools1<'a> {
            #[serde(rename = "tool_names")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_names: &'a Option<Vec<String>>,
        }
        let Self { tool_names } = self;
        McpToolAllowedTools1 { tool_names }.serialize(serializer)
    }
}
#[doc = "A filter object to specify which tools are allowed.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct McpToolAllowedTools1 {
    #[doc = "List of allowed tool names."]
    #[builder(default)]
    pub tool_names: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for McpToolAllowedTools {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum McpToolAllowedTools {
            Array(#[allow(dead_code)] Vec<String>),
            _1(#[allow(dead_code)] McpToolAllowedTools1),
        }
        Ok(match McpToolAllowedTools::deserialize(deserializer)? {
            McpToolAllowedTools::Array(_v) => Self::Array(_v),
            McpToolAllowedTools::_1(_v) => Self::_1(_v),
        })
    }
}
impl serde::Serialize for McpToolAllowedTools {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum McpToolAllowedTools<'a> {
            Array(#[allow(dead_code)] &'a Vec<String>),
            _1(#[allow(dead_code)] &'a McpToolAllowedTools1),
        }
        match self {
            Self::Array(_v) => McpToolAllowedTools::Array(_v).serialize(serializer),
            Self::_1(_v) => McpToolAllowedTools::_1(_v).serialize(serializer),
        }
    }
}
#[doc = "List of allowed tool names or a filter object.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum McpToolAllowedTools {
    #[doc = "A string array of allowed tool names"]
    Array(Vec<String>),
    #[doc = "A filter object to specify which tools are allowed.\n"]
    _1(McpToolAllowedTools1),
}
impl<'de> serde::Deserialize<'de> for McpToolRequireApproval0Always {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpToolRequireApproval0Always {
            #[serde(rename = "tool_names")]
            #[allow(dead_code)]
            tool_names: Option<Vec<String>>,
        }
        let McpToolRequireApproval0Always { tool_names, .. } =
            McpToolRequireApproval0Always::deserialize(deserializer)?;
        Ok(Self { tool_names })
    }
}
impl serde::Serialize for McpToolRequireApproval0Always {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpToolRequireApproval0Always<'a> {
            #[serde(rename = "tool_names")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_names: &'a Option<Vec<String>>,
        }
        let Self { tool_names } = self;
        McpToolRequireApproval0Always { tool_names }.serialize(serializer)
    }
}
#[doc = "A list of tools that always require approval.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct McpToolRequireApproval0Always {
    #[doc = "List of tools that require approval."]
    #[builder(default)]
    pub tool_names: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for McpToolRequireApproval0Never {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpToolRequireApproval0Never {
            #[serde(rename = "tool_names")]
            #[allow(dead_code)]
            tool_names: Option<Vec<String>>,
        }
        let McpToolRequireApproval0Never { tool_names, .. } =
            McpToolRequireApproval0Never::deserialize(deserializer)?;
        Ok(Self { tool_names })
    }
}
impl serde::Serialize for McpToolRequireApproval0Never {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpToolRequireApproval0Never<'a> {
            #[serde(rename = "tool_names")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_names: &'a Option<Vec<String>>,
        }
        let Self { tool_names } = self;
        McpToolRequireApproval0Never { tool_names }.serialize(serializer)
    }
}
#[doc = "A list of tools that never require approval.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct McpToolRequireApproval0Never {
    #[doc = "List of tools that do not require approval."]
    #[builder(default)]
    pub tool_names: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for McpToolRequireApproval0 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpToolRequireApproval0 {
            #[serde(rename = "always")]
            #[allow(dead_code)]
            always: Option<McpToolRequireApproval0Always>,
            #[serde(rename = "never")]
            #[allow(dead_code)]
            never: Option<McpToolRequireApproval0Never>,
        }
        let McpToolRequireApproval0 { always, never, .. } =
            McpToolRequireApproval0::deserialize(deserializer)?;
        Ok(Self { always, never })
    }
}
impl serde::Serialize for McpToolRequireApproval0 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpToolRequireApproval0<'a> {
            #[serde(rename = "always")]
            #[serde(skip_serializing_if = "Option::is_none")]
            always: &'a Option<McpToolRequireApproval0Always>,
            #[serde(rename = "never")]
            #[serde(skip_serializing_if = "Option::is_none")]
            never: &'a Option<McpToolRequireApproval0Never>,
        }
        let Self { always, never } = self;
        McpToolRequireApproval0 { always, never }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct McpToolRequireApproval0 {
    #[doc = "A list of tools that always require approval.\n"]
    #[builder(default)]
    pub always: Option<McpToolRequireApproval0Always>,
    #[doc = "A list of tools that never require approval.\n"]
    #[builder(default)]
    pub never: Option<McpToolRequireApproval0Never>,
}
impl<'de> serde::Deserialize<'de> for McpToolRequireApproval {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpToolRequireApprovalAlways {
            #[default]
            #[serde(rename = "always")]
            Always,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpToolRequireApprovalNever {
            #[default]
            #[serde(rename = "never")]
            Never,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum McpToolRequireApproval {
            Always(#[allow(dead_code)] McpToolRequireApprovalAlways),
            Never(#[allow(dead_code)] McpToolRequireApprovalNever),
            _0(#[allow(dead_code)] McpToolRequireApproval0),
        }
        Ok(match McpToolRequireApproval::deserialize(deserializer)? {
            McpToolRequireApproval::_0(_v) => Self::_0(_v),
            McpToolRequireApproval::Always(_) => Self::Always,
            McpToolRequireApproval::Never(_) => Self::Never,
        })
    }
}
impl serde::Serialize for McpToolRequireApproval {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpToolRequireApprovalAlways {
            #[default]
            #[serde(rename = "always")]
            Always,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpToolRequireApprovalNever {
            #[default]
            #[serde(rename = "never")]
            Never,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum McpToolRequireApproval<'a> {
            _0(#[allow(dead_code)] &'a McpToolRequireApproval0),
            Always(#[allow(dead_code)] &'a McpToolRequireApprovalAlways),
            Never(#[allow(dead_code)] &'a McpToolRequireApprovalNever),
        }
        match self {
            Self::_0(_v) => McpToolRequireApproval::_0(_v).serialize(serializer),
            Self::Always => {
                McpToolRequireApproval::Always(&Default::default()).serialize(serializer)
            }
            Self::Never => McpToolRequireApproval::Never(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specify which of the MCP server's tools require approval."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum McpToolRequireApproval {
    _0(McpToolRequireApproval0),
    #[doc = "always"]
    Always,
    #[doc = "never"]
    Never,
}
impl<'de> serde::Deserialize<'de> for McpTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the MCP tool. Always `mcp`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpToolType {
            #[default]
            #[serde(rename = "mcp")]
            Mcp,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: McpToolType,
            #[serde(rename = "server_label")]
            #[allow(dead_code)]
            server_label: String,
            #[serde(rename = "server_url")]
            #[allow(dead_code)]
            server_url: String,
            #[serde(rename = "headers")]
            #[allow(dead_code)]
            headers: Option<std::collections::HashMap<String, String>>,
            #[serde(rename = "allowed_tools")]
            #[allow(dead_code)]
            allowed_tools: Option<McpToolAllowedTools>,
            #[serde(rename = "require_approval")]
            #[allow(dead_code)]
            require_approval: Option<McpToolRequireApproval>,
        }
        let McpTool {
            server_label,
            server_url,
            headers,
            allowed_tools,
            require_approval,
            ..
        } = McpTool::deserialize(deserializer)?;
        Ok(Self {
            server_label,
            server_url,
            headers,
            allowed_tools,
            require_approval,
        })
    }
}
impl serde::Serialize for McpTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the MCP tool. Always `mcp`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpToolType {
            #[default]
            #[serde(rename = "mcp")]
            Mcp,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpTool<'a> {
            #[serde(rename = "type")]
            type_: &'a McpToolType,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "server_url")]
            server_url: &'a String,
            #[serde(rename = "headers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            headers: &'a Option<std::collections::HashMap<String, String>>,
            #[serde(rename = "allowed_tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            allowed_tools: &'a Option<McpToolAllowedTools>,
            #[serde(rename = "require_approval")]
            #[serde(skip_serializing_if = "Option::is_none")]
            require_approval: &'a Option<McpToolRequireApproval>,
        }
        let Self {
            server_label,
            server_url,
            headers,
            allowed_tools,
            require_approval,
        } = self;
        McpTool {
            type_: &Default::default(),
            server_label,
            server_url,
            headers,
            allowed_tools,
            require_approval,
        }
        .serialize(serializer)
    }
}
#[doc = "Give the model access to additional tools via remote Model Context Protocol \n(MCP) servers. [Learn more about MCP](https://platform.openai.com/docs/guides/tools-remote-mcp).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpTool {
    #[doc = "A label for this MCP server, used to identify it in tool calls.\n"]
    pub server_label: String,
    #[doc = "The URL for the MCP server.\n"]
    pub server_url: String,
    #[doc = "Optional HTTP headers to send to the MCP server. Use for authentication\nor other purposes.\n"]
    #[builder(default)]
    pub headers: Option<std::collections::HashMap<String, String>>,
    #[doc = "List of allowed tool names or a filter object.\n"]
    #[builder(default)]
    pub allowed_tools: Option<McpToolAllowedTools>,
    #[doc = "Specify which of the MCP server's tools require approval."]
    #[builder(default)]
    pub require_approval: Option<McpToolRequireApproval>,
}
impl<'de> serde::Deserialize<'de> for McpToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the item. Always `mcp_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpToolCallType {
            #[default]
            #[serde(rename = "mcp_call")]
            McpCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: McpToolCallType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "server_label")]
            #[allow(dead_code)]
            server_label: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<String>,
        }
        let McpToolCall {
            id,
            server_label,
            name,
            arguments,
            output,
            error,
            ..
        } = McpToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            server_label,
            name,
            arguments,
            output,
            error,
        })
    }
}
impl serde::Serialize for McpToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the item. Always `mcp_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum McpToolCallType {
            #[default]
            #[serde(rename = "mcp_call")]
            McpCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpToolCall<'a> {
            #[serde(rename = "type")]
            type_: &'a McpToolCallType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<String>,
        }
        let Self {
            id,
            server_label,
            name,
            arguments,
            output,
            error,
        } = self;
        McpToolCall {
            type_: &Default::default(),
            id,
            server_label,
            name,
            arguments,
            output,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "An invocation of a tool on an MCP server.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpToolCall {
    #[doc = "The unique ID of the tool call.\n"]
    pub id: String,
    #[doc = "The label of the MCP server running the tool.\n"]
    pub server_label: String,
    #[doc = "The name of the tool that was run.\n"]
    pub name: String,
    #[doc = "A JSON string of the arguments passed to the tool.\n"]
    pub arguments: String,
    #[doc = "The output from the tool call.\n"]
    #[builder(default)]
    pub output: Option<String>,
    #[doc = "The error from the tool call, if any.\n"]
    #[builder(default)]
    pub error: Option<String>,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageFileObjectImageFileDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageContentImageFileObjectImageFileDetail {
            Auto(#[allow(dead_code)] MessageContentImageFileObjectImageFileDetailAuto),
            Low(#[allow(dead_code)] MessageContentImageFileObjectImageFileDetailLow),
            High(#[allow(dead_code)] MessageContentImageFileObjectImageFileDetailHigh),
        }
        Ok(
            match MessageContentImageFileObjectImageFileDetail::deserialize(deserializer)? {
                MessageContentImageFileObjectImageFileDetail::Auto(_) => Self::Auto,
                MessageContentImageFileObjectImageFileDetail::Low(_) => Self::Low,
                MessageContentImageFileObjectImageFileDetail::High(_) => Self::High,
            },
        )
    }
}
impl serde::Serialize for MessageContentImageFileObjectImageFileDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectImageFileDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageContentImageFileObjectImageFileDetail<'a> {
            Auto(#[allow(dead_code)] &'a MessageContentImageFileObjectImageFileDetailAuto),
            Low(#[allow(dead_code)] &'a MessageContentImageFileObjectImageFileDetailLow),
            High(#[allow(dead_code)] &'a MessageContentImageFileObjectImageFileDetailHigh),
        }
        match self {
            Self::Auto => MessageContentImageFileObjectImageFileDetail::Auto(&Default::default())
                .serialize(serializer),
            Self::Low => MessageContentImageFileObjectImageFileDetail::Low(&Default::default())
                .serialize(serializer),
            Self::High => MessageContentImageFileObjectImageFileDetail::High(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContentImageFileObjectImageFileDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageFileObjectImageFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentImageFileObjectImageFile {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<MessageContentImageFileObjectImageFileDetail>,
        }
        let MessageContentImageFileObjectImageFile {
            file_id, detail, ..
        } = MessageContentImageFileObjectImageFile::deserialize(deserializer)?;
        Ok(Self { file_id, detail })
    }
}
impl serde::Serialize for MessageContentImageFileObjectImageFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentImageFileObjectImageFile<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<MessageContentImageFileObjectImageFileDetail>,
        }
        let Self { file_id, detail } = self;
        MessageContentImageFileObjectImageFile { file_id, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageFileObjectImageFile {
    #[doc = "The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content."]
    pub file_id: String,
    #[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
    #[builder(default)]
    pub detail: Option<MessageContentImageFileObjectImageFileDetail>,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectType {
            #[default]
            #[serde(rename = "image_file")]
            ImageFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentImageFileObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentImageFileObjectType,
            #[serde(rename = "image_file")]
            #[allow(dead_code)]
            image_file: MessageContentImageFileObjectImageFile,
        }
        let MessageContentImageFileObject { image_file, .. } =
            MessageContentImageFileObject::deserialize(deserializer)?;
        Ok(Self { image_file })
    }
}
impl serde::Serialize for MessageContentImageFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageFileObjectType {
            #[default]
            #[serde(rename = "image_file")]
            ImageFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentImageFileObject<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentImageFileObjectType,
            #[serde(rename = "image_file")]
            image_file: &'a MessageContentImageFileObjectImageFile,
        }
        let Self { image_file } = self;
        MessageContentImageFileObject {
            type_: &Default::default(),
            image_file,
        }
        .serialize(serializer)
    }
}
#[doc = "References an image [File](https://platform.openai.com/docs/api-reference/files) in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageFileObject {
    pub image_file: MessageContentImageFileObjectImageFile,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageUrlObjectImageUrlDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageContentImageUrlObjectImageUrlDetail {
            Auto(#[allow(dead_code)] MessageContentImageUrlObjectImageUrlDetailAuto),
            Low(#[allow(dead_code)] MessageContentImageUrlObjectImageUrlDetailLow),
            High(#[allow(dead_code)] MessageContentImageUrlObjectImageUrlDetailHigh),
        }
        Ok(
            match MessageContentImageUrlObjectImageUrlDetail::deserialize(deserializer)? {
                MessageContentImageUrlObjectImageUrlDetail::Auto(_) => Self::Auto,
                MessageContentImageUrlObjectImageUrlDetail::Low(_) => Self::Low,
                MessageContentImageUrlObjectImageUrlDetail::High(_) => Self::High,
            },
        )
    }
}
impl serde::Serialize for MessageContentImageUrlObjectImageUrlDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageContentImageUrlObjectImageUrlDetail<'a> {
            Auto(#[allow(dead_code)] &'a MessageContentImageUrlObjectImageUrlDetailAuto),
            Low(#[allow(dead_code)] &'a MessageContentImageUrlObjectImageUrlDetailLow),
            High(#[allow(dead_code)] &'a MessageContentImageUrlObjectImageUrlDetailHigh),
        }
        match self {
            Self::Auto => MessageContentImageUrlObjectImageUrlDetail::Auto(&Default::default())
                .serialize(serializer),
            Self::Low => MessageContentImageUrlObjectImageUrlDetail::Low(&Default::default())
                .serialize(serializer),
            Self::High => MessageContentImageUrlObjectImageUrlDetail::High(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContentImageUrlObjectImageUrlDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageUrlObjectImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentImageUrlObjectImageUrl {
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<MessageContentImageUrlObjectImageUrlDetail>,
        }
        let MessageContentImageUrlObjectImageUrl { url, detail, .. } =
            MessageContentImageUrlObjectImageUrl::deserialize(deserializer)?;
        Ok(Self { url, detail })
    }
}
impl serde::Serialize for MessageContentImageUrlObjectImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentImageUrlObjectImageUrl<'a> {
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<MessageContentImageUrlObjectImageUrlDetail>,
        }
        let Self { url, detail } = self;
        MessageContentImageUrlObjectImageUrl { url, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageUrlObjectImageUrl {
    #[doc = "The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp."]
    pub url: String,
    #[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`"]
    #[builder(default)]
    pub detail: Option<MessageContentImageUrlObjectImageUrlDetail>,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageUrlObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentImageUrlObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentImageUrlObjectType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: MessageContentImageUrlObjectImageUrl,
        }
        let MessageContentImageUrlObject { image_url, .. } =
            MessageContentImageUrlObject::deserialize(deserializer)?;
        Ok(Self { image_url })
    }
}
impl serde::Serialize for MessageContentImageUrlObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the content part."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentImageUrlObjectType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentImageUrlObject<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentImageUrlObjectType,
            #[serde(rename = "image_url")]
            image_url: &'a MessageContentImageUrlObjectImageUrl,
        }
        let Self { image_url } = self;
        MessageContentImageUrlObject {
            type_: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[doc = "References an image URL in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageUrlObject {
    pub image_url: MessageContentImageUrlObjectImageUrl,
}
impl<'de> serde::Deserialize<'de> for MessageContentRefusalObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentRefusalObjectType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentRefusalObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentRefusalObjectType,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: String,
        }
        let MessageContentRefusalObject { refusal, .. } =
            MessageContentRefusalObject::deserialize(deserializer)?;
        Ok(Self { refusal })
    }
}
impl serde::Serialize for MessageContentRefusalObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentRefusalObjectType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentRefusalObject<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentRefusalObjectType,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let Self { refusal } = self;
        MessageContentRefusalObject {
            type_: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "The refusal content generated by the assistant."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentRefusalObject {
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFileCitationObjectFileCitation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextAnnotationsFileCitationObjectFileCitation {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
        }
        let MessageContentTextAnnotationsFileCitationObjectFileCitation { file_id, .. } =
            MessageContentTextAnnotationsFileCitationObjectFileCitation::deserialize(deserializer)?;
        Ok(Self { file_id })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFileCitationObjectFileCitation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextAnnotationsFileCitationObjectFileCitation<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
        }
        let Self { file_id } = self;
        MessageContentTextAnnotationsFileCitationObjectFileCitation { file_id }
            .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFileCitationObjectFileCitation {
    #[doc = "The ID of the specific File the citation is from."]
    pub file_id: String,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFileCitationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextAnnotationsFileCitationObjectType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextAnnotationsFileCitationObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentTextAnnotationsFileCitationObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "file_citation")]
            #[allow(dead_code)]
            file_citation: MessageContentTextAnnotationsFileCitationObjectFileCitation,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
        }
        let MessageContentTextAnnotationsFileCitationObject {
            text,
            file_citation,
            start_index,
            end_index,
            ..
        } = MessageContentTextAnnotationsFileCitationObject::deserialize(deserializer)?;
        Ok(Self {
            text,
            file_citation,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFileCitationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextAnnotationsFileCitationObjectType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextAnnotationsFileCitationObject<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentTextAnnotationsFileCitationObjectType,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "file_citation")]
            file_citation: &'a MessageContentTextAnnotationsFileCitationObjectFileCitation,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "end_index")]
            end_index: &'a u64,
        }
        let Self {
            text,
            file_citation,
            start_index,
            end_index,
        } = self;
        MessageContentTextAnnotationsFileCitationObject {
            type_: &Default::default(),
            text,
            file_citation,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFileCitationObject {
    #[doc = "The text in the message content that needs to be replaced."]
    pub text: String,
    pub file_citation: MessageContentTextAnnotationsFileCitationObjectFileCitation,
    pub start_index: u64,
    pub end_index: u64,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFilePathObjectFilePath {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextAnnotationsFilePathObjectFilePath {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
        }
        let MessageContentTextAnnotationsFilePathObjectFilePath { file_id, .. } =
            MessageContentTextAnnotationsFilePathObjectFilePath::deserialize(deserializer)?;
        Ok(Self { file_id })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFilePathObjectFilePath {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextAnnotationsFilePathObjectFilePath<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
        }
        let Self { file_id } = self;
        MessageContentTextAnnotationsFilePathObjectFilePath { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFilePathObjectFilePath {
    #[doc = "The ID of the file that was generated."]
    pub file_id: String,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFilePathObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `file_path`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextAnnotationsFilePathObjectType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextAnnotationsFilePathObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentTextAnnotationsFilePathObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "file_path")]
            #[allow(dead_code)]
            file_path: MessageContentTextAnnotationsFilePathObjectFilePath,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
        }
        let MessageContentTextAnnotationsFilePathObject {
            text,
            file_path,
            start_index,
            end_index,
            ..
        } = MessageContentTextAnnotationsFilePathObject::deserialize(deserializer)?;
        Ok(Self {
            text,
            file_path,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFilePathObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `file_path`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextAnnotationsFilePathObjectType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextAnnotationsFilePathObject<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentTextAnnotationsFilePathObjectType,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "file_path")]
            file_path: &'a MessageContentTextAnnotationsFilePathObjectFilePath,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "end_index")]
            end_index: &'a u64,
        }
        let Self {
            text,
            file_path,
            start_index,
            end_index,
        } = self;
        MessageContentTextAnnotationsFilePathObject {
            type_: &Default::default(),
            text,
            file_path,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFilePathObject {
    #[doc = "The text in the message content that needs to be replaced."]
    pub text: String,
    pub file_path: MessageContentTextAnnotationsFilePathObjectFilePath,
    pub start_index: u64,
    pub end_index: u64,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextObjectText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextObjectText {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: String,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Vec<TextAnnotation>,
        }
        let MessageContentTextObjectText {
            value, annotations, ..
        } = MessageContentTextObjectText::deserialize(deserializer)?;
        Ok(Self { value, annotations })
    }
}
impl serde::Serialize for MessageContentTextObjectText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextObjectText<'a> {
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "annotations")]
            annotations: &'a Vec<TextAnnotation>,
        }
        let Self { value, annotations } = self;
        MessageContentTextObjectText { value, annotations }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextObjectText {
    #[doc = "The data that makes up the text."]
    pub value: String,
    pub annotations: Vec<TextAnnotation>,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageContentTextObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: MessageContentTextObjectText,
        }
        let MessageContentTextObject { text, .. } =
            MessageContentTextObject::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for MessageContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextObject<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageContentTextObjectType,
            #[serde(rename = "text")]
            text: &'a MessageContentTextObjectText,
        }
        let Self { text } = self;
        MessageContentTextObject {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextObject {
    pub text: MessageContentTextObjectText,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageFileObjectImageFileDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageDeltaContentImageFileObjectImageFileDetail {
            Auto(#[allow(dead_code)] MessageDeltaContentImageFileObjectImageFileDetailAuto),
            Low(#[allow(dead_code)] MessageDeltaContentImageFileObjectImageFileDetailLow),
            High(#[allow(dead_code)] MessageDeltaContentImageFileObjectImageFileDetailHigh),
        }
        Ok(
            match MessageDeltaContentImageFileObjectImageFileDetail::deserialize(deserializer)? {
                MessageDeltaContentImageFileObjectImageFileDetail::Auto(_) => Self::Auto,
                MessageDeltaContentImageFileObjectImageFileDetail::Low(_) => Self::Low,
                MessageDeltaContentImageFileObjectImageFileDetail::High(_) => Self::High,
            },
        )
    }
}
impl serde::Serialize for MessageDeltaContentImageFileObjectImageFileDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectImageFileDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageDeltaContentImageFileObjectImageFileDetail<'a> {
            Auto(#[allow(dead_code)] &'a MessageDeltaContentImageFileObjectImageFileDetailAuto),
            Low(#[allow(dead_code)] &'a MessageDeltaContentImageFileObjectImageFileDetailLow),
            High(#[allow(dead_code)] &'a MessageDeltaContentImageFileObjectImageFileDetailHigh),
        }
        match self {
            Self::Auto => {
                MessageDeltaContentImageFileObjectImageFileDetail::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Low => {
                MessageDeltaContentImageFileObjectImageFileDetail::Low(&Default::default())
                    .serialize(serializer)
            }
            Self::High => {
                MessageDeltaContentImageFileObjectImageFileDetail::High(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum MessageDeltaContentImageFileObjectImageFileDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageFileObjectImageFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentImageFileObjectImageFile {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<MessageDeltaContentImageFileObjectImageFileDetail>,
        }
        let MessageDeltaContentImageFileObjectImageFile {
            file_id, detail, ..
        } = MessageDeltaContentImageFileObjectImageFile::deserialize(deserializer)?;
        Ok(Self { file_id, detail })
    }
}
impl serde::Serialize for MessageDeltaContentImageFileObjectImageFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentImageFileObjectImageFile<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<MessageDeltaContentImageFileObjectImageFileDetail>,
        }
        let Self { file_id, detail } = self;
        MessageDeltaContentImageFileObjectImageFile { file_id, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageFileObjectImageFile {
    #[doc = "The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
    #[builder(default)]
    pub detail: Option<MessageDeltaContentImageFileObjectImageFileDetail>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectType {
            #[default]
            #[serde(rename = "image_file")]
            ImageFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentImageFileObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentImageFileObjectType,
            #[serde(rename = "image_file")]
            #[allow(dead_code)]
            image_file: Option<MessageDeltaContentImageFileObjectImageFile>,
        }
        let MessageDeltaContentImageFileObject {
            index, image_file, ..
        } = MessageDeltaContentImageFileObject::deserialize(deserializer)?;
        Ok(Self { index, image_file })
    }
}
impl serde::Serialize for MessageDeltaContentImageFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageFileObjectType {
            #[default]
            #[serde(rename = "image_file")]
            ImageFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentImageFileObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentImageFileObjectType,
            #[serde(rename = "image_file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_file: &'a Option<MessageDeltaContentImageFileObjectImageFile>,
        }
        let Self { index, image_file } = self;
        MessageDeltaContentImageFileObject {
            index,
            type_: &Default::default(),
            image_file,
        }
        .serialize(serializer)
    }
}
#[doc = "References an image [File](https://platform.openai.com/docs/api-reference/files) in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageFileObject {
    #[doc = "The index of the content part in the message."]
    pub index: u64,
    #[builder(default)]
    pub image_file: Option<MessageDeltaContentImageFileObjectImageFile>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageUrlObjectImageUrlDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageDeltaContentImageUrlObjectImageUrlDetail {
            Auto(#[allow(dead_code)] MessageDeltaContentImageUrlObjectImageUrlDetailAuto),
            Low(#[allow(dead_code)] MessageDeltaContentImageUrlObjectImageUrlDetailLow),
            High(#[allow(dead_code)] MessageDeltaContentImageUrlObjectImageUrlDetailHigh),
        }
        Ok(
            match MessageDeltaContentImageUrlObjectImageUrlDetail::deserialize(deserializer)? {
                MessageDeltaContentImageUrlObjectImageUrlDetail::Auto(_) => Self::Auto,
                MessageDeltaContentImageUrlObjectImageUrlDetail::Low(_) => Self::Low,
                MessageDeltaContentImageUrlObjectImageUrlDetail::High(_) => Self::High,
            },
        )
    }
}
impl serde::Serialize for MessageDeltaContentImageUrlObjectImageUrlDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectImageUrlDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageDeltaContentImageUrlObjectImageUrlDetail<'a> {
            Auto(#[allow(dead_code)] &'a MessageDeltaContentImageUrlObjectImageUrlDetailAuto),
            Low(#[allow(dead_code)] &'a MessageDeltaContentImageUrlObjectImageUrlDetailLow),
            High(#[allow(dead_code)] &'a MessageDeltaContentImageUrlObjectImageUrlDetailHigh),
        }
        match self {
            Self::Auto => {
                MessageDeltaContentImageUrlObjectImageUrlDetail::Auto(&Default::default())
                    .serialize(serializer)
            }
            Self::Low => MessageDeltaContentImageUrlObjectImageUrlDetail::Low(&Default::default())
                .serialize(serializer),
            Self::High => {
                MessageDeltaContentImageUrlObjectImageUrlDetail::High(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum MessageDeltaContentImageUrlObjectImageUrlDetail {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageUrlObjectImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentImageUrlObjectImageUrl {
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: Option<String>,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: Option<MessageDeltaContentImageUrlObjectImageUrlDetail>,
        }
        let MessageDeltaContentImageUrlObjectImageUrl { url, detail, .. } =
            MessageDeltaContentImageUrlObjectImageUrl::deserialize(deserializer)?;
        Ok(Self { url, detail })
    }
}
impl serde::Serialize for MessageDeltaContentImageUrlObjectImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentImageUrlObjectImageUrl<'a> {
            #[serde(rename = "url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            url: &'a Option<String>,
            #[serde(rename = "detail")]
            #[serde(skip_serializing_if = "Option::is_none")]
            detail: &'a Option<MessageDeltaContentImageUrlObjectImageUrlDetail>,
        }
        let Self { url, detail } = self;
        MessageDeltaContentImageUrlObjectImageUrl { url, detail }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageUrlObjectImageUrl {
    #[doc = "The URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp."]
    #[builder(default)]
    pub url: Option<String>,
    #[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
    #[builder(default)]
    pub detail: Option<MessageDeltaContentImageUrlObjectImageUrlDetail>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageUrlObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image_url`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentImageUrlObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentImageUrlObjectType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: Option<MessageDeltaContentImageUrlObjectImageUrl>,
        }
        let MessageDeltaContentImageUrlObject {
            index, image_url, ..
        } = MessageDeltaContentImageUrlObject::deserialize(deserializer)?;
        Ok(Self { index, image_url })
    }
}
impl serde::Serialize for MessageDeltaContentImageUrlObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image_url`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentImageUrlObjectType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentImageUrlObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentImageUrlObjectType,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<MessageDeltaContentImageUrlObjectImageUrl>,
        }
        let Self { index, image_url } = self;
        MessageDeltaContentImageUrlObject {
            index,
            type_: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[doc = "References an image URL in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageUrlObject {
    #[doc = "The index of the content part in the message."]
    pub index: u64,
    #[builder(default)]
    pub image_url: Option<MessageDeltaContentImageUrlObjectImageUrl>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentRefusalObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentRefusalObjectType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentRefusalObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentRefusalObjectType,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: Option<String>,
        }
        let MessageDeltaContentRefusalObject { index, refusal, .. } =
            MessageDeltaContentRefusalObject::deserialize(deserializer)?;
        Ok(Self { index, refusal })
    }
}
impl serde::Serialize for MessageDeltaContentRefusalObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentRefusalObjectType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentRefusalObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentRefusalObjectType,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
        }
        let Self { index, refusal } = self;
        MessageDeltaContentRefusalObject {
            index,
            type_: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "The refusal content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentRefusalObject {
    #[doc = "The index of the refusal part in the message."]
    pub index: u64,
    #[builder(default)]
    pub refusal: Option<String>,
}
impl<'de> serde::Deserialize<'de>
    for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "quote")]
            #[allow(dead_code)]
            quote: Option<String>,
        }
        let MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
            file_id, quote, ..
        } = MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation::deserialize(
            deserializer,
        )?;
        Ok(Self { file_id, quote })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "quote")]
            #[serde(skip_serializing_if = "Option::is_none")]
            quote: &'a Option<String>,
        }
        let Self { file_id, quote } = self;
        MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation { file_id, quote }
            .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation {
    #[doc = "The ID of the specific File the citation is from."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The specific quote in the file."]
    #[builder(default)]
    pub quote: Option<String>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextAnnotationsFileCitationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextAnnotationsFileCitationObjectType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextAnnotationsFileCitationObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentTextAnnotationsFileCitationObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "file_citation")]
            #[allow(dead_code)]
            file_citation: Option<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: Option<u64>,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: Option<u64>,
        }
        let MessageDeltaContentTextAnnotationsFileCitationObject {
            index,
            text,
            file_citation,
            start_index,
            end_index,
            ..
        } = MessageDeltaContentTextAnnotationsFileCitationObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            text,
            file_citation,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFileCitationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextAnnotationsFileCitationObjectType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextAnnotationsFileCitationObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentTextAnnotationsFileCitationObjectType,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "file_citation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_citation:
                &'a Option<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,
            #[serde(rename = "start_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            start_index: &'a Option<u64>,
            #[serde(rename = "end_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            end_index: &'a Option<u64>,
        }
        let Self {
            index,
            text,
            file_citation,
            start_index,
            end_index,
        } = self;
        MessageDeltaContentTextAnnotationsFileCitationObject {
            index,
            type_: &Default::default(),
            text,
            file_citation,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFileCitationObject {
    #[doc = "The index of the annotation in the text content part."]
    pub index: u64,
    #[doc = "The text in the message content that needs to be replaced."]
    #[builder(default)]
    pub text: Option<String>,
    #[builder(default)]
    pub file_citation: Option<MessageDeltaContentTextAnnotationsFileCitationObjectFileCitation>,
    #[builder(default)]
    pub start_index: Option<u64>,
    #[builder(default)]
    pub end_index: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let MessageDeltaContentTextAnnotationsFilePathObjectFilePath { file_id, .. } =
            MessageDeltaContentTextAnnotationsFilePathObjectFilePath::deserialize(deserializer)?;
        Ok(Self { file_id })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextAnnotationsFilePathObjectFilePath<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let Self { file_id } = self;
        MessageDeltaContentTextAnnotationsFilePathObjectFilePath { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFilePathObjectFilePath {
    #[doc = "The ID of the file that was generated."]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextAnnotationsFilePathObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `file_path`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextAnnotationsFilePathObjectType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextAnnotationsFilePathObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentTextAnnotationsFilePathObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "file_path")]
            #[allow(dead_code)]
            file_path: Option<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: Option<u64>,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: Option<u64>,
        }
        let MessageDeltaContentTextAnnotationsFilePathObject {
            index,
            text,
            file_path,
            start_index,
            end_index,
            ..
        } = MessageDeltaContentTextAnnotationsFilePathObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            text,
            file_path,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFilePathObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `file_path`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextAnnotationsFilePathObjectType {
            #[default]
            #[serde(rename = "file_path")]
            FilePath,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextAnnotationsFilePathObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentTextAnnotationsFilePathObjectType,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "file_path")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_path: &'a Option<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,
            #[serde(rename = "start_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            start_index: &'a Option<u64>,
            #[serde(rename = "end_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            end_index: &'a Option<u64>,
        }
        let Self {
            index,
            text,
            file_path,
            start_index,
            end_index,
        } = self;
        MessageDeltaContentTextAnnotationsFilePathObject {
            index,
            type_: &Default::default(),
            text,
            file_path,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFilePathObject {
    #[doc = "The index of the annotation in the text content part."]
    pub index: u64,
    #[doc = "The text in the message content that needs to be replaced."]
    #[builder(default)]
    pub text: Option<String>,
    #[builder(default)]
    pub file_path: Option<MessageDeltaContentTextAnnotationsFilePathObjectFilePath>,
    #[builder(default)]
    pub start_index: Option<u64>,
    #[builder(default)]
    pub end_index: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextObjectText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextObjectText {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: Option<String>,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Option<Vec<TextAnnotationDelta>>,
        }
        let MessageDeltaContentTextObjectText {
            value, annotations, ..
        } = MessageDeltaContentTextObjectText::deserialize(deserializer)?;
        Ok(Self { value, annotations })
    }
}
impl serde::Serialize for MessageDeltaContentTextObjectText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextObjectText<'a> {
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            value: &'a Option<String>,
            #[serde(rename = "annotations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            annotations: &'a Option<Vec<TextAnnotationDelta>>,
        }
        let Self { value, annotations } = self;
        MessageDeltaContentTextObjectText { value, annotations }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextObjectText {
    #[doc = "The data that makes up the text."]
    #[builder(default)]
    pub value: Option<String>,
    #[builder(default)]
    pub annotations: Option<Vec<TextAnnotationDelta>>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageDeltaContentTextObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<MessageDeltaContentTextObjectText>,
        }
        let MessageDeltaContentTextObject { index, text, .. } =
            MessageDeltaContentTextObject::deserialize(deserializer)?;
        Ok(Self { index, text })
    }
}
impl serde::Serialize for MessageDeltaContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a MessageDeltaContentTextObjectType,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<MessageDeltaContentTextObjectText>,
        }
        let Self { index, text } = self;
        MessageDeltaContentTextObject {
            index,
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextObject {
    #[doc = "The index of the content part in the message."]
    pub index: u64,
    #[builder(default)]
    pub text: Option<MessageDeltaContentTextObjectText>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaObjectDeltaRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectDeltaRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectDeltaRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageDeltaObjectDeltaRole {
            User(#[allow(dead_code)] MessageDeltaObjectDeltaRoleUser),
            Assistant(#[allow(dead_code)] MessageDeltaObjectDeltaRoleAssistant),
        }
        Ok(
            match MessageDeltaObjectDeltaRole::deserialize(deserializer)? {
                MessageDeltaObjectDeltaRole::User(_) => Self::User,
                MessageDeltaObjectDeltaRole::Assistant(_) => Self::Assistant,
            },
        )
    }
}
impl serde::Serialize for MessageDeltaObjectDeltaRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectDeltaRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectDeltaRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageDeltaObjectDeltaRole<'a> {
            User(#[allow(dead_code)] &'a MessageDeltaObjectDeltaRoleUser),
            Assistant(#[allow(dead_code)] &'a MessageDeltaObjectDeltaRoleAssistant),
        }
        match self {
            Self::User => {
                MessageDeltaObjectDeltaRole::User(&Default::default()).serialize(serializer)
            }
            Self::Assistant => {
                MessageDeltaObjectDeltaRole::Assistant(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The entity that produced the message. One of `user` or `assistant`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageDeltaObjectDeltaRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaObjectDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaObjectDelta {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<MessageDeltaObjectDeltaRole>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<MessageContentDelta>>,
        }
        let MessageDeltaObjectDelta { role, content, .. } =
            MessageDeltaObjectDelta::deserialize(deserializer)?;
        Ok(Self { role, content })
    }
}
impl serde::Serialize for MessageDeltaObjectDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaObjectDelta<'a> {
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<MessageDeltaObjectDeltaRole>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<MessageContentDelta>>,
        }
        let Self { role, content } = self;
        MessageDeltaObjectDelta { role, content }.serialize(serializer)
    }
}
#[doc = "The delta containing the fields that have changed on the Message."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageDeltaObjectDelta {
    #[doc = "The entity that produced the message. One of `user` or `assistant`."]
    #[builder(default)]
    pub role: Option<MessageDeltaObjectDeltaRole>,
    #[doc = "The content of the message in array of text and/or images."]
    #[builder(default)]
    pub content: Option<Vec<MessageContentDelta>>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.message.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectObject {
            #[default]
            #[serde(rename = "thread.message.delta")]
            ThreadMessageDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: MessageDeltaObjectObject,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: MessageDeltaObjectDelta,
        }
        let MessageDeltaObject { id, delta, .. } = MessageDeltaObject::deserialize(deserializer)?;
        Ok(Self { id, delta })
    }
}
impl serde::Serialize for MessageDeltaObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.message.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageDeltaObjectObject {
            #[default]
            #[serde(rename = "thread.message.delta")]
            ThreadMessageDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a MessageDeltaObjectObject,
            #[serde(rename = "delta")]
            delta: &'a MessageDeltaObjectDelta,
        }
        let Self { id, delta } = self;
        MessageDeltaObject {
            id,
            object: &Default::default(),
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a message delta i.e. any changed fields on a message during streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaObject {
    #[doc = "The identifier of the message, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The delta containing the fields that have changed on the Message."]
    #[builder(default)]
    pub delta: MessageDeltaObjectDelta,
}
impl<'de> serde::Deserialize<'de> for MessageObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageObjectStatus {
            InProgress(#[allow(dead_code)] MessageObjectStatusInProgress),
            Incomplete(#[allow(dead_code)] MessageObjectStatusIncomplete),
            Completed(#[allow(dead_code)] MessageObjectStatusCompleted),
        }
        Ok(match MessageObjectStatus::deserialize(deserializer)? {
            MessageObjectStatus::InProgress(_) => Self::InProgress,
            MessageObjectStatus::Incomplete(_) => Self::Incomplete,
            MessageObjectStatus::Completed(_) => Self::Completed,
        })
    }
}
impl serde::Serialize for MessageObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageObjectStatus<'a> {
            InProgress(#[allow(dead_code)] &'a MessageObjectStatusInProgress),
            Incomplete(#[allow(dead_code)] &'a MessageObjectStatusIncomplete),
            Completed(#[allow(dead_code)] &'a MessageObjectStatusCompleted),
        }
        match self {
            Self::InProgress => {
                MessageObjectStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                MessageObjectStatus::Incomplete(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                MessageObjectStatus::Completed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the message, which can be either `in_progress`, `incomplete`, or `completed`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "incomplete"]
    Incomplete,
    #[doc = "completed"]
    Completed,
}
impl<'de> serde::Deserialize<'de> for MessageObjectIncompleteDetailsReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonMaxTokens {
            #[default]
            #[serde(rename = "max_tokens")]
            MaxTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunCancelled {
            #[default]
            #[serde(rename = "run_cancelled")]
            RunCancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunExpired {
            #[default]
            #[serde(rename = "run_expired")]
            RunExpired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunFailed {
            #[default]
            #[serde(rename = "run_failed")]
            RunFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageObjectIncompleteDetailsReason {
            ContentFilter(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonContentFilter),
            MaxTokens(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonMaxTokens),
            RunCancelled(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonRunCancelled),
            RunExpired(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonRunExpired),
            RunFailed(#[allow(dead_code)] MessageObjectIncompleteDetailsReasonRunFailed),
        }
        Ok(
            match MessageObjectIncompleteDetailsReason::deserialize(deserializer)? {
                MessageObjectIncompleteDetailsReason::ContentFilter(_) => Self::ContentFilter,
                MessageObjectIncompleteDetailsReason::MaxTokens(_) => Self::MaxTokens,
                MessageObjectIncompleteDetailsReason::RunCancelled(_) => Self::RunCancelled,
                MessageObjectIncompleteDetailsReason::RunExpired(_) => Self::RunExpired,
                MessageObjectIncompleteDetailsReason::RunFailed(_) => Self::RunFailed,
            },
        )
    }
}
impl serde::Serialize for MessageObjectIncompleteDetailsReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonMaxTokens {
            #[default]
            #[serde(rename = "max_tokens")]
            MaxTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunCancelled {
            #[default]
            #[serde(rename = "run_cancelled")]
            RunCancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunExpired {
            #[default]
            #[serde(rename = "run_expired")]
            RunExpired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectIncompleteDetailsReasonRunFailed {
            #[default]
            #[serde(rename = "run_failed")]
            RunFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageObjectIncompleteDetailsReason<'a> {
            ContentFilter(
                #[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonContentFilter,
            ),
            MaxTokens(#[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonMaxTokens),
            RunCancelled(#[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonRunCancelled),
            RunExpired(#[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonRunExpired),
            RunFailed(#[allow(dead_code)] &'a MessageObjectIncompleteDetailsReasonRunFailed),
        }
        match self {
            Self::ContentFilter => {
                MessageObjectIncompleteDetailsReason::ContentFilter(&Default::default())
                    .serialize(serializer)
            }
            Self::MaxTokens => MessageObjectIncompleteDetailsReason::MaxTokens(&Default::default())
                .serialize(serializer),
            Self::RunCancelled => {
                MessageObjectIncompleteDetailsReason::RunCancelled(&Default::default())
                    .serialize(serializer)
            }
            Self::RunExpired => {
                MessageObjectIncompleteDetailsReason::RunExpired(&Default::default())
                    .serialize(serializer)
            }
            Self::RunFailed => MessageObjectIncompleteDetailsReason::RunFailed(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The reason the message is incomplete."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectIncompleteDetailsReason {
    #[doc = "content_filter"]
    ContentFilter,
    #[doc = "max_tokens"]
    MaxTokens,
    #[doc = "run_cancelled"]
    RunCancelled,
    #[doc = "run_expired"]
    RunExpired,
    #[doc = "run_failed"]
    RunFailed,
}
impl<'de> serde::Deserialize<'de> for MessageObjectIncompleteDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageObjectIncompleteDetails {
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: MessageObjectIncompleteDetailsReason,
        }
        let MessageObjectIncompleteDetails { reason, .. } =
            MessageObjectIncompleteDetails::deserialize(deserializer)?;
        Ok(Self { reason })
    }
}
impl serde::Serialize for MessageObjectIncompleteDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageObjectIncompleteDetails<'a> {
            #[serde(rename = "reason")]
            reason: &'a MessageObjectIncompleteDetailsReason,
        }
        let Self { reason } = self;
        MessageObjectIncompleteDetails { reason }.serialize(serializer)
    }
}
#[doc = "On an incomplete message, details about why the message is incomplete."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct MessageObjectIncompleteDetails {
    #[doc = "The reason the message is incomplete."]
    pub reason: MessageObjectIncompleteDetailsReason,
}
impl<'de> serde::Deserialize<'de> for MessageObjectRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageObjectRole {
            User(#[allow(dead_code)] MessageObjectRoleUser),
            Assistant(#[allow(dead_code)] MessageObjectRoleAssistant),
        }
        Ok(match MessageObjectRole::deserialize(deserializer)? {
            MessageObjectRole::User(_) => Self::User,
            MessageObjectRole::Assistant(_) => Self::Assistant,
        })
    }
}
impl serde::Serialize for MessageObjectRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageObjectRole<'a> {
            User(#[allow(dead_code)] &'a MessageObjectRoleUser),
            Assistant(#[allow(dead_code)] &'a MessageObjectRoleAssistant),
        }
        match self {
            Self::User => MessageObjectRole::User(&Default::default()).serialize(serializer),
            Self::Assistant => {
                MessageObjectRole::Assistant(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The entity that produced the message. One of `user` or `assistant`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
}
impl<'de> serde::Deserialize<'de> for MessageObjectAttachmentsTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageObjectAttachmentsTool {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearchTypeOnly),
        }
        Ok(
            match MessageObjectAttachmentsTool::deserialize(deserializer)? {
                MessageObjectAttachmentsTool::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
                MessageObjectAttachmentsTool::FileSearch(_v) => Self::FileSearch(_v),
            },
        )
    }
}
impl serde::Serialize for MessageObjectAttachmentsTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageObjectAttachmentsTool<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearchTypeOnly),
        }
        match self {
            Self::CodeInterpreter(_v) => {
                MessageObjectAttachmentsTool::CodeInterpreter(_v).serialize(serializer)
            }
            Self::FileSearch(_v) => {
                MessageObjectAttachmentsTool::FileSearch(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum MessageObjectAttachmentsTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearchTypeOnly),
}
impl<'de> serde::Deserialize<'de> for MessageObjectAttachments {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageObjectAttachments {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<MessageObjectAttachmentsTool>>,
        }
        let MessageObjectAttachments { file_id, tools, .. } =
            MessageObjectAttachments::deserialize(deserializer)?;
        Ok(Self { file_id, tools })
    }
}
impl serde::Serialize for MessageObjectAttachments {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageObjectAttachments<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<MessageObjectAttachmentsTool>>,
        }
        let Self { file_id, tools } = self;
        MessageObjectAttachments { file_id, tools }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct MessageObjectAttachments {
    #[doc = "The ID of the file to attach to the message."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The tools to add this file to."]
    #[builder(default)]
    pub tools: Option<Vec<MessageObjectAttachmentsTool>>,
}
impl<'de> serde::Deserialize<'de> for MessageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.message`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectObject {
            #[default]
            #[serde(rename = "thread.message")]
            ThreadMessage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: MessageObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "thread_id")]
            #[allow(dead_code)]
            thread_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: MessageObjectStatus,
            #[serde(rename = "incomplete_details")]
            #[allow(dead_code)]
            incomplete_details: Option<MessageObjectIncompleteDetails>,
            #[serde(rename = "completed_at")]
            #[allow(dead_code)]
            completed_at: Option<u64>,
            #[serde(rename = "incomplete_at")]
            #[allow(dead_code)]
            incomplete_at: Option<u64>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: MessageObjectRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Vec<MessageContent>,
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: Option<String>,
            #[serde(rename = "run_id")]
            #[allow(dead_code)]
            run_id: Option<String>,
            #[serde(rename = "attachments")]
            #[allow(dead_code)]
            attachments: Option<Vec<MessageObjectAttachments>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let MessageObject {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
            ..
        } = MessageObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        })
    }
}
impl serde::Serialize for MessageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.message`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageObjectObject {
            #[default]
            #[serde(rename = "thread.message")]
            ThreadMessage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a MessageObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "status")]
            status: &'a MessageObjectStatus,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<MessageObjectIncompleteDetails>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<u64>,
            #[serde(rename = "incomplete_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_at: &'a Option<u64>,
            #[serde(rename = "role")]
            role: &'a MessageObjectRole,
            #[serde(rename = "content")]
            content: &'a Vec<MessageContent>,
            #[serde(rename = "assistant_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            assistant_id: &'a Option<String>,
            #[serde(rename = "run_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            run_id: &'a Option<String>,
            #[serde(rename = "attachments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attachments: &'a Option<Vec<MessageObjectAttachments>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        } = self;
        MessageObject {
            id,
            object: &Default::default(),
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a message within a [thread](https://platform.openai.com/docs/api-reference/threads)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the message was created."]
    pub created_at: u64,
    #[doc = "The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to."]
    pub thread_id: String,
    #[doc = "The status of the message, which can be either `in_progress`, `incomplete`, or `completed`."]
    pub status: MessageObjectStatus,
    #[doc = "On an incomplete message, details about why the message is incomplete."]
    #[builder(default)]
    pub incomplete_details: Option<MessageObjectIncompleteDetails>,
    #[doc = "The Unix timestamp (in seconds) for when the message was completed."]
    #[builder(default)]
    pub completed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the message was marked as incomplete."]
    #[builder(default)]
    pub incomplete_at: Option<u64>,
    #[doc = "The entity that produced the message. One of `user` or `assistant`."]
    pub role: MessageObjectRole,
    #[doc = "The content of the message in array of text and/or images."]
    pub content: Vec<MessageContent>,
    #[doc = "If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message."]
    #[builder(default)]
    pub assistant_id: Option<String>,
    #[doc = "The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints."]
    #[builder(default)]
    pub run_id: Option<String>,
    #[doc = "A list of files attached to the message, and the tools they were added to."]
    #[builder(default)]
    pub attachments: Option<Vec<MessageObjectAttachments>>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for MessageRequestContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageRequestContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageRequestContentTextObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MessageRequestContentTextObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let MessageRequestContentTextObject { text, .. } =
            MessageRequestContentTextObject::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for MessageRequestContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageRequestContentTextObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageRequestContentTextObject<'a> {
            #[serde(rename = "type")]
            type_: &'a MessageRequestContentTextObjectType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        MessageRequestContentTextObject {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageRequestContentTextObject {
    #[doc = "Text content to be sent to the model"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageCreatedEvent {
            #[default]
            #[serde(rename = "thread.message.created")]
            ThreadMessageCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageStreamEventThreadMessageCreated {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageCreatedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageObject,
        }
        let MessageStreamEventThreadMessageCreated { data, .. } =
            MessageStreamEventThreadMessageCreated::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageCreatedEvent {
            #[default]
            #[serde(rename = "thread.message.created")]
            ThreadMessageCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageStreamEventThreadMessageCreated<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageCreatedEvent,
            #[serde(rename = "data")]
            data: &'a MessageObject,
        }
        let Self { data } = self;
        MessageStreamEventThreadMessageCreated {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is created."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageCreated {
    pub data: MessageObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageInProgress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageInProgressEvent {
            #[default]
            #[serde(rename = "thread.message.in_progress")]
            ThreadMessageInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageStreamEventThreadMessageInProgress {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageInProgressEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageObject,
        }
        let MessageStreamEventThreadMessageInProgress { data, .. } =
            MessageStreamEventThreadMessageInProgress::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageInProgress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageInProgressEvent {
            #[default]
            #[serde(rename = "thread.message.in_progress")]
            ThreadMessageInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageStreamEventThreadMessageInProgress<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageInProgressEvent,
            #[serde(rename = "data")]
            data: &'a MessageObject,
        }
        let Self { data } = self;
        MessageStreamEventThreadMessageInProgress {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) moves to an `in_progress` state."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageInProgress {
    pub data: MessageObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageDeltaEvent {
            #[default]
            #[serde(rename = "thread.message.delta")]
            ThreadMessageDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageStreamEventThreadMessageDelta {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageDeltaEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageDeltaObject,
        }
        let MessageStreamEventThreadMessageDelta { data, .. } =
            MessageStreamEventThreadMessageDelta::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageDeltaEvent {
            #[default]
            #[serde(rename = "thread.message.delta")]
            ThreadMessageDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageStreamEventThreadMessageDelta<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageDeltaEvent,
            #[serde(rename = "data")]
            data: &'a MessageDeltaObject,
        }
        let Self { data } = self;
        MessageStreamEventThreadMessageDelta {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when parts of a [Message](https://platform.openai.com/docs/api-reference/messages/object) are being streamed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageDelta {
    pub data: MessageDeltaObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageCompleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageCompletedEvent {
            #[default]
            #[serde(rename = "thread.message.completed")]
            ThreadMessageCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageStreamEventThreadMessageCompleted {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageCompletedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageObject,
        }
        let MessageStreamEventThreadMessageCompleted { data, .. } =
            MessageStreamEventThreadMessageCompleted::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageCompletedEvent {
            #[default]
            #[serde(rename = "thread.message.completed")]
            ThreadMessageCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageStreamEventThreadMessageCompleted<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageCompletedEvent,
            #[serde(rename = "data")]
            data: &'a MessageObject,
        }
        let Self { data } = self;
        MessageStreamEventThreadMessageCompleted {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageCompleted {
    pub data: MessageObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEventThreadMessageIncomplete {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageIncompleteEvent {
            #[default]
            #[serde(rename = "thread.message.incomplete")]
            ThreadMessageIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageStreamEventThreadMessageIncomplete {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: MessageStreamEventThreadMessageIncompleteEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: MessageObject,
        }
        let MessageStreamEventThreadMessageIncomplete { data, .. } =
            MessageStreamEventThreadMessageIncomplete::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for MessageStreamEventThreadMessageIncomplete {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MessageStreamEventThreadMessageIncompleteEvent {
            #[default]
            #[serde(rename = "thread.message.incomplete")]
            ThreadMessageIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageStreamEventThreadMessageIncomplete<'a> {
            #[serde(rename = "event")]
            event: &'a MessageStreamEventThreadMessageIncompleteEvent,
            #[serde(rename = "data")]
            data: &'a MessageObject,
        }
        let Self { data } = self;
        MessageStreamEventThreadMessageIncomplete {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) ends before it is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageStreamEventThreadMessageIncomplete {
    pub data: MessageObject,
}
impl<'de> serde::Deserialize<'de> for MessageStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageStreamEvent {
            ThreadMessageCreated(#[allow(dead_code)] MessageStreamEventThreadMessageCreated),
            ThreadMessageInProgress(#[allow(dead_code)] MessageStreamEventThreadMessageInProgress),
            ThreadMessageDelta(#[allow(dead_code)] MessageStreamEventThreadMessageDelta),
            ThreadMessageCompleted(#[allow(dead_code)] MessageStreamEventThreadMessageCompleted),
            ThreadMessageIncomplete(#[allow(dead_code)] MessageStreamEventThreadMessageIncomplete),
        }
        Ok(match MessageStreamEvent::deserialize(deserializer)? {
            MessageStreamEvent::ThreadMessageCreated(_v) => Self::ThreadMessageCreated(_v),
            MessageStreamEvent::ThreadMessageInProgress(_v) => Self::ThreadMessageInProgress(_v),
            MessageStreamEvent::ThreadMessageDelta(_v) => Self::ThreadMessageDelta(_v),
            MessageStreamEvent::ThreadMessageCompleted(_v) => Self::ThreadMessageCompleted(_v),
            MessageStreamEvent::ThreadMessageIncomplete(_v) => Self::ThreadMessageIncomplete(_v),
        })
    }
}
impl serde::Serialize for MessageStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageStreamEvent<'a> {
            ThreadMessageCreated(#[allow(dead_code)] &'a MessageStreamEventThreadMessageCreated),
            ThreadMessageInProgress(
                #[allow(dead_code)] &'a MessageStreamEventThreadMessageInProgress,
            ),
            ThreadMessageDelta(#[allow(dead_code)] &'a MessageStreamEventThreadMessageDelta),
            ThreadMessageCompleted(
                #[allow(dead_code)] &'a MessageStreamEventThreadMessageCompleted,
            ),
            ThreadMessageIncomplete(
                #[allow(dead_code)] &'a MessageStreamEventThreadMessageIncomplete,
            ),
        }
        match self {
            Self::ThreadMessageCreated(_v) => {
                MessageStreamEvent::ThreadMessageCreated(_v).serialize(serializer)
            }
            Self::ThreadMessageInProgress(_v) => {
                MessageStreamEvent::ThreadMessageInProgress(_v).serialize(serializer)
            }
            Self::ThreadMessageDelta(_v) => {
                MessageStreamEvent::ThreadMessageDelta(_v).serialize(serializer)
            }
            Self::ThreadMessageCompleted(_v) => {
                MessageStreamEvent::ThreadMessageCompleted(_v).serialize(serializer)
            }
            Self::ThreadMessageIncomplete(_v) => {
                MessageStreamEvent::ThreadMessageIncomplete(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum MessageStreamEvent {
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is created."]
    ThreadMessageCreated(MessageStreamEventThreadMessageCreated),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) moves to an `in_progress` state."]
    ThreadMessageInProgress(MessageStreamEventThreadMessageInProgress),
    #[doc = "Occurs when parts of a [Message](https://platform.openai.com/docs/api-reference/messages/object) are being streamed."]
    ThreadMessageDelta(MessageStreamEventThreadMessageDelta),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is completed."]
    ThreadMessageCompleted(MessageStreamEventThreadMessageCompleted),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) ends before it is completed."]
    ThreadMessageIncomplete(MessageStreamEventThreadMessageIncomplete),
}
#[doc = "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. \n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"]
pub type Metadata = std::collections::HashMap<String, String>;
impl<'de> serde::Deserialize<'de> for Model {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"model\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelObject {
            #[default]
            #[serde(rename = "model")]
            Model,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Model {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created")]
            #[allow(dead_code)]
            created: u64,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ModelObject,
            #[serde(rename = "owned_by")]
            #[allow(dead_code)]
            owned_by: String,
        }
        let Model {
            id,
            created,
            owned_by,
            ..
        } = Model::deserialize(deserializer)?;
        Ok(Self {
            id,
            created,
            owned_by,
        })
    }
}
impl serde::Serialize for Model {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"model\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelObject {
            #[default]
            #[serde(rename = "model")]
            Model,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Model<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created")]
            created: &'a u64,
            #[serde(rename = "object")]
            object: &'a ModelObject,
            #[serde(rename = "owned_by")]
            owned_by: &'a String,
        }
        let Self {
            id,
            created,
            owned_by,
        } = self;
        Model {
            id,
            created,
            object: &Default::default(),
            owned_by,
        }
        .serialize(serializer)
    }
}
#[doc = "Describes an OpenAI model offering that can be used with the API."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Model {
    #[doc = "The model identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) when the model was created."]
    pub created: u64,
    #[doc = "The organization that owns the model."]
    pub owned_by: String,
}
impl<'de> serde::Deserialize<'de> for ModelIds {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ModelIds {
            ModelIdsShared(#[allow(dead_code)] ModelIdsShared),
            ModelIdsResponses(#[allow(dead_code)] ModelIdsResponses),
        }
        Ok(match ModelIds::deserialize(deserializer)? {
            ModelIds::ModelIdsShared(_v) => Self::ModelIdsShared(_v),
            ModelIds::ModelIdsResponses(_v) => Self::ModelIdsResponses(_v),
        })
    }
}
impl serde::Serialize for ModelIds {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ModelIds<'a> {
            ModelIdsShared(#[allow(dead_code)] &'a ModelIdsShared),
            ModelIdsResponses(#[allow(dead_code)] &'a ModelIdsResponses),
        }
        match self {
            Self::ModelIdsShared(_v) => ModelIds::ModelIdsShared(_v).serialize(serializer),
            Self::ModelIdsResponses(_v) => ModelIds::ModelIdsResponses(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIds {
    ModelIdsShared(ModelIdsShared),
    ModelIdsResponses(ModelIdsResponses),
}
impl<'de> serde::Deserialize<'de> for ModelIdsResponses {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO1Pro {
            #[default]
            #[serde(rename = "o1-pro")]
            O1Pro,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO1Pro2025_03_19 {
            #[default]
            #[serde(rename = "o1-pro-2025-03-19")]
            O1Pro2025_03_19,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO3Pro {
            #[default]
            #[serde(rename = "o3-pro")]
            O3Pro,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO3Pro2025_06_10 {
            #[default]
            #[serde(rename = "o3-pro-2025-06-10")]
            O3Pro2025_06_10,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesComputerUsePreview {
            #[default]
            #[serde(rename = "computer-use-preview")]
            ComputerUsePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesComputerUsePreview2025_03_11 {
            #[default]
            #[serde(rename = "computer-use-preview-2025-03-11")]
            ComputerUsePreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ModelIdsResponses {
            O1Pro(#[allow(dead_code)] ModelIdsResponsesO1Pro),
            O1Pro2025_03_19(#[allow(dead_code)] ModelIdsResponsesO1Pro2025_03_19),
            O3Pro(#[allow(dead_code)] ModelIdsResponsesO3Pro),
            O3Pro2025_06_10(#[allow(dead_code)] ModelIdsResponsesO3Pro2025_06_10),
            ComputerUsePreview(#[allow(dead_code)] ModelIdsResponsesComputerUsePreview),
            ComputerUsePreview2025_03_11(
                #[allow(dead_code)] ModelIdsResponsesComputerUsePreview2025_03_11,
            ),
            ModelIdsShared(#[allow(dead_code)] ModelIdsShared),
        }
        Ok(match ModelIdsResponses::deserialize(deserializer)? {
            ModelIdsResponses::ModelIdsShared(_v) => Self::ModelIdsShared(_v),
            ModelIdsResponses::O1Pro(_) => Self::O1Pro,
            ModelIdsResponses::O1Pro2025_03_19(_) => Self::O1Pro2025_03_19,
            ModelIdsResponses::O3Pro(_) => Self::O3Pro,
            ModelIdsResponses::O3Pro2025_06_10(_) => Self::O3Pro2025_06_10,
            ModelIdsResponses::ComputerUsePreview(_) => Self::ComputerUsePreview,
            ModelIdsResponses::ComputerUsePreview2025_03_11(_) => {
                Self::ComputerUsePreview2025_03_11
            }
        })
    }
}
impl serde::Serialize for ModelIdsResponses {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO1Pro {
            #[default]
            #[serde(rename = "o1-pro")]
            O1Pro,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO1Pro2025_03_19 {
            #[default]
            #[serde(rename = "o1-pro-2025-03-19")]
            O1Pro2025_03_19,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO3Pro {
            #[default]
            #[serde(rename = "o3-pro")]
            O3Pro,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesO3Pro2025_06_10 {
            #[default]
            #[serde(rename = "o3-pro-2025-06-10")]
            O3Pro2025_06_10,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesComputerUsePreview {
            #[default]
            #[serde(rename = "computer-use-preview")]
            ComputerUsePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModelIdsResponsesComputerUsePreview2025_03_11 {
            #[default]
            #[serde(rename = "computer-use-preview-2025-03-11")]
            ComputerUsePreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ModelIdsResponses<'a> {
            ModelIdsShared(#[allow(dead_code)] &'a ModelIdsShared),
            O1Pro(#[allow(dead_code)] &'a ModelIdsResponsesO1Pro),
            O1Pro2025_03_19(#[allow(dead_code)] &'a ModelIdsResponsesO1Pro2025_03_19),
            O3Pro(#[allow(dead_code)] &'a ModelIdsResponsesO3Pro),
            O3Pro2025_06_10(#[allow(dead_code)] &'a ModelIdsResponsesO3Pro2025_06_10),
            ComputerUsePreview(#[allow(dead_code)] &'a ModelIdsResponsesComputerUsePreview),
            ComputerUsePreview2025_03_11(
                #[allow(dead_code)] &'a ModelIdsResponsesComputerUsePreview2025_03_11,
            ),
        }
        match self {
            Self::ModelIdsShared(_v) => ModelIdsResponses::ModelIdsShared(_v).serialize(serializer),
            Self::O1Pro => ModelIdsResponses::O1Pro(&Default::default()).serialize(serializer),
            Self::O1Pro2025_03_19 => {
                ModelIdsResponses::O1Pro2025_03_19(&Default::default()).serialize(serializer)
            }
            Self::O3Pro => ModelIdsResponses::O3Pro(&Default::default()).serialize(serializer),
            Self::O3Pro2025_06_10 => {
                ModelIdsResponses::O3Pro2025_06_10(&Default::default()).serialize(serializer)
            }
            Self::ComputerUsePreview => {
                ModelIdsResponses::ComputerUsePreview(&Default::default()).serialize(serializer)
            }
            Self::ComputerUsePreview2025_03_11 => {
                ModelIdsResponses::ComputerUsePreview2025_03_11(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIdsResponses {
    ModelIdsShared(ModelIdsShared),
    #[doc = "o1-pro"]
    O1Pro,
    #[doc = "o1-pro-2025-03-19"]
    O1Pro2025_03_19,
    #[doc = "o3-pro"]
    O3Pro,
    #[doc = "o3-pro-2025-06-10"]
    O3Pro2025_06_10,
    #[doc = "computer-use-preview"]
    ComputerUsePreview,
    #[doc = "computer-use-preview-2025-03-11"]
    ComputerUsePreview2025_03_11,
}
impl<'de> serde::Deserialize<'de> for ModelIdsShared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ModelIdsShared {
            ChatModel(#[allow(dead_code)] ChatModel),
            Other(#[allow(dead_code)] String),
        }
        Ok(match ModelIdsShared::deserialize(deserializer)? {
            ModelIdsShared::Other(_v) => Self::Other(_v),
            ModelIdsShared::ChatModel(_v) => Self::ChatModel(_v),
        })
    }
}
impl serde::Serialize for ModelIdsShared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ModelIdsShared<'a> {
            Other(#[allow(dead_code)] &'a String),
            ChatModel(#[allow(dead_code)] &'a ChatModel),
        }
        match self {
            Self::Other(_v) => ModelIdsShared::Other(_v).serialize(serializer),
            Self::ChatModel(_v) => ModelIdsShared::ChatModel(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIdsShared {
    Other(String),
    ChatModel(ChatModel),
}
impl<'de> serde::Deserialize<'de> for ModelResponseProperties {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModelResponseProperties {
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<String>,
            #[serde(rename = "service_tier")]
            #[allow(dead_code)]
            service_tier: Option<ServiceTier>,
        }
        let ModelResponseProperties {
            metadata,
            temperature,
            top_p,
            user,
            service_tier,
            ..
        } = ModelResponseProperties::deserialize(deserializer)?;
        Ok(Self {
            metadata,
            temperature,
            top_p,
            user,
            service_tier,
        })
    }
}
impl serde::Serialize for ModelResponseProperties {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModelResponseProperties<'a> {
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<ServiceTier>,
        }
        let Self {
            metadata,
            temperature,
            top_p,
            user,
            service_tier,
        } = self;
        ModelResponseProperties {
            metadata,
            temperature,
            top_p,
            user,
            service_tier,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModelResponseProperties {
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "A stable identifier for your end-users. \nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[builder(default)]
    pub user: Option<String>,
    #[builder(default)]
    pub service_tier: Option<ServiceTier>,
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ModifyAssistantRequestModel {
            AssistantSupportedModels(#[allow(dead_code)] AssistantSupportedModels),
            Other(#[allow(dead_code)] String),
        }
        Ok(
            match ModifyAssistantRequestModel::deserialize(deserializer)? {
                ModifyAssistantRequestModel::Other(_v) => Self::Other(_v),
                ModifyAssistantRequestModel::AssistantSupportedModels(_v) => {
                    Self::AssistantSupportedModels(_v)
                }
            },
        )
    }
}
impl serde::Serialize for ModifyAssistantRequestModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ModifyAssistantRequestModel<'a> {
            Other(#[allow(dead_code)] &'a String),
            AssistantSupportedModels(#[allow(dead_code)] &'a AssistantSupportedModels),
        }
        match self {
            Self::Other(_v) => ModifyAssistantRequestModel::Other(_v).serialize(serializer),
            Self::AssistantSupportedModels(_v) => {
                ModifyAssistantRequestModel::AssistantSupportedModels(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModifyAssistantRequestModel {
    Other(String),
    AssistantSupportedModels(AssistantSupportedModels),
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyAssistantRequestToolResourcesCodeInterpreter {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let ModifyAssistantRequestToolResourcesCodeInterpreter { file_ids, .. } =
            ModifyAssistantRequestToolResourcesCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for ModifyAssistantRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyAssistantRequestToolResourcesCodeInterpreter<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        ModifyAssistantRequestToolResourcesCodeInterpreter { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequestToolResourcesCodeInterpreter {
    #[doc = "Overrides the list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyAssistantRequestToolResourcesFileSearch {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let ModifyAssistantRequestToolResourcesFileSearch {
            vector_store_ids, ..
        } = ModifyAssistantRequestToolResourcesFileSearch::deserialize(deserializer)?;
        Ok(Self { vector_store_ids })
    }
}
impl serde::Serialize for ModifyAssistantRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyAssistantRequestToolResourcesFileSearch<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let Self { vector_store_ids } = self;
        ModifyAssistantRequestToolResourcesFileSearch { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequestToolResourcesFileSearch {
    #[doc = "Overrides the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyAssistantRequestToolResources {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<ModifyAssistantRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<ModifyAssistantRequestToolResourcesFileSearch>,
        }
        let ModifyAssistantRequestToolResources {
            code_interpreter,
            file_search,
            ..
        } = ModifyAssistantRequestToolResources::deserialize(deserializer)?;
        Ok(Self {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for ModifyAssistantRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyAssistantRequestToolResources<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<ModifyAssistantRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<ModifyAssistantRequestToolResourcesFileSearch>,
        }
        let Self {
            code_interpreter,
            file_search,
        } = self;
        ModifyAssistantRequestToolResources {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<ModifyAssistantRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<ModifyAssistantRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for ModifyAssistantRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyAssistantRequest {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<ModifyAssistantRequestModel>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<AssistantTool>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<ModifyAssistantRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let ModifyAssistantRequest {
            model,
            reasoning_effort,
            name,
            description,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
            ..
        } = ModifyAssistantRequest::deserialize(deserializer)?;
        Ok(Self {
            model,
            reasoning_effort,
            name,
            description,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        })
    }
}
impl serde::Serialize for ModifyAssistantRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyAssistantRequest<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<ModifyAssistantRequestModel>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<AssistantTool>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<ModifyAssistantRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let Self {
            model,
            reasoning_effort,
            name,
            description,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        } = self;
        ModifyAssistantRequest {
            model,
            reasoning_effort,
            name,
            description,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[builder(default)]
    pub model: Option<ModifyAssistantRequestModel>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    #[builder(default)]
    pub tools: Option<Vec<AssistantTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<ModifyAssistantRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for ModifyCertificateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyCertificateRequest {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ModifyCertificateRequest { name, .. } =
            ModifyCertificateRequest::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ModifyCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyCertificateRequest<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ModifyCertificateRequest { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ModifyCertificateRequest {
    #[doc = "The updated name for the certificate"]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ModifyMessageRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyMessageRequest {
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let ModifyMessageRequest { metadata, .. } =
            ModifyMessageRequest::deserialize(deserializer)?;
        Ok(Self { metadata })
    }
}
impl serde::Serialize for ModifyMessageRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyMessageRequest<'a> {
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self { metadata } = self;
        ModifyMessageRequest { metadata }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyMessageRequest {
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for ModifyRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyRunRequest {
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let ModifyRunRequest { metadata, .. } = ModifyRunRequest::deserialize(deserializer)?;
        Ok(Self { metadata })
    }
}
impl serde::Serialize for ModifyRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyRunRequest<'a> {
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self { metadata } = self;
        ModifyRunRequest { metadata }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyRunRequest {
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for ModifyThreadRequestToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyThreadRequestToolResourcesCodeInterpreter {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let ModifyThreadRequestToolResourcesCodeInterpreter { file_ids, .. } =
            ModifyThreadRequestToolResourcesCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for ModifyThreadRequestToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyThreadRequestToolResourcesCodeInterpreter<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        ModifyThreadRequestToolResourcesCodeInterpreter { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequestToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ModifyThreadRequestToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyThreadRequestToolResourcesFileSearch {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let ModifyThreadRequestToolResourcesFileSearch {
            vector_store_ids, ..
        } = ModifyThreadRequestToolResourcesFileSearch::deserialize(deserializer)?;
        Ok(Self { vector_store_ids })
    }
}
impl serde::Serialize for ModifyThreadRequestToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyThreadRequestToolResourcesFileSearch<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let Self { vector_store_ids } = self;
        ModifyThreadRequestToolResourcesFileSearch { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequestToolResourcesFileSearch {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ModifyThreadRequestToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyThreadRequestToolResources {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<ModifyThreadRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<ModifyThreadRequestToolResourcesFileSearch>,
        }
        let ModifyThreadRequestToolResources {
            code_interpreter,
            file_search,
            ..
        } = ModifyThreadRequestToolResources::deserialize(deserializer)?;
        Ok(Self {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for ModifyThreadRequestToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyThreadRequestToolResources<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<ModifyThreadRequestToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<ModifyThreadRequestToolResourcesFileSearch>,
        }
        let Self {
            code_interpreter,
            file_search,
        } = self;
        ModifyThreadRequestToolResources {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequestToolResources {
    #[builder(default)]
    pub code_interpreter: Option<ModifyThreadRequestToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<ModifyThreadRequestToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for ModifyThreadRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModifyThreadRequest {
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<ModifyThreadRequestToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let ModifyThreadRequest {
            tool_resources,
            metadata,
            ..
        } = ModifyThreadRequest::deserialize(deserializer)?;
        Ok(Self {
            tool_resources,
            metadata,
        })
    }
}
impl serde::Serialize for ModifyThreadRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModifyThreadRequest<'a> {
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<ModifyThreadRequestToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            tool_resources,
            metadata,
        } = self;
        ModifyThreadRequest {
            tool_resources,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequest {
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<ModifyThreadRequestToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for Move {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a move action, this property is \nalways set to `move`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MoveType {
            #[default]
            #[serde(rename = "move")]
            Move,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Move {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: MoveType,
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
        }
        let Move { x, y, .. } = Move::deserialize(deserializer)?;
        Ok(Self { x, y })
    }
}
impl serde::Serialize for Move {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a move action, this property is \nalways set to `move`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum MoveType {
            #[default]
            #[serde(rename = "move")]
            Move,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Move<'a> {
            #[serde(rename = "type")]
            type_: &'a MoveType,
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
        }
        let Self { x, y } = self;
        Move {
            type_: &Default::default(),
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[doc = "A mouse move action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct Move {
    #[doc = "The x-coordinate to move to.\n"]
    pub x: u64,
    #[doc = "The y-coordinate to move to.\n"]
    pub y: u64,
}
impl<'de> serde::Deserialize<'de> for OpenAiFilePurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeAssistantsOutput {
            #[default]
            #[serde(rename = "assistants_output")]
            AssistantsOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeBatchOutput {
            #[default]
            #[serde(rename = "batch_output")]
            BatchOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeFineTuneResults {
            #[default]
            #[serde(rename = "fine-tune-results")]
            FineTuneResults,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum OpenAiFilePurpose {
            Assistants(#[allow(dead_code)] OpenAiFilePurposeAssistants),
            AssistantsOutput(#[allow(dead_code)] OpenAiFilePurposeAssistantsOutput),
            Batch(#[allow(dead_code)] OpenAiFilePurposeBatch),
            BatchOutput(#[allow(dead_code)] OpenAiFilePurposeBatchOutput),
            FineTune(#[allow(dead_code)] OpenAiFilePurposeFineTune),
            FineTuneResults(#[allow(dead_code)] OpenAiFilePurposeFineTuneResults),
            Vision(#[allow(dead_code)] OpenAiFilePurposeVision),
        }
        Ok(match OpenAiFilePurpose::deserialize(deserializer)? {
            OpenAiFilePurpose::Assistants(_) => Self::Assistants,
            OpenAiFilePurpose::AssistantsOutput(_) => Self::AssistantsOutput,
            OpenAiFilePurpose::Batch(_) => Self::Batch,
            OpenAiFilePurpose::BatchOutput(_) => Self::BatchOutput,
            OpenAiFilePurpose::FineTune(_) => Self::FineTune,
            OpenAiFilePurpose::FineTuneResults(_) => Self::FineTuneResults,
            OpenAiFilePurpose::Vision(_) => Self::Vision,
        })
    }
}
impl serde::Serialize for OpenAiFilePurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeAssistantsOutput {
            #[default]
            #[serde(rename = "assistants_output")]
            AssistantsOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeBatchOutput {
            #[default]
            #[serde(rename = "batch_output")]
            BatchOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeFineTuneResults {
            #[default]
            #[serde(rename = "fine-tune-results")]
            FineTuneResults,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFilePurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum OpenAiFilePurpose<'a> {
            Assistants(#[allow(dead_code)] &'a OpenAiFilePurposeAssistants),
            AssistantsOutput(#[allow(dead_code)] &'a OpenAiFilePurposeAssistantsOutput),
            Batch(#[allow(dead_code)] &'a OpenAiFilePurposeBatch),
            BatchOutput(#[allow(dead_code)] &'a OpenAiFilePurposeBatchOutput),
            FineTune(#[allow(dead_code)] &'a OpenAiFilePurposeFineTune),
            FineTuneResults(#[allow(dead_code)] &'a OpenAiFilePurposeFineTuneResults),
            Vision(#[allow(dead_code)] &'a OpenAiFilePurposeVision),
        }
        match self {
            Self::Assistants => {
                OpenAiFilePurpose::Assistants(&Default::default()).serialize(serializer)
            }
            Self::AssistantsOutput => {
                OpenAiFilePurpose::AssistantsOutput(&Default::default()).serialize(serializer)
            }
            Self::Batch => OpenAiFilePurpose::Batch(&Default::default()).serialize(serializer),
            Self::BatchOutput => {
                OpenAiFilePurpose::BatchOutput(&Default::default()).serialize(serializer)
            }
            Self::FineTune => {
                OpenAiFilePurpose::FineTune(&Default::default()).serialize(serializer)
            }
            Self::FineTuneResults => {
                OpenAiFilePurpose::FineTuneResults(&Default::default()).serialize(serializer)
            }
            Self::Vision => OpenAiFilePurpose::Vision(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum OpenAiFilePurpose {
    #[doc = "assistants"]
    Assistants,
    #[doc = "assistants_output"]
    AssistantsOutput,
    #[doc = "batch"]
    Batch,
    #[doc = "batch_output"]
    BatchOutput,
    #[doc = "fine-tune"]
    FineTune,
    #[doc = "fine-tune-results"]
    FineTuneResults,
    #[doc = "vision"]
    Vision,
}
impl<'de> serde::Deserialize<'de> for OpenAiFileStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusUploaded {
            #[default]
            #[serde(rename = "uploaded")]
            Uploaded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusProcessed {
            #[default]
            #[serde(rename = "processed")]
            Processed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusError {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum OpenAiFileStatus {
            Uploaded(#[allow(dead_code)] OpenAiFileStatusUploaded),
            Processed(#[allow(dead_code)] OpenAiFileStatusProcessed),
            Error(#[allow(dead_code)] OpenAiFileStatusError),
        }
        Ok(match OpenAiFileStatus::deserialize(deserializer)? {
            OpenAiFileStatus::Uploaded(_) => Self::Uploaded,
            OpenAiFileStatus::Processed(_) => Self::Processed,
            OpenAiFileStatus::Error(_) => Self::Error,
        })
    }
}
impl serde::Serialize for OpenAiFileStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusUploaded {
            #[default]
            #[serde(rename = "uploaded")]
            Uploaded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusProcessed {
            #[default]
            #[serde(rename = "processed")]
            Processed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileStatusError {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum OpenAiFileStatus<'a> {
            Uploaded(#[allow(dead_code)] &'a OpenAiFileStatusUploaded),
            Processed(#[allow(dead_code)] &'a OpenAiFileStatusProcessed),
            Error(#[allow(dead_code)] &'a OpenAiFileStatusError),
        }
        match self {
            Self::Uploaded => OpenAiFileStatus::Uploaded(&Default::default()).serialize(serializer),
            Self::Processed => {
                OpenAiFileStatus::Processed(&Default::default()).serialize(serializer)
            }
            Self::Error => OpenAiFileStatus::Error(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum OpenAiFileStatus {
    #[doc = "uploaded"]
    Uploaded,
    #[doc = "processed"]
    Processed,
    #[doc = "error"]
    Error,
}
impl<'de> serde::Deserialize<'de> for OpenAiFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileObject {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OpenAiFile {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: u64,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: OpenAiFileObject,
            #[serde(rename = "purpose")]
            #[allow(dead_code)]
            purpose: OpenAiFilePurpose,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: OpenAiFileStatus,
            #[serde(rename = "status_details")]
            #[allow(dead_code)]
            status_details: Option<String>,
        }
        let OpenAiFile {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
            ..
        } = OpenAiFile::deserialize(deserializer)?;
        Ok(Self {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
        })
    }
}
impl serde::Serialize for OpenAiFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OpenAiFileObject {
            #[default]
            #[serde(rename = "file")]
            File,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OpenAiFile<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "bytes")]
            bytes: &'a u64,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "object")]
            object: &'a OpenAiFileObject,
            #[serde(rename = "purpose")]
            purpose: &'a OpenAiFilePurpose,
            #[serde(rename = "status")]
            status: &'a OpenAiFileStatus,
            #[serde(rename = "status_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status_details: &'a Option<String>,
        }
        let Self {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
        } = self;
        OpenAiFile {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            object: &Default::default(),
            purpose,
            status,
            status_details,
        }
        .serialize(serializer)
    }
}
#[doc = "The `File` object represents a document that has been uploaded to OpenAI."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OpenAiFile {
    #[doc = "The file identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The size of the file, in bytes."]
    pub bytes: u64,
    #[doc = "The Unix timestamp (in seconds) for when the file was created."]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) for when the file will expire."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The name of the file."]
    pub filename: String,
    #[doc = "The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results` and `vision`."]
    pub purpose: OpenAiFilePurpose,
    #[doc = "Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`."]
    pub status: OpenAiFileStatus,
    #[doc = "Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`."]
    #[builder(default)]
    pub status_details: Option<String>,
}
impl<'de> serde::Deserialize<'de> for OtherChunkingStrategyResponseParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `other`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OtherChunkingStrategyResponseParamType {
            #[default]
            #[serde(rename = "other")]
            Other,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OtherChunkingStrategyResponseParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: OtherChunkingStrategyResponseParamType,
        }
        let OtherChunkingStrategyResponseParam { .. } =
            OtherChunkingStrategyResponseParam::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for OtherChunkingStrategyResponseParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `other`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OtherChunkingStrategyResponseParamType {
            #[default]
            #[serde(rename = "other")]
            Other,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OtherChunkingStrategyResponseParam<'a> {
            #[serde(rename = "type")]
            type_: &'a OtherChunkingStrategyResponseParamType,
        }
        let Self {} = self;
        OtherChunkingStrategyResponseParam {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct OtherChunkingStrategyResponseParam {}
impl<'de> serde::Deserialize<'de> for OutputAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the output audio. Always `output_audio`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputAudioType {
            #[default]
            #[serde(rename = "output_audio")]
            OutputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OutputAudio {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: OutputAudioType,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: String,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: String,
        }
        let OutputAudio {
            data, transcript, ..
        } = OutputAudio::deserialize(deserializer)?;
        Ok(Self { data, transcript })
    }
}
impl serde::Serialize for OutputAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the output audio. Always `output_audio`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputAudioType {
            #[default]
            #[serde(rename = "output_audio")]
            OutputAudio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OutputAudio<'a> {
            #[serde(rename = "type")]
            type_: &'a OutputAudioType,
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "transcript")]
            transcript: &'a String,
        }
        let Self { data, transcript } = self;
        OutputAudio {
            type_: &Default::default(),
            data,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "An audio output from the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputAudio {
    #[doc = "Base64-encoded audio data from the model.\n"]
    pub data: String,
    #[doc = "The transcript of the audio data from the model.\n"]
    pub transcript: String,
}
impl<'de> serde::Deserialize<'de> for OutputContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum OutputContent {
            OutputText(#[allow(dead_code)] OutputTextContent),
            Refusal(#[allow(dead_code)] RefusalContent),
        }
        Ok(match OutputContent::deserialize(deserializer)? {
            OutputContent::OutputText(_v) => Self::OutputText(_v),
            OutputContent::Refusal(_v) => Self::Refusal(_v),
        })
    }
}
impl serde::Serialize for OutputContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum OutputContent<'a> {
            OutputText(#[allow(dead_code)] &'a OutputTextContent),
            Refusal(#[allow(dead_code)] &'a RefusalContent),
        }
        match self {
            Self::OutputText(_v) => OutputContent::OutputText(_v).serialize(serializer),
            Self::Refusal(_v) => OutputContent::Refusal(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum OutputContent {
    OutputText(OutputTextContent),
    Refusal(RefusalContent),
}
impl<'de> serde::Deserialize<'de> for OutputItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum OutputItem {
            Message(#[allow(dead_code)] OutputMessage),
            FileSearchCall(#[allow(dead_code)] FileSearchToolCall),
            FunctionCall(#[allow(dead_code)] FunctionToolCall),
            WebSearchCall(#[allow(dead_code)] WebSearchToolCall),
            ComputerCall(#[allow(dead_code)] ComputerToolCall),
            Reasoning(#[allow(dead_code)] ReasoningItem),
            ImageGenerationCall(#[allow(dead_code)] ImageGenToolCall),
            CodeInterpreterCall(#[allow(dead_code)] CodeInterpreterToolCall),
            LocalShellCall(#[allow(dead_code)] LocalShellToolCall),
            McpCall(#[allow(dead_code)] McpToolCall),
            McpListTools(#[allow(dead_code)] McpListTools),
            McpApprovalRequest(#[allow(dead_code)] McpApprovalRequest),
        }
        Ok(match OutputItem::deserialize(deserializer)? {
            OutputItem::Message(_v) => Self::Message(_v),
            OutputItem::FileSearchCall(_v) => Self::FileSearchCall(_v),
            OutputItem::FunctionCall(_v) => Self::FunctionCall(_v),
            OutputItem::WebSearchCall(_v) => Self::WebSearchCall(_v),
            OutputItem::ComputerCall(_v) => Self::ComputerCall(_v),
            OutputItem::Reasoning(_v) => Self::Reasoning(_v),
            OutputItem::ImageGenerationCall(_v) => Self::ImageGenerationCall(_v),
            OutputItem::CodeInterpreterCall(_v) => Self::CodeInterpreterCall(_v),
            OutputItem::LocalShellCall(_v) => Self::LocalShellCall(_v),
            OutputItem::McpCall(_v) => Self::McpCall(_v),
            OutputItem::McpListTools(_v) => Self::McpListTools(_v),
            OutputItem::McpApprovalRequest(_v) => Self::McpApprovalRequest(_v),
        })
    }
}
impl serde::Serialize for OutputItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum OutputItem<'a> {
            Message(#[allow(dead_code)] &'a OutputMessage),
            FileSearchCall(#[allow(dead_code)] &'a FileSearchToolCall),
            FunctionCall(#[allow(dead_code)] &'a FunctionToolCall),
            WebSearchCall(#[allow(dead_code)] &'a WebSearchToolCall),
            ComputerCall(#[allow(dead_code)] &'a ComputerToolCall),
            Reasoning(#[allow(dead_code)] &'a ReasoningItem),
            ImageGenerationCall(#[allow(dead_code)] &'a ImageGenToolCall),
            CodeInterpreterCall(#[allow(dead_code)] &'a CodeInterpreterToolCall),
            LocalShellCall(#[allow(dead_code)] &'a LocalShellToolCall),
            McpCall(#[allow(dead_code)] &'a McpToolCall),
            McpListTools(#[allow(dead_code)] &'a McpListTools),
            McpApprovalRequest(#[allow(dead_code)] &'a McpApprovalRequest),
        }
        match self {
            Self::Message(_v) => OutputItem::Message(_v).serialize(serializer),
            Self::FileSearchCall(_v) => OutputItem::FileSearchCall(_v).serialize(serializer),
            Self::FunctionCall(_v) => OutputItem::FunctionCall(_v).serialize(serializer),
            Self::WebSearchCall(_v) => OutputItem::WebSearchCall(_v).serialize(serializer),
            Self::ComputerCall(_v) => OutputItem::ComputerCall(_v).serialize(serializer),
            Self::Reasoning(_v) => OutputItem::Reasoning(_v).serialize(serializer),
            Self::ImageGenerationCall(_v) => {
                OutputItem::ImageGenerationCall(_v).serialize(serializer)
            }
            Self::CodeInterpreterCall(_v) => {
                OutputItem::CodeInterpreterCall(_v).serialize(serializer)
            }
            Self::LocalShellCall(_v) => OutputItem::LocalShellCall(_v).serialize(serializer),
            Self::McpCall(_v) => OutputItem::McpCall(_v).serialize(serializer),
            Self::McpListTools(_v) => OutputItem::McpListTools(_v).serialize(serializer),
            Self::McpApprovalRequest(_v) => {
                OutputItem::McpApprovalRequest(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum OutputItem {
    Message(OutputMessage),
    FileSearchCall(FileSearchToolCall),
    FunctionCall(FunctionToolCall),
    WebSearchCall(WebSearchToolCall),
    ComputerCall(ComputerToolCall),
    Reasoning(ReasoningItem),
    ImageGenerationCall(ImageGenToolCall),
    CodeInterpreterCall(CodeInterpreterToolCall),
    LocalShellCall(LocalShellToolCall),
    McpCall(McpToolCall),
    McpListTools(McpListTools),
    McpApprovalRequest(McpApprovalRequest),
}
impl<'de> serde::Deserialize<'de> for OutputMessageStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum OutputMessageStatus {
            InProgress(#[allow(dead_code)] OutputMessageStatusInProgress),
            Completed(#[allow(dead_code)] OutputMessageStatusCompleted),
            Incomplete(#[allow(dead_code)] OutputMessageStatusIncomplete),
        }
        Ok(match OutputMessageStatus::deserialize(deserializer)? {
            OutputMessageStatus::InProgress(_) => Self::InProgress,
            OutputMessageStatus::Completed(_) => Self::Completed,
            OutputMessageStatus::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for OutputMessageStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum OutputMessageStatus<'a> {
            InProgress(#[allow(dead_code)] &'a OutputMessageStatusInProgress),
            Completed(#[allow(dead_code)] &'a OutputMessageStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a OutputMessageStatusIncomplete),
        }
        match self {
            Self::InProgress => {
                OutputMessageStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                OutputMessageStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                OutputMessageStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum OutputMessageStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for OutputMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the output message. Always `message`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageType {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[doc = "The role of the output message. Always `assistant`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OutputMessage {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: OutputMessageType,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: OutputMessageRole,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Vec<OutputContent>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: OutputMessageStatus,
        }
        let OutputMessage {
            id,
            content,
            status,
            ..
        } = OutputMessage::deserialize(deserializer)?;
        Ok(Self {
            id,
            content,
            status,
        })
    }
}
impl serde::Serialize for OutputMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the output message. Always `message`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageType {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[doc = "The role of the output message. Always `assistant`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputMessageRole {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OutputMessage<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a OutputMessageType,
            #[serde(rename = "role")]
            role: &'a OutputMessageRole,
            #[serde(rename = "content")]
            content: &'a Vec<OutputContent>,
            #[serde(rename = "status")]
            status: &'a OutputMessageStatus,
        }
        let Self {
            id,
            content,
            status,
        } = self;
        OutputMessage {
            id,
            type_: &Default::default(),
            role: &Default::default(),
            content,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "An output message from the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputMessage {
    #[doc = "The unique ID of the output message.\n"]
    pub id: String,
    #[doc = "The content of the output message.\n"]
    pub content: Vec<OutputContent>,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    pub status: OutputMessageStatus,
}
#[doc = "Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling) during tool use."]
pub type ParallelToolCalls = bool;
impl<'de> serde::Deserialize<'de> for PredictionContentContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum PredictionContentContent {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<ChatCompletionRequestMessageContentPartText>),
        }
        Ok(match PredictionContentContent::deserialize(deserializer)? {
            PredictionContentContent::String(_v) => Self::String(_v),
            PredictionContentContent::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for PredictionContentContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum PredictionContentContent<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<ChatCompletionRequestMessageContentPartText>),
        }
        match self {
            Self::String(_v) => PredictionContentContent::String(_v).serialize(serializer),
            Self::Array(_v) => PredictionContentContent::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "The content that should be matched when generating a model response.\nIf generated tokens would match this content, the entire model response\ncan be returned much more quickly.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum PredictionContentContent {
    #[doc = "The content used for a Predicted Output. This is often the\ntext of a file you are regenerating with minor changes.\n"]
    String(String),
    #[doc = "An array of content parts with a defined type. Supported options differ based on the [model](https://platform.openai.com/docs/models) being used to generate the response. Can contain text inputs."]
    Array(Vec<ChatCompletionRequestMessageContentPartText>),
}
impl<'de> serde::Deserialize<'de> for PredictionContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the predicted content you want to provide. This type is\ncurrently always `content`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum PredictionContentType {
            #[default]
            #[serde(rename = "content")]
            Content,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct PredictionContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: PredictionContentType,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: PredictionContentContent,
        }
        let PredictionContent { content, .. } = PredictionContent::deserialize(deserializer)?;
        Ok(Self { content })
    }
}
impl serde::Serialize for PredictionContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the predicted content you want to provide. This type is\ncurrently always `content`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum PredictionContentType {
            #[default]
            #[serde(rename = "content")]
            Content,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct PredictionContent<'a> {
            #[serde(rename = "type")]
            type_: &'a PredictionContentType,
            #[serde(rename = "content")]
            content: &'a PredictionContentContent,
        }
        let Self { content } = self;
        PredictionContent {
            type_: &Default::default(),
            content,
        }
        .serialize(serializer)
    }
}
#[doc = "Static predicted output content, such as the content of a text file that is\nbeing regenerated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct PredictionContent {
    #[doc = "The content that should be matched when generating a model response.\nIf generated tokens would match this content, the entire model response\ncan be returned much more quickly.\n"]
    pub content: PredictionContentContent,
}
impl<'de> serde::Deserialize<'de> for ProjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectStatusActive {
            #[default]
            #[serde(rename = "active")]
            Active,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectStatusArchived {
            #[default]
            #[serde(rename = "archived")]
            Archived,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ProjectStatus {
            Active(#[allow(dead_code)] ProjectStatusActive),
            Archived(#[allow(dead_code)] ProjectStatusArchived),
        }
        Ok(match ProjectStatus::deserialize(deserializer)? {
            ProjectStatus::Active(_) => Self::Active,
            ProjectStatus::Archived(_) => Self::Archived,
        })
    }
}
impl serde::Serialize for ProjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectStatusActive {
            #[default]
            #[serde(rename = "active")]
            Active,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectStatusArchived {
            #[default]
            #[serde(rename = "archived")]
            Archived,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ProjectStatus<'a> {
            Active(#[allow(dead_code)] &'a ProjectStatusActive),
            Archived(#[allow(dead_code)] &'a ProjectStatusArchived),
        }
        match self {
            Self::Active => ProjectStatus::Active(&Default::default()).serialize(serializer),
            Self::Archived => ProjectStatus::Archived(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`active` or `archived`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectStatus {
    #[doc = "active"]
    Active,
    #[doc = "archived"]
    Archived,
}
impl<'de> serde::Deserialize<'de> for Project {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectObject {
            #[default]
            #[serde(rename = "organization.project")]
            OrganizationProject,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Project {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectObject,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "archived_at")]
            #[allow(dead_code)]
            archived_at: Option<u64>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: ProjectStatus,
        }
        let Project {
            id,
            name,
            created_at,
            archived_at,
            status,
            ..
        } = Project::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            created_at,
            archived_at,
            status,
        })
    }
}
impl serde::Serialize for Project {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectObject {
            #[default]
            #[serde(rename = "organization.project")]
            OrganizationProject,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Project<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a ProjectObject,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "archived_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            archived_at: &'a Option<u64>,
            #[serde(rename = "status")]
            status: &'a ProjectStatus,
        }
        let Self {
            id,
            name,
            created_at,
            archived_at,
            status,
        } = self;
        Project {
            id,
            object: &Default::default(),
            name,
            created_at,
            archived_at,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Project {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the project. This appears in reporting."]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the project was created."]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the project was archived or `null`."]
    #[builder(default)]
    pub archived_at: Option<u64>,
    #[doc = "`active` or `archived`"]
    pub status: ProjectStatus,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyOwnerType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyOwnerTypeUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyOwnerTypeServiceAccount {
            #[default]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ProjectApiKeyOwnerType {
            User(#[allow(dead_code)] ProjectApiKeyOwnerTypeUser),
            ServiceAccount(#[allow(dead_code)] ProjectApiKeyOwnerTypeServiceAccount),
        }
        Ok(match ProjectApiKeyOwnerType::deserialize(deserializer)? {
            ProjectApiKeyOwnerType::User(_) => Self::User,
            ProjectApiKeyOwnerType::ServiceAccount(_) => Self::ServiceAccount,
        })
    }
}
impl serde::Serialize for ProjectApiKeyOwnerType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyOwnerTypeUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyOwnerTypeServiceAccount {
            #[default]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ProjectApiKeyOwnerType<'a> {
            User(#[allow(dead_code)] &'a ProjectApiKeyOwnerTypeUser),
            ServiceAccount(#[allow(dead_code)] &'a ProjectApiKeyOwnerTypeServiceAccount),
        }
        match self {
            Self::User => ProjectApiKeyOwnerType::User(&Default::default()).serialize(serializer),
            Self::ServiceAccount => {
                ProjectApiKeyOwnerType::ServiceAccount(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "`user` or `service_account`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectApiKeyOwnerType {
    #[doc = "user"]
    User,
    #[doc = "service_account"]
    ServiceAccount,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyOwner {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectApiKeyOwner {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<ProjectApiKeyOwnerType>,
            #[serde(rename = "user")]
            #[allow(dead_code)]
            user: Option<ProjectUser>,
            #[serde(rename = "service_account")]
            #[allow(dead_code)]
            service_account: Option<ProjectServiceAccount>,
        }
        let ProjectApiKeyOwner {
            type_,
            user,
            service_account,
            ..
        } = ProjectApiKeyOwner::deserialize(deserializer)?;
        Ok(Self {
            type_,
            user,
            service_account,
        })
    }
}
impl serde::Serialize for ProjectApiKeyOwner {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectApiKeyOwner<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<ProjectApiKeyOwnerType>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<ProjectUser>,
            #[serde(rename = "service_account")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_account: &'a Option<ProjectServiceAccount>,
        }
        let Self {
            type_,
            user,
            service_account,
        } = self;
        ProjectApiKeyOwner {
            type_,
            user,
            service_account,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ProjectApiKeyOwner {
    #[doc = "`user` or `service_account`"]
    #[builder(default)]
    pub type_: Option<ProjectApiKeyOwnerType>,
    #[builder(default)]
    pub user: Option<ProjectUser>,
    #[builder(default)]
    pub service_account: Option<ProjectServiceAccount>,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project.api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyObject {
            #[default]
            #[serde(rename = "organization.project.api_key")]
            OrganizationProjectApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectApiKey {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectApiKeyObject,
            #[serde(rename = "redacted_value")]
            #[allow(dead_code)]
            redacted_value: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "last_used_at")]
            #[allow(dead_code)]
            last_used_at: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "owner")]
            #[allow(dead_code)]
            owner: ProjectApiKeyOwner,
        }
        let ProjectApiKey {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
            ..
        } = ProjectApiKey::deserialize(deserializer)?;
        Ok(Self {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        })
    }
}
impl serde::Serialize for ProjectApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project.api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyObject {
            #[default]
            #[serde(rename = "organization.project.api_key")]
            OrganizationProjectApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectApiKey<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectApiKeyObject,
            #[serde(rename = "redacted_value")]
            redacted_value: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "last_used_at")]
            last_used_at: &'a u64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "owner")]
            owner: &'a ProjectApiKeyOwner,
        }
        let Self {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        } = self;
        ProjectApiKey {
            object: &Default::default(),
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual API key in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKey {
    #[doc = "The redacted value of the API key"]
    pub redacted_value: String,
    #[doc = "The name of the API key"]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the API key was created"]
    pub created_at: u64,
    #[doc = "The Unix timestamp (in seconds) of when the API key was last used."]
    pub last_used_at: u64,
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[builder(default)]
    pub owner: ProjectApiKeyOwner,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.api_key.deleted")]
            OrganizationProjectApiKeyDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectApiKeyDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectApiKeyDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let ProjectApiKeyDeleteResponse { id, deleted, .. } =
            ProjectApiKeyDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for ProjectApiKeyDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.api_key.deleted")]
            OrganizationProjectApiKeyDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectApiKeyDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectApiKeyDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        ProjectApiKeyDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKeyDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectApiKeyListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectApiKeyListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ProjectApiKey>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ProjectApiKeyListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectApiKeyListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectApiKeyListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectApiKeyListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectApiKeyListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectApiKeyListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<ProjectApiKey>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectApiKeyListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKeyListResponse {
    pub data: Vec<ProjectApiKey>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectCreateRequest {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ProjectCreateRequest { name, .. } = ProjectCreateRequest::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ProjectCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectCreateRequest<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ProjectCreateRequest { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectCreateRequest {
    #[doc = "The friendly name of the project, this name appears in reports."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ProjectListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<Project>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ProjectListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<Project>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectListResponse {
    pub data: Vec<Project>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectRateLimit {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `project.rate_limit`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectRateLimitObject {
            #[default]
            #[serde(rename = "project.rate_limit")]
            ProjectRateLimit,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectRateLimit {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectRateLimitObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "max_requests_per_1_minute")]
            #[allow(dead_code)]
            max_requests_per_1_minute: u64,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[allow(dead_code)]
            max_tokens_per_1_minute: u64,
            #[serde(rename = "max_images_per_1_minute")]
            #[allow(dead_code)]
            max_images_per_1_minute: Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[allow(dead_code)]
            max_audio_megabytes_per_1_minute: Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[allow(dead_code)]
            max_requests_per_1_day: Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[allow(dead_code)]
            batch_1_day_max_input_tokens: Option<u64>,
        }
        let ProjectRateLimit {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
            ..
        } = ProjectRateLimit::deserialize(deserializer)?;
        Ok(Self {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        })
    }
}
impl serde::Serialize for ProjectRateLimit {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `project.rate_limit`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectRateLimitObject {
            #[default]
            #[serde(rename = "project.rate_limit")]
            ProjectRateLimit,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectRateLimit<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectRateLimitObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "max_requests_per_1_minute")]
            max_requests_per_1_minute: &'a u64,
            #[serde(rename = "max_tokens_per_1_minute")]
            max_tokens_per_1_minute: &'a u64,
            #[serde(rename = "max_images_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_images_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_audio_megabytes_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_day: &'a Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_1_day_max_input_tokens: &'a Option<u64>,
        }
        let Self {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        } = self;
        ProjectRateLimit {
            object: &Default::default(),
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a project rate limit config."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimit {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The model this rate limit applies to."]
    pub model: String,
    #[doc = "The maximum requests per minute."]
    pub max_requests_per_1_minute: u64,
    #[doc = "The maximum tokens per minute."]
    pub max_tokens_per_1_minute: u64,
    #[doc = "The maximum images per minute. Only present for relevant models."]
    #[builder(default)]
    pub max_images_per_1_minute: Option<u64>,
    #[doc = "The maximum audio megabytes per minute. Only present for relevant models."]
    #[builder(default)]
    pub max_audio_megabytes_per_1_minute: Option<u64>,
    #[doc = "The maximum requests per day. Only present for relevant models."]
    #[builder(default)]
    pub max_requests_per_1_day: Option<u64>,
    #[doc = "The maximum batch input tokens per day. Only present for relevant models."]
    #[builder(default)]
    pub batch_1_day_max_input_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for ProjectRateLimitListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectRateLimitListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectRateLimitListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectRateLimitListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ProjectRateLimit>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ProjectRateLimitListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectRateLimitListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectRateLimitListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectRateLimitListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectRateLimitListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectRateLimitListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<ProjectRateLimit>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectRateLimitListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimitListResponse {
    pub data: Vec<ProjectRateLimit>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectRateLimitUpdateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectRateLimitUpdateRequest {
            #[serde(rename = "max_requests_per_1_minute")]
            #[allow(dead_code)]
            max_requests_per_1_minute: Option<u64>,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[allow(dead_code)]
            max_tokens_per_1_minute: Option<u64>,
            #[serde(rename = "max_images_per_1_minute")]
            #[allow(dead_code)]
            max_images_per_1_minute: Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[allow(dead_code)]
            max_audio_megabytes_per_1_minute: Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[allow(dead_code)]
            max_requests_per_1_day: Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[allow(dead_code)]
            batch_1_day_max_input_tokens: Option<u64>,
        }
        let ProjectRateLimitUpdateRequest {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
            ..
        } = ProjectRateLimitUpdateRequest::deserialize(deserializer)?;
        Ok(Self {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        })
    }
}
impl serde::Serialize for ProjectRateLimitUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectRateLimitUpdateRequest<'a> {
            #[serde(rename = "max_requests_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_tokens_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tokens_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_images_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_images_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_audio_megabytes_per_1_minute: &'a Option<u64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_day: &'a Option<u64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_1_day_max_input_tokens: &'a Option<u64>,
        }
        let Self {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        } = self;
        ProjectRateLimitUpdateRequest {
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimitUpdateRequest {
    #[doc = "The maximum requests per minute."]
    #[builder(default)]
    pub max_requests_per_1_minute: Option<u64>,
    #[doc = "The maximum tokens per minute."]
    #[builder(default)]
    pub max_tokens_per_1_minute: Option<u64>,
    #[doc = "The maximum images per minute. Only relevant for certain models."]
    #[builder(default)]
    pub max_images_per_1_minute: Option<u64>,
    #[doc = "The maximum audio megabytes per minute. Only relevant for certain models."]
    #[builder(default)]
    pub max_audio_megabytes_per_1_minute: Option<u64>,
    #[doc = "The maximum requests per day. Only relevant for certain models."]
    #[builder(default)]
    pub max_requests_per_1_day: Option<u64>,
    #[doc = "The maximum batch input tokens per day. Only relevant for certain models."]
    #[builder(default)]
    pub batch_1_day_max_input_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ProjectServiceAccountRole {
            Owner(#[allow(dead_code)] ProjectServiceAccountRoleOwner),
            Member(#[allow(dead_code)] ProjectServiceAccountRoleMember),
        }
        Ok(
            match ProjectServiceAccountRole::deserialize(deserializer)? {
                ProjectServiceAccountRole::Owner(_) => Self::Owner,
                ProjectServiceAccountRole::Member(_) => Self::Member,
            },
        )
    }
}
impl serde::Serialize for ProjectServiceAccountRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ProjectServiceAccountRole<'a> {
            Owner(#[allow(dead_code)] &'a ProjectServiceAccountRoleOwner),
            Member(#[allow(dead_code)] &'a ProjectServiceAccountRoleMember),
        }
        match self {
            Self::Owner => {
                ProjectServiceAccountRole::Owner(&Default::default()).serialize(serializer)
            }
            Self::Member => {
                ProjectServiceAccountRole::Member(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "`owner` or `member`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectServiceAccountRole {
    #[doc = "owner"]
    Owner,
    #[doc = "member"]
    Member,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project.service_account`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountObject {
            #[default]
            #[serde(rename = "organization.project.service_account")]
            OrganizationProjectServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccount {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectServiceAccountRole,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
        }
        let ProjectServiceAccount {
            id,
            name,
            role,
            created_at,
            ..
        } = ProjectServiceAccount::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            role,
            created_at,
        })
    }
}
impl serde::Serialize for ProjectServiceAccount {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project.service_account`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountObject {
            #[default]
            #[serde(rename = "organization.project.service_account")]
            OrganizationProjectServiceAccount,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccount<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "role")]
            role: &'a ProjectServiceAccountRole,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
        }
        let Self {
            id,
            name,
            role,
            created_at,
        } = self;
        ProjectServiceAccount {
            object: &Default::default(),
            id,
            name,
            role,
            created_at,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual service account in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccount {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the service account"]
    pub name: String,
    #[doc = "`owner` or `member`"]
    pub role: ProjectServiceAccountRole,
    #[doc = "The Unix timestamp (in seconds) of when the service account was created"]
    pub created_at: u64,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project.service_account.api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountApiKeyObject {
            #[default]
            #[serde(rename = "organization.project.service_account.api_key")]
            OrganizationProjectServiceAccountApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountApiKey {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountApiKeyObject,
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let ProjectServiceAccountApiKey {
            value,
            name,
            created_at,
            id,
            ..
        } = ProjectServiceAccountApiKey::deserialize(deserializer)?;
        Ok(Self {
            value,
            name,
            created_at,
            id,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project.service_account.api_key`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountApiKeyObject {
            #[default]
            #[serde(rename = "organization.project.service_account.api_key")]
            OrganizationProjectServiceAccountApiKey,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountApiKey<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountApiKeyObject,
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self {
            value,
            name,
            created_at,
            id,
        } = self;
        ProjectServiceAccountApiKey {
            object: &Default::default(),
            value,
            name,
            created_at,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountApiKey {
    pub value: String,
    pub name: String,
    pub created_at: u64,
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountCreateRequest {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ProjectServiceAccountCreateRequest { name, .. } =
            ProjectServiceAccountCreateRequest::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ProjectServiceAccountCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountCreateRequest<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ProjectServiceAccountCreateRequest { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountCreateRequest {
    #[doc = "The name of the service account being created."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountCreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountCreateResponseObject {
            #[default]
            #[serde(rename = "organization.project.service_account")]
            OrganizationProjectServiceAccount,
        }
        #[doc = "Service accounts can only have one role of type `member`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountCreateResponseRole {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountCreateResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountCreateResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectServiceAccountCreateResponseRole,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "api_key")]
            #[allow(dead_code)]
            api_key: ProjectServiceAccountApiKey,
        }
        let ProjectServiceAccountCreateResponse {
            id,
            name,
            created_at,
            api_key,
            ..
        } = ProjectServiceAccountCreateResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            created_at,
            api_key,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountCreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountCreateResponseObject {
            #[default]
            #[serde(rename = "organization.project.service_account")]
            OrganizationProjectServiceAccount,
        }
        #[doc = "Service accounts can only have one role of type `member`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountCreateResponseRole {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountCreateResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountCreateResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "role")]
            role: &'a ProjectServiceAccountCreateResponseRole,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "api_key")]
            api_key: &'a ProjectServiceAccountApiKey,
        }
        let Self {
            id,
            name,
            created_at,
            api_key,
        } = self;
        ProjectServiceAccountCreateResponse {
            object: &Default::default(),
            id,
            name,
            role: &Default::default(),
            created_at,
            api_key,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountCreateResponse {
    pub id: String,
    pub name: String,
    pub created_at: u64,
    pub api_key: ProjectServiceAccountApiKey,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.service_account.deleted")]
            OrganizationProjectServiceAccountDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let ProjectServiceAccountDeleteResponse { id, deleted, .. } =
            ProjectServiceAccountDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for ProjectServiceAccountDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.service_account.deleted")]
            OrganizationProjectServiceAccountDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        ProjectServiceAccountDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectServiceAccountListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ProjectServiceAccount>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ProjectServiceAccountListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectServiceAccountListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectServiceAccountListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectServiceAccountListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<ProjectServiceAccount>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectServiceAccountListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountListResponse {
    pub data: Vec<ProjectServiceAccount>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectUpdateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectUpdateRequest {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ProjectUpdateRequest { name, .. } = ProjectUpdateRequest::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ProjectUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectUpdateRequest<'a> {
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ProjectUpdateRequest { name }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUpdateRequest {
    #[doc = "The updated name of the project, this name appears in reports."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ProjectUserRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ProjectUserRole {
            Owner(#[allow(dead_code)] ProjectUserRoleOwner),
            Member(#[allow(dead_code)] ProjectUserRoleMember),
        }
        Ok(match ProjectUserRole::deserialize(deserializer)? {
            ProjectUserRole::Owner(_) => Self::Owner,
            ProjectUserRole::Member(_) => Self::Member,
        })
    }
}
impl serde::Serialize for ProjectUserRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ProjectUserRole<'a> {
            Owner(#[allow(dead_code)] &'a ProjectUserRoleOwner),
            Member(#[allow(dead_code)] &'a ProjectUserRoleMember),
        }
        match self {
            Self::Owner => ProjectUserRole::Owner(&Default::default()).serialize(serializer),
            Self::Member => ProjectUserRole::Member(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `member`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectUserRole {
    #[doc = "owner"]
    Owner,
    #[doc = "member"]
    Member,
}
impl<'de> serde::Deserialize<'de> for ProjectUser {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.project.user`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserObject {
            #[default]
            #[serde(rename = "organization.project.user")]
            OrganizationProjectUser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectUser {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectUserObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectUserRole,
            #[serde(rename = "added_at")]
            #[allow(dead_code)]
            added_at: u64,
        }
        let ProjectUser {
            id,
            name,
            email,
            role,
            added_at,
            ..
        } = ProjectUser::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            email,
            role,
            added_at,
        })
    }
}
impl serde::Serialize for ProjectUser {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.project.user`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserObject {
            #[default]
            #[serde(rename = "organization.project.user")]
            OrganizationProjectUser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectUser<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectUserObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a ProjectUserRole,
            #[serde(rename = "added_at")]
            added_at: &'a u64,
        }
        let Self {
            id,
            name,
            email,
            role,
            added_at,
        } = self;
        ProjectUser {
            object: &Default::default(),
            id,
            name,
            email,
            role,
            added_at,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual user in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUser {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the user"]
    pub name: String,
    #[doc = "The email address of the user"]
    pub email: String,
    #[doc = "`owner` or `member`"]
    pub role: ProjectUserRole,
    #[doc = "The Unix timestamp (in seconds) of when the project was added."]
    pub added_at: u64,
}
impl<'de> serde::Deserialize<'de> for ProjectUserCreateRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserCreateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserCreateRequestRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ProjectUserCreateRequestRole {
            Owner(#[allow(dead_code)] ProjectUserCreateRequestRoleOwner),
            Member(#[allow(dead_code)] ProjectUserCreateRequestRoleMember),
        }
        Ok(
            match ProjectUserCreateRequestRole::deserialize(deserializer)? {
                ProjectUserCreateRequestRole::Owner(_) => Self::Owner,
                ProjectUserCreateRequestRole::Member(_) => Self::Member,
            },
        )
    }
}
impl serde::Serialize for ProjectUserCreateRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserCreateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserCreateRequestRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ProjectUserCreateRequestRole<'a> {
            Owner(#[allow(dead_code)] &'a ProjectUserCreateRequestRoleOwner),
            Member(#[allow(dead_code)] &'a ProjectUserCreateRequestRoleMember),
        }
        match self {
            Self::Owner => {
                ProjectUserCreateRequestRole::Owner(&Default::default()).serialize(serializer)
            }
            Self::Member => {
                ProjectUserCreateRequestRole::Member(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "`owner` or `member`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectUserCreateRequestRole {
    #[doc = "owner"]
    Owner,
    #[doc = "member"]
    Member,
}
impl<'de> serde::Deserialize<'de> for ProjectUserCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectUserCreateRequest {
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectUserCreateRequestRole,
        }
        let ProjectUserCreateRequest { user_id, role, .. } =
            ProjectUserCreateRequest::deserialize(deserializer)?;
        Ok(Self { user_id, role })
    }
}
impl serde::Serialize for ProjectUserCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectUserCreateRequest<'a> {
            #[serde(rename = "user_id")]
            user_id: &'a String,
            #[serde(rename = "role")]
            role: &'a ProjectUserCreateRequestRole,
        }
        let Self { user_id, role } = self;
        ProjectUserCreateRequest { user_id, role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUserCreateRequest {
    #[doc = "The ID of the user."]
    pub user_id: String,
    #[doc = "`owner` or `member`"]
    pub role: ProjectUserCreateRequestRole,
}
impl<'de> serde::Deserialize<'de> for ProjectUserDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.user.deleted")]
            OrganizationProjectUserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectUserDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ProjectUserDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let ProjectUserDeleteResponse { id, deleted, .. } =
            ProjectUserDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for ProjectUserDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.project.user.deleted")]
            OrganizationProjectUserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectUserDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a ProjectUserDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        ProjectUserDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUserDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectUserListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectUserListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: String,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ProjectUser>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let ProjectUserListResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectUserListResponse::deserialize(deserializer)?;
        Ok(Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectUserListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectUserListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a String,
            #[serde(rename = "data")]
            data: &'a Vec<ProjectUser>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            object,
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectUserListResponse {
            object,
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUserListResponse {
    pub object: String,
    pub data: Vec<ProjectUser>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectUserUpdateRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserUpdateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserUpdateRequestRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ProjectUserUpdateRequestRole {
            Owner(#[allow(dead_code)] ProjectUserUpdateRequestRoleOwner),
            Member(#[allow(dead_code)] ProjectUserUpdateRequestRoleMember),
        }
        Ok(
            match ProjectUserUpdateRequestRole::deserialize(deserializer)? {
                ProjectUserUpdateRequestRole::Owner(_) => Self::Owner,
                ProjectUserUpdateRequestRole::Member(_) => Self::Member,
            },
        )
    }
}
impl serde::Serialize for ProjectUserUpdateRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserUpdateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ProjectUserUpdateRequestRoleMember {
            #[default]
            #[serde(rename = "member")]
            Member,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ProjectUserUpdateRequestRole<'a> {
            Owner(#[allow(dead_code)] &'a ProjectUserUpdateRequestRoleOwner),
            Member(#[allow(dead_code)] &'a ProjectUserUpdateRequestRoleMember),
        }
        match self {
            Self::Owner => {
                ProjectUserUpdateRequestRole::Owner(&Default::default()).serialize(serializer)
            }
            Self::Member => {
                ProjectUserUpdateRequestRole::Member(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "`owner` or `member`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ProjectUserUpdateRequestRole {
    #[doc = "owner"]
    Owner,
    #[doc = "member"]
    Member,
}
impl<'de> serde::Deserialize<'de> for ProjectUserUpdateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectUserUpdateRequest {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: ProjectUserUpdateRequestRole,
        }
        let ProjectUserUpdateRequest { role, .. } =
            ProjectUserUpdateRequest::deserialize(deserializer)?;
        Ok(Self { role })
    }
}
impl serde::Serialize for ProjectUserUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectUserUpdateRequest<'a> {
            #[serde(rename = "role")]
            role: &'a ProjectUserUpdateRequestRole,
        }
        let Self { role } = self;
        ProjectUserUpdateRequest { role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ProjectUserUpdateRequest {
    #[doc = "`owner` or `member`"]
    pub role: ProjectUserUpdateRequestRole,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeClientEvent {
            ConversationItemCreate(#[allow(dead_code)] RealtimeClientEventConversationItemCreate),
            ConversationItemDelete(#[allow(dead_code)] RealtimeClientEventConversationItemDelete),
            ConversationItemRetrieve(
                #[allow(dead_code)] RealtimeClientEventConversationItemRetrieve,
            ),
            ConversationItemTruncate(
                #[allow(dead_code)] RealtimeClientEventConversationItemTruncate,
            ),
            InputAudioBufferAppend(#[allow(dead_code)] RealtimeClientEventInputAudioBufferAppend),
            InputAudioBufferClear(#[allow(dead_code)] RealtimeClientEventInputAudioBufferClear),
            OutputAudioBufferClear(#[allow(dead_code)] RealtimeClientEventOutputAudioBufferClear),
            InputAudioBufferCommit(#[allow(dead_code)] RealtimeClientEventInputAudioBufferCommit),
            ResponseCancel(#[allow(dead_code)] RealtimeClientEventResponseCancel),
            ResponseCreate(#[allow(dead_code)] RealtimeClientEventResponseCreate),
            SessionUpdate(#[allow(dead_code)] RealtimeClientEventSessionUpdate),
            TranscriptionSessionUpdate(
                #[allow(dead_code)] RealtimeClientEventTranscriptionSessionUpdate,
            ),
        }
        Ok(match RealtimeClientEvent::deserialize(deserializer)? {
            RealtimeClientEvent::ConversationItemCreate(_v) => Self::ConversationItemCreate(_v),
            RealtimeClientEvent::ConversationItemDelete(_v) => Self::ConversationItemDelete(_v),
            RealtimeClientEvent::ConversationItemRetrieve(_v) => Self::ConversationItemRetrieve(_v),
            RealtimeClientEvent::ConversationItemTruncate(_v) => Self::ConversationItemTruncate(_v),
            RealtimeClientEvent::InputAudioBufferAppend(_v) => Self::InputAudioBufferAppend(_v),
            RealtimeClientEvent::InputAudioBufferClear(_v) => Self::InputAudioBufferClear(_v),
            RealtimeClientEvent::OutputAudioBufferClear(_v) => Self::OutputAudioBufferClear(_v),
            RealtimeClientEvent::InputAudioBufferCommit(_v) => Self::InputAudioBufferCommit(_v),
            RealtimeClientEvent::ResponseCancel(_v) => Self::ResponseCancel(_v),
            RealtimeClientEvent::ResponseCreate(_v) => Self::ResponseCreate(_v),
            RealtimeClientEvent::SessionUpdate(_v) => Self::SessionUpdate(_v),
            RealtimeClientEvent::TranscriptionSessionUpdate(_v) => {
                Self::TranscriptionSessionUpdate(_v)
            }
        })
    }
}
impl serde::Serialize for RealtimeClientEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeClientEvent<'a> {
            ConversationItemCreate(
                #[allow(dead_code)] &'a RealtimeClientEventConversationItemCreate,
            ),
            ConversationItemDelete(
                #[allow(dead_code)] &'a RealtimeClientEventConversationItemDelete,
            ),
            ConversationItemRetrieve(
                #[allow(dead_code)] &'a RealtimeClientEventConversationItemRetrieve,
            ),
            ConversationItemTruncate(
                #[allow(dead_code)] &'a RealtimeClientEventConversationItemTruncate,
            ),
            InputAudioBufferAppend(
                #[allow(dead_code)] &'a RealtimeClientEventInputAudioBufferAppend,
            ),
            InputAudioBufferClear(#[allow(dead_code)] &'a RealtimeClientEventInputAudioBufferClear),
            OutputAudioBufferClear(
                #[allow(dead_code)] &'a RealtimeClientEventOutputAudioBufferClear,
            ),
            InputAudioBufferCommit(
                #[allow(dead_code)] &'a RealtimeClientEventInputAudioBufferCommit,
            ),
            ResponseCancel(#[allow(dead_code)] &'a RealtimeClientEventResponseCancel),
            ResponseCreate(#[allow(dead_code)] &'a RealtimeClientEventResponseCreate),
            SessionUpdate(#[allow(dead_code)] &'a RealtimeClientEventSessionUpdate),
            TranscriptionSessionUpdate(
                #[allow(dead_code)] &'a RealtimeClientEventTranscriptionSessionUpdate,
            ),
        }
        match self {
            Self::ConversationItemCreate(_v) => {
                RealtimeClientEvent::ConversationItemCreate(_v).serialize(serializer)
            }
            Self::ConversationItemDelete(_v) => {
                RealtimeClientEvent::ConversationItemDelete(_v).serialize(serializer)
            }
            Self::ConversationItemRetrieve(_v) => {
                RealtimeClientEvent::ConversationItemRetrieve(_v).serialize(serializer)
            }
            Self::ConversationItemTruncate(_v) => {
                RealtimeClientEvent::ConversationItemTruncate(_v).serialize(serializer)
            }
            Self::InputAudioBufferAppend(_v) => {
                RealtimeClientEvent::InputAudioBufferAppend(_v).serialize(serializer)
            }
            Self::InputAudioBufferClear(_v) => {
                RealtimeClientEvent::InputAudioBufferClear(_v).serialize(serializer)
            }
            Self::OutputAudioBufferClear(_v) => {
                RealtimeClientEvent::OutputAudioBufferClear(_v).serialize(serializer)
            }
            Self::InputAudioBufferCommit(_v) => {
                RealtimeClientEvent::InputAudioBufferCommit(_v).serialize(serializer)
            }
            Self::ResponseCancel(_v) => {
                RealtimeClientEvent::ResponseCancel(_v).serialize(serializer)
            }
            Self::ResponseCreate(_v) => {
                RealtimeClientEvent::ResponseCreate(_v).serialize(serializer)
            }
            Self::SessionUpdate(_v) => RealtimeClientEvent::SessionUpdate(_v).serialize(serializer),
            Self::TranscriptionSessionUpdate(_v) => {
                RealtimeClientEvent::TranscriptionSessionUpdate(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "A realtime client event.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeClientEvent {
    ConversationItemCreate(RealtimeClientEventConversationItemCreate),
    ConversationItemDelete(RealtimeClientEventConversationItemDelete),
    ConversationItemRetrieve(RealtimeClientEventConversationItemRetrieve),
    ConversationItemTruncate(RealtimeClientEventConversationItemTruncate),
    InputAudioBufferAppend(RealtimeClientEventInputAudioBufferAppend),
    InputAudioBufferClear(RealtimeClientEventInputAudioBufferClear),
    OutputAudioBufferClear(RealtimeClientEventOutputAudioBufferClear),
    InputAudioBufferCommit(RealtimeClientEventInputAudioBufferCommit),
    ResponseCancel(RealtimeClientEventResponseCancel),
    ResponseCreate(RealtimeClientEventResponseCreate),
    SessionUpdate(RealtimeClientEventSessionUpdate),
    TranscriptionSessionUpdate(RealtimeClientEventTranscriptionSessionUpdate),
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemCreate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.create`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemCreateType {
            #[default]
            #[serde(rename = "conversation.item.create")]
            ConversationItemCreate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventConversationItemCreate {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventConversationItemCreateType,
            #[serde(rename = "previous_item_id")]
            #[allow(dead_code)]
            previous_item_id: Option<String>,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let RealtimeClientEventConversationItemCreate {
            event_id,
            previous_item_id,
            item,
            ..
        } = RealtimeClientEventConversationItemCreate::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            previous_item_id,
            item,
        })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemCreate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.create`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemCreateType {
            #[default]
            #[serde(rename = "conversation.item.create")]
            ConversationItemCreate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventConversationItemCreate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventConversationItemCreateType,
            #[serde(rename = "previous_item_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            previous_item_id: &'a Option<String>,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let Self {
            event_id,
            previous_item_id,
            item,
        } = self;
        RealtimeClientEventConversationItemCreate {
            event_id,
            type_: &Default::default(),
            previous_item_id,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Add a new Item to the Conversation's context, including messages, function \ncalls, and function call responses. This event can be used both to populate a \n\"history\" of the conversation and to add new items mid-stream, but has the \ncurrent limitation that it cannot populate assistant audio messages.\n\nIf successful, the server will respond with a `conversation.item.created` \nevent, otherwise an `error` event will be sent.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemCreate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the preceding item after which the new item will be inserted. \nIf not set, the new item will be appended to the end of the conversation.\nIf set to `root`, the new item will be added to the beginning of the conversation.\nIf set to an existing ID, it allows an item to be inserted mid-conversation. If the\nID cannot be found, an error will be returned and the item will not be added.\n"]
    #[builder(default)]
    pub previous_item_id: Option<String>,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemDelete {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.delete`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemDeleteType {
            #[default]
            #[serde(rename = "conversation.item.delete")]
            ConversationItemDelete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventConversationItemDelete {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventConversationItemDeleteType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let RealtimeClientEventConversationItemDelete {
            event_id, item_id, ..
        } = RealtimeClientEventConversationItemDelete::deserialize(deserializer)?;
        Ok(Self { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemDelete {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.delete`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemDeleteType {
            #[default]
            #[serde(rename = "conversation.item.delete")]
            ConversationItemDelete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventConversationItemDelete<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventConversationItemDeleteType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self { event_id, item_id } = self;
        RealtimeClientEventConversationItemDelete {
            event_id,
            type_: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event when you want to remove any item from the conversation \nhistory. The server will respond with a `conversation.item.deleted` event, \nunless the item does not exist in the conversation history, in which case the \nserver will respond with an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemDelete {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the item to delete."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemRetrieve {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.retrieve`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemRetrieveType {
            #[default]
            #[serde(rename = "conversation.item.retrieve")]
            ConversationItemRetrieve,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventConversationItemRetrieve {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventConversationItemRetrieveType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let RealtimeClientEventConversationItemRetrieve {
            event_id, item_id, ..
        } = RealtimeClientEventConversationItemRetrieve::deserialize(deserializer)?;
        Ok(Self { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemRetrieve {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.retrieve`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemRetrieveType {
            #[default]
            #[serde(rename = "conversation.item.retrieve")]
            ConversationItemRetrieve,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventConversationItemRetrieve<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventConversationItemRetrieveType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self { event_id, item_id } = self;
        RealtimeClientEventConversationItemRetrieve {
            event_id,
            type_: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event when you want to retrieve the server's representation of a specific item in the conversation history. This is useful, for example, to inspect user audio after noise cancellation and VAD.\nThe server will respond with a `conversation.item.retrieved` event, \nunless the item does not exist in the conversation history, in which case the \nserver will respond with an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemRetrieve {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the item to retrieve."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemTruncate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.truncate`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemTruncateType {
            #[default]
            #[serde(rename = "conversation.item.truncate")]
            ConversationItemTruncate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventConversationItemTruncate {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventConversationItemTruncateType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "audio_end_ms")]
            #[allow(dead_code)]
            audio_end_ms: u64,
        }
        let RealtimeClientEventConversationItemTruncate {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
            ..
        } = RealtimeClientEventConversationItemTruncate::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemTruncate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.truncate`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventConversationItemTruncateType {
            #[default]
            #[serde(rename = "conversation.item.truncate")]
            ConversationItemTruncate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventConversationItemTruncate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventConversationItemTruncateType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a u64,
        }
        let Self {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        } = self;
        RealtimeClientEventConversationItemTruncate {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            audio_end_ms,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to truncate a previous assistant message’s audio. The server \nwill produce audio faster than realtime, so this event is useful when the user \ninterrupts to truncate audio that has already been sent to the client but not \nyet played. This will synchronize the server's understanding of the audio with \nthe client's playback.\n\nTruncating audio will delete the server-side text transcript to ensure there \nis not text in the context that hasn't been heard by the user.\n\nIf successful, the server will respond with a `conversation.item.truncated` \nevent. \n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemTruncate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the assistant message item to truncate. Only assistant message \nitems can be truncated.\n"]
    pub item_id: String,
    #[doc = "The index of the content part to truncate. Set this to 0."]
    pub content_index: u64,
    #[doc = "Inclusive duration up to which audio is truncated, in milliseconds. If \nthe audio_end_ms is greater than the actual audio duration, the server \nwill respond with an error.\n"]
    pub audio_end_ms: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferAppend {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.append`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferAppendType {
            #[default]
            #[serde(rename = "input_audio_buffer.append")]
            InputAudioBufferAppend,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventInputAudioBufferAppend {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventInputAudioBufferAppendType,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: String,
        }
        let RealtimeClientEventInputAudioBufferAppend {
            event_id, audio, ..
        } = RealtimeClientEventInputAudioBufferAppend::deserialize(deserializer)?;
        Ok(Self { event_id, audio })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferAppend {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.append`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferAppendType {
            #[default]
            #[serde(rename = "input_audio_buffer.append")]
            InputAudioBufferAppend,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventInputAudioBufferAppend<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventInputAudioBufferAppendType,
            #[serde(rename = "audio")]
            audio: &'a String,
        }
        let Self { event_id, audio } = self;
        RealtimeClientEventInputAudioBufferAppend {
            event_id,
            type_: &Default::default(),
            audio,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to append audio bytes to the input audio buffer. The audio \nbuffer is temporary storage you can write to and later commit. In Server VAD \nmode, the audio buffer is used to detect speech and the server will decide \nwhen to commit. When Server VAD is disabled, you must commit the audio buffer\nmanually.\n\nThe client may choose how much audio to place in each event up to a maximum \nof 15 MiB, for example streaming smaller chunks from the client may allow the \nVAD to be more responsive. Unlike made other client events, the server will \nnot send a confirmation response to this event.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferAppend {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "Base64-encoded audio bytes. This must be in the format specified by the \n`input_audio_format` field in the session configuration.\n"]
    pub audio: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferClear {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.clear`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferClearType {
            #[default]
            #[serde(rename = "input_audio_buffer.clear")]
            InputAudioBufferClear,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventInputAudioBufferClear {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventInputAudioBufferClearType,
        }
        let RealtimeClientEventInputAudioBufferClear { event_id, .. } =
            RealtimeClientEventInputAudioBufferClear::deserialize(deserializer)?;
        Ok(Self { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferClear {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.clear`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferClearType {
            #[default]
            #[serde(rename = "input_audio_buffer.clear")]
            InputAudioBufferClear,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventInputAudioBufferClear<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventInputAudioBufferClearType,
        }
        let Self { event_id } = self;
        RealtimeClientEventInputAudioBufferClear {
            event_id,
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to clear the audio bytes in the buffer. The server will \nrespond with an `input_audio_buffer.cleared` event.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferClear {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferCommit {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.commit`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferCommitType {
            #[default]
            #[serde(rename = "input_audio_buffer.commit")]
            InputAudioBufferCommit,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventInputAudioBufferCommit {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventInputAudioBufferCommitType,
        }
        let RealtimeClientEventInputAudioBufferCommit { event_id, .. } =
            RealtimeClientEventInputAudioBufferCommit::deserialize(deserializer)?;
        Ok(Self { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferCommit {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.commit`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventInputAudioBufferCommitType {
            #[default]
            #[serde(rename = "input_audio_buffer.commit")]
            InputAudioBufferCommit,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventInputAudioBufferCommit<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventInputAudioBufferCommitType,
        }
        let Self { event_id } = self;
        RealtimeClientEventInputAudioBufferCommit {
            event_id,
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to commit the user input audio buffer, which will create a \nnew user message item in the conversation. This event will produce an error \nif the input audio buffer is empty. When in Server VAD mode, the client does \nnot need to send this event, the server will commit the audio buffer \nautomatically.\n\nCommitting the input audio buffer will trigger input audio transcription \n(if enabled in session configuration), but it will not create a response \nfrom the model. The server will respond with an `input_audio_buffer.committed` \nevent.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferCommit {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventOutputAudioBufferClear {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `output_audio_buffer.clear`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventOutputAudioBufferClearType {
            #[default]
            #[serde(rename = "output_audio_buffer.clear")]
            OutputAudioBufferClear,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventOutputAudioBufferClear {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventOutputAudioBufferClearType,
        }
        let RealtimeClientEventOutputAudioBufferClear { event_id, .. } =
            RealtimeClientEventOutputAudioBufferClear::deserialize(deserializer)?;
        Ok(Self { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventOutputAudioBufferClear {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `output_audio_buffer.clear`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventOutputAudioBufferClearType {
            #[default]
            #[serde(rename = "output_audio_buffer.clear")]
            OutputAudioBufferClear,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventOutputAudioBufferClear<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventOutputAudioBufferClearType,
        }
        let Self { event_id } = self;
        RealtimeClientEventOutputAudioBufferClear {
            event_id,
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "**WebRTC Only:** Emit to cut off the current audio response. This will trigger the server to\nstop generating audio and emit a `output_audio_buffer.cleared` event. This \nevent should be preceded by a `response.cancel` client event to stop the \ngeneration of the current response.\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventOutputAudioBufferClear {
    #[doc = "The unique ID of the client event used for error handling."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventResponseCancel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.cancel`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventResponseCancelType {
            #[default]
            #[serde(rename = "response.cancel")]
            ResponseCancel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventResponseCancel {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventResponseCancelType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: Option<String>,
        }
        let RealtimeClientEventResponseCancel {
            event_id,
            response_id,
            ..
        } = RealtimeClientEventResponseCancel::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeClientEventResponseCancel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.cancel`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventResponseCancelType {
            #[default]
            #[serde(rename = "response.cancel")]
            ResponseCancel,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventResponseCancel<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventResponseCancelType,
            #[serde(rename = "response_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_id: &'a Option<String>,
        }
        let Self {
            event_id,
            response_id,
        } = self;
        RealtimeClientEventResponseCancel {
            event_id,
            type_: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to cancel an in-progress response. The server will respond \nwith a `response.cancelled` event or an error if there is no response to \ncancel.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventResponseCancel {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "A specific response ID to cancel - if not provided, will cancel an \nin-progress response in the default conversation.\n"]
    #[builder(default)]
    pub response_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventResponseCreate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.create`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventResponseCreateType {
            #[default]
            #[serde(rename = "response.create")]
            ResponseCreate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventResponseCreate {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventResponseCreateType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Option<RealtimeResponseCreateParams>,
        }
        let RealtimeClientEventResponseCreate {
            event_id, response, ..
        } = RealtimeClientEventResponseCreate::deserialize(deserializer)?;
        Ok(Self { event_id, response })
    }
}
impl serde::Serialize for RealtimeClientEventResponseCreate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.create`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventResponseCreateType {
            #[default]
            #[serde(rename = "response.create")]
            ResponseCreate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventResponseCreate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventResponseCreateType,
            #[serde(rename = "response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response: &'a Option<RealtimeResponseCreateParams>,
        }
        let Self { event_id, response } = self;
        RealtimeClientEventResponseCreate {
            event_id,
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "This event instructs the server to create a Response, which means triggering \nmodel inference. When in Server VAD mode, the server will create Responses \nautomatically.\n\nA Response will include at least one Item, and may have two, in which case \nthe second will be a function call. These Items will be appended to the \nconversation history.\n\nThe server will respond with a `response.created` event, events for Items \nand content created, and finally a `response.done` event to indicate the \nResponse is complete.\n\nThe `response.create` event includes inference configuration like \n`instructions`, and `temperature`. These fields will override the Session's \nconfiguration for this Response only.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventResponseCreate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub response: Option<RealtimeResponseCreateParams>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventSessionUpdate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `session.update`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventSessionUpdateType {
            #[default]
            #[serde(rename = "session.update")]
            SessionUpdate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventSessionUpdate {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventSessionUpdateType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeSessionCreateRequest,
        }
        let RealtimeClientEventSessionUpdate {
            event_id, session, ..
        } = RealtimeClientEventSessionUpdate::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeClientEventSessionUpdate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `session.update`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventSessionUpdateType {
            #[default]
            #[serde(rename = "session.update")]
            SessionUpdate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventSessionUpdate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventSessionUpdateType,
            #[serde(rename = "session")]
            session: &'a RealtimeSessionCreateRequest,
        }
        let Self { event_id, session } = self;
        RealtimeClientEventSessionUpdate {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to update the session’s default configuration.\nThe client may send this event at any time to update any field,\nexcept for `voice`. However, note that once a session has been\ninitialized with a particular `model`, it can’t be changed to\nanother model using `session.update`.\n\nWhen the server receives a `session.update`, it will respond\nwith a `session.updated` event showing the full, effective configuration.\nOnly the fields that are present are updated. To clear a field like\n`instructions`, pass an empty string.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventSessionUpdate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub session: RealtimeSessionCreateRequest,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventTranscriptionSessionUpdate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `transcription_session.update`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventTranscriptionSessionUpdateType {
            #[default]
            #[serde(rename = "transcription_session.update")]
            TranscriptionSessionUpdate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventTranscriptionSessionUpdate {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeClientEventTranscriptionSessionUpdateType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeTranscriptionSessionCreateRequest,
        }
        let RealtimeClientEventTranscriptionSessionUpdate {
            event_id, session, ..
        } = RealtimeClientEventTranscriptionSessionUpdate::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeClientEventTranscriptionSessionUpdate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `transcription_session.update`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeClientEventTranscriptionSessionUpdateType {
            #[default]
            #[serde(rename = "transcription_session.update")]
            TranscriptionSessionUpdate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventTranscriptionSessionUpdate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RealtimeClientEventTranscriptionSessionUpdateType,
            #[serde(rename = "session")]
            session: &'a RealtimeTranscriptionSessionCreateRequest,
        }
        let Self { event_id, session } = self;
        RealtimeClientEventTranscriptionSessionUpdate {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Send this event to update a transcription session.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventTranscriptionSessionUpdate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub session: RealtimeTranscriptionSessionCreateRequest,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeFunctionCallOutput {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeConversationItemType {
            Message(#[allow(dead_code)] RealtimeConversationItemTypeMessage),
            FunctionCall(#[allow(dead_code)] RealtimeConversationItemTypeFunctionCall),
            FunctionCallOutput(#[allow(dead_code)] RealtimeConversationItemTypeFunctionCallOutput),
        }
        Ok(
            match RealtimeConversationItemType::deserialize(deserializer)? {
                RealtimeConversationItemType::Message(_) => Self::Message,
                RealtimeConversationItemType::FunctionCall(_) => Self::FunctionCall,
                RealtimeConversationItemType::FunctionCallOutput(_) => Self::FunctionCallOutput,
            },
        )
    }
}
impl serde::Serialize for RealtimeConversationItemType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemTypeFunctionCallOutput {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeConversationItemType<'a> {
            Message(#[allow(dead_code)] &'a RealtimeConversationItemTypeMessage),
            FunctionCall(#[allow(dead_code)] &'a RealtimeConversationItemTypeFunctionCall),
            FunctionCallOutput(
                #[allow(dead_code)] &'a RealtimeConversationItemTypeFunctionCallOutput,
            ),
        }
        match self {
            Self::Message => {
                RealtimeConversationItemType::Message(&Default::default()).serialize(serializer)
            }
            Self::FunctionCall => RealtimeConversationItemType::FunctionCall(&Default::default())
                .serialize(serializer),
            Self::FunctionCallOutput => {
                RealtimeConversationItemType::FunctionCallOutput(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The type of the item (`message`, `function_call`, `function_call_output`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemType {
    #[doc = "message"]
    Message,
    #[doc = "function_call"]
    FunctionCall,
    #[doc = "function_call_output"]
    FunctionCallOutput,
}
#[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeConversationItemObject {
    #[default]
    #[serde(rename = "realtime.item")]
    RealtimeItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeConversationItemStatus {
            Completed(#[allow(dead_code)] RealtimeConversationItemStatusCompleted),
            Incomplete(#[allow(dead_code)] RealtimeConversationItemStatusIncomplete),
        }
        Ok(
            match RealtimeConversationItemStatus::deserialize(deserializer)? {
                RealtimeConversationItemStatus::Completed(_) => Self::Completed,
                RealtimeConversationItemStatus::Incomplete(_) => Self::Incomplete,
            },
        )
    }
}
impl serde::Serialize for RealtimeConversationItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeConversationItemStatus<'a> {
            Completed(#[allow(dead_code)] &'a RealtimeConversationItemStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a RealtimeConversationItemStatusIncomplete),
        }
        match self {
            Self::Completed => {
                RealtimeConversationItemStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => RealtimeConversationItemStatus::Incomplete(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The status of the item (`completed`, `incomplete`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemStatus {
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeConversationItemRole {
            User(#[allow(dead_code)] RealtimeConversationItemRoleUser),
            Assistant(#[allow(dead_code)] RealtimeConversationItemRoleAssistant),
            System(#[allow(dead_code)] RealtimeConversationItemRoleSystem),
        }
        Ok(
            match RealtimeConversationItemRole::deserialize(deserializer)? {
                RealtimeConversationItemRole::User(_) => Self::User,
                RealtimeConversationItemRole::Assistant(_) => Self::Assistant,
                RealtimeConversationItemRole::System(_) => Self::System,
            },
        )
    }
}
impl serde::Serialize for RealtimeConversationItemRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeConversationItemRole<'a> {
            User(#[allow(dead_code)] &'a RealtimeConversationItemRoleUser),
            Assistant(#[allow(dead_code)] &'a RealtimeConversationItemRoleAssistant),
            System(#[allow(dead_code)] &'a RealtimeConversationItemRoleSystem),
        }
        match self {
            Self::User => {
                RealtimeConversationItemRole::User(&Default::default()).serialize(serializer)
            }
            Self::Assistant => {
                RealtimeConversationItemRole::Assistant(&Default::default()).serialize(serializer)
            }
            Self::System => {
                RealtimeConversationItemRole::System(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "system"]
    System,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeConversationItem {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeConversationItemType>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<RealtimeConversationItemObject>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<RealtimeConversationItemStatus>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<RealtimeConversationItemRole>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<RealtimeConversationItemContent>>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let RealtimeConversationItem {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
            ..
        } = RealtimeConversationItem::deserialize(deserializer)?;
        Ok(Self {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        })
    }
}
impl serde::Serialize for RealtimeConversationItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeConversationItem<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeConversationItemType>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<RealtimeConversationItemObject>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<RealtimeConversationItemStatus>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<RealtimeConversationItemRole>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<RealtimeConversationItemContent>>,
            #[serde(rename = "call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            call_id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let Self {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        } = self;
        RealtimeConversationItem {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        }
        .serialize(serializer)
    }
}
#[doc = "The item to add to the conversation."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItem {
    #[doc = "The unique ID of the item, this can be generated by the client to help \nmanage server-side context, but is not required because the server will \ngenerate one if not provided.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the item (`message`, `function_call`, `function_call_output`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeConversationItemType>,
    #[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
    #[builder(default)]
    pub object: Option<RealtimeConversationItemObject>,
    #[doc = "The status of the item (`completed`, `incomplete`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
    #[builder(default)]
    pub status: Option<RealtimeConversationItemStatus>,
    #[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
    #[builder(default)]
    pub role: Option<RealtimeConversationItemRole>,
    #[doc = "The content of the message, applicable for `message` items. \n- Message items of role `system` support only `input_text` content\n- Message items of role `user` support `input_text` and `input_audio` \n  content\n- Message items of role `assistant` support `text` content.\n"]
    #[builder(default)]
    pub content: Option<Vec<RealtimeConversationItemContent>>,
    #[doc = "The ID of the function call (for `function_call` and \n`function_call_output` items). If passed on a `function_call_output` \nitem, the server will check that a `function_call` item with the same \nID exists in the conversation history.\n"]
    #[builder(default)]
    pub call_id: Option<String>,
    #[doc = "The name of the function being called (for `function_call` items).\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments of the function call (for `function_call` items).\n"]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The output of the function call (for `function_call_output` items).\n"]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReferenceType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeFunctionCallOutput {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeConversationItemWithReferenceType {
            Message(#[allow(dead_code)] RealtimeConversationItemWithReferenceTypeMessage),
            FunctionCall(#[allow(dead_code)] RealtimeConversationItemWithReferenceTypeFunctionCall),
            FunctionCallOutput(
                #[allow(dead_code)] RealtimeConversationItemWithReferenceTypeFunctionCallOutput,
            ),
            ItemReference(
                #[allow(dead_code)] RealtimeConversationItemWithReferenceTypeItemReference,
            ),
        }
        Ok(
            match RealtimeConversationItemWithReferenceType::deserialize(deserializer)? {
                RealtimeConversationItemWithReferenceType::Message(_) => Self::Message,
                RealtimeConversationItemWithReferenceType::FunctionCall(_) => Self::FunctionCall,
                RealtimeConversationItemWithReferenceType::FunctionCallOutput(_) => {
                    Self::FunctionCallOutput
                }
                RealtimeConversationItemWithReferenceType::ItemReference(_) => Self::ItemReference,
            },
        )
    }
}
impl serde::Serialize for RealtimeConversationItemWithReferenceType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeMessage {
            #[default]
            #[serde(rename = "message")]
            Message,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeFunctionCall {
            #[default]
            #[serde(rename = "function_call")]
            FunctionCall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeFunctionCallOutput {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeConversationItemWithReferenceType<'a> {
            Message(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceTypeMessage),
            FunctionCall(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceTypeFunctionCall,
            ),
            FunctionCallOutput(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceTypeFunctionCallOutput,
            ),
            ItemReference(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceTypeItemReference,
            ),
        }
        match self {
            Self::Message => {
                RealtimeConversationItemWithReferenceType::Message(&Default::default())
                    .serialize(serializer)
            }
            Self::FunctionCall => {
                RealtimeConversationItemWithReferenceType::FunctionCall(&Default::default())
                    .serialize(serializer)
            }
            Self::FunctionCallOutput => {
                RealtimeConversationItemWithReferenceType::FunctionCallOutput(&Default::default())
                    .serialize(serializer)
            }
            Self::ItemReference => {
                RealtimeConversationItemWithReferenceType::ItemReference(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The type of the item (`message`, `function_call`, `function_call_output`, `item_reference`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemWithReferenceType {
    #[doc = "message"]
    Message,
    #[doc = "function_call"]
    FunctionCall,
    #[doc = "function_call_output"]
    FunctionCallOutput,
    #[doc = "item_reference"]
    ItemReference,
}
#[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeConversationItemWithReferenceObject {
    #[default]
    #[serde(rename = "realtime.item")]
    RealtimeItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReferenceStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeConversationItemWithReferenceStatus {
            Completed(#[allow(dead_code)] RealtimeConversationItemWithReferenceStatusCompleted),
            Incomplete(#[allow(dead_code)] RealtimeConversationItemWithReferenceStatusIncomplete),
        }
        Ok(
            match RealtimeConversationItemWithReferenceStatus::deserialize(deserializer)? {
                RealtimeConversationItemWithReferenceStatus::Completed(_) => Self::Completed,
                RealtimeConversationItemWithReferenceStatus::Incomplete(_) => Self::Incomplete,
            },
        )
    }
}
impl serde::Serialize for RealtimeConversationItemWithReferenceStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeConversationItemWithReferenceStatus<'a> {
            Completed(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceStatusCompleted),
            Incomplete(
                #[allow(dead_code)] &'a RealtimeConversationItemWithReferenceStatusIncomplete,
            ),
        }
        match self {
            Self::Completed => {
                RealtimeConversationItemWithReferenceStatus::Completed(&Default::default())
                    .serialize(serializer)
            }
            Self::Incomplete => {
                RealtimeConversationItemWithReferenceStatus::Incomplete(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the item (`completed`, `incomplete`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemWithReferenceStatus {
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReferenceRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeConversationItemWithReferenceRole {
            User(#[allow(dead_code)] RealtimeConversationItemWithReferenceRoleUser),
            Assistant(#[allow(dead_code)] RealtimeConversationItemWithReferenceRoleAssistant),
            System(#[allow(dead_code)] RealtimeConversationItemWithReferenceRoleSystem),
        }
        Ok(
            match RealtimeConversationItemWithReferenceRole::deserialize(deserializer)? {
                RealtimeConversationItemWithReferenceRole::User(_) => Self::User,
                RealtimeConversationItemWithReferenceRole::Assistant(_) => Self::Assistant,
                RealtimeConversationItemWithReferenceRole::System(_) => Self::System,
            },
        )
    }
}
impl serde::Serialize for RealtimeConversationItemWithReferenceRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleUser {
            #[default]
            #[serde(rename = "user")]
            User,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleAssistant {
            #[default]
            #[serde(rename = "assistant")]
            Assistant,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemWithReferenceRoleSystem {
            #[default]
            #[serde(rename = "system")]
            System,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeConversationItemWithReferenceRole<'a> {
            User(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceRoleUser),
            Assistant(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceRoleAssistant),
            System(#[allow(dead_code)] &'a RealtimeConversationItemWithReferenceRoleSystem),
        }
        match self {
            Self::User => RealtimeConversationItemWithReferenceRole::User(&Default::default())
                .serialize(serializer),
            Self::Assistant => {
                RealtimeConversationItemWithReferenceRole::Assistant(&Default::default())
                    .serialize(serializer)
            }
            Self::System => RealtimeConversationItemWithReferenceRole::System(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemWithReferenceRole {
    #[doc = "user"]
    User,
    #[doc = "assistant"]
    Assistant,
    #[doc = "system"]
    System,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemWithReference {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeConversationItemWithReference {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeConversationItemWithReferenceType>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<RealtimeConversationItemWithReferenceObject>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<RealtimeConversationItemWithReferenceStatus>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: Option<RealtimeConversationItemWithReferenceRole>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<RealtimeConversationItemContent>>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let RealtimeConversationItemWithReference {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
            ..
        } = RealtimeConversationItemWithReference::deserialize(deserializer)?;
        Ok(Self {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemWithReference {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeConversationItemWithReference<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeConversationItemWithReferenceType>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<RealtimeConversationItemWithReferenceObject>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<RealtimeConversationItemWithReferenceStatus>,
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            role: &'a Option<RealtimeConversationItemWithReferenceRole>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<RealtimeConversationItemContent>>,
            #[serde(rename = "call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            call_id: &'a Option<String>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let Self {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        } = self;
        RealtimeConversationItemWithReference {
            id,
            type_,
            object,
            status,
            role,
            content,
            call_id,
            name,
            arguments,
            output,
        }
        .serialize(serializer)
    }
}
#[doc = "The item to add to the conversation."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItemWithReference {
    #[doc = "For an item of type (`message` | `function_call` | `function_call_output`)\nthis field allows the client to assign the unique ID of the item. It is\nnot required because the server will generate one if not provided.\n\nFor an item of type `item_reference`, this field is required and is a\nreference to any item that has previously existed in the conversation.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the item (`message`, `function_call`, `function_call_output`, `item_reference`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeConversationItemWithReferenceType>,
    #[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
    #[builder(default)]
    pub object: Option<RealtimeConversationItemWithReferenceObject>,
    #[doc = "The status of the item (`completed`, `incomplete`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
    #[builder(default)]
    pub status: Option<RealtimeConversationItemWithReferenceStatus>,
    #[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
    #[builder(default)]
    pub role: Option<RealtimeConversationItemWithReferenceRole>,
    #[doc = "The content of the message, applicable for `message` items. \n- Message items of role `system` support only `input_text` content\n- Message items of role `user` support `input_text` and `input_audio` \n  content\n- Message items of role `assistant` support `text` content.\n"]
    #[builder(default)]
    pub content: Option<Vec<RealtimeConversationItemContent>>,
    #[doc = "The ID of the function call (for `function_call` and \n`function_call_output` items). If passed on a `function_call_output` \nitem, the server will check that a `function_call` item with the same \nID exists in the conversation history.\n"]
    #[builder(default)]
    pub call_id: Option<String>,
    #[doc = "The name of the function being called (for `function_call` items).\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments of the function call (for `function_call` items).\n"]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The output of the function call (for `function_call_output` items).\n"]
    #[builder(default)]
    pub output: Option<String>,
}
#[doc = "The object type, must be `realtime.response`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeResponseObject {
    #[default]
    #[serde(rename = "realtime.response")]
    RealtimeResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseStatus {
            Completed(#[allow(dead_code)] RealtimeResponseStatusCompleted),
            Cancelled(#[allow(dead_code)] RealtimeResponseStatusCancelled),
            Failed(#[allow(dead_code)] RealtimeResponseStatusFailed),
            Incomplete(#[allow(dead_code)] RealtimeResponseStatusIncomplete),
        }
        Ok(match RealtimeResponseStatus::deserialize(deserializer)? {
            RealtimeResponseStatus::Completed(_) => Self::Completed,
            RealtimeResponseStatus::Cancelled(_) => Self::Cancelled,
            RealtimeResponseStatus::Failed(_) => Self::Failed,
            RealtimeResponseStatus::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for RealtimeResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseStatus<'a> {
            Completed(#[allow(dead_code)] &'a RealtimeResponseStatusCompleted),
            Cancelled(#[allow(dead_code)] &'a RealtimeResponseStatusCancelled),
            Failed(#[allow(dead_code)] &'a RealtimeResponseStatusFailed),
            Incomplete(#[allow(dead_code)] &'a RealtimeResponseStatusIncomplete),
        }
        match self {
            Self::Completed => {
                RealtimeResponseStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Cancelled => {
                RealtimeResponseStatus::Cancelled(&Default::default()).serialize(serializer)
            }
            Self::Failed => {
                RealtimeResponseStatus::Failed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                RealtimeResponseStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The final status of the response (`completed`, `cancelled`, `failed`, or \n`incomplete`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseStatus {
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatusDetailsType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseStatusDetailsType {
            Completed(#[allow(dead_code)] RealtimeResponseStatusDetailsTypeCompleted),
            Cancelled(#[allow(dead_code)] RealtimeResponseStatusDetailsTypeCancelled),
            Incomplete(#[allow(dead_code)] RealtimeResponseStatusDetailsTypeIncomplete),
            Failed(#[allow(dead_code)] RealtimeResponseStatusDetailsTypeFailed),
        }
        Ok(
            match RealtimeResponseStatusDetailsType::deserialize(deserializer)? {
                RealtimeResponseStatusDetailsType::Completed(_) => Self::Completed,
                RealtimeResponseStatusDetailsType::Cancelled(_) => Self::Cancelled,
                RealtimeResponseStatusDetailsType::Incomplete(_) => Self::Incomplete,
                RealtimeResponseStatusDetailsType::Failed(_) => Self::Failed,
            },
        )
    }
}
impl serde::Serialize for RealtimeResponseStatusDetailsType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsTypeFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseStatusDetailsType<'a> {
            Completed(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsTypeCompleted),
            Cancelled(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsTypeCancelled),
            Incomplete(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsTypeIncomplete),
            Failed(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsTypeFailed),
        }
        match self {
            Self::Completed => RealtimeResponseStatusDetailsType::Completed(&Default::default())
                .serialize(serializer),
            Self::Cancelled => RealtimeResponseStatusDetailsType::Cancelled(&Default::default())
                .serialize(serializer),
            Self::Incomplete => RealtimeResponseStatusDetailsType::Incomplete(&Default::default())
                .serialize(serializer),
            Self::Failed => {
                RealtimeResponseStatusDetailsType::Failed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of error that caused the response to fail, corresponding \nwith the `status` field (`completed`, `cancelled`, `incomplete`, \n`failed`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseStatusDetailsType {
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "incomplete"]
    Incomplete,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatusDetailsReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonTurnDetected {
            #[default]
            #[serde(rename = "turn_detected")]
            TurnDetected,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonClientCancelled {
            #[default]
            #[serde(rename = "client_cancelled")]
            ClientCancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonMaxOutputTokens {
            #[default]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseStatusDetailsReason {
            TurnDetected(#[allow(dead_code)] RealtimeResponseStatusDetailsReasonTurnDetected),
            ClientCancelled(#[allow(dead_code)] RealtimeResponseStatusDetailsReasonClientCancelled),
            MaxOutputTokens(#[allow(dead_code)] RealtimeResponseStatusDetailsReasonMaxOutputTokens),
            ContentFilter(#[allow(dead_code)] RealtimeResponseStatusDetailsReasonContentFilter),
        }
        Ok(
            match RealtimeResponseStatusDetailsReason::deserialize(deserializer)? {
                RealtimeResponseStatusDetailsReason::TurnDetected(_) => Self::TurnDetected,
                RealtimeResponseStatusDetailsReason::ClientCancelled(_) => Self::ClientCancelled,
                RealtimeResponseStatusDetailsReason::MaxOutputTokens(_) => Self::MaxOutputTokens,
                RealtimeResponseStatusDetailsReason::ContentFilter(_) => Self::ContentFilter,
            },
        )
    }
}
impl serde::Serialize for RealtimeResponseStatusDetailsReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonTurnDetected {
            #[default]
            #[serde(rename = "turn_detected")]
            TurnDetected,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonClientCancelled {
            #[default]
            #[serde(rename = "client_cancelled")]
            ClientCancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonMaxOutputTokens {
            #[default]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseStatusDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseStatusDetailsReason<'a> {
            TurnDetected(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsReasonTurnDetected),
            ClientCancelled(
                #[allow(dead_code)] &'a RealtimeResponseStatusDetailsReasonClientCancelled,
            ),
            MaxOutputTokens(
                #[allow(dead_code)] &'a RealtimeResponseStatusDetailsReasonMaxOutputTokens,
            ),
            ContentFilter(#[allow(dead_code)] &'a RealtimeResponseStatusDetailsReasonContentFilter),
        }
        match self {
            Self::TurnDetected => {
                RealtimeResponseStatusDetailsReason::TurnDetected(&Default::default())
                    .serialize(serializer)
            }
            Self::ClientCancelled => {
                RealtimeResponseStatusDetailsReason::ClientCancelled(&Default::default())
                    .serialize(serializer)
            }
            Self::MaxOutputTokens => {
                RealtimeResponseStatusDetailsReason::MaxOutputTokens(&Default::default())
                    .serialize(serializer)
            }
            Self::ContentFilter => {
                RealtimeResponseStatusDetailsReason::ContentFilter(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The reason the Response did not complete. For a `cancelled` Response, \none of `turn_detected` (the server VAD detected a new start of speech) \nor `client_cancelled` (the client sent a cancel event). For an \n`incomplete` Response, one of `max_output_tokens` or `content_filter` \n(the server-side safety filter activated and cut off the response).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseStatusDetailsReason {
    #[doc = "turn_detected"]
    TurnDetected,
    #[doc = "client_cancelled"]
    ClientCancelled,
    #[doc = "max_output_tokens"]
    MaxOutputTokens,
    #[doc = "content_filter"]
    ContentFilter,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatusDetailsError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeResponseStatusDetailsError {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
        }
        let RealtimeResponseStatusDetailsError { type_, code, .. } =
            RealtimeResponseStatusDetailsError::deserialize(deserializer)?;
        Ok(Self { type_, code })
    }
}
impl serde::Serialize for RealtimeResponseStatusDetailsError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeResponseStatusDetailsError<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
        }
        let Self { type_, code } = self;
        RealtimeResponseStatusDetailsError { type_, code }.serialize(serializer)
    }
}
#[doc = "A description of the error that caused the response to fail, \npopulated when the `status` is `failed`.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseStatusDetailsError {
    #[doc = "The type of error."]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "Error code, if any."]
    #[builder(default)]
    pub code: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseStatusDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeResponseStatusDetails {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeResponseStatusDetailsType>,
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: Option<RealtimeResponseStatusDetailsReason>,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<RealtimeResponseStatusDetailsError>,
        }
        let RealtimeResponseStatusDetails {
            type_,
            reason,
            error,
            ..
        } = RealtimeResponseStatusDetails::deserialize(deserializer)?;
        Ok(Self {
            type_,
            reason,
            error,
        })
    }
}
impl serde::Serialize for RealtimeResponseStatusDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeResponseStatusDetails<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeResponseStatusDetailsType>,
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<RealtimeResponseStatusDetailsReason>,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<RealtimeResponseStatusDetailsError>,
        }
        let Self {
            type_,
            reason,
            error,
        } = self;
        RealtimeResponseStatusDetails {
            type_,
            reason,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "Additional details about the status."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseStatusDetails {
    #[doc = "The type of error that caused the response to fail, corresponding \nwith the `status` field (`completed`, `cancelled`, `incomplete`, \n`failed`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeResponseStatusDetailsType>,
    #[doc = "The reason the Response did not complete. For a `cancelled` Response, \none of `turn_detected` (the server VAD detected a new start of speech) \nor `client_cancelled` (the client sent a cancel event). For an \n`incomplete` Response, one of `max_output_tokens` or `content_filter` \n(the server-side safety filter activated and cut off the response).\n"]
    #[builder(default)]
    pub reason: Option<RealtimeResponseStatusDetailsReason>,
    #[doc = "A description of the error that caused the response to fail, \npopulated when the `status` is `failed`.\n"]
    #[builder(default)]
    pub error: Option<RealtimeResponseStatusDetailsError>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseUsageInputTokenDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeResponseUsageInputTokenDetails {
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: Option<u64>,
            #[serde(rename = "text_tokens")]
            #[allow(dead_code)]
            text_tokens: Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[allow(dead_code)]
            audio_tokens: Option<u64>,
        }
        let RealtimeResponseUsageInputTokenDetails {
            cached_tokens,
            text_tokens,
            audio_tokens,
            ..
        } = RealtimeResponseUsageInputTokenDetails::deserialize(deserializer)?;
        Ok(Self {
            cached_tokens,
            text_tokens,
            audio_tokens,
        })
    }
}
impl serde::Serialize for RealtimeResponseUsageInputTokenDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeResponseUsageInputTokenDetails<'a> {
            #[serde(rename = "cached_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cached_tokens: &'a Option<u64>,
            #[serde(rename = "text_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text_tokens: &'a Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio_tokens: &'a Option<u64>,
        }
        let Self {
            cached_tokens,
            text_tokens,
            audio_tokens,
        } = self;
        RealtimeResponseUsageInputTokenDetails {
            cached_tokens,
            text_tokens,
            audio_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Details about the input tokens used in the Response."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseUsageInputTokenDetails {
    #[doc = "The number of cached tokens used in the Response."]
    #[builder(default)]
    pub cached_tokens: Option<u64>,
    #[doc = "The number of text tokens used in the Response."]
    #[builder(default)]
    pub text_tokens: Option<u64>,
    #[doc = "The number of audio tokens used in the Response."]
    #[builder(default)]
    pub audio_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseUsageOutputTokenDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeResponseUsageOutputTokenDetails {
            #[serde(rename = "text_tokens")]
            #[allow(dead_code)]
            text_tokens: Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[allow(dead_code)]
            audio_tokens: Option<u64>,
        }
        let RealtimeResponseUsageOutputTokenDetails {
            text_tokens,
            audio_tokens,
            ..
        } = RealtimeResponseUsageOutputTokenDetails::deserialize(deserializer)?;
        Ok(Self {
            text_tokens,
            audio_tokens,
        })
    }
}
impl serde::Serialize for RealtimeResponseUsageOutputTokenDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeResponseUsageOutputTokenDetails<'a> {
            #[serde(rename = "text_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text_tokens: &'a Option<u64>,
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio_tokens: &'a Option<u64>,
        }
        let Self {
            text_tokens,
            audio_tokens,
        } = self;
        RealtimeResponseUsageOutputTokenDetails {
            text_tokens,
            audio_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Details about the output tokens used in the Response."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseUsageOutputTokenDetails {
    #[doc = "The number of text tokens used in the Response."]
    #[builder(default)]
    pub text_tokens: Option<u64>,
    #[doc = "The number of audio tokens used in the Response."]
    #[builder(default)]
    pub audio_tokens: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeResponseUsage {
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: Option<u64>,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: Option<u64>,
            #[serde(rename = "output_tokens")]
            #[allow(dead_code)]
            output_tokens: Option<u64>,
            #[serde(rename = "input_token_details")]
            #[allow(dead_code)]
            input_token_details: Option<RealtimeResponseUsageInputTokenDetails>,
            #[serde(rename = "output_token_details")]
            #[allow(dead_code)]
            output_token_details: Option<RealtimeResponseUsageOutputTokenDetails>,
        }
        let RealtimeResponseUsage {
            total_tokens,
            input_tokens,
            output_tokens,
            input_token_details,
            output_token_details,
            ..
        } = RealtimeResponseUsage::deserialize(deserializer)?;
        Ok(Self {
            total_tokens,
            input_tokens,
            output_tokens,
            input_token_details,
            output_token_details,
        })
    }
}
impl serde::Serialize for RealtimeResponseUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeResponseUsage<'a> {
            #[serde(rename = "total_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            total_tokens: &'a Option<u64>,
            #[serde(rename = "input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_tokens: &'a Option<u64>,
            #[serde(rename = "output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_tokens: &'a Option<u64>,
            #[serde(rename = "input_token_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_token_details: &'a Option<RealtimeResponseUsageInputTokenDetails>,
            #[serde(rename = "output_token_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_token_details: &'a Option<RealtimeResponseUsageOutputTokenDetails>,
        }
        let Self {
            total_tokens,
            input_tokens,
            output_tokens,
            input_token_details,
            output_token_details,
        } = self;
        RealtimeResponseUsage {
            total_tokens,
            input_tokens,
            output_tokens,
            input_token_details,
            output_token_details,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics for the Response, this will correspond to billing. A \nRealtime API session will maintain a conversation context and append new \nItems to the Conversation, thus output from previous turns (text and \naudio tokens) will become the input for later turns.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseUsage {
    #[doc = "The total number of tokens in the Response including input and output \ntext and audio tokens.\n"]
    #[builder(default)]
    pub total_tokens: Option<u64>,
    #[doc = "The number of input tokens used in the Response, including text and \naudio tokens.\n"]
    #[builder(default)]
    pub input_tokens: Option<u64>,
    #[doc = "The number of output tokens sent in the Response, including text and \naudio tokens.\n"]
    #[builder(default)]
    pub output_tokens: Option<u64>,
    #[doc = "Details about the input tokens used in the Response."]
    #[builder(default)]
    pub input_token_details: Option<RealtimeResponseUsageInputTokenDetails>,
    #[doc = "Details about the output tokens used in the Response."]
    #[builder(default)]
    pub output_token_details: Option<RealtimeResponseUsageOutputTokenDetails>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseModality {
            Text(#[allow(dead_code)] RealtimeResponseModalityText),
            Audio(#[allow(dead_code)] RealtimeResponseModalityAudio),
        }
        Ok(match RealtimeResponseModality::deserialize(deserializer)? {
            RealtimeResponseModality::Text(_) => Self::Text,
            RealtimeResponseModality::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeResponseModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseModality<'a> {
            Text(#[allow(dead_code)] &'a RealtimeResponseModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeResponseModalityAudio),
        }
        match self {
            Self::Text => RealtimeResponseModality::Text(&Default::default()).serialize(serializer),
            Self::Audio => {
                RealtimeResponseModality::Audio(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseOutputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseOutputAudioFormat {
            Pcm16(#[allow(dead_code)] RealtimeResponseOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeResponseOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeResponseOutputAudioFormatG711Alaw),
        }
        Ok(
            match RealtimeResponseOutputAudioFormat::deserialize(deserializer)? {
                RealtimeResponseOutputAudioFormat::Pcm16(_) => Self::Pcm16,
                RealtimeResponseOutputAudioFormat::G711Ulaw(_) => Self::G711Ulaw,
                RealtimeResponseOutputAudioFormat::G711Alaw(_) => Self::G711Alaw,
            },
        )
    }
}
impl serde::Serialize for RealtimeResponseOutputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseOutputAudioFormat<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeResponseOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeResponseOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeResponseOutputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => {
                RealtimeResponseOutputAudioFormat::Pcm16(&Default::default()).serialize(serializer)
            }
            Self::G711Ulaw => RealtimeResponseOutputAudioFormat::G711Ulaw(&Default::default())
                .serialize(serializer),
            Self::G711Alaw => RealtimeResponseOutputAudioFormat::G711Alaw(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseOutputAudioFormat {
    #[doc = "pcm16"]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseMaxOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseMaxOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseMaxOutputTokens {
            Inf(#[allow(dead_code)] RealtimeResponseMaxOutputTokensInf),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match RealtimeResponseMaxOutputTokens::deserialize(deserializer)? {
                RealtimeResponseMaxOutputTokens::Integer(_v) => Self::Integer(_v),
                RealtimeResponseMaxOutputTokens::Inf(_) => Self::Inf,
            },
        )
    }
}
impl serde::Serialize for RealtimeResponseMaxOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseMaxOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseMaxOutputTokens<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeResponseMaxOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => RealtimeResponseMaxOutputTokens::Integer(_v).serialize(serializer),
            Self::Inf => {
                RealtimeResponseMaxOutputTokens::Inf(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls, that was used in this response.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseMaxOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeResponse {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<RealtimeResponseObject>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<RealtimeResponseStatus>,
            #[serde(rename = "status_details")]
            #[allow(dead_code)]
            status_details: Option<RealtimeResponseStatusDetails>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<Vec<RealtimeConversationItem>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<RealtimeResponseUsage>,
            #[serde(rename = "conversation_id")]
            #[allow(dead_code)]
            conversation_id: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeResponseModality>>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<RealtimeResponseOutputAudioFormat>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_output_tokens")]
            #[allow(dead_code)]
            max_output_tokens: Option<RealtimeResponseMaxOutputTokens>,
        }
        let RealtimeResponse {
            id,
            object,
            status,
            status_details,
            output,
            metadata,
            usage,
            conversation_id,
            voice,
            modalities,
            output_audio_format,
            temperature,
            max_output_tokens,
            ..
        } = RealtimeResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            object,
            status,
            status_details,
            output,
            metadata,
            usage,
            conversation_id,
            voice,
            modalities,
            output_audio_format,
            temperature,
            max_output_tokens,
        })
    }
}
impl serde::Serialize for RealtimeResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeResponse<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<RealtimeResponseObject>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<RealtimeResponseStatus>,
            #[serde(rename = "status_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status_details: &'a Option<RealtimeResponseStatusDetails>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<Vec<RealtimeConversationItem>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<RealtimeResponseUsage>,
            #[serde(rename = "conversation_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            conversation_id: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeResponseModality>>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<RealtimeResponseOutputAudioFormat>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_output_tokens: &'a Option<RealtimeResponseMaxOutputTokens>,
        }
        let Self {
            id,
            object,
            status,
            status_details,
            output,
            metadata,
            usage,
            conversation_id,
            voice,
            modalities,
            output_audio_format,
            temperature,
            max_output_tokens,
        } = self;
        RealtimeResponse {
            id,
            object,
            status,
            status_details,
            output,
            metadata,
            usage,
            conversation_id,
            voice,
            modalities,
            output_audio_format,
            temperature,
            max_output_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "The response resource."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponse {
    #[doc = "The unique ID of the response."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The object type, must be `realtime.response`."]
    #[builder(default)]
    pub object: Option<RealtimeResponseObject>,
    #[doc = "The final status of the response (`completed`, `cancelled`, `failed`, or \n`incomplete`).\n"]
    #[builder(default)]
    pub status: Option<RealtimeResponseStatus>,
    #[doc = "Additional details about the status."]
    #[builder(default)]
    pub status_details: Option<RealtimeResponseStatusDetails>,
    #[doc = "The list of output items generated by the response."]
    #[builder(default)]
    pub output: Option<Vec<RealtimeConversationItem>>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "Usage statistics for the Response, this will correspond to billing. A \nRealtime API session will maintain a conversation context and append new \nItems to the Conversation, thus output from previous turns (text and \naudio tokens) will become the input for later turns.\n"]
    #[builder(default)]
    pub usage: Option<RealtimeResponseUsage>,
    #[doc = "Which conversation the response is added to, determined by the `conversation`\nfield in the `response.create` event. If `auto`, the response will be added to\nthe default conversation and the value of `conversation_id` will be an id like\n`conv_1234`. If `none`, the response will not be added to any conversation and\nthe value of `conversation_id` will be `null`. If responses are being triggered\nby server VAD, the response will be added to the default conversation, thus\nthe `conversation_id` will be an id like `conv_1234`.\n"]
    #[builder(default)]
    pub conversation_id: Option<String>,
    #[doc = "The voice the model used to respond.\nCurrent voice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`,\n`onyx`, `nova`, `sage`, `shimmer`, and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The set of modalities the model used to respond. If there are multiple modalities,\nthe model will pick one, for example if `modalities` is `[\"text\", \"audio\"]`, the model\ncould be responding in either text or audio.\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeResponseModality>>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub output_audio_format: Option<RealtimeResponseOutputAudioFormat>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls, that was used in this response.\n"]
    #[builder(default)]
    pub max_output_tokens: Option<RealtimeResponseMaxOutputTokens>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseCreateParamsModality {
            Text(#[allow(dead_code)] RealtimeResponseCreateParamsModalityText),
            Audio(#[allow(dead_code)] RealtimeResponseCreateParamsModalityAudio),
        }
        Ok(
            match RealtimeResponseCreateParamsModality::deserialize(deserializer)? {
                RealtimeResponseCreateParamsModality::Text(_) => Self::Text,
                RealtimeResponseCreateParamsModality::Audio(_) => Self::Audio,
            },
        )
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseCreateParamsModality<'a> {
            Text(#[allow(dead_code)] &'a RealtimeResponseCreateParamsModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeResponseCreateParamsModalityAudio),
        }
        match self {
            Self::Text => RealtimeResponseCreateParamsModality::Text(&Default::default())
                .serialize(serializer),
            Self::Audio => RealtimeResponseCreateParamsModality::Audio(&Default::default())
                .serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsOutputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseCreateParamsOutputAudioFormat {
            Pcm16(#[allow(dead_code)] RealtimeResponseCreateParamsOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeResponseCreateParamsOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeResponseCreateParamsOutputAudioFormatG711Alaw),
        }
        Ok(
            match RealtimeResponseCreateParamsOutputAudioFormat::deserialize(deserializer)? {
                RealtimeResponseCreateParamsOutputAudioFormat::Pcm16(_) => Self::Pcm16,
                RealtimeResponseCreateParamsOutputAudioFormat::G711Ulaw(_) => Self::G711Ulaw,
                RealtimeResponseCreateParamsOutputAudioFormat::G711Alaw(_) => Self::G711Alaw,
            },
        )
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsOutputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseCreateParamsOutputAudioFormat<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeResponseCreateParamsOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeResponseCreateParamsOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeResponseCreateParamsOutputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => {
                RealtimeResponseCreateParamsOutputAudioFormat::Pcm16(&Default::default())
                    .serialize(serializer)
            }
            Self::G711Ulaw => {
                RealtimeResponseCreateParamsOutputAudioFormat::G711Ulaw(&Default::default())
                    .serialize(serializer)
            }
            Self::G711Alaw => {
                RealtimeResponseCreateParamsOutputAudioFormat::G711Alaw(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsOutputAudioFormat {
    #[doc = "pcm16"]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
#[doc = "The type of the tool, i.e. `function`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeResponseCreateParamsToolType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeResponseCreateParamsTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeResponseCreateParamsToolType>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeResponseCreateParamsTool {
            type_,
            name,
            description,
            parameters,
            ..
        } = RealtimeResponseCreateParamsTool::deserialize(deserializer)?;
        Ok(Self {
            type_,
            name,
            description,
            parameters,
        })
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeResponseCreateParamsTool<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeResponseCreateParamsToolType>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            type_,
            name,
            description,
            parameters,
        } = self;
        RealtimeResponseCreateParamsTool {
            type_,
            name,
            description,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseCreateParamsTool {
    #[doc = "The type of the tool, i.e. `function`."]
    #[builder(default)]
    pub type_: Option<RealtimeResponseCreateParamsToolType>,
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "Parameters of the function in JSON Schema."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsMaxResponseOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseCreateParamsMaxResponseOutputTokens {
            Inf(#[allow(dead_code)] RealtimeResponseCreateParamsMaxResponseOutputTokensInf),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match RealtimeResponseCreateParamsMaxResponseOutputTokens::deserialize(deserializer)? {
                RealtimeResponseCreateParamsMaxResponseOutputTokens::Integer(_v) => {
                    Self::Integer(_v)
                }
                RealtimeResponseCreateParamsMaxResponseOutputTokens::Inf(_) => Self::Inf,
            },
        )
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsMaxResponseOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseCreateParamsMaxResponseOutputTokens<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeResponseCreateParamsMaxResponseOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => RealtimeResponseCreateParamsMaxResponseOutputTokens::Integer(_v)
                .serialize(serializer),
            Self::Inf => {
                RealtimeResponseCreateParamsMaxResponseOutputTokens::Inf(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsMaxResponseOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParamsConversation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsConversationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsConversationNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeResponseCreateParamsConversation {
            Auto(#[allow(dead_code)] RealtimeResponseCreateParamsConversationAuto),
            None(#[allow(dead_code)] RealtimeResponseCreateParamsConversationNone),
            Other(#[allow(dead_code)] String),
        }
        Ok(
            match RealtimeResponseCreateParamsConversation::deserialize(deserializer)? {
                RealtimeResponseCreateParamsConversation::Other(_v) => Self::Other(_v),
                RealtimeResponseCreateParamsConversation::Auto(_) => Self::Auto,
                RealtimeResponseCreateParamsConversation::None(_) => Self::None,
            },
        )
    }
}
impl serde::Serialize for RealtimeResponseCreateParamsConversation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsConversationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeResponseCreateParamsConversationNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeResponseCreateParamsConversation<'a> {
            Other(#[allow(dead_code)] &'a String),
            Auto(#[allow(dead_code)] &'a RealtimeResponseCreateParamsConversationAuto),
            None(#[allow(dead_code)] &'a RealtimeResponseCreateParamsConversationNone),
        }
        match self {
            Self::Other(_v) => {
                RealtimeResponseCreateParamsConversation::Other(_v).serialize(serializer)
            }
            Self::Auto => RealtimeResponseCreateParamsConversation::Auto(&Default::default())
                .serialize(serializer),
            Self::None => RealtimeResponseCreateParamsConversation::None(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "Controls which conversation the response is added to. Currently supports\n`auto` and `none`, with `auto` as the default value. The `auto` value\nmeans that the contents of the response will be added to the default\nconversation. Set this to `none` to create an out-of-band response which \nwill not add items to default conversation.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeResponseCreateParamsConversation {
    Other(String),
    #[doc = "auto"]
    Auto,
    #[doc = "none"]
    None,
}
impl<'de> serde::Deserialize<'de> for RealtimeResponseCreateParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeResponseCreateParams {
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeResponseCreateParamsModality>>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<RealtimeResponseCreateParamsOutputAudioFormat>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<RealtimeResponseCreateParamsTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[allow(dead_code)]
            max_response_output_tokens: Option<RealtimeResponseCreateParamsMaxResponseOutputTokens>,
            #[serde(rename = "conversation")]
            #[allow(dead_code)]
            conversation: Option<RealtimeResponseCreateParamsConversation>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Option<Vec<RealtimeConversationItemWithReference>>,
        }
        let RealtimeResponseCreateParams {
            modalities,
            instructions,
            voice,
            output_audio_format,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            conversation,
            metadata,
            input,
            ..
        } = RealtimeResponseCreateParams::deserialize(deserializer)?;
        Ok(Self {
            modalities,
            instructions,
            voice,
            output_audio_format,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            conversation,
            metadata,
            input,
        })
    }
}
impl serde::Serialize for RealtimeResponseCreateParams {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeResponseCreateParams<'a> {
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeResponseCreateParamsModality>>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<RealtimeResponseCreateParamsOutputAudioFormat>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<RealtimeResponseCreateParamsTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_response_output_tokens:
                &'a Option<RealtimeResponseCreateParamsMaxResponseOutputTokens>,
            #[serde(rename = "conversation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            conversation: &'a Option<RealtimeResponseCreateParamsConversation>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "input")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input: &'a Option<Vec<RealtimeConversationItemWithReference>>,
        }
        let Self {
            modalities,
            instructions,
            voice,
            output_audio_format,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            conversation,
            metadata,
            input,
        } = self;
        RealtimeResponseCreateParams {
            modalities,
            instructions,
            voice,
            output_audio_format,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            conversation,
            metadata,
            input,
        }
        .serialize(serializer)
    }
}
#[doc = "Create a new Realtime response with these parameters"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseCreateParams {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeResponseCreateParamsModality>>,
    #[doc = "The default system instructions (i.e. system message) prepended to model \ncalls. This field allows the client to guide the model on desired \nresponses. The model can be instructed on response content and format, \n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good \nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion \ninto your voice\", \"laugh frequently\"). The instructions are not guaranteed \nto be followed by the model, but they provide guidance to the model on the \ndesired behavior.\n\nNote that the server sets default instructions which will be used if this \nfield is not set and are visible in the `session.created` event at the \nstart of the session.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the \nsession once the model has responded with audio at least once. Current \nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`,\n`onyx`, `nova`, `sage`, `shimmer`, and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub output_audio_format: Option<RealtimeResponseCreateParamsOutputAudioFormat>,
    #[doc = "Tools (functions) available to the model."]
    #[builder(default)]
    pub tools: Option<Vec<RealtimeResponseCreateParamsTool>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or \nspecify a function, like `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}`.\n"]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[builder(default)]
    pub max_response_output_tokens: Option<RealtimeResponseCreateParamsMaxResponseOutputTokens>,
    #[doc = "Controls which conversation the response is added to. Currently supports\n`auto` and `none`, with `auto` as the default value. The `auto` value\nmeans that the contents of the response will be added to the default\nconversation. Set this to `none` to create an out-of-band response which \nwill not add items to default conversation.\n"]
    #[builder(default)]
    pub conversation: Option<RealtimeResponseCreateParamsConversation>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "Input items to include in the prompt for the model. Using this field\ncreates a new context for this Response instead of using the default\nconversation. An empty array `[]` will clear the context for this Response.\nNote that this can include references to items from the default conversation.\n"]
    #[builder(default)]
    pub input: Option<Vec<RealtimeConversationItemWithReference>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeServerEvent {
            ConversationCreated(#[allow(dead_code)] RealtimeServerEventConversationCreated),
            ConversationItemCreated(#[allow(dead_code)] RealtimeServerEventConversationItemCreated),
            ConversationItemDeleted(#[allow(dead_code)] RealtimeServerEventConversationItemDeleted),
            ConversationItemInputAudioTranscriptionCompleted(
                #[allow(dead_code)]
                RealtimeServerEventConversationItemInputAudioTranscriptionCompleted,
            ),
            ConversationItemInputAudioTranscriptionDelta(
                #[allow(dead_code)] RealtimeServerEventConversationItemInputAudioTranscriptionDelta,
            ),
            ConversationItemInputAudioTranscriptionFailed(
                #[allow(dead_code)]
                RealtimeServerEventConversationItemInputAudioTranscriptionFailed,
            ),
            ConversationItemRetrieved(
                #[allow(dead_code)] RealtimeServerEventConversationItemRetrieved,
            ),
            ConversationItemTruncated(
                #[allow(dead_code)] RealtimeServerEventConversationItemTruncated,
            ),
            Error(#[allow(dead_code)] RealtimeServerEventError),
            InputAudioBufferCleared(#[allow(dead_code)] RealtimeServerEventInputAudioBufferCleared),
            InputAudioBufferCommitted(
                #[allow(dead_code)] RealtimeServerEventInputAudioBufferCommitted,
            ),
            InputAudioBufferSpeechStarted(
                #[allow(dead_code)] RealtimeServerEventInputAudioBufferSpeechStarted,
            ),
            InputAudioBufferSpeechStopped(
                #[allow(dead_code)] RealtimeServerEventInputAudioBufferSpeechStopped,
            ),
            RateLimitsUpdated(#[allow(dead_code)] RealtimeServerEventRateLimitsUpdated),
            ResponseAudioDelta(#[allow(dead_code)] RealtimeServerEventResponseAudioDelta),
            ResponseAudioDone(#[allow(dead_code)] RealtimeServerEventResponseAudioDone),
            ResponseAudioTranscriptDelta(
                #[allow(dead_code)] RealtimeServerEventResponseAudioTranscriptDelta,
            ),
            ResponseAudioTranscriptDone(
                #[allow(dead_code)] RealtimeServerEventResponseAudioTranscriptDone,
            ),
            ResponseContentPartAdded(
                #[allow(dead_code)] RealtimeServerEventResponseContentPartAdded,
            ),
            ResponseContentPartDone(#[allow(dead_code)] RealtimeServerEventResponseContentPartDone),
            ResponseCreated(#[allow(dead_code)] RealtimeServerEventResponseCreated),
            ResponseDone(#[allow(dead_code)] RealtimeServerEventResponseDone),
            ResponseFunctionCallArgumentsDelta(
                #[allow(dead_code)] RealtimeServerEventResponseFunctionCallArgumentsDelta,
            ),
            ResponseFunctionCallArgumentsDone(
                #[allow(dead_code)] RealtimeServerEventResponseFunctionCallArgumentsDone,
            ),
            ResponseOutputItemAdded(#[allow(dead_code)] RealtimeServerEventResponseOutputItemAdded),
            ResponseOutputItemDone(#[allow(dead_code)] RealtimeServerEventResponseOutputItemDone),
            ResponseTextDelta(#[allow(dead_code)] RealtimeServerEventResponseTextDelta),
            ResponseTextDone(#[allow(dead_code)] RealtimeServerEventResponseTextDone),
            SessionCreated(#[allow(dead_code)] RealtimeServerEventSessionCreated),
            SessionUpdated(#[allow(dead_code)] RealtimeServerEventSessionUpdated),
            TranscriptionSessionUpdated(
                #[allow(dead_code)] RealtimeServerEventTranscriptionSessionUpdated,
            ),
            OutputAudioBufferStarted(
                #[allow(dead_code)] RealtimeServerEventOutputAudioBufferStarted,
            ),
            OutputAudioBufferStopped(
                #[allow(dead_code)] RealtimeServerEventOutputAudioBufferStopped,
            ),
            OutputAudioBufferCleared(
                #[allow(dead_code)] RealtimeServerEventOutputAudioBufferCleared,
            ),
        }
        Ok(match RealtimeServerEvent::deserialize(deserializer)? {
            RealtimeServerEvent::ConversationCreated(_v) => Self::ConversationCreated(_v),
            RealtimeServerEvent::ConversationItemCreated(_v) => Self::ConversationItemCreated(_v),
            RealtimeServerEvent::ConversationItemDeleted(_v) => Self::ConversationItemDeleted(_v),
            RealtimeServerEvent::ConversationItemInputAudioTranscriptionCompleted(_v) => {
                Self::ConversationItemInputAudioTranscriptionCompleted(_v)
            }
            RealtimeServerEvent::ConversationItemInputAudioTranscriptionDelta(_v) => {
                Self::ConversationItemInputAudioTranscriptionDelta(_v)
            }
            RealtimeServerEvent::ConversationItemInputAudioTranscriptionFailed(_v) => {
                Self::ConversationItemInputAudioTranscriptionFailed(_v)
            }
            RealtimeServerEvent::ConversationItemRetrieved(_v) => {
                Self::ConversationItemRetrieved(_v)
            }
            RealtimeServerEvent::ConversationItemTruncated(_v) => {
                Self::ConversationItemTruncated(_v)
            }
            RealtimeServerEvent::Error(_v) => Self::Error(_v),
            RealtimeServerEvent::InputAudioBufferCleared(_v) => Self::InputAudioBufferCleared(_v),
            RealtimeServerEvent::InputAudioBufferCommitted(_v) => {
                Self::InputAudioBufferCommitted(_v)
            }
            RealtimeServerEvent::InputAudioBufferSpeechStarted(_v) => {
                Self::InputAudioBufferSpeechStarted(_v)
            }
            RealtimeServerEvent::InputAudioBufferSpeechStopped(_v) => {
                Self::InputAudioBufferSpeechStopped(_v)
            }
            RealtimeServerEvent::RateLimitsUpdated(_v) => Self::RateLimitsUpdated(_v),
            RealtimeServerEvent::ResponseAudioDelta(_v) => Self::ResponseAudioDelta(_v),
            RealtimeServerEvent::ResponseAudioDone(_v) => Self::ResponseAudioDone(_v),
            RealtimeServerEvent::ResponseAudioTranscriptDelta(_v) => {
                Self::ResponseAudioTranscriptDelta(_v)
            }
            RealtimeServerEvent::ResponseAudioTranscriptDone(_v) => {
                Self::ResponseAudioTranscriptDone(_v)
            }
            RealtimeServerEvent::ResponseContentPartAdded(_v) => Self::ResponseContentPartAdded(_v),
            RealtimeServerEvent::ResponseContentPartDone(_v) => Self::ResponseContentPartDone(_v),
            RealtimeServerEvent::ResponseCreated(_v) => Self::ResponseCreated(_v),
            RealtimeServerEvent::ResponseDone(_v) => Self::ResponseDone(_v),
            RealtimeServerEvent::ResponseFunctionCallArgumentsDelta(_v) => {
                Self::ResponseFunctionCallArgumentsDelta(_v)
            }
            RealtimeServerEvent::ResponseFunctionCallArgumentsDone(_v) => {
                Self::ResponseFunctionCallArgumentsDone(_v)
            }
            RealtimeServerEvent::ResponseOutputItemAdded(_v) => Self::ResponseOutputItemAdded(_v),
            RealtimeServerEvent::ResponseOutputItemDone(_v) => Self::ResponseOutputItemDone(_v),
            RealtimeServerEvent::ResponseTextDelta(_v) => Self::ResponseTextDelta(_v),
            RealtimeServerEvent::ResponseTextDone(_v) => Self::ResponseTextDone(_v),
            RealtimeServerEvent::SessionCreated(_v) => Self::SessionCreated(_v),
            RealtimeServerEvent::SessionUpdated(_v) => Self::SessionUpdated(_v),
            RealtimeServerEvent::TranscriptionSessionUpdated(_v) => {
                Self::TranscriptionSessionUpdated(_v)
            }
            RealtimeServerEvent::OutputAudioBufferStarted(_v) => Self::OutputAudioBufferStarted(_v),
            RealtimeServerEvent::OutputAudioBufferStopped(_v) => Self::OutputAudioBufferStopped(_v),
            RealtimeServerEvent::OutputAudioBufferCleared(_v) => Self::OutputAudioBufferCleared(_v),
        })
    }
}
impl serde::Serialize for RealtimeServerEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeServerEvent<'a> {
            ConversationCreated(#[allow(dead_code)] &'a RealtimeServerEventConversationCreated),
            ConversationItemCreated(
                #[allow(dead_code)] &'a RealtimeServerEventConversationItemCreated,
            ),
            ConversationItemDeleted(
                #[allow(dead_code)] &'a RealtimeServerEventConversationItemDeleted,
            ),
            ConversationItemInputAudioTranscriptionCompleted(
                #[allow(dead_code)]
                &'a RealtimeServerEventConversationItemInputAudioTranscriptionCompleted,
            ),
            ConversationItemInputAudioTranscriptionDelta(
                #[allow(dead_code)]
                &'a RealtimeServerEventConversationItemInputAudioTranscriptionDelta,
            ),
            ConversationItemInputAudioTranscriptionFailed(
                #[allow(dead_code)]
                &'a RealtimeServerEventConversationItemInputAudioTranscriptionFailed,
            ),
            ConversationItemRetrieved(
                #[allow(dead_code)] &'a RealtimeServerEventConversationItemRetrieved,
            ),
            ConversationItemTruncated(
                #[allow(dead_code)] &'a RealtimeServerEventConversationItemTruncated,
            ),
            Error(#[allow(dead_code)] &'a RealtimeServerEventError),
            InputAudioBufferCleared(
                #[allow(dead_code)] &'a RealtimeServerEventInputAudioBufferCleared,
            ),
            InputAudioBufferCommitted(
                #[allow(dead_code)] &'a RealtimeServerEventInputAudioBufferCommitted,
            ),
            InputAudioBufferSpeechStarted(
                #[allow(dead_code)] &'a RealtimeServerEventInputAudioBufferSpeechStarted,
            ),
            InputAudioBufferSpeechStopped(
                #[allow(dead_code)] &'a RealtimeServerEventInputAudioBufferSpeechStopped,
            ),
            RateLimitsUpdated(#[allow(dead_code)] &'a RealtimeServerEventRateLimitsUpdated),
            ResponseAudioDelta(#[allow(dead_code)] &'a RealtimeServerEventResponseAudioDelta),
            ResponseAudioDone(#[allow(dead_code)] &'a RealtimeServerEventResponseAudioDone),
            ResponseAudioTranscriptDelta(
                #[allow(dead_code)] &'a RealtimeServerEventResponseAudioTranscriptDelta,
            ),
            ResponseAudioTranscriptDone(
                #[allow(dead_code)] &'a RealtimeServerEventResponseAudioTranscriptDone,
            ),
            ResponseContentPartAdded(
                #[allow(dead_code)] &'a RealtimeServerEventResponseContentPartAdded,
            ),
            ResponseContentPartDone(
                #[allow(dead_code)] &'a RealtimeServerEventResponseContentPartDone,
            ),
            ResponseCreated(#[allow(dead_code)] &'a RealtimeServerEventResponseCreated),
            ResponseDone(#[allow(dead_code)] &'a RealtimeServerEventResponseDone),
            ResponseFunctionCallArgumentsDelta(
                #[allow(dead_code)] &'a RealtimeServerEventResponseFunctionCallArgumentsDelta,
            ),
            ResponseFunctionCallArgumentsDone(
                #[allow(dead_code)] &'a RealtimeServerEventResponseFunctionCallArgumentsDone,
            ),
            ResponseOutputItemAdded(
                #[allow(dead_code)] &'a RealtimeServerEventResponseOutputItemAdded,
            ),
            ResponseOutputItemDone(
                #[allow(dead_code)] &'a RealtimeServerEventResponseOutputItemDone,
            ),
            ResponseTextDelta(#[allow(dead_code)] &'a RealtimeServerEventResponseTextDelta),
            ResponseTextDone(#[allow(dead_code)] &'a RealtimeServerEventResponseTextDone),
            SessionCreated(#[allow(dead_code)] &'a RealtimeServerEventSessionCreated),
            SessionUpdated(#[allow(dead_code)] &'a RealtimeServerEventSessionUpdated),
            TranscriptionSessionUpdated(
                #[allow(dead_code)] &'a RealtimeServerEventTranscriptionSessionUpdated,
            ),
            OutputAudioBufferStarted(
                #[allow(dead_code)] &'a RealtimeServerEventOutputAudioBufferStarted,
            ),
            OutputAudioBufferStopped(
                #[allow(dead_code)] &'a RealtimeServerEventOutputAudioBufferStopped,
            ),
            OutputAudioBufferCleared(
                #[allow(dead_code)] &'a RealtimeServerEventOutputAudioBufferCleared,
            ),
        }
        match self {
            Self::ConversationCreated(_v) => {
                RealtimeServerEvent::ConversationCreated(_v).serialize(serializer)
            }
            Self::ConversationItemCreated(_v) => {
                RealtimeServerEvent::ConversationItemCreated(_v).serialize(serializer)
            }
            Self::ConversationItemDeleted(_v) => {
                RealtimeServerEvent::ConversationItemDeleted(_v).serialize(serializer)
            }
            Self::ConversationItemInputAudioTranscriptionCompleted(_v) => {
                RealtimeServerEvent::ConversationItemInputAudioTranscriptionCompleted(_v)
                    .serialize(serializer)
            }
            Self::ConversationItemInputAudioTranscriptionDelta(_v) => {
                RealtimeServerEvent::ConversationItemInputAudioTranscriptionDelta(_v)
                    .serialize(serializer)
            }
            Self::ConversationItemInputAudioTranscriptionFailed(_v) => {
                RealtimeServerEvent::ConversationItemInputAudioTranscriptionFailed(_v)
                    .serialize(serializer)
            }
            Self::ConversationItemRetrieved(_v) => {
                RealtimeServerEvent::ConversationItemRetrieved(_v).serialize(serializer)
            }
            Self::ConversationItemTruncated(_v) => {
                RealtimeServerEvent::ConversationItemTruncated(_v).serialize(serializer)
            }
            Self::Error(_v) => RealtimeServerEvent::Error(_v).serialize(serializer),
            Self::InputAudioBufferCleared(_v) => {
                RealtimeServerEvent::InputAudioBufferCleared(_v).serialize(serializer)
            }
            Self::InputAudioBufferCommitted(_v) => {
                RealtimeServerEvent::InputAudioBufferCommitted(_v).serialize(serializer)
            }
            Self::InputAudioBufferSpeechStarted(_v) => {
                RealtimeServerEvent::InputAudioBufferSpeechStarted(_v).serialize(serializer)
            }
            Self::InputAudioBufferSpeechStopped(_v) => {
                RealtimeServerEvent::InputAudioBufferSpeechStopped(_v).serialize(serializer)
            }
            Self::RateLimitsUpdated(_v) => {
                RealtimeServerEvent::RateLimitsUpdated(_v).serialize(serializer)
            }
            Self::ResponseAudioDelta(_v) => {
                RealtimeServerEvent::ResponseAudioDelta(_v).serialize(serializer)
            }
            Self::ResponseAudioDone(_v) => {
                RealtimeServerEvent::ResponseAudioDone(_v).serialize(serializer)
            }
            Self::ResponseAudioTranscriptDelta(_v) => {
                RealtimeServerEvent::ResponseAudioTranscriptDelta(_v).serialize(serializer)
            }
            Self::ResponseAudioTranscriptDone(_v) => {
                RealtimeServerEvent::ResponseAudioTranscriptDone(_v).serialize(serializer)
            }
            Self::ResponseContentPartAdded(_v) => {
                RealtimeServerEvent::ResponseContentPartAdded(_v).serialize(serializer)
            }
            Self::ResponseContentPartDone(_v) => {
                RealtimeServerEvent::ResponseContentPartDone(_v).serialize(serializer)
            }
            Self::ResponseCreated(_v) => {
                RealtimeServerEvent::ResponseCreated(_v).serialize(serializer)
            }
            Self::ResponseDone(_v) => RealtimeServerEvent::ResponseDone(_v).serialize(serializer),
            Self::ResponseFunctionCallArgumentsDelta(_v) => {
                RealtimeServerEvent::ResponseFunctionCallArgumentsDelta(_v).serialize(serializer)
            }
            Self::ResponseFunctionCallArgumentsDone(_v) => {
                RealtimeServerEvent::ResponseFunctionCallArgumentsDone(_v).serialize(serializer)
            }
            Self::ResponseOutputItemAdded(_v) => {
                RealtimeServerEvent::ResponseOutputItemAdded(_v).serialize(serializer)
            }
            Self::ResponseOutputItemDone(_v) => {
                RealtimeServerEvent::ResponseOutputItemDone(_v).serialize(serializer)
            }
            Self::ResponseTextDelta(_v) => {
                RealtimeServerEvent::ResponseTextDelta(_v).serialize(serializer)
            }
            Self::ResponseTextDone(_v) => {
                RealtimeServerEvent::ResponseTextDone(_v).serialize(serializer)
            }
            Self::SessionCreated(_v) => {
                RealtimeServerEvent::SessionCreated(_v).serialize(serializer)
            }
            Self::SessionUpdated(_v) => {
                RealtimeServerEvent::SessionUpdated(_v).serialize(serializer)
            }
            Self::TranscriptionSessionUpdated(_v) => {
                RealtimeServerEvent::TranscriptionSessionUpdated(_v).serialize(serializer)
            }
            Self::OutputAudioBufferStarted(_v) => {
                RealtimeServerEvent::OutputAudioBufferStarted(_v).serialize(serializer)
            }
            Self::OutputAudioBufferStopped(_v) => {
                RealtimeServerEvent::OutputAudioBufferStopped(_v).serialize(serializer)
            }
            Self::OutputAudioBufferCleared(_v) => {
                RealtimeServerEvent::OutputAudioBufferCleared(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "A realtime server event.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEvent {
    ConversationCreated(RealtimeServerEventConversationCreated),
    ConversationItemCreated(RealtimeServerEventConversationItemCreated),
    ConversationItemDeleted(RealtimeServerEventConversationItemDeleted),
    ConversationItemInputAudioTranscriptionCompleted(
        RealtimeServerEventConversationItemInputAudioTranscriptionCompleted,
    ),
    ConversationItemInputAudioTranscriptionDelta(
        RealtimeServerEventConversationItemInputAudioTranscriptionDelta,
    ),
    ConversationItemInputAudioTranscriptionFailed(
        RealtimeServerEventConversationItemInputAudioTranscriptionFailed,
    ),
    ConversationItemRetrieved(RealtimeServerEventConversationItemRetrieved),
    ConversationItemTruncated(RealtimeServerEventConversationItemTruncated),
    Error(RealtimeServerEventError),
    InputAudioBufferCleared(RealtimeServerEventInputAudioBufferCleared),
    InputAudioBufferCommitted(RealtimeServerEventInputAudioBufferCommitted),
    InputAudioBufferSpeechStarted(RealtimeServerEventInputAudioBufferSpeechStarted),
    InputAudioBufferSpeechStopped(RealtimeServerEventInputAudioBufferSpeechStopped),
    RateLimitsUpdated(RealtimeServerEventRateLimitsUpdated),
    ResponseAudioDelta(RealtimeServerEventResponseAudioDelta),
    ResponseAudioDone(RealtimeServerEventResponseAudioDone),
    ResponseAudioTranscriptDelta(RealtimeServerEventResponseAudioTranscriptDelta),
    ResponseAudioTranscriptDone(RealtimeServerEventResponseAudioTranscriptDone),
    ResponseContentPartAdded(RealtimeServerEventResponseContentPartAdded),
    ResponseContentPartDone(RealtimeServerEventResponseContentPartDone),
    ResponseCreated(RealtimeServerEventResponseCreated),
    ResponseDone(RealtimeServerEventResponseDone),
    ResponseFunctionCallArgumentsDelta(RealtimeServerEventResponseFunctionCallArgumentsDelta),
    ResponseFunctionCallArgumentsDone(RealtimeServerEventResponseFunctionCallArgumentsDone),
    ResponseOutputItemAdded(RealtimeServerEventResponseOutputItemAdded),
    ResponseOutputItemDone(RealtimeServerEventResponseOutputItemDone),
    ResponseTextDelta(RealtimeServerEventResponseTextDelta),
    ResponseTextDone(RealtimeServerEventResponseTextDone),
    SessionCreated(RealtimeServerEventSessionCreated),
    SessionUpdated(RealtimeServerEventSessionUpdated),
    TranscriptionSessionUpdated(RealtimeServerEventTranscriptionSessionUpdated),
    OutputAudioBufferStarted(RealtimeServerEventOutputAudioBufferStarted),
    OutputAudioBufferStopped(RealtimeServerEventOutputAudioBufferStopped),
    OutputAudioBufferCleared(RealtimeServerEventOutputAudioBufferCleared),
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationCreatedConversation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationCreatedConversation {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: Option<serde_json::Value>,
        }
        let RealtimeServerEventConversationCreatedConversation { id, object, .. } =
            RealtimeServerEventConversationCreatedConversation::deserialize(deserializer)?;
        Ok(Self { id, object })
    }
}
impl serde::Serialize for RealtimeServerEventConversationCreatedConversation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationCreatedConversation<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<serde_json::Value>,
        }
        let Self { id, object } = self;
        RealtimeServerEventConversationCreatedConversation { id, object }.serialize(serializer)
    }
}
#[doc = "The conversation resource."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationCreatedConversation {
    #[doc = "The unique ID of the conversation."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The object type, must be `realtime.conversation`."]
    #[builder(default)]
    pub object: Option<serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationCreatedType {
            #[default]
            #[serde(rename = "conversation.created")]
            ConversationCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationCreated {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationCreatedType,
            #[serde(rename = "conversation")]
            #[allow(dead_code)]
            conversation: RealtimeServerEventConversationCreatedConversation,
        }
        let RealtimeServerEventConversationCreated {
            event_id,
            conversation,
            ..
        } = RealtimeServerEventConversationCreated::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            conversation,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationCreatedType {
            #[default]
            #[serde(rename = "conversation.created")]
            ConversationCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationCreated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationCreatedType,
            #[serde(rename = "conversation")]
            conversation: &'a RealtimeServerEventConversationCreatedConversation,
        }
        let Self {
            event_id,
            conversation,
        } = self;
        RealtimeServerEventConversationCreated {
            event_id,
            type_: &Default::default(),
            conversation,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a conversation is created. Emitted right after session creation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The conversation resource."]
    #[builder(default)]
    pub conversation: RealtimeServerEventConversationCreatedConversation,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemCreatedType {
            #[default]
            #[serde(rename = "conversation.item.created")]
            ConversationItemCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemCreated {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemCreatedType,
            #[serde(rename = "previous_item_id")]
            #[allow(dead_code)]
            previous_item_id: String,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let RealtimeServerEventConversationItemCreated {
            event_id,
            previous_item_id,
            item,
            ..
        } = RealtimeServerEventConversationItemCreated::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            previous_item_id,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemCreatedType {
            #[default]
            #[serde(rename = "conversation.item.created")]
            ConversationItemCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemCreated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemCreatedType,
            #[serde(rename = "previous_item_id")]
            previous_item_id: &'a String,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let Self {
            event_id,
            previous_item_id,
            item,
        } = self;
        RealtimeServerEventConversationItemCreated {
            event_id,
            type_: &Default::default(),
            previous_item_id,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a conversation item is created. There are several scenarios that produce this event:\n  - The server is generating a Response, which if successful will produce \n    either one or two Items, which will be of type `message` \n    (role `assistant`) or type `function_call`.\n  - The input audio buffer has been committed, either by the client or the \n    server (in `server_vad` mode). The server will take the content of the \n    input audio buffer and add it to a new user message Item.\n  - The client has sent a `conversation.item.create` event to add a new Item \n    to the Conversation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the preceding item in the Conversation context, allows the \nclient to understand the order of the conversation.\n"]
    pub previous_item_id: String,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.deleted`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemDeletedType {
            #[default]
            #[serde(rename = "conversation.item.deleted")]
            ConversationItemDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemDeleted {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemDeletedType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let RealtimeServerEventConversationItemDeleted {
            event_id, item_id, ..
        } = RealtimeServerEventConversationItemDeleted::deserialize(deserializer)?;
        Ok(Self { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.deleted`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemDeletedType {
            #[default]
            #[serde(rename = "conversation.item.deleted")]
            ConversationItemDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemDeleted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemDeletedType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self { event_id, item_id } = self;
        RealtimeServerEventConversationItemDeleted {
            event_id,
            type_: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an item in the conversation is deleted by the client with a \n`conversation.item.delete` event. This event is used to synchronize the \nserver's understanding of the conversation history with the client's view.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemDeleted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the item that was deleted."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionCompletedType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.completed")]
            ConversationItemInputAudioTranscriptionCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemInputAudioTranscriptionCompletedType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: String,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<LogProbProperties>>,
        }
        let RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
            event_id,
            item_id,
            content_index,
            transcript,
            logprobs,
            ..
        } = RealtimeServerEventConversationItemInputAudioTranscriptionCompleted::deserialize(
            deserializer,
        )?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            transcript,
            logprobs,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionCompletedType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.completed")]
            ConversationItemInputAudioTranscriptionCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionCompleted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemInputAudioTranscriptionCompletedType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "transcript")]
            transcript: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<LogProbProperties>>,
        }
        let Self {
            event_id,
            item_id,
            content_index,
            transcript,
            logprobs,
        } = self;
        RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            transcript,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "This event is the output of audio transcription for user audio written to the \nuser audio buffer. Transcription begins when the input audio buffer is \ncommitted by the client or server (in `server_vad` mode). Transcription runs \nasynchronously with Response creation, so this event may come before or after \nthe Response events.\n\nRealtime API models accept audio natively, and thus input transcription is a \nseparate process run on a separate ASR (Automatic Speech Recognition) model, \ncurrently always `whisper-1`. Thus the transcript may diverge somewhat from \nthe model's interpretation, and should be treated as a rough guide.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the user message item containing the audio."]
    pub item_id: String,
    #[doc = "The index of the content part containing the audio."]
    pub content_index: u64,
    #[doc = "The transcribed text."]
    pub transcript: String,
    #[doc = "The log probabilities of the transcription."]
    #[builder(default)]
    pub logprobs: Option<Vec<LogProbProperties>>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionDelta
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.input_audio_transcription.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionDeltaType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.delta")]
            ConversationItemInputAudioTranscriptionDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemInputAudioTranscriptionDeltaType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: Option<u64>,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: Option<String>,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<LogProbProperties>>,
        }
        let RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
            event_id,
            item_id,
            content_index,
            delta,
            logprobs,
            ..
        } = RealtimeServerEventConversationItemInputAudioTranscriptionDelta::deserialize(
            deserializer,
        )?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            delta,
            logprobs,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.input_audio_transcription.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionDeltaType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.delta")]
            ConversationItemInputAudioTranscriptionDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionDelta<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemInputAudioTranscriptionDeltaType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content_index: &'a Option<u64>,
            #[serde(rename = "delta")]
            #[serde(skip_serializing_if = "Option::is_none")]
            delta: &'a Option<String>,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<LogProbProperties>>,
        }
        let Self {
            event_id,
            item_id,
            content_index,
            delta,
            logprobs,
        } = self;
        RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            delta,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the text value of an input audio transcription content part is updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the content part in the item's content array."]
    #[builder(default)]
    pub content_index: Option<u64>,
    #[doc = "The text delta."]
    #[builder(default)]
    pub delta: Option<String>,
    #[doc = "The log probabilities of the transcription."]
    #[builder(default)]
    pub logprobs: Option<Vec<LogProbProperties>>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionFailedError
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: Option<String>,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
        }
        let RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
            type_,
            code,
            message,
            param,
            ..
        } = RealtimeServerEventConversationItemInputAudioTranscriptionFailedError::deserialize(
            deserializer,
        )?;
        Ok(Self {
            type_,
            code,
            message,
            param,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionFailedError<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message: &'a Option<String>,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
        }
        let Self {
            type_,
            code,
            message,
            param,
        } = self;
        RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
            type_,
            code,
            message,
            param,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the transcription error."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionFailedError {
    #[doc = "The type of error."]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "Error code, if any."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable error message."]
    #[builder(default)]
    pub message: Option<String>,
    #[doc = "Parameter related to the error, if any."]
    #[builder(default)]
    pub param: Option<String>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionFailed
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.failed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionFailedType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.failed")]
            ConversationItemInputAudioTranscriptionFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemInputAudioTranscriptionFailedType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: RealtimeServerEventConversationItemInputAudioTranscriptionFailedError,
        }
        let RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
            event_id,
            item_id,
            content_index,
            error,
            ..
        } = RealtimeServerEventConversationItemInputAudioTranscriptionFailed::deserialize(
            deserializer,
        )?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            error,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.failed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemInputAudioTranscriptionFailedType {
            #[default]
            #[serde(rename = "conversation.item.input_audio_transcription.failed")]
            ConversationItemInputAudioTranscriptionFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemInputAudioTranscriptionFailedType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "error")]
            error: &'a RealtimeServerEventConversationItemInputAudioTranscriptionFailedError,
        }
        let Self {
            event_id,
            item_id,
            content_index,
            error,
        } = self;
        RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when input audio transcription is configured, and a transcription \nrequest for a user message failed. These events are separate from other \n`error` events so that the client can identify the related Item.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the user message item."]
    pub item_id: String,
    #[doc = "The index of the content part containing the audio."]
    pub content_index: u64,
    #[doc = "Details of the transcription error."]
    #[builder(default)]
    pub error: RealtimeServerEventConversationItemInputAudioTranscriptionFailedError,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemRetrieved {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.retrieved`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemRetrievedType {
            #[default]
            #[serde(rename = "conversation.item.retrieved")]
            ConversationItemRetrieved,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemRetrieved {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemRetrievedType,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let RealtimeServerEventConversationItemRetrieved { event_id, item, .. } =
            RealtimeServerEventConversationItemRetrieved::deserialize(deserializer)?;
        Ok(Self { event_id, item })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemRetrieved {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.retrieved`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemRetrievedType {
            #[default]
            #[serde(rename = "conversation.item.retrieved")]
            ConversationItemRetrieved,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemRetrieved<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemRetrievedType,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let Self { event_id, item } = self;
        RealtimeServerEventConversationItemRetrieved {
            event_id,
            type_: &Default::default(),
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a conversation item is retrieved with `conversation.item.retrieve`.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemRetrieved {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemTruncated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `conversation.item.truncated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemTruncatedType {
            #[default]
            #[serde(rename = "conversation.item.truncated")]
            ConversationItemTruncated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemTruncated {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventConversationItemTruncatedType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "audio_end_ms")]
            #[allow(dead_code)]
            audio_end_ms: u64,
        }
        let RealtimeServerEventConversationItemTruncated {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
            ..
        } = RealtimeServerEventConversationItemTruncated::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemTruncated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `conversation.item.truncated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventConversationItemTruncatedType {
            #[default]
            #[serde(rename = "conversation.item.truncated")]
            ConversationItemTruncated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemTruncated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventConversationItemTruncatedType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a u64,
        }
        let Self {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        } = self;
        RealtimeServerEventConversationItemTruncated {
            event_id,
            type_: &Default::default(),
            item_id,
            content_index,
            audio_end_ms,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an earlier assistant audio message item is truncated by the \nclient with a `conversation.item.truncate` event. This event is used to \nsynchronize the server's understanding of the audio with the client's playback.\n\nThis action will truncate the audio and remove the server-side text transcript \nto ensure there is no text in the context that hasn't been heard by the user.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemTruncated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the assistant message item that was truncated."]
    pub item_id: String,
    #[doc = "The index of the content part that was truncated."]
    pub content_index: u64,
    #[doc = "The duration up to which the audio was truncated, in milliseconds.\n"]
    pub audio_end_ms: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventErrorError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventErrorError {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: String,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: Option<String>,
        }
        let RealtimeServerEventErrorError {
            type_,
            code,
            message,
            param,
            event_id,
            ..
        } = RealtimeServerEventErrorError::deserialize(deserializer)?;
        Ok(Self {
            type_,
            code,
            message,
            param,
            event_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventErrorError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventErrorError<'a> {
            #[serde(rename = "type")]
            type_: &'a String,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
        }
        let Self {
            type_,
            code,
            message,
            param,
            event_id,
        } = self;
        RealtimeServerEventErrorError {
            type_,
            code,
            message,
            param,
            event_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the error."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventErrorError {
    #[doc = "The type of error (e.g., \"invalid_request_error\", \"server_error\").\n"]
    pub type_: String,
    #[doc = "Error code, if any."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable error message."]
    pub message: String,
    #[doc = "Parameter related to the error, if any."]
    #[builder(default)]
    pub param: Option<String>,
    #[doc = "The event_id of the client event that caused the error, if applicable.\n"]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `error`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventErrorType {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventError {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventErrorType,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: RealtimeServerEventErrorError,
        }
        let RealtimeServerEventError {
            event_id, error, ..
        } = RealtimeServerEventError::deserialize(deserializer)?;
        Ok(Self { event_id, error })
    }
}
impl serde::Serialize for RealtimeServerEventError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `error`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventErrorType {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventError<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventErrorType,
            #[serde(rename = "error")]
            error: &'a RealtimeServerEventErrorError,
        }
        let Self { event_id, error } = self;
        RealtimeServerEventError {
            event_id,
            type_: &Default::default(),
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an error occurs, which could be a client problem or a server \nproblem. Most errors are recoverable and the session will stay open, we \nrecommend to implementors to monitor and log error messages by default.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventError {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Details of the error."]
    pub error: RealtimeServerEventErrorError,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferCleared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.cleared`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferClearedType {
            #[default]
            #[serde(rename = "input_audio_buffer.cleared")]
            InputAudioBufferCleared,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventInputAudioBufferCleared {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventInputAudioBufferClearedType,
        }
        let RealtimeServerEventInputAudioBufferCleared { event_id, .. } =
            RealtimeServerEventInputAudioBufferCleared::deserialize(deserializer)?;
        Ok(Self { event_id })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferCleared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.cleared`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferClearedType {
            #[default]
            #[serde(rename = "input_audio_buffer.cleared")]
            InputAudioBufferCleared,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventInputAudioBufferCleared<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventInputAudioBufferClearedType,
        }
        let Self { event_id } = self;
        RealtimeServerEventInputAudioBufferCleared {
            event_id,
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the input audio buffer is cleared by the client with a \n`input_audio_buffer.clear` event.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferCleared {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferCommitted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.committed`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferCommittedType {
            #[default]
            #[serde(rename = "input_audio_buffer.committed")]
            InputAudioBufferCommitted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventInputAudioBufferCommitted {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventInputAudioBufferCommittedType,
            #[serde(rename = "previous_item_id")]
            #[allow(dead_code)]
            previous_item_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let RealtimeServerEventInputAudioBufferCommitted {
            event_id,
            previous_item_id,
            item_id,
            ..
        } = RealtimeServerEventInputAudioBufferCommitted::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            previous_item_id,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferCommitted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.committed`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferCommittedType {
            #[default]
            #[serde(rename = "input_audio_buffer.committed")]
            InputAudioBufferCommitted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventInputAudioBufferCommitted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventInputAudioBufferCommittedType,
            #[serde(rename = "previous_item_id")]
            previous_item_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            event_id,
            previous_item_id,
            item_id,
        } = self;
        RealtimeServerEventInputAudioBufferCommitted {
            event_id,
            type_: &Default::default(),
            previous_item_id,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an input audio buffer is committed, either by the client or \nautomatically in server VAD mode. The `item_id` property is the ID of the user\nmessage item that will be created, thus a `conversation.item.created` event \nwill also be sent to the client.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferCommitted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the preceding item after which the new item will be inserted.\n"]
    pub previous_item_id: String,
    #[doc = "The ID of the user message item that will be created."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferSpeechStarted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.speech_started`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferSpeechStartedType {
            #[default]
            #[serde(rename = "input_audio_buffer.speech_started")]
            InputAudioBufferSpeechStarted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventInputAudioBufferSpeechStarted {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventInputAudioBufferSpeechStartedType,
            #[serde(rename = "audio_start_ms")]
            #[allow(dead_code)]
            audio_start_ms: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let RealtimeServerEventInputAudioBufferSpeechStarted {
            event_id,
            audio_start_ms,
            item_id,
            ..
        } = RealtimeServerEventInputAudioBufferSpeechStarted::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            audio_start_ms,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferSpeechStarted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.speech_started`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferSpeechStartedType {
            #[default]
            #[serde(rename = "input_audio_buffer.speech_started")]
            InputAudioBufferSpeechStarted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventInputAudioBufferSpeechStarted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventInputAudioBufferSpeechStartedType,
            #[serde(rename = "audio_start_ms")]
            audio_start_ms: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            event_id,
            audio_start_ms,
            item_id,
        } = self;
        RealtimeServerEventInputAudioBufferSpeechStarted {
            event_id,
            type_: &Default::default(),
            audio_start_ms,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Sent by the server when in `server_vad` mode to indicate that speech has been \ndetected in the audio buffer. This can happen any time audio is added to the \nbuffer (unless speech is already detected). The client may want to use this \nevent to interrupt audio playback or provide visual feedback to the user. \n\nThe client should expect to receive a `input_audio_buffer.speech_stopped` event \nwhen speech stops. The `item_id` property is the ID of the user message item \nthat will be created when speech stops and will also be included in the \n`input_audio_buffer.speech_stopped` event (unless the client manually commits \nthe audio buffer during VAD activation).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferSpeechStarted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Milliseconds from the start of all audio written to the buffer during the \nsession when speech was first detected. This will correspond to the \nbeginning of audio sent to the model, and thus includes the \n`prefix_padding_ms` configured in the Session.\n"]
    pub audio_start_ms: u64,
    #[doc = "The ID of the user message item that will be created when speech stops.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferSpeechStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `input_audio_buffer.speech_stopped`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferSpeechStoppedType {
            #[default]
            #[serde(rename = "input_audio_buffer.speech_stopped")]
            InputAudioBufferSpeechStopped,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventInputAudioBufferSpeechStopped {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventInputAudioBufferSpeechStoppedType,
            #[serde(rename = "audio_end_ms")]
            #[allow(dead_code)]
            audio_end_ms: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let RealtimeServerEventInputAudioBufferSpeechStopped {
            event_id,
            audio_end_ms,
            item_id,
            ..
        } = RealtimeServerEventInputAudioBufferSpeechStopped::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            audio_end_ms,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferSpeechStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `input_audio_buffer.speech_stopped`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventInputAudioBufferSpeechStoppedType {
            #[default]
            #[serde(rename = "input_audio_buffer.speech_stopped")]
            InputAudioBufferSpeechStopped,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventInputAudioBufferSpeechStopped<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventInputAudioBufferSpeechStoppedType,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            event_id,
            audio_end_ms,
            item_id,
        } = self;
        RealtimeServerEventInputAudioBufferSpeechStopped {
            event_id,
            type_: &Default::default(),
            audio_end_ms,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned in `server_vad` mode when the server detects the end of speech in \nthe audio buffer. The server will also send an `conversation.item.created` \nevent with the user message item that is created from the audio buffer.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferSpeechStopped {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Milliseconds since the session started when speech stopped. This will \ncorrespond to the end of audio sent to the model, and thus includes the \n`min_silence_duration_ms` configured in the Session.\n"]
    pub audio_end_ms: u64,
    #[doc = "The ID of the user message item that will be created."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferCleared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `output_audio_buffer.cleared`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferClearedType {
            #[default]
            #[serde(rename = "output_audio_buffer.cleared")]
            OutputAudioBufferCleared,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventOutputAudioBufferCleared {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventOutputAudioBufferClearedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
        }
        let RealtimeServerEventOutputAudioBufferCleared {
            event_id,
            response_id,
            ..
        } = RealtimeServerEventOutputAudioBufferCleared::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferCleared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `output_audio_buffer.cleared`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferClearedType {
            #[default]
            #[serde(rename = "output_audio_buffer.cleared")]
            OutputAudioBufferCleared,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventOutputAudioBufferCleared<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventOutputAudioBufferClearedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let Self {
            event_id,
            response_id,
        } = self;
        RealtimeServerEventOutputAudioBufferCleared {
            event_id,
            type_: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[doc = "**WebRTC Only:** Emitted when the output audio buffer is cleared. This happens either in VAD\nmode when the user has interrupted (`input_audio_buffer.speech_started`),\nor when the client has emitted the `output_audio_buffer.clear` event to manually\ncut off the current audio response.\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferCleared {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferStarted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `output_audio_buffer.started`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferStartedType {
            #[default]
            #[serde(rename = "output_audio_buffer.started")]
            OutputAudioBufferStarted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventOutputAudioBufferStarted {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventOutputAudioBufferStartedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
        }
        let RealtimeServerEventOutputAudioBufferStarted {
            event_id,
            response_id,
            ..
        } = RealtimeServerEventOutputAudioBufferStarted::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferStarted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `output_audio_buffer.started`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferStartedType {
            #[default]
            #[serde(rename = "output_audio_buffer.started")]
            OutputAudioBufferStarted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventOutputAudioBufferStarted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventOutputAudioBufferStartedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let Self {
            event_id,
            response_id,
        } = self;
        RealtimeServerEventOutputAudioBufferStarted {
            event_id,
            type_: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[doc = "**WebRTC Only:** Emitted when the server begins streaming audio to the client. This event is\nemitted after an audio content part has been added (`response.content_part.added`)\nto the response.\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferStarted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `output_audio_buffer.stopped`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferStoppedType {
            #[default]
            #[serde(rename = "output_audio_buffer.stopped")]
            OutputAudioBufferStopped,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventOutputAudioBufferStopped {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventOutputAudioBufferStoppedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
        }
        let RealtimeServerEventOutputAudioBufferStopped {
            event_id,
            response_id,
            ..
        } = RealtimeServerEventOutputAudioBufferStopped::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `output_audio_buffer.stopped`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventOutputAudioBufferStoppedType {
            #[default]
            #[serde(rename = "output_audio_buffer.stopped")]
            OutputAudioBufferStopped,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventOutputAudioBufferStopped<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventOutputAudioBufferStoppedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let Self {
            event_id,
            response_id,
        } = self;
        RealtimeServerEventOutputAudioBufferStopped {
            event_id,
            type_: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[doc = "**WebRTC Only:** Emitted when the output audio buffer has been completely drained on the server,\nand no more audio is forthcoming. This event is emitted after the full response\ndata has been sent to the client (`response.done`).\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferStopped {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventRateLimitsUpdatedRateLimitsName {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsNameRequests {
            #[default]
            #[serde(rename = "requests")]
            Requests,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsNameTokens {
            #[default]
            #[serde(rename = "tokens")]
            Tokens,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsName {
            Requests(
                #[allow(dead_code)] RealtimeServerEventRateLimitsUpdatedRateLimitsNameRequests,
            ),
            Tokens(#[allow(dead_code)] RealtimeServerEventRateLimitsUpdatedRateLimitsNameTokens),
        }
        Ok(
            match RealtimeServerEventRateLimitsUpdatedRateLimitsName::deserialize(deserializer)? {
                RealtimeServerEventRateLimitsUpdatedRateLimitsName::Requests(_) => Self::Requests,
                RealtimeServerEventRateLimitsUpdatedRateLimitsName::Tokens(_) => Self::Tokens,
            },
        )
    }
}
impl serde::Serialize for RealtimeServerEventRateLimitsUpdatedRateLimitsName {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsNameRequests {
            #[default]
            #[serde(rename = "requests")]
            Requests,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsNameTokens {
            #[default]
            #[serde(rename = "tokens")]
            Tokens,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeServerEventRateLimitsUpdatedRateLimitsName<'a> {
            Requests(
                #[allow(dead_code)] &'a RealtimeServerEventRateLimitsUpdatedRateLimitsNameRequests,
            ),
            Tokens(
                #[allow(dead_code)] &'a RealtimeServerEventRateLimitsUpdatedRateLimitsNameTokens,
            ),
        }
        match self {
            Self::Requests => {
                RealtimeServerEventRateLimitsUpdatedRateLimitsName::Requests(&Default::default())
                    .serialize(serializer)
            }
            Self::Tokens => {
                RealtimeServerEventRateLimitsUpdatedRateLimitsName::Tokens(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The name of the rate limit (`requests`, `tokens`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEventRateLimitsUpdatedRateLimitsName {
    #[doc = "requests"]
    Requests,
    #[doc = "tokens"]
    Tokens,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventRateLimitsUpdatedRateLimits {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventRateLimitsUpdatedRateLimits {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<RealtimeServerEventRateLimitsUpdatedRateLimitsName>,
            #[serde(rename = "limit")]
            #[allow(dead_code)]
            limit: Option<u64>,
            #[serde(rename = "remaining")]
            #[allow(dead_code)]
            remaining: Option<u64>,
            #[serde(rename = "reset_seconds")]
            #[allow(dead_code)]
            reset_seconds: Option<f64>,
        }
        let RealtimeServerEventRateLimitsUpdatedRateLimits {
            name,
            limit,
            remaining,
            reset_seconds,
            ..
        } = RealtimeServerEventRateLimitsUpdatedRateLimits::deserialize(deserializer)?;
        Ok(Self {
            name,
            limit,
            remaining,
            reset_seconds,
        })
    }
}
impl serde::Serialize for RealtimeServerEventRateLimitsUpdatedRateLimits {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventRateLimitsUpdatedRateLimits<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<RealtimeServerEventRateLimitsUpdatedRateLimitsName>,
            #[serde(rename = "limit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            limit: &'a Option<u64>,
            #[serde(rename = "remaining")]
            #[serde(skip_serializing_if = "Option::is_none")]
            remaining: &'a Option<u64>,
            #[serde(rename = "reset_seconds")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reset_seconds: &'a Option<f64>,
        }
        let Self {
            name,
            limit,
            remaining,
            reset_seconds,
        } = self;
        RealtimeServerEventRateLimitsUpdatedRateLimits {
            name,
            limit,
            remaining,
            reset_seconds,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventRateLimitsUpdatedRateLimits {
    #[doc = "The name of the rate limit (`requests`, `tokens`).\n"]
    #[builder(default)]
    pub name: Option<RealtimeServerEventRateLimitsUpdatedRateLimitsName>,
    #[doc = "The maximum allowed value for the rate limit."]
    #[builder(default)]
    pub limit: Option<u64>,
    #[doc = "The remaining value before the limit is reached."]
    #[builder(default)]
    pub remaining: Option<u64>,
    #[doc = "Seconds until the rate limit resets."]
    #[builder(default)]
    pub reset_seconds: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventRateLimitsUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `rate_limits.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedType {
            #[default]
            #[serde(rename = "rate_limits.updated")]
            RateLimitsUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventRateLimitsUpdated {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventRateLimitsUpdatedType,
            #[serde(rename = "rate_limits")]
            #[allow(dead_code)]
            rate_limits: Vec<RealtimeServerEventRateLimitsUpdatedRateLimits>,
        }
        let RealtimeServerEventRateLimitsUpdated {
            event_id,
            rate_limits,
            ..
        } = RealtimeServerEventRateLimitsUpdated::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            rate_limits,
        })
    }
}
impl serde::Serialize for RealtimeServerEventRateLimitsUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `rate_limits.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventRateLimitsUpdatedType {
            #[default]
            #[serde(rename = "rate_limits.updated")]
            RateLimitsUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventRateLimitsUpdated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventRateLimitsUpdatedType,
            #[serde(rename = "rate_limits")]
            rate_limits: &'a Vec<RealtimeServerEventRateLimitsUpdatedRateLimits>,
        }
        let Self {
            event_id,
            rate_limits,
        } = self;
        RealtimeServerEventRateLimitsUpdated {
            event_id,
            type_: &Default::default(),
            rate_limits,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted at the beginning of a Response to indicate the updated rate limits. \nWhen a Response is created some tokens will be \"reserved\" for the output \ntokens, the rate limits shown here reflect that reservation, which is then \nadjusted accordingly once the Response is completed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventRateLimitsUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "List of rate limit information."]
    pub rate_limits: Vec<RealtimeServerEventRateLimitsUpdatedRateLimits>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.audio.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioDeltaType {
            #[default]
            #[serde(rename = "response.audio.delta")]
            ResponseAudioDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseAudioDelta {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseAudioDeltaType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let RealtimeServerEventResponseAudioDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = RealtimeServerEventResponseAudioDelta::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.audio.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioDeltaType {
            #[default]
            #[serde(rename = "response.audio.delta")]
            ResponseAudioDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseAudioDelta<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseAudioDeltaType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        RealtimeServerEventResponseAudioDelta {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated audio is updated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "Base64-encoded audio data delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.audio.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioDoneType {
            #[default]
            #[serde(rename = "response.audio.done")]
            ResponseAudioDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseAudioDone {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseAudioDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
        }
        let RealtimeServerEventResponseAudioDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            ..
        } = RealtimeServerEventResponseAudioDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.audio.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioDoneType {
            #[default]
            #[serde(rename = "response.audio.done")]
            ResponseAudioDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseAudioDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseAudioDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
        } = self;
        RealtimeServerEventResponseAudioDone {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated audio is done. Also emitted when a Response\nis interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioTranscriptDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.audio_transcript.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioTranscriptDeltaType {
            #[default]
            #[serde(rename = "response.audio_transcript.delta")]
            ResponseAudioTranscriptDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseAudioTranscriptDelta {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseAudioTranscriptDeltaType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let RealtimeServerEventResponseAudioTranscriptDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = RealtimeServerEventResponseAudioTranscriptDelta::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioTranscriptDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.audio_transcript.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioTranscriptDeltaType {
            #[default]
            #[serde(rename = "response.audio_transcript.delta")]
            ResponseAudioTranscriptDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseAudioTranscriptDelta<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseAudioTranscriptDeltaType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        RealtimeServerEventResponseAudioTranscriptDelta {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated transcription of audio output is updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioTranscriptDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The transcript delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioTranscriptDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.audio_transcript.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioTranscriptDoneType {
            #[default]
            #[serde(rename = "response.audio_transcript.done")]
            ResponseAudioTranscriptDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseAudioTranscriptDone {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseAudioTranscriptDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: String,
        }
        let RealtimeServerEventResponseAudioTranscriptDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
            ..
        } = RealtimeServerEventResponseAudioTranscriptDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioTranscriptDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.audio_transcript.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseAudioTranscriptDoneType {
            #[default]
            #[serde(rename = "response.audio_transcript.done")]
            ResponseAudioTranscriptDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseAudioTranscriptDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseAudioTranscriptDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "transcript")]
            transcript: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        } = self;
        RealtimeServerEventResponseAudioTranscriptDone {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated transcription of audio output is done\nstreaming. Also emitted when a Response is interrupted, incomplete, or\ncancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioTranscriptDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The final transcript of the audio."]
    pub transcript: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartAddedPartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedPartTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedPartTypeAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeServerEventResponseContentPartAddedPartType {
            Text(#[allow(dead_code)] RealtimeServerEventResponseContentPartAddedPartTypeText),
            Audio(#[allow(dead_code)] RealtimeServerEventResponseContentPartAddedPartTypeAudio),
        }
        Ok(
            match RealtimeServerEventResponseContentPartAddedPartType::deserialize(deserializer)? {
                RealtimeServerEventResponseContentPartAddedPartType::Text(_) => Self::Text,
                RealtimeServerEventResponseContentPartAddedPartType::Audio(_) => Self::Audio,
            },
        )
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartAddedPartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedPartTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedPartTypeAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeServerEventResponseContentPartAddedPartType<'a> {
            Text(#[allow(dead_code)] &'a RealtimeServerEventResponseContentPartAddedPartTypeText),
            Audio(#[allow(dead_code)] &'a RealtimeServerEventResponseContentPartAddedPartTypeAudio),
        }
        match self {
            Self::Text => {
                RealtimeServerEventResponseContentPartAddedPartType::Text(&Default::default())
                    .serialize(serializer)
            }
            Self::Audio => {
                RealtimeServerEventResponseContentPartAddedPartType::Audio(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The content type (\"text\", \"audio\")."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEventResponseContentPartAddedPartType {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartAddedPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseContentPartAddedPart {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeServerEventResponseContentPartAddedPartType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<String>,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: Option<String>,
        }
        let RealtimeServerEventResponseContentPartAddedPart {
            type_,
            text,
            audio,
            transcript,
            ..
        } = RealtimeServerEventResponseContentPartAddedPart::deserialize(deserializer)?;
        Ok(Self {
            type_,
            text,
            audio,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartAddedPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseContentPartAddedPart<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeServerEventResponseContentPartAddedPartType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<String>,
            #[serde(rename = "transcript")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transcript: &'a Option<String>,
        }
        let Self {
            type_,
            text,
            audio,
            transcript,
        } = self;
        RealtimeServerEventResponseContentPartAddedPart {
            type_,
            text,
            audio,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "The content part that was added."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartAddedPart {
    #[doc = "The content type (\"text\", \"audio\")."]
    #[builder(default)]
    pub type_: Option<RealtimeServerEventResponseContentPartAddedPartType>,
    #[doc = "The text content (if type is \"text\")."]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "Base64-encoded audio data (if type is \"audio\")."]
    #[builder(default)]
    pub audio: Option<String>,
    #[doc = "The transcript of the audio (if type is \"audio\")."]
    #[builder(default)]
    pub transcript: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartAdded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.content_part.added`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedType {
            #[default]
            #[serde(rename = "response.content_part.added")]
            ResponseContentPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseContentPartAdded {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseContentPartAddedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: RealtimeServerEventResponseContentPartAddedPart,
        }
        let RealtimeServerEventResponseContentPartAdded {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
            ..
        } = RealtimeServerEventResponseContentPartAdded::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartAdded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.content_part.added`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartAddedType {
            #[default]
            #[serde(rename = "response.content_part.added")]
            ResponseContentPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseContentPartAdded<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseContentPartAddedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a RealtimeServerEventResponseContentPartAddedPart,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        } = self;
        RealtimeServerEventResponseContentPartAdded {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a new content part is added to an assistant message item during\nresponse generation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartAdded {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item to which the content part was added."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The content part that was added."]
    #[builder(default)]
    pub part: RealtimeServerEventResponseContentPartAddedPart,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartDonePartType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDonePartTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDonePartTypeAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeServerEventResponseContentPartDonePartType {
            Text(#[allow(dead_code)] RealtimeServerEventResponseContentPartDonePartTypeText),
            Audio(#[allow(dead_code)] RealtimeServerEventResponseContentPartDonePartTypeAudio),
        }
        Ok(
            match RealtimeServerEventResponseContentPartDonePartType::deserialize(deserializer)? {
                RealtimeServerEventResponseContentPartDonePartType::Text(_) => Self::Text,
                RealtimeServerEventResponseContentPartDonePartType::Audio(_) => Self::Audio,
            },
        )
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartDonePartType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDonePartTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDonePartTypeAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeServerEventResponseContentPartDonePartType<'a> {
            Text(#[allow(dead_code)] &'a RealtimeServerEventResponseContentPartDonePartTypeText),
            Audio(#[allow(dead_code)] &'a RealtimeServerEventResponseContentPartDonePartTypeAudio),
        }
        match self {
            Self::Text => {
                RealtimeServerEventResponseContentPartDonePartType::Text(&Default::default())
                    .serialize(serializer)
            }
            Self::Audio => {
                RealtimeServerEventResponseContentPartDonePartType::Audio(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The content type (\"text\", \"audio\")."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEventResponseContentPartDonePartType {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartDonePart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseContentPartDonePart {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeServerEventResponseContentPartDonePartType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<String>,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: Option<String>,
        }
        let RealtimeServerEventResponseContentPartDonePart {
            type_,
            text,
            audio,
            transcript,
            ..
        } = RealtimeServerEventResponseContentPartDonePart::deserialize(deserializer)?;
        Ok(Self {
            type_,
            text,
            audio,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartDonePart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseContentPartDonePart<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeServerEventResponseContentPartDonePartType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<String>,
            #[serde(rename = "transcript")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transcript: &'a Option<String>,
        }
        let Self {
            type_,
            text,
            audio,
            transcript,
        } = self;
        RealtimeServerEventResponseContentPartDonePart {
            type_,
            text,
            audio,
            transcript,
        }
        .serialize(serializer)
    }
}
#[doc = "The content part that is done."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartDonePart {
    #[doc = "The content type (\"text\", \"audio\")."]
    #[builder(default)]
    pub type_: Option<RealtimeServerEventResponseContentPartDonePartType>,
    #[doc = "The text content (if type is \"text\")."]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "Base64-encoded audio data (if type is \"audio\")."]
    #[builder(default)]
    pub audio: Option<String>,
    #[doc = "The transcript of the audio (if type is \"audio\")."]
    #[builder(default)]
    pub transcript: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.content_part.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDoneType {
            #[default]
            #[serde(rename = "response.content_part.done")]
            ResponseContentPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseContentPartDone {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseContentPartDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: RealtimeServerEventResponseContentPartDonePart,
        }
        let RealtimeServerEventResponseContentPartDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
            ..
        } = RealtimeServerEventResponseContentPartDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.content_part.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseContentPartDoneType {
            #[default]
            #[serde(rename = "response.content_part.done")]
            ResponseContentPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseContentPartDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseContentPartDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a RealtimeServerEventResponseContentPartDonePart,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        } = self;
        RealtimeServerEventResponseContentPartDone {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a content part is done streaming in an assistant message item.\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The content part that is done."]
    #[builder(default)]
    pub part: RealtimeServerEventResponseContentPartDonePart,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseCreatedType {
            #[default]
            #[serde(rename = "response.created")]
            ResponseCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseCreated {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseCreatedType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: RealtimeResponse,
        }
        let RealtimeServerEventResponseCreated {
            event_id, response, ..
        } = RealtimeServerEventResponseCreated::deserialize(deserializer)?;
        Ok(Self { event_id, response })
    }
}
impl serde::Serialize for RealtimeServerEventResponseCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseCreatedType {
            #[default]
            #[serde(rename = "response.created")]
            ResponseCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseCreated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseCreatedType,
            #[serde(rename = "response")]
            response: &'a RealtimeResponse,
        }
        let Self { event_id, response } = self;
        RealtimeServerEventResponseCreated {
            event_id,
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a new Response is created. The first event of response creation,\nwhere the response is in an initial state of `in_progress`.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub response: RealtimeResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseDoneType {
            #[default]
            #[serde(rename = "response.done")]
            ResponseDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseDone {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseDoneType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: RealtimeResponse,
        }
        let RealtimeServerEventResponseDone {
            event_id, response, ..
        } = RealtimeServerEventResponseDone::deserialize(deserializer)?;
        Ok(Self { event_id, response })
    }
}
impl serde::Serialize for RealtimeServerEventResponseDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseDoneType {
            #[default]
            #[serde(rename = "response.done")]
            ResponseDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseDoneType,
            #[serde(rename = "response")]
            response: &'a RealtimeResponse,
        }
        let Self { event_id, response } = self;
        RealtimeServerEventResponseDone {
            event_id,
            type_: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a Response is done streaming. Always emitted, no matter the \nfinal state. The Response object included in the `response.done` event will \ninclude all output Items in the Response but will omit the raw audio data.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub response: RealtimeResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseFunctionCallArgumentsDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.function_call_arguments.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseFunctionCallArgumentsDeltaType {
            #[default]
            #[serde(rename = "response.function_call_arguments.delta")]
            ResponseFunctionCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseFunctionCallArgumentsDelta {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseFunctionCallArgumentsDeltaType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let RealtimeServerEventResponseFunctionCallArgumentsDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
            ..
        } = RealtimeServerEventResponseFunctionCallArgumentsDelta::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseFunctionCallArgumentsDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.function_call_arguments.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseFunctionCallArgumentsDeltaType {
            #[default]
            #[serde(rename = "response.function_call_arguments.delta")]
            ResponseFunctionCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseFunctionCallArgumentsDelta<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseFunctionCallArgumentsDeltaType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        } = self;
        RealtimeServerEventResponseFunctionCallArgumentsDelta {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated function call arguments are updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseFunctionCallArgumentsDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the function call item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The ID of the function call."]
    pub call_id: String,
    #[doc = "The arguments delta as a JSON string."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseFunctionCallArgumentsDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.function_call_arguments.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseFunctionCallArgumentsDoneType {
            #[default]
            #[serde(rename = "response.function_call_arguments.done")]
            ResponseFunctionCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseFunctionCallArgumentsDone {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseFunctionCallArgumentsDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let RealtimeServerEventResponseFunctionCallArgumentsDone {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
            ..
        } = RealtimeServerEventResponseFunctionCallArgumentsDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseFunctionCallArgumentsDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.function_call_arguments.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseFunctionCallArgumentsDoneType {
            #[default]
            #[serde(rename = "response.function_call_arguments.done")]
            ResponseFunctionCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseFunctionCallArgumentsDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseFunctionCallArgumentsDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        } = self;
        RealtimeServerEventResponseFunctionCallArgumentsDone {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the model-generated function call arguments are done streaming.\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseFunctionCallArgumentsDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the function call item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The ID of the function call."]
    pub call_id: String,
    #[doc = "The final arguments as a JSON string."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseOutputItemAdded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.output_item.added`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseOutputItemAddedType {
            #[default]
            #[serde(rename = "response.output_item.added")]
            ResponseOutputItemAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseOutputItemAdded {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseOutputItemAddedType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let RealtimeServerEventResponseOutputItemAdded {
            event_id,
            response_id,
            output_index,
            item,
            ..
        } = RealtimeServerEventResponseOutputItemAdded::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            output_index,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseOutputItemAdded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.output_item.added`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseOutputItemAddedType {
            #[default]
            #[serde(rename = "response.output_item.added")]
            ResponseOutputItemAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseOutputItemAdded<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseOutputItemAddedType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let Self {
            event_id,
            response_id,
            output_index,
            item,
        } = self;
        RealtimeServerEventResponseOutputItemAdded {
            event_id,
            type_: &Default::default(),
            response_id,
            output_index,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a new Item is created during Response generation."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseOutputItemAdded {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the Response to which the item belongs."]
    pub response_id: String,
    #[doc = "The index of the output item in the Response."]
    pub output_index: u64,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseOutputItemDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.output_item.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseOutputItemDoneType {
            #[default]
            #[serde(rename = "response.output_item.done")]
            ResponseOutputItemDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseOutputItemDone {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseOutputItemDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: RealtimeConversationItem,
        }
        let RealtimeServerEventResponseOutputItemDone {
            event_id,
            response_id,
            output_index,
            item,
            ..
        } = RealtimeServerEventResponseOutputItemDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            output_index,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseOutputItemDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.output_item.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseOutputItemDoneType {
            #[default]
            #[serde(rename = "response.output_item.done")]
            ResponseOutputItemDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseOutputItemDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseOutputItemDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item")]
            item: &'a RealtimeConversationItem,
        }
        let Self {
            event_id,
            response_id,
            output_index,
            item,
        } = self;
        RealtimeServerEventResponseOutputItemDone {
            event_id,
            type_: &Default::default(),
            response_id,
            output_index,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when an Item is done streaming. Also emitted when a Response is \ninterrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseOutputItemDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the Response to which the item belongs."]
    pub response_id: String,
    #[doc = "The index of the output item in the Response."]
    pub output_index: u64,
    #[builder(default)]
    pub item: RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseTextDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.text.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseTextDeltaType {
            #[default]
            #[serde(rename = "response.text.delta")]
            ResponseTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseTextDelta {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseTextDeltaType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let RealtimeServerEventResponseTextDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = RealtimeServerEventResponseTextDelta::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseTextDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.text.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseTextDeltaType {
            #[default]
            #[serde(rename = "response.text.delta")]
            ResponseTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseTextDelta<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseTextDeltaType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        RealtimeServerEventResponseTextDelta {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the text value of a \"text\" content part is updated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseTextDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The text delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseTextDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `response.text.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseTextDoneType {
            #[default]
            #[serde(rename = "response.text.done")]
            ResponseTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseTextDone {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventResponseTextDoneType,
            #[serde(rename = "response_id")]
            #[allow(dead_code)]
            response_id: String,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let RealtimeServerEventResponseTextDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
            ..
        } = RealtimeServerEventResponseTextDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseTextDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `response.text.done`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventResponseTextDoneType {
            #[default]
            #[serde(rename = "response.text.done")]
            ResponseTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseTextDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventResponseTextDoneType,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        } = self;
        RealtimeServerEventResponseTextDone {
            event_id,
            type_: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when the text value of a \"text\" content part is done streaming. Also\nemitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseTextDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: u64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: u64,
    #[doc = "The final text content."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventSessionCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `session.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventSessionCreatedType {
            #[default]
            #[serde(rename = "session.created")]
            SessionCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventSessionCreated {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventSessionCreatedType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeSession,
        }
        let RealtimeServerEventSessionCreated {
            event_id, session, ..
        } = RealtimeServerEventSessionCreated::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventSessionCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `session.created`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventSessionCreatedType {
            #[default]
            #[serde(rename = "session.created")]
            SessionCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventSessionCreated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventSessionCreatedType,
            #[serde(rename = "session")]
            session: &'a RealtimeSession,
        }
        let Self { event_id, session } = self;
        RealtimeServerEventSessionCreated {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a Session is created. Emitted automatically when a new \nconnection is established as the first server event. This event will contain \nthe default Session configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventSessionCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub session: RealtimeSession,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventSessionUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `session.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventSessionUpdatedType {
            #[default]
            #[serde(rename = "session.updated")]
            SessionUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventSessionUpdated {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventSessionUpdatedType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeSession,
        }
        let RealtimeServerEventSessionUpdated {
            event_id, session, ..
        } = RealtimeServerEventSessionUpdated::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventSessionUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `session.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventSessionUpdatedType {
            #[default]
            #[serde(rename = "session.updated")]
            SessionUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventSessionUpdated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventSessionUpdatedType,
            #[serde(rename = "session")]
            session: &'a RealtimeSession,
        }
        let Self { event_id, session } = self;
        RealtimeServerEventSessionUpdated {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a session is updated with a `session.update` event, unless \nthere is an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventSessionUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub session: RealtimeSession,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventTranscriptionSessionUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The event type, must be `transcription_session.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventTranscriptionSessionUpdatedType {
            #[default]
            #[serde(rename = "transcription_session.updated")]
            TranscriptionSessionUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventTranscriptionSessionUpdated {
            #[serde(rename = "event_id")]
            #[allow(dead_code)]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RealtimeServerEventTranscriptionSessionUpdatedType,
            #[serde(rename = "session")]
            #[allow(dead_code)]
            session: RealtimeTranscriptionSessionCreateResponse,
        }
        let RealtimeServerEventTranscriptionSessionUpdated {
            event_id, session, ..
        } = RealtimeServerEventTranscriptionSessionUpdated::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventTranscriptionSessionUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The event type, must be `transcription_session.updated`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeServerEventTranscriptionSessionUpdatedType {
            #[default]
            #[serde(rename = "transcription_session.updated")]
            TranscriptionSessionUpdated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventTranscriptionSessionUpdated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RealtimeServerEventTranscriptionSessionUpdatedType,
            #[serde(rename = "session")]
            session: &'a RealtimeTranscriptionSessionCreateResponse,
        }
        let Self { event_id, session } = self;
        RealtimeServerEventTranscriptionSessionUpdated {
            event_id,
            type_: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[doc = "Returned when a transcription session is updated with a `transcription_session.update` event, unless \nthere is an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventTranscriptionSessionUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    pub session: RealtimeTranscriptionSessionCreateResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionModality {
            Text(#[allow(dead_code)] RealtimeSessionModalityText),
            Audio(#[allow(dead_code)] RealtimeSessionModalityAudio),
        }
        Ok(match RealtimeSessionModality::deserialize(deserializer)? {
            RealtimeSessionModality::Text(_) => Self::Text,
            RealtimeSessionModality::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for RealtimeSessionModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionModality<'a> {
            Text(#[allow(dead_code)] &'a RealtimeSessionModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeSessionModalityAudio),
        }
        match self {
            Self::Text => RealtimeSessionModality::Text(&Default::default()).serialize(serializer),
            Self::Audio => {
                RealtimeSessionModality::Audio(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview")]
            Gpt4oRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
            Gpt4oRealtimePreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
            Gpt4oRealtimePreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2025_06_03 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2025-06-03")]
            Gpt4oRealtimePreview2025_06_03,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oMiniRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview")]
            Gpt4oMiniRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oMiniRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
            Gpt4oMiniRealtimePreview2024_12_17,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionModel {
            Gpt4oRealtimePreview(#[allow(dead_code)] RealtimeSessionModelGpt4oRealtimePreview),
            Gpt4oRealtimePreview2024_10_01(
                #[allow(dead_code)] RealtimeSessionModelGpt4oRealtimePreview2024_10_01,
            ),
            Gpt4oRealtimePreview2024_12_17(
                #[allow(dead_code)] RealtimeSessionModelGpt4oRealtimePreview2024_12_17,
            ),
            Gpt4oRealtimePreview2025_06_03(
                #[allow(dead_code)] RealtimeSessionModelGpt4oRealtimePreview2025_06_03,
            ),
            Gpt4oMiniRealtimePreview(
                #[allow(dead_code)] RealtimeSessionModelGpt4oMiniRealtimePreview,
            ),
            Gpt4oMiniRealtimePreview2024_12_17(
                #[allow(dead_code)] RealtimeSessionModelGpt4oMiniRealtimePreview2024_12_17,
            ),
        }
        Ok(match RealtimeSessionModel::deserialize(deserializer)? {
            RealtimeSessionModel::Gpt4oRealtimePreview(_) => Self::Gpt4oRealtimePreview,
            RealtimeSessionModel::Gpt4oRealtimePreview2024_10_01(_) => {
                Self::Gpt4oRealtimePreview2024_10_01
            }
            RealtimeSessionModel::Gpt4oRealtimePreview2024_12_17(_) => {
                Self::Gpt4oRealtimePreview2024_12_17
            }
            RealtimeSessionModel::Gpt4oRealtimePreview2025_06_03(_) => {
                Self::Gpt4oRealtimePreview2025_06_03
            }
            RealtimeSessionModel::Gpt4oMiniRealtimePreview(_) => Self::Gpt4oMiniRealtimePreview,
            RealtimeSessionModel::Gpt4oMiniRealtimePreview2024_12_17(_) => {
                Self::Gpt4oMiniRealtimePreview2024_12_17
            }
        })
    }
}
impl serde::Serialize for RealtimeSessionModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview")]
            Gpt4oRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
            Gpt4oRealtimePreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
            Gpt4oRealtimePreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oRealtimePreview2025_06_03 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2025-06-03")]
            Gpt4oRealtimePreview2025_06_03,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oMiniRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview")]
            Gpt4oMiniRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionModelGpt4oMiniRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
            Gpt4oMiniRealtimePreview2024_12_17,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionModel<'a> {
            Gpt4oRealtimePreview(#[allow(dead_code)] &'a RealtimeSessionModelGpt4oRealtimePreview),
            Gpt4oRealtimePreview2024_10_01(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oRealtimePreview2024_10_01,
            ),
            Gpt4oRealtimePreview2024_12_17(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oRealtimePreview2024_12_17,
            ),
            Gpt4oRealtimePreview2025_06_03(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oRealtimePreview2025_06_03,
            ),
            Gpt4oMiniRealtimePreview(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oMiniRealtimePreview,
            ),
            Gpt4oMiniRealtimePreview2024_12_17(
                #[allow(dead_code)] &'a RealtimeSessionModelGpt4oMiniRealtimePreview2024_12_17,
            ),
        }
        match self {
            Self::Gpt4oRealtimePreview => {
                RealtimeSessionModel::Gpt4oRealtimePreview(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2024_10_01 => {
                RealtimeSessionModel::Gpt4oRealtimePreview2024_10_01(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2024_12_17 => {
                RealtimeSessionModel::Gpt4oRealtimePreview2024_12_17(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2025_06_03 => {
                RealtimeSessionModel::Gpt4oRealtimePreview2025_06_03(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4oMiniRealtimePreview => {
                RealtimeSessionModel::Gpt4oMiniRealtimePreview(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4oMiniRealtimePreview2024_12_17 => {
                RealtimeSessionModel::Gpt4oMiniRealtimePreview2024_12_17(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The Realtime model used for this session.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionModel {
    #[doc = "gpt-4o-realtime-preview"]
    Gpt4oRealtimePreview,
    #[doc = "gpt-4o-realtime-preview-2024-10-01"]
    Gpt4oRealtimePreview2024_10_01,
    #[doc = "gpt-4o-realtime-preview-2024-12-17"]
    Gpt4oRealtimePreview2024_12_17,
    #[doc = "gpt-4o-realtime-preview-2025-06-03"]
    Gpt4oRealtimePreview2025_06_03,
    #[doc = "gpt-4o-mini-realtime-preview"]
    Gpt4oMiniRealtimePreview,
    #[doc = "gpt-4o-mini-realtime-preview-2024-12-17"]
    Gpt4oMiniRealtimePreview2024_12_17,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionInputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionInputAudioFormat {
            Pcm16(#[allow(dead_code)] RealtimeSessionInputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeSessionInputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeSessionInputAudioFormatG711Alaw),
        }
        Ok(
            match RealtimeSessionInputAudioFormat::deserialize(deserializer)? {
                RealtimeSessionInputAudioFormat::Pcm16(_) => Self::Pcm16,
                RealtimeSessionInputAudioFormat::G711Ulaw(_) => Self::G711Ulaw,
                RealtimeSessionInputAudioFormat::G711Alaw(_) => Self::G711Alaw,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionInputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionInputAudioFormat<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeSessionInputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeSessionInputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeSessionInputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => {
                RealtimeSessionInputAudioFormat::Pcm16(&Default::default()).serialize(serializer)
            }
            Self::G711Ulaw => {
                RealtimeSessionInputAudioFormat::G711Ulaw(&Default::default()).serialize(serializer)
            }
            Self::G711Alaw => {
                RealtimeSessionInputAudioFormat::G711Alaw(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate, \nsingle channel (mono), and little-endian byte order.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionInputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionOutputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionOutputAudioFormat {
            Pcm16(#[allow(dead_code)] RealtimeSessionOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeSessionOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeSessionOutputAudioFormatG711Alaw),
        }
        Ok(
            match RealtimeSessionOutputAudioFormat::deserialize(deserializer)? {
                RealtimeSessionOutputAudioFormat::Pcm16(_) => Self::Pcm16,
                RealtimeSessionOutputAudioFormat::G711Ulaw(_) => Self::G711Ulaw,
                RealtimeSessionOutputAudioFormat::G711Alaw(_) => Self::G711Alaw,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionOutputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionOutputAudioFormat<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeSessionOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeSessionOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeSessionOutputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => {
                RealtimeSessionOutputAudioFormat::Pcm16(&Default::default()).serialize(serializer)
            }
            Self::G711Ulaw => RealtimeSessionOutputAudioFormat::G711Ulaw(&Default::default())
                .serialize(serializer),
            Self::G711Alaw => RealtimeSessionOutputAudioFormat::G711Alaw(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionOutputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionInputAudioTranscription {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionInputAudioTranscription {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
        }
        let RealtimeSessionInputAudioTranscription {
            model,
            language,
            prompt,
            ..
        } = RealtimeSessionInputAudioTranscription::deserialize(deserializer)?;
        Ok(Self {
            model,
            language,
            prompt,
        })
    }
}
impl serde::Serialize for RealtimeSessionInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionInputAudioTranscription<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
        }
        let Self {
            model,
            language,
            prompt,
        } = self;
        RealtimeSessionInputAudioTranscription {
            model,
            language,
            prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs  asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionInputAudioTranscription {
    #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](https://platform.openai.com/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"]
    #[builder(default)]
    pub prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTurnDetectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionTurnDetectionType {
            ServerVad(#[allow(dead_code)] RealtimeSessionTurnDetectionTypeServerVad),
            SemanticVad(#[allow(dead_code)] RealtimeSessionTurnDetectionTypeSemanticVad),
        }
        Ok(
            match RealtimeSessionTurnDetectionType::deserialize(deserializer)? {
                RealtimeSessionTurnDetectionType::ServerVad(_) => Self::ServerVad,
                RealtimeSessionTurnDetectionType::SemanticVad(_) => Self::SemanticVad,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionTurnDetectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionTurnDetectionType<'a> {
            ServerVad(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionTypeServerVad),
            SemanticVad(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionTypeSemanticVad),
        }
        match self {
            Self::ServerVad => RealtimeSessionTurnDetectionType::ServerVad(&Default::default())
                .serialize(serializer),
            Self::SemanticVad => RealtimeSessionTurnDetectionType::SemanticVad(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "Type of turn detection.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionTurnDetectionType {
    #[doc = "server_vad"]
    #[default]
    ServerVad,
    #[doc = "semantic_vad"]
    SemanticVad,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTurnDetectionEagerness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionTurnDetectionEagerness {
            Low(#[allow(dead_code)] RealtimeSessionTurnDetectionEagernessLow),
            Medium(#[allow(dead_code)] RealtimeSessionTurnDetectionEagernessMedium),
            High(#[allow(dead_code)] RealtimeSessionTurnDetectionEagernessHigh),
            Auto(#[allow(dead_code)] RealtimeSessionTurnDetectionEagernessAuto),
        }
        Ok(
            match RealtimeSessionTurnDetectionEagerness::deserialize(deserializer)? {
                RealtimeSessionTurnDetectionEagerness::Low(_) => Self::Low,
                RealtimeSessionTurnDetectionEagerness::Medium(_) => Self::Medium,
                RealtimeSessionTurnDetectionEagerness::High(_) => Self::High,
                RealtimeSessionTurnDetectionEagerness::Auto(_) => Self::Auto,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionTurnDetectionEagerness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionTurnDetectionEagerness<'a> {
            Low(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionEagernessLow),
            Medium(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionEagernessMedium),
            High(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionEagernessHigh),
            Auto(#[allow(dead_code)] &'a RealtimeSessionTurnDetectionEagernessAuto),
        }
        match self {
            Self::Low => RealtimeSessionTurnDetectionEagerness::Low(&Default::default())
                .serialize(serializer),
            Self::Medium => RealtimeSessionTurnDetectionEagerness::Medium(&Default::default())
                .serialize(serializer),
            Self::High => RealtimeSessionTurnDetectionEagerness::High(&Default::default())
                .serialize(serializer),
            Self::Auto => RealtimeSessionTurnDetectionEagerness::Auto(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionTurnDetectionEagerness {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionTurnDetection {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[allow(dead_code)]
            eagerness: Option<RealtimeSessionTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
            #[serde(rename = "create_response")]
            #[allow(dead_code)]
            create_response: Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[allow(dead_code)]
            interrupt_response: Option<bool>,
        }
        let RealtimeSessionTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
            ..
        } = RealtimeSessionTurnDetection::deserialize(deserializer)?;
        Ok(Self {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        })
    }
}
impl serde::Serialize for RealtimeSessionTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionTurnDetection<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[serde(skip_serializing_if = "Option::is_none")]
            eagerness: &'a Option<RealtimeSessionTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
            #[serde(rename = "create_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            create_response: &'a Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            interrupt_response: &'a Option<bool>,
        }
        let Self {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        } = self;
        RealtimeSessionTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionTurnDetection {
    #[doc = "Type of turn detection.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeSessionTurnDetectionType>,
    #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
    #[builder(default)]
    pub eagerness: Option<RealtimeSessionTurnDetectionEagerness>,
    #[doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
    #[doc = "Whether or not to automatically generate a response when a VAD stop event occurs.\n"]
    #[builder(default)]
    pub create_response: Option<bool>,
    #[doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs.\n"]
    #[builder(default)]
    pub interrupt_response: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionInputAudioNoiseReductionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionInputAudioNoiseReductionType {
            NearField(#[allow(dead_code)] RealtimeSessionInputAudioNoiseReductionTypeNearField),
            FarField(#[allow(dead_code)] RealtimeSessionInputAudioNoiseReductionTypeFarField),
        }
        Ok(
            match RealtimeSessionInputAudioNoiseReductionType::deserialize(deserializer)? {
                RealtimeSessionInputAudioNoiseReductionType::NearField(_) => Self::NearField,
                RealtimeSessionInputAudioNoiseReductionType::FarField(_) => Self::FarField,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionInputAudioNoiseReductionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionInputAudioNoiseReductionType<'a> {
            NearField(#[allow(dead_code)] &'a RealtimeSessionInputAudioNoiseReductionTypeNearField),
            FarField(#[allow(dead_code)] &'a RealtimeSessionInputAudioNoiseReductionTypeFarField),
        }
        match self {
            Self::NearField => {
                RealtimeSessionInputAudioNoiseReductionType::NearField(&Default::default())
                    .serialize(serializer)
            }
            Self::FarField => {
                RealtimeSessionInputAudioNoiseReductionType::FarField(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionInputAudioNoiseReductionType {
    #[doc = "near_field"]
    NearField,
    #[doc = "far_field"]
    FarField,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionInputAudioNoiseReduction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionInputAudioNoiseReduction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionInputAudioNoiseReductionType>,
        }
        let RealtimeSessionInputAudioNoiseReduction { type_, .. } =
            RealtimeSessionInputAudioNoiseReduction::deserialize(deserializer)?;
        Ok(Self { type_ })
    }
}
impl serde::Serialize for RealtimeSessionInputAudioNoiseReduction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionInputAudioNoiseReduction<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionInputAudioNoiseReductionType>,
        }
        let Self { type_ } = self;
        RealtimeSessionInputAudioNoiseReduction { type_ }.serialize(serializer)
    }
}
#[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionInputAudioNoiseReduction {
    #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeSessionInputAudioNoiseReductionType>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTracing1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionTracing1 {
            #[serde(rename = "workflow_name")]
            #[allow(dead_code)]
            workflow_name: Option<String>,
            #[serde(rename = "group_id")]
            #[allow(dead_code)]
            group_id: Option<String>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionTracing1 {
            workflow_name,
            group_id,
            metadata,
            ..
        } = RealtimeSessionTracing1::deserialize(deserializer)?;
        Ok(Self {
            workflow_name,
            group_id,
            metadata,
        })
    }
}
impl serde::Serialize for RealtimeSessionTracing1 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionTracing1<'a> {
            #[serde(rename = "workflow_name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            workflow_name: &'a Option<String>,
            #[serde(rename = "group_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            group_id: &'a Option<String>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            workflow_name,
            group_id,
            metadata,
        } = self;
        RealtimeSessionTracing1 {
            workflow_name,
            group_id,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Granular configuration for tracing.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionTracing1 {
    #[doc = "The name of the workflow to attach to this trace. This is used to \nname the trace in the traces dashboard.\n"]
    #[builder(default)]
    pub workflow_name: Option<String>,
    #[doc = "The group id to attach to this trace to enable filtering and \ngrouping in the traces dashboard.\n"]
    #[builder(default)]
    pub group_id: Option<String>,
    #[doc = "The arbitrary metadata to attach to this trace to enable \nfiltering in the traces dashboard.\n"]
    #[builder(default)]
    pub metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTracing {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTracingAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionTracing {
            Auto(#[allow(dead_code)] RealtimeSessionTracingAuto),
            _1(#[allow(dead_code)] RealtimeSessionTracing1),
        }
        Ok(match RealtimeSessionTracing::deserialize(deserializer)? {
            RealtimeSessionTracing::Auto(_) => Self::Auto,
            RealtimeSessionTracing::_1(_v) => Self::_1(_v),
        })
    }
}
impl serde::Serialize for RealtimeSessionTracing {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionTracingAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionTracing<'a> {
            Auto(#[allow(dead_code)] &'a RealtimeSessionTracingAuto),
            _1(#[allow(dead_code)] &'a RealtimeSessionTracing1),
        }
        match self {
            Self::Auto => RealtimeSessionTracing::Auto(&Default::default()).serialize(serializer),
            Self::_1(_v) => RealtimeSessionTracing::_1(_v).serialize(serializer),
        }
    }
}
#[doc = "Configuration options for tracing. Set to null to disable tracing. Once \ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the \nworkflow name, group id, and metadata.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionTracing {
    #[doc = "auto"]
    Auto,
    #[doc = "Granular configuration for tracing.\n"]
    _1(RealtimeSessionTracing1),
}
#[doc = "The type of the tool, i.e. `function`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeSessionToolType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionToolType>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionTool {
            type_,
            name,
            description,
            parameters,
            ..
        } = RealtimeSessionTool::deserialize(deserializer)?;
        Ok(Self {
            type_,
            name,
            description,
            parameters,
        })
    }
}
impl serde::Serialize for RealtimeSessionTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionTool<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionToolType>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            type_,
            name,
            description,
            parameters,
        } = self;
        RealtimeSessionTool {
            type_,
            name,
            description,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionTool {
    #[doc = "The type of the tool, i.e. `function`."]
    #[builder(default)]
    pub type_: Option<RealtimeSessionToolType>,
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "Parameters of the function in JSON Schema."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionMaxResponseOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionMaxResponseOutputTokens {
            Inf(#[allow(dead_code)] RealtimeSessionMaxResponseOutputTokensInf),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match RealtimeSessionMaxResponseOutputTokens::deserialize(deserializer)? {
                RealtimeSessionMaxResponseOutputTokens::Integer(_v) => Self::Integer(_v),
                RealtimeSessionMaxResponseOutputTokens::Inf(_) => Self::Inf,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionMaxResponseOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionMaxResponseOutputTokens<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeSessionMaxResponseOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => {
                RealtimeSessionMaxResponseOutputTokens::Integer(_v).serialize(serializer)
            }
            Self::Inf => RealtimeSessionMaxResponseOutputTokens::Inf(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionMaxResponseOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeSession {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSession {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeSessionModality>>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<RealtimeSessionModel>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<RealtimeSessionInputAudioFormat>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<RealtimeSessionOutputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription: Option<RealtimeSessionInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeSessionTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[allow(dead_code)]
            input_audio_noise_reduction: Option<RealtimeSessionInputAudioNoiseReduction>,
            #[serde(rename = "speed")]
            #[allow(dead_code)]
            speed: Option<f64>,
            #[serde(rename = "tracing")]
            #[allow(dead_code)]
            tracing: Option<RealtimeSessionTracing>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<RealtimeSessionTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[allow(dead_code)]
            max_response_output_tokens: Option<RealtimeSessionMaxResponseOutputTokens>,
        }
        let RealtimeSession {
            id,
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            speed,
            tracing,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            ..
        } = RealtimeSession::deserialize(deserializer)?;
        Ok(Self {
            id,
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            speed,
            tracing,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        })
    }
}
impl serde::Serialize for RealtimeSession {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSession<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeSessionModality>>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<RealtimeSessionModel>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format: &'a Option<RealtimeSessionInputAudioFormat>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<RealtimeSessionOutputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription: &'a Option<RealtimeSessionInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeSessionTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_noise_reduction: &'a Option<RealtimeSessionInputAudioNoiseReduction>,
            #[serde(rename = "speed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            speed: &'a Option<f64>,
            #[serde(rename = "tracing")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tracing: &'a Option<RealtimeSessionTracing>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<RealtimeSessionTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_response_output_tokens: &'a Option<RealtimeSessionMaxResponseOutputTokens>,
        }
        let Self {
            id,
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            speed,
            tracing,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        } = self;
        RealtimeSession {
            id,
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            speed,
            tracing,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Realtime session object configuration."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSession {
    #[doc = "Unique identifier for the session that looks like `sess_1234567890abcdef`.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeSessionModality>>,
    #[doc = "The Realtime model used for this session.\n"]
    #[builder(default)]
    pub model: Option<RealtimeSessionModel>,
    #[doc = "The default system instructions (i.e. system message) prepended to model \ncalls. This field allows the client to guide the model on desired \nresponses. The model can be instructed on response content and format, \n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good \nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion \ninto your voice\", \"laugh frequently\"). The instructions are not\nguaranteed to be followed by the model, but they provide guidance to the \nmodel on the desired behavior.\n\n\nNote that the server sets default instructions which will be used if this\nfield is not set and are visible in the `session.created` event at the\nstart of the session.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the\nsession once the model has responded with audio at least once. Current\nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`,\n`onyx`, `nova`, `sage`, `shimmer`, and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate, \nsingle channel (mono), and little-endian byte order.\n"]
    #[builder(default)]
    pub input_audio_format: Option<RealtimeSessionInputAudioFormat>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
    #[builder(default)]
    pub output_audio_format: Option<RealtimeSessionOutputAudioFormat>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be  set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs  asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[builder(default)]
    pub input_audio_transcription: Option<RealtimeSessionInputAudioTranscription>,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeSessionTurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[builder(default)]
    pub input_audio_noise_reduction: Option<RealtimeSessionInputAudioNoiseReduction>,
    #[doc = "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\nin between model turns, not while a response is in progress.\n"]
    #[builder(default)]
    pub speed: Option<f64>,
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once \ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the \nworkflow name, group id, and metadata.\n"]
    #[builder(default)]
    pub tracing: Option<RealtimeSessionTracing>,
    #[doc = "Tools (functions) available to the model."]
    #[builder(default)]
    pub tools: Option<Vec<RealtimeSessionTool>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or \nspecify a function.\n"]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. For audio models a temperature of 0.8 is highly recommended for best performance.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[builder(default)]
    pub max_response_output_tokens: Option<RealtimeSessionMaxResponseOutputTokens>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestModality {
            Text(#[allow(dead_code)] RealtimeSessionCreateRequestModalityText),
            Audio(#[allow(dead_code)] RealtimeSessionCreateRequestModalityAudio),
        }
        Ok(
            match RealtimeSessionCreateRequestModality::deserialize(deserializer)? {
                RealtimeSessionCreateRequestModality::Text(_) => Self::Text,
                RealtimeSessionCreateRequestModality::Audio(_) => Self::Audio,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestModality<'a> {
            Text(#[allow(dead_code)] &'a RealtimeSessionCreateRequestModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeSessionCreateRequestModalityAudio),
        }
        match self {
            Self::Text => RealtimeSessionCreateRequestModality::Text(&Default::default())
                .serialize(serializer),
            Self::Audio => RealtimeSessionCreateRequestModality::Audio(&Default::default())
                .serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview")]
            Gpt4oRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
            Gpt4oRealtimePreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
            Gpt4oRealtimePreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2025_06_03 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2025-06-03")]
            Gpt4oRealtimePreview2025_06_03,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview")]
            Gpt4oMiniRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
            Gpt4oMiniRealtimePreview2024_12_17,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestModel {
            Gpt4oRealtimePreview(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oRealtimePreview,
            ),
            Gpt4oRealtimePreview2024_10_01(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_10_01,
            ),
            Gpt4oRealtimePreview2024_12_17(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_12_17,
            ),
            Gpt4oRealtimePreview2025_06_03(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oRealtimePreview2025_06_03,
            ),
            Gpt4oMiniRealtimePreview(
                #[allow(dead_code)] RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview,
            ),
            Gpt4oMiniRealtimePreview2024_12_17(
                #[allow(dead_code)]
                RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview2024_12_17,
            ),
        }
        Ok(
            match RealtimeSessionCreateRequestModel::deserialize(deserializer)? {
                RealtimeSessionCreateRequestModel::Gpt4oRealtimePreview(_) => {
                    Self::Gpt4oRealtimePreview
                }
                RealtimeSessionCreateRequestModel::Gpt4oRealtimePreview2024_10_01(_) => {
                    Self::Gpt4oRealtimePreview2024_10_01
                }
                RealtimeSessionCreateRequestModel::Gpt4oRealtimePreview2024_12_17(_) => {
                    Self::Gpt4oRealtimePreview2024_12_17
                }
                RealtimeSessionCreateRequestModel::Gpt4oRealtimePreview2025_06_03(_) => {
                    Self::Gpt4oRealtimePreview2025_06_03
                }
                RealtimeSessionCreateRequestModel::Gpt4oMiniRealtimePreview(_) => {
                    Self::Gpt4oMiniRealtimePreview
                }
                RealtimeSessionCreateRequestModel::Gpt4oMiniRealtimePreview2024_12_17(_) => {
                    Self::Gpt4oMiniRealtimePreview2024_12_17
                }
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview")]
            Gpt4oRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
            Gpt4oRealtimePreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
            Gpt4oRealtimePreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oRealtimePreview2025_06_03 {
            #[default]
            #[serde(rename = "gpt-4o-realtime-preview-2025-06-03")]
            Gpt4oRealtimePreview2025_06_03,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview")]
            Gpt4oMiniRealtimePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
            Gpt4oMiniRealtimePreview2024_12_17,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestModel<'a> {
            Gpt4oRealtimePreview(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestModelGpt4oRealtimePreview,
            ),
            Gpt4oRealtimePreview2024_10_01(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_10_01,
            ),
            Gpt4oRealtimePreview2024_12_17(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestModelGpt4oRealtimePreview2024_12_17,
            ),
            Gpt4oRealtimePreview2025_06_03(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestModelGpt4oRealtimePreview2025_06_03,
            ),
            Gpt4oMiniRealtimePreview(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview,
            ),
            Gpt4oMiniRealtimePreview2024_12_17(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestModelGpt4oMiniRealtimePreview2024_12_17,
            ),
        }
        match self {
            Self::Gpt4oRealtimePreview => {
                RealtimeSessionCreateRequestModel::Gpt4oRealtimePreview(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2024_10_01 => {
                RealtimeSessionCreateRequestModel::Gpt4oRealtimePreview2024_10_01(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2024_12_17 => {
                RealtimeSessionCreateRequestModel::Gpt4oRealtimePreview2024_12_17(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::Gpt4oRealtimePreview2025_06_03 => {
                RealtimeSessionCreateRequestModel::Gpt4oRealtimePreview2025_06_03(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::Gpt4oMiniRealtimePreview => {
                RealtimeSessionCreateRequestModel::Gpt4oMiniRealtimePreview(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4oMiniRealtimePreview2024_12_17 => {
                RealtimeSessionCreateRequestModel::Gpt4oMiniRealtimePreview2024_12_17(
                    &Default::default(),
                )
                .serialize(serializer)
            }
        }
    }
}
#[doc = "The Realtime model used for this session.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestModel {
    #[doc = "gpt-4o-realtime-preview"]
    Gpt4oRealtimePreview,
    #[doc = "gpt-4o-realtime-preview-2024-10-01"]
    Gpt4oRealtimePreview2024_10_01,
    #[doc = "gpt-4o-realtime-preview-2024-12-17"]
    Gpt4oRealtimePreview2024_12_17,
    #[doc = "gpt-4o-realtime-preview-2025-06-03"]
    Gpt4oRealtimePreview2025_06_03,
    #[doc = "gpt-4o-mini-realtime-preview"]
    Gpt4oMiniRealtimePreview,
    #[doc = "gpt-4o-mini-realtime-preview-2024-12-17"]
    Gpt4oMiniRealtimePreview2024_12_17,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestInputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestInputAudioFormat {
            Pcm16(#[allow(dead_code)] RealtimeSessionCreateRequestInputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeSessionCreateRequestInputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeSessionCreateRequestInputAudioFormatG711Alaw),
        }
        Ok(
            match RealtimeSessionCreateRequestInputAudioFormat::deserialize(deserializer)? {
                RealtimeSessionCreateRequestInputAudioFormat::Pcm16(_) => Self::Pcm16,
                RealtimeSessionCreateRequestInputAudioFormat::G711Ulaw(_) => Self::G711Ulaw,
                RealtimeSessionCreateRequestInputAudioFormat::G711Alaw(_) => Self::G711Alaw,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestInputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestInputAudioFormat<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeSessionCreateRequestInputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeSessionCreateRequestInputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeSessionCreateRequestInputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => RealtimeSessionCreateRequestInputAudioFormat::Pcm16(&Default::default())
                .serialize(serializer),
            Self::G711Ulaw => {
                RealtimeSessionCreateRequestInputAudioFormat::G711Ulaw(&Default::default())
                    .serialize(serializer)
            }
            Self::G711Alaw => {
                RealtimeSessionCreateRequestInputAudioFormat::G711Alaw(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestInputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestOutputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestOutputAudioFormat {
            Pcm16(#[allow(dead_code)] RealtimeSessionCreateRequestOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] RealtimeSessionCreateRequestOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] RealtimeSessionCreateRequestOutputAudioFormatG711Alaw),
        }
        Ok(
            match RealtimeSessionCreateRequestOutputAudioFormat::deserialize(deserializer)? {
                RealtimeSessionCreateRequestOutputAudioFormat::Pcm16(_) => Self::Pcm16,
                RealtimeSessionCreateRequestOutputAudioFormat::G711Ulaw(_) => Self::G711Ulaw,
                RealtimeSessionCreateRequestOutputAudioFormat::G711Alaw(_) => Self::G711Alaw,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestOutputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestOutputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestOutputAudioFormat<'a> {
            Pcm16(#[allow(dead_code)] &'a RealtimeSessionCreateRequestOutputAudioFormatPcm16),
            G711Ulaw(#[allow(dead_code)] &'a RealtimeSessionCreateRequestOutputAudioFormatG711Ulaw),
            G711Alaw(#[allow(dead_code)] &'a RealtimeSessionCreateRequestOutputAudioFormatG711Alaw),
        }
        match self {
            Self::Pcm16 => {
                RealtimeSessionCreateRequestOutputAudioFormat::Pcm16(&Default::default())
                    .serialize(serializer)
            }
            Self::G711Ulaw => {
                RealtimeSessionCreateRequestOutputAudioFormat::G711Ulaw(&Default::default())
                    .serialize(serializer)
            }
            Self::G711Alaw => {
                RealtimeSessionCreateRequestOutputAudioFormat::G711Alaw(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestOutputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestInputAudioTranscription {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateRequestInputAudioTranscription {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
        }
        let RealtimeSessionCreateRequestInputAudioTranscription {
            model,
            language,
            prompt,
            ..
        } = RealtimeSessionCreateRequestInputAudioTranscription::deserialize(deserializer)?;
        Ok(Self {
            model,
            language,
            prompt,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateRequestInputAudioTranscription<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
        }
        let Self {
            model,
            language,
            prompt,
        } = self;
        RealtimeSessionCreateRequestInputAudioTranscription {
            model,
            language,
            prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestInputAudioTranscription {
    #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](https://platform.openai.com/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"]
    #[builder(default)]
    pub prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTurnDetectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestTurnDetectionType {
            ServerVad(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionTypeServerVad),
            SemanticVad(
                #[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionTypeSemanticVad,
            ),
        }
        Ok(
            match RealtimeSessionCreateRequestTurnDetectionType::deserialize(deserializer)? {
                RealtimeSessionCreateRequestTurnDetectionType::ServerVad(_) => Self::ServerVad,
                RealtimeSessionCreateRequestTurnDetectionType::SemanticVad(_) => Self::SemanticVad,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTurnDetectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestTurnDetectionType<'a> {
            ServerVad(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionTypeServerVad,
            ),
            SemanticVad(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionTypeSemanticVad,
            ),
        }
        match self {
            Self::ServerVad => {
                RealtimeSessionCreateRequestTurnDetectionType::ServerVad(&Default::default())
                    .serialize(serializer)
            }
            Self::SemanticVad => {
                RealtimeSessionCreateRequestTurnDetectionType::SemanticVad(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Type of turn detection.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestTurnDetectionType {
    #[doc = "server_vad"]
    #[default]
    ServerVad,
    #[doc = "semantic_vad"]
    SemanticVad,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTurnDetectionEagerness {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestTurnDetectionEagerness {
            Low(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionEagernessLow),
            Medium(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionEagernessMedium),
            High(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionEagernessHigh),
            Auto(#[allow(dead_code)] RealtimeSessionCreateRequestTurnDetectionEagernessAuto),
        }
        Ok(
            match RealtimeSessionCreateRequestTurnDetectionEagerness::deserialize(deserializer)? {
                RealtimeSessionCreateRequestTurnDetectionEagerness::Low(_) => Self::Low,
                RealtimeSessionCreateRequestTurnDetectionEagerness::Medium(_) => Self::Medium,
                RealtimeSessionCreateRequestTurnDetectionEagerness::High(_) => Self::High,
                RealtimeSessionCreateRequestTurnDetectionEagerness::Auto(_) => Self::Auto,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTurnDetectionEagerness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestTurnDetectionEagerness<'a> {
            Low(#[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionEagernessLow),
            Medium(
                #[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionEagernessMedium,
            ),
            High(#[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionEagernessHigh),
            Auto(#[allow(dead_code)] &'a RealtimeSessionCreateRequestTurnDetectionEagernessAuto),
        }
        match self {
            Self::Low => {
                RealtimeSessionCreateRequestTurnDetectionEagerness::Low(&Default::default())
                    .serialize(serializer)
            }
            Self::Medium => {
                RealtimeSessionCreateRequestTurnDetectionEagerness::Medium(&Default::default())
                    .serialize(serializer)
            }
            Self::High => {
                RealtimeSessionCreateRequestTurnDetectionEagerness::High(&Default::default())
                    .serialize(serializer)
            }
            Self::Auto => {
                RealtimeSessionCreateRequestTurnDetectionEagerness::Auto(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestTurnDetectionEagerness {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateRequestTurnDetection {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionCreateRequestTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[allow(dead_code)]
            eagerness: Option<RealtimeSessionCreateRequestTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
            #[serde(rename = "create_response")]
            #[allow(dead_code)]
            create_response: Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[allow(dead_code)]
            interrupt_response: Option<bool>,
        }
        let RealtimeSessionCreateRequestTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
            ..
        } = RealtimeSessionCreateRequestTurnDetection::deserialize(deserializer)?;
        Ok(Self {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateRequestTurnDetection<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionCreateRequestTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[serde(skip_serializing_if = "Option::is_none")]
            eagerness: &'a Option<RealtimeSessionCreateRequestTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
            #[serde(rename = "create_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            create_response: &'a Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            interrupt_response: &'a Option<bool>,
        }
        let Self {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        } = self;
        RealtimeSessionCreateRequestTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestTurnDetection {
    #[doc = "Type of turn detection.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeSessionCreateRequestTurnDetectionType>,
    #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
    #[builder(default)]
    pub eagerness: Option<RealtimeSessionCreateRequestTurnDetectionEagerness>,
    #[doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
    #[doc = "Whether or not to automatically generate a response when a VAD stop event occurs.\n"]
    #[builder(default)]
    pub create_response: Option<bool>,
    #[doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs.\n"]
    #[builder(default)]
    pub interrupt_response: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestInputAudioNoiseReductionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionType {
            NearField(
                #[allow(dead_code)]
                RealtimeSessionCreateRequestInputAudioNoiseReductionTypeNearField,
            ),
            FarField(
                #[allow(dead_code)]
                RealtimeSessionCreateRequestInputAudioNoiseReductionTypeFarField,
            ),
        }
        Ok(
            match RealtimeSessionCreateRequestInputAudioNoiseReductionType::deserialize(
                deserializer,
            )? {
                RealtimeSessionCreateRequestInputAudioNoiseReductionType::NearField(_) => {
                    Self::NearField
                }
                RealtimeSessionCreateRequestInputAudioNoiseReductionType::FarField(_) => {
                    Self::FarField
                }
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestInputAudioNoiseReductionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestInputAudioNoiseReductionType<'a> {
            NearField(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestInputAudioNoiseReductionTypeNearField,
            ),
            FarField(
                #[allow(dead_code)]
                &'a RealtimeSessionCreateRequestInputAudioNoiseReductionTypeFarField,
            ),
        }
        match self {
            Self::NearField => RealtimeSessionCreateRequestInputAudioNoiseReductionType::NearField(
                &Default::default(),
            )
            .serialize(serializer),
            Self::FarField => RealtimeSessionCreateRequestInputAudioNoiseReductionType::FarField(
                &Default::default(),
            )
            .serialize(serializer),
        }
    }
}
#[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestInputAudioNoiseReductionType {
    #[doc = "near_field"]
    NearField,
    #[doc = "far_field"]
    FarField,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestInputAudioNoiseReduction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateRequestInputAudioNoiseReduction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionCreateRequestInputAudioNoiseReductionType>,
        }
        let RealtimeSessionCreateRequestInputAudioNoiseReduction { type_, .. } =
            RealtimeSessionCreateRequestInputAudioNoiseReduction::deserialize(deserializer)?;
        Ok(Self { type_ })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestInputAudioNoiseReduction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateRequestInputAudioNoiseReduction<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionCreateRequestInputAudioNoiseReductionType>,
        }
        let Self { type_ } = self;
        RealtimeSessionCreateRequestInputAudioNoiseReduction { type_ }.serialize(serializer)
    }
}
#[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestInputAudioNoiseReduction {
    #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeSessionCreateRequestInputAudioNoiseReductionType>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTracing1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateRequestTracing1 {
            #[serde(rename = "workflow_name")]
            #[allow(dead_code)]
            workflow_name: Option<String>,
            #[serde(rename = "group_id")]
            #[allow(dead_code)]
            group_id: Option<String>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionCreateRequestTracing1 {
            workflow_name,
            group_id,
            metadata,
            ..
        } = RealtimeSessionCreateRequestTracing1::deserialize(deserializer)?;
        Ok(Self {
            workflow_name,
            group_id,
            metadata,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTracing1 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateRequestTracing1<'a> {
            #[serde(rename = "workflow_name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            workflow_name: &'a Option<String>,
            #[serde(rename = "group_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            group_id: &'a Option<String>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            workflow_name,
            group_id,
            metadata,
        } = self;
        RealtimeSessionCreateRequestTracing1 {
            workflow_name,
            group_id,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Granular configuration for tracing.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestTracing1 {
    #[doc = "The name of the workflow to attach to this trace. This is used to \nname the trace in the traces dashboard.\n"]
    #[builder(default)]
    pub workflow_name: Option<String>,
    #[doc = "The group id to attach to this trace to enable filtering and \ngrouping in the traces dashboard.\n"]
    #[builder(default)]
    pub group_id: Option<String>,
    #[doc = "The arbitrary metadata to attach to this trace to enable \nfiltering in the traces dashboard.\n"]
    #[builder(default)]
    pub metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTracing {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTracingAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestTracing {
            Auto(#[allow(dead_code)] RealtimeSessionCreateRequestTracingAuto),
            _1(#[allow(dead_code)] RealtimeSessionCreateRequestTracing1),
        }
        Ok(
            match RealtimeSessionCreateRequestTracing::deserialize(deserializer)? {
                RealtimeSessionCreateRequestTracing::Auto(_) => Self::Auto,
                RealtimeSessionCreateRequestTracing::_1(_v) => Self::_1(_v),
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTracing {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestTracingAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestTracing<'a> {
            Auto(#[allow(dead_code)] &'a RealtimeSessionCreateRequestTracingAuto),
            _1(#[allow(dead_code)] &'a RealtimeSessionCreateRequestTracing1),
        }
        match self {
            Self::Auto => {
                RealtimeSessionCreateRequestTracing::Auto(&Default::default()).serialize(serializer)
            }
            Self::_1(_v) => RealtimeSessionCreateRequestTracing::_1(_v).serialize(serializer),
        }
    }
}
#[doc = "Configuration options for tracing. Set to null to disable tracing. Once \ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the \nworkflow name, group id, and metadata.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestTracing {
    #[doc = "auto"]
    Auto,
    #[doc = "Granular configuration for tracing.\n"]
    _1(RealtimeSessionCreateRequestTracing1),
}
#[doc = "The type of the tool, i.e. `function`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeSessionCreateRequestToolType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateRequestTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionCreateRequestToolType>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionCreateRequestTool {
            type_,
            name,
            description,
            parameters,
            ..
        } = RealtimeSessionCreateRequestTool::deserialize(deserializer)?;
        Ok(Self {
            type_,
            name,
            description,
            parameters,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateRequestTool<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionCreateRequestToolType>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            type_,
            name,
            description,
            parameters,
        } = self;
        RealtimeSessionCreateRequestTool {
            type_,
            name,
            description,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestTool {
    #[doc = "The type of the tool, i.e. `function`."]
    #[builder(default)]
    pub type_: Option<RealtimeSessionCreateRequestToolType>,
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the function, including guidance on when and how\nto call it, and guidance about what to tell the user when calling\n(if anything).\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "Parameters of the function in JSON Schema."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestMaxResponseOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateRequestMaxResponseOutputTokens {
            Inf(#[allow(dead_code)] RealtimeSessionCreateRequestMaxResponseOutputTokensInf),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match RealtimeSessionCreateRequestMaxResponseOutputTokens::deserialize(deserializer)? {
                RealtimeSessionCreateRequestMaxResponseOutputTokens::Integer(_v) => {
                    Self::Integer(_v)
                }
                RealtimeSessionCreateRequestMaxResponseOutputTokens::Inf(_) => Self::Inf,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestMaxResponseOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateRequestMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateRequestMaxResponseOutputTokens<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeSessionCreateRequestMaxResponseOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => RealtimeSessionCreateRequestMaxResponseOutputTokens::Integer(_v)
                .serialize(serializer),
            Self::Inf => {
                RealtimeSessionCreateRequestMaxResponseOutputTokens::Inf(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateRequestMaxResponseOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
#[doc = "The anchor point for the ephemeral token expiration. Only `created_at` is currently supported.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeSessionCreateRequestClientSecretExpiresAtAnchor {
    #[default]
    #[serde(rename = "created_at")]
    CreatedAt,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestClientSecretExpiresAt {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateRequestClientSecretExpiresAt {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: Option<RealtimeSessionCreateRequestClientSecretExpiresAtAnchor>,
            #[serde(rename = "seconds")]
            #[allow(dead_code)]
            seconds: Option<u64>,
        }
        let RealtimeSessionCreateRequestClientSecretExpiresAt {
            anchor, seconds, ..
        } = RealtimeSessionCreateRequestClientSecretExpiresAt::deserialize(deserializer)?;
        Ok(Self { anchor, seconds })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestClientSecretExpiresAt {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateRequestClientSecretExpiresAt<'a> {
            #[serde(rename = "anchor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            anchor: &'a Option<RealtimeSessionCreateRequestClientSecretExpiresAtAnchor>,
            #[serde(rename = "seconds")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seconds: &'a Option<u64>,
        }
        let Self { anchor, seconds } = self;
        RealtimeSessionCreateRequestClientSecretExpiresAt { anchor, seconds }.serialize(serializer)
    }
}
#[doc = "Configuration for the ephemeral token expiration.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestClientSecretExpiresAt {
    #[doc = "The anchor point for the ephemeral token expiration. Only `created_at` is currently supported.\n"]
    #[builder(default)]
    pub anchor: Option<RealtimeSessionCreateRequestClientSecretExpiresAtAnchor>,
    #[doc = "The number of seconds from the anchor point to the expiration. Select a value between `10` and `7200`.\n"]
    #[builder(default)]
    pub seconds: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequestClientSecret {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateRequestClientSecret {
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<RealtimeSessionCreateRequestClientSecretExpiresAt>,
        }
        let RealtimeSessionCreateRequestClientSecret { expires_at, .. } =
            RealtimeSessionCreateRequestClientSecret::deserialize(deserializer)?;
        Ok(Self { expires_at })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequestClientSecret {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateRequestClientSecret<'a> {
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<RealtimeSessionCreateRequestClientSecretExpiresAt>,
        }
        let Self { expires_at } = self;
        RealtimeSessionCreateRequestClientSecret { expires_at }.serialize(serializer)
    }
}
#[doc = "Configuration options for the generated client secret.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequestClientSecret {
    #[doc = "Configuration for the ephemeral token expiration.\n"]
    #[builder(default)]
    pub expires_at: Option<RealtimeSessionCreateRequestClientSecretExpiresAt>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateRequest {
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeSessionCreateRequestModality>>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<RealtimeSessionCreateRequestModel>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<RealtimeSessionCreateRequestInputAudioFormat>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<RealtimeSessionCreateRequestOutputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription: Option<RealtimeSessionCreateRequestInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeSessionCreateRequestTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[allow(dead_code)]
            input_audio_noise_reduction:
                Option<RealtimeSessionCreateRequestInputAudioNoiseReduction>,
            #[serde(rename = "speed")]
            #[allow(dead_code)]
            speed: Option<f64>,
            #[serde(rename = "tracing")]
            #[allow(dead_code)]
            tracing: Option<RealtimeSessionCreateRequestTracing>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<RealtimeSessionCreateRequestTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[allow(dead_code)]
            max_response_output_tokens: Option<RealtimeSessionCreateRequestMaxResponseOutputTokens>,
            #[serde(rename = "client_secret")]
            #[allow(dead_code)]
            client_secret: Option<RealtimeSessionCreateRequestClientSecret>,
        }
        let RealtimeSessionCreateRequest {
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            speed,
            tracing,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            client_secret,
            ..
        } = RealtimeSessionCreateRequest::deserialize(deserializer)?;
        Ok(Self {
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            speed,
            tracing,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            client_secret,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateRequest<'a> {
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeSessionCreateRequestModality>>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<RealtimeSessionCreateRequestModel>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format: &'a Option<RealtimeSessionCreateRequestInputAudioFormat>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<RealtimeSessionCreateRequestOutputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription:
                &'a Option<RealtimeSessionCreateRequestInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeSessionCreateRequestTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_noise_reduction:
                &'a Option<RealtimeSessionCreateRequestInputAudioNoiseReduction>,
            #[serde(rename = "speed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            speed: &'a Option<f64>,
            #[serde(rename = "tracing")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tracing: &'a Option<RealtimeSessionCreateRequestTracing>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<RealtimeSessionCreateRequestTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_response_output_tokens:
                &'a Option<RealtimeSessionCreateRequestMaxResponseOutputTokens>,
            #[serde(rename = "client_secret")]
            #[serde(skip_serializing_if = "Option::is_none")]
            client_secret: &'a Option<RealtimeSessionCreateRequestClientSecret>,
        }
        let Self {
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            speed,
            tracing,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            client_secret,
        } = self;
        RealtimeSessionCreateRequest {
            modalities,
            model,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            speed,
            tracing,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            client_secret,
        }
        .serialize(serializer)
    }
}
#[doc = "Realtime session object configuration."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequest {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeSessionCreateRequestModality>>,
    #[doc = "The Realtime model used for this session.\n"]
    #[builder(default)]
    pub model: Option<RealtimeSessionCreateRequestModel>,
    #[doc = "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion into your voice\", \"laugh frequently\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\n\nNote that the server sets default instructions which will be used if this field is not set and are visible in the `session.created` event at the start of the session.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the\nsession once the model has responded with audio at least once. Current\nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`,\n`onyx`, `nova`, `sage`, `shimmer`, and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
    #[builder(default)]
    pub input_audio_format: Option<RealtimeSessionCreateRequestInputAudioFormat>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
    #[builder(default)]
    pub output_audio_format: Option<RealtimeSessionCreateRequestOutputAudioFormat>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[builder(default)]
    pub input_audio_transcription: Option<RealtimeSessionCreateRequestInputAudioTranscription>,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeSessionCreateRequestTurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[builder(default)]
    pub input_audio_noise_reduction: Option<RealtimeSessionCreateRequestInputAudioNoiseReduction>,
    #[doc = "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\nin between model turns, not while a response is in progress.\n"]
    #[builder(default)]
    pub speed: Option<f64>,
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once \ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the \nworkflow name, group id, and metadata.\n"]
    #[builder(default)]
    pub tracing: Option<RealtimeSessionCreateRequestTracing>,
    #[doc = "Tools (functions) available to the model."]
    #[builder(default)]
    pub tools: Option<Vec<RealtimeSessionCreateRequestTool>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or\nspecify a function.\n"]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. For audio models a temperature of 0.8 is highly recommended for best performance.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[builder(default)]
    pub max_response_output_tokens: Option<RealtimeSessionCreateRequestMaxResponseOutputTokens>,
    #[doc = "Configuration options for the generated client secret.\n"]
    #[builder(default)]
    pub client_secret: Option<RealtimeSessionCreateRequestClientSecret>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseClientSecret {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateResponseClientSecret {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: String,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
        }
        let RealtimeSessionCreateResponseClientSecret {
            value, expires_at, ..
        } = RealtimeSessionCreateResponseClientSecret::deserialize(deserializer)?;
        Ok(Self { value, expires_at })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseClientSecret {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateResponseClientSecret<'a> {
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
        }
        let Self { value, expires_at } = self;
        RealtimeSessionCreateResponseClientSecret { value, expires_at }.serialize(serializer)
    }
}
#[doc = "Ephemeral key returned by the API."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseClientSecret {
    #[doc = "Ephemeral key usable in client environments to authenticate connections\nto the Realtime API. Use this in client-side environments rather than\na standard API token, which should only be used server-side.\n"]
    pub value: String,
    #[doc = "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"]
    pub expires_at: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateResponseModality {
            Text(#[allow(dead_code)] RealtimeSessionCreateResponseModalityText),
            Audio(#[allow(dead_code)] RealtimeSessionCreateResponseModalityAudio),
        }
        Ok(
            match RealtimeSessionCreateResponseModality::deserialize(deserializer)? {
                RealtimeSessionCreateResponseModality::Text(_) => Self::Text,
                RealtimeSessionCreateResponseModality::Audio(_) => Self::Audio,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateResponseModality<'a> {
            Text(#[allow(dead_code)] &'a RealtimeSessionCreateResponseModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeSessionCreateResponseModalityAudio),
        }
        match self {
            Self::Text => RealtimeSessionCreateResponseModality::Text(&Default::default())
                .serialize(serializer),
            Self::Audio => RealtimeSessionCreateResponseModality::Audio(&Default::default())
                .serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateResponseModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseInputAudioTranscription {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateResponseInputAudioTranscription {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let RealtimeSessionCreateResponseInputAudioTranscription { model, .. } =
            RealtimeSessionCreateResponseInputAudioTranscription::deserialize(deserializer)?;
        Ok(Self { model })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateResponseInputAudioTranscription<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self { model } = self;
        RealtimeSessionCreateResponseInputAudioTranscription { model }.serialize(serializer)
    }
}
#[doc = "Configuration for input audio transcription, defaults to off and can be \nset to `null` to turn off once on. Input audio transcription is not native \nto the model, since the model consumes audio directly. Transcription runs \nasynchronously through Whisper and should be treated as rough guidance \nrather than the representation understood by the model.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseInputAudioTranscription {
    #[doc = "The model to use for transcription, `whisper-1` is the only currently \nsupported model.\n"]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseTracing1 {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateResponseTracing1 {
            #[serde(rename = "workflow_name")]
            #[allow(dead_code)]
            workflow_name: Option<String>,
            #[serde(rename = "group_id")]
            #[allow(dead_code)]
            group_id: Option<String>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionCreateResponseTracing1 {
            workflow_name,
            group_id,
            metadata,
            ..
        } = RealtimeSessionCreateResponseTracing1::deserialize(deserializer)?;
        Ok(Self {
            workflow_name,
            group_id,
            metadata,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseTracing1 {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateResponseTracing1<'a> {
            #[serde(rename = "workflow_name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            workflow_name: &'a Option<String>,
            #[serde(rename = "group_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            group_id: &'a Option<String>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            workflow_name,
            group_id,
            metadata,
        } = self;
        RealtimeSessionCreateResponseTracing1 {
            workflow_name,
            group_id,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Granular configuration for tracing.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseTracing1 {
    #[doc = "The name of the workflow to attach to this trace. This is used to \nname the trace in the traces dashboard.\n"]
    #[builder(default)]
    pub workflow_name: Option<String>,
    #[doc = "The group id to attach to this trace to enable filtering and \ngrouping in the traces dashboard.\n"]
    #[builder(default)]
    pub group_id: Option<String>,
    #[doc = "The arbitrary metadata to attach to this trace to enable \nfiltering in the traces dashboard.\n"]
    #[builder(default)]
    pub metadata: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseTracing {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseTracingAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateResponseTracing {
            Auto(#[allow(dead_code)] RealtimeSessionCreateResponseTracingAuto),
            _1(#[allow(dead_code)] RealtimeSessionCreateResponseTracing1),
        }
        Ok(
            match RealtimeSessionCreateResponseTracing::deserialize(deserializer)? {
                RealtimeSessionCreateResponseTracing::Auto(_) => Self::Auto,
                RealtimeSessionCreateResponseTracing::_1(_v) => Self::_1(_v),
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseTracing {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseTracingAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateResponseTracing<'a> {
            Auto(#[allow(dead_code)] &'a RealtimeSessionCreateResponseTracingAuto),
            _1(#[allow(dead_code)] &'a RealtimeSessionCreateResponseTracing1),
        }
        match self {
            Self::Auto => RealtimeSessionCreateResponseTracing::Auto(&Default::default())
                .serialize(serializer),
            Self::_1(_v) => RealtimeSessionCreateResponseTracing::_1(_v).serialize(serializer),
        }
    }
}
#[doc = "Configuration options for tracing. Set to null to disable tracing. Once \ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the \nworkflow name, group id, and metadata.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateResponseTracing {
    #[doc = "auto"]
    Auto,
    #[doc = "Granular configuration for tracing.\n"]
    _1(RealtimeSessionCreateResponseTracing1),
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateResponseTurnDetection {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
        }
        let RealtimeSessionCreateResponseTurnDetection {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            ..
        } = RealtimeSessionCreateResponseTurnDetection::deserialize(deserializer)?;
        Ok(Self {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateResponseTurnDetection<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
        }
        let Self {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        } = self;
        RealtimeSessionCreateResponseTurnDetection {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseTurnDetection {
    #[doc = "Type of turn detection, only `server_vad` is currently supported.\n"]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
}
#[doc = "The type of the tool, i.e. `function`."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeSessionCreateResponseToolType {
    #[default]
    #[serde(rename = "function")]
    Function,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateResponseTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeSessionCreateResponseToolType>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let RealtimeSessionCreateResponseTool {
            type_,
            name,
            description,
            parameters,
            ..
        } = RealtimeSessionCreateResponseTool::deserialize(deserializer)?;
        Ok(Self {
            type_,
            name,
            description,
            parameters,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateResponseTool<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeSessionCreateResponseToolType>,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
        }
        let Self {
            type_,
            name,
            description,
            parameters,
        } = self;
        RealtimeSessionCreateResponseTool {
            type_,
            name,
            description,
            parameters,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponseTool {
    #[doc = "The type of the tool, i.e. `function`."]
    #[builder(default)]
    pub type_: Option<RealtimeSessionCreateResponseToolType>,
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "Parameters of the function in JSON Schema."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponseMaxResponseOutputTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeSessionCreateResponseMaxResponseOutputTokens {
            Inf(#[allow(dead_code)] RealtimeSessionCreateResponseMaxResponseOutputTokensInf),
            Integer(#[allow(dead_code)] u64),
        }
        Ok(
            match RealtimeSessionCreateResponseMaxResponseOutputTokens::deserialize(deserializer)? {
                RealtimeSessionCreateResponseMaxResponseOutputTokens::Integer(_v) => {
                    Self::Integer(_v)
                }
                RealtimeSessionCreateResponseMaxResponseOutputTokens::Inf(_) => Self::Inf,
            },
        )
    }
}
impl serde::Serialize for RealtimeSessionCreateResponseMaxResponseOutputTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeSessionCreateResponseMaxResponseOutputTokensInf {
            #[default]
            #[serde(rename = "inf")]
            Inf,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeSessionCreateResponseMaxResponseOutputTokens<'a> {
            Integer(#[allow(dead_code)] &'a u64),
            Inf(#[allow(dead_code)] &'a RealtimeSessionCreateResponseMaxResponseOutputTokensInf),
        }
        match self {
            Self::Integer(_v) => RealtimeSessionCreateResponseMaxResponseOutputTokens::Integer(_v)
                .serialize(serializer),
            Self::Inf => {
                RealtimeSessionCreateResponseMaxResponseOutputTokens::Inf(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeSessionCreateResponseMaxResponseOutputTokens {
    Integer(u64),
    #[doc = "inf"]
    Inf,
}
impl<'de> serde::Deserialize<'de> for RealtimeSessionCreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeSessionCreateResponse {
            #[serde(rename = "client_secret")]
            #[allow(dead_code)]
            client_secret: RealtimeSessionCreateResponseClientSecret,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeSessionCreateResponseModality>>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "voice")]
            #[allow(dead_code)]
            voice: Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<String>,
            #[serde(rename = "output_audio_format")]
            #[allow(dead_code)]
            output_audio_format: Option<String>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription: Option<RealtimeSessionCreateResponseInputAudioTranscription>,
            #[serde(rename = "speed")]
            #[allow(dead_code)]
            speed: Option<f64>,
            #[serde(rename = "tracing")]
            #[allow(dead_code)]
            tracing: Option<RealtimeSessionCreateResponseTracing>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeSessionCreateResponseTurnDetection>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<RealtimeSessionCreateResponseTool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<String>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[allow(dead_code)]
            max_response_output_tokens:
                Option<RealtimeSessionCreateResponseMaxResponseOutputTokens>,
        }
        let RealtimeSessionCreateResponse {
            client_secret,
            modalities,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            speed,
            tracing,
            turn_detection,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
            ..
        } = RealtimeSessionCreateResponse::deserialize(deserializer)?;
        Ok(Self {
            client_secret,
            modalities,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            speed,
            tracing,
            turn_detection,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        })
    }
}
impl serde::Serialize for RealtimeSessionCreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeSessionCreateResponse<'a> {
            #[serde(rename = "client_secret")]
            client_secret: &'a RealtimeSessionCreateResponseClientSecret,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeSessionCreateResponseModality>>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "voice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            voice: &'a Option<VoiceIdsShared>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format: &'a Option<String>,
            #[serde(rename = "output_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_format: &'a Option<String>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription:
                &'a Option<RealtimeSessionCreateResponseInputAudioTranscription>,
            #[serde(rename = "speed")]
            #[serde(skip_serializing_if = "Option::is_none")]
            speed: &'a Option<f64>,
            #[serde(rename = "tracing")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tracing: &'a Option<RealtimeSessionCreateResponseTracing>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeSessionCreateResponseTurnDetection>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<RealtimeSessionCreateResponseTool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<String>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "max_response_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_response_output_tokens:
                &'a Option<RealtimeSessionCreateResponseMaxResponseOutputTokens>,
        }
        let Self {
            client_secret,
            modalities,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            speed,
            tracing,
            turn_detection,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        } = self;
        RealtimeSessionCreateResponse {
            client_secret,
            modalities,
            instructions,
            voice,
            input_audio_format,
            output_audio_format,
            input_audio_transcription,
            speed,
            tracing,
            turn_detection,
            tools,
            tool_choice,
            temperature,
            max_response_output_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "A new Realtime session configuration, with an ephermeral key. Default TTL\nfor keys is one minute.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponse {
    #[doc = "Ephemeral key returned by the API."]
    pub client_secret: RealtimeSessionCreateResponseClientSecret,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeSessionCreateResponseModality>>,
    #[doc = "The default system instructions (i.e. system message) prepended to model \ncalls. This field allows the client to guide the model on desired \nresponses. The model can be instructed on response content and format, \n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good \nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion \ninto your voice\", \"laugh frequently\"). The instructions are not guaranteed \nto be followed by the model, but they provide guidance to the model on the \ndesired behavior.\n\nNote that the server sets default instructions which will be used if this \nfield is not set and are visible in the `session.created` event at the \nstart of the session.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the \nsession once the model has responded with audio at least once. Current \nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo` `sage`, \n`shimmer` and `verse`.\n"]
    #[builder(default)]
    pub voice: Option<VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub input_audio_format: Option<String>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub output_audio_format: Option<String>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be \nset to `null` to turn off once on. Input audio transcription is not native \nto the model, since the model consumes audio directly. Transcription runs \nasynchronously through Whisper and should be treated as rough guidance \nrather than the representation understood by the model.\n"]
    #[builder(default)]
    pub input_audio_transcription: Option<RealtimeSessionCreateResponseInputAudioTranscription>,
    #[doc = "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\nin between model turns, not while a response is in progress.\n"]
    #[builder(default)]
    pub speed: Option<f64>,
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once \ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the \nworkflow name, group id, and metadata.\n"]
    #[builder(default)]
    pub tracing: Option<RealtimeSessionCreateResponseTracing>,
    #[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeSessionCreateResponseTurnDetection>,
    #[doc = "Tools (functions) available to the model."]
    #[builder(default)]
    pub tools: Option<Vec<RealtimeSessionCreateResponseTool>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or \nspecify a function.\n"]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[builder(default)]
    pub max_response_output_tokens: Option<RealtimeSessionCreateResponseMaxResponseOutputTokens>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeTranscriptionSessionCreateRequestModality {
            Text(#[allow(dead_code)] RealtimeTranscriptionSessionCreateRequestModalityText),
            Audio(#[allow(dead_code)] RealtimeTranscriptionSessionCreateRequestModalityAudio),
        }
        Ok(
            match RealtimeTranscriptionSessionCreateRequestModality::deserialize(deserializer)? {
                RealtimeTranscriptionSessionCreateRequestModality::Text(_) => Self::Text,
                RealtimeTranscriptionSessionCreateRequestModality::Audio(_) => Self::Audio,
            },
        )
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeTranscriptionSessionCreateRequestModality<'a> {
            Text(#[allow(dead_code)] &'a RealtimeTranscriptionSessionCreateRequestModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeTranscriptionSessionCreateRequestModalityAudio),
        }
        match self {
            Self::Text => {
                RealtimeTranscriptionSessionCreateRequestModality::Text(&Default::default())
                    .serialize(serializer)
            }
            Self::Audio => {
                RealtimeTranscriptionSessionCreateRequestModality::Audio(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestInputAudioFormat {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormat {
            Pcm16(
                #[allow(dead_code)] RealtimeTranscriptionSessionCreateRequestInputAudioFormatPcm16,
            ),
            G711Ulaw(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Ulaw,
            ),
            G711Alaw(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Alaw,
            ),
        }
        Ok(
            match RealtimeTranscriptionSessionCreateRequestInputAudioFormat::deserialize(
                deserializer,
            )? {
                RealtimeTranscriptionSessionCreateRequestInputAudioFormat::Pcm16(_) => Self::Pcm16,
                RealtimeTranscriptionSessionCreateRequestInputAudioFormat::G711Ulaw(_) => {
                    Self::G711Ulaw
                }
                RealtimeTranscriptionSessionCreateRequestInputAudioFormat::G711Alaw(_) => {
                    Self::G711Alaw
                }
            },
        )
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioFormat {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatPcm16 {
            #[default]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Ulaw {
            #[default]
            #[serde(rename = "g711_ulaw")]
            G711Ulaw,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Alaw {
            #[default]
            #[serde(rename = "g711_alaw")]
            G711Alaw,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioFormat<'a> {
            Pcm16(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioFormatPcm16,
            ),
            G711Ulaw(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Ulaw,
            ),
            G711Alaw(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioFormatG711Alaw,
            ),
        }
        match self {
            Self::Pcm16 => RealtimeTranscriptionSessionCreateRequestInputAudioFormat::Pcm16(
                &Default::default(),
            )
            .serialize(serializer),
            Self::G711Ulaw => RealtimeTranscriptionSessionCreateRequestInputAudioFormat::G711Ulaw(
                &Default::default(),
            )
            .serialize(serializer),
            Self::G711Alaw => RealtimeTranscriptionSessionCreateRequestInputAudioFormat::G711Alaw(
                &Default::default(),
            )
            .serialize(serializer),
        }
    }
}
#[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestInputAudioFormat {
    #[doc = "pcm16"]
    #[default]
    Pcm16,
    #[doc = "g711_ulaw"]
    G711Ulaw,
    #[doc = "g711_alaw"]
    G711Alaw,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oMiniTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelWhisper1 {
            #[default]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel {
            Gpt4oTranscribe (# [allow (dead_code)] RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oTranscribe) , Gpt4oMiniTranscribe (# [allow (dead_code)] RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oMiniTranscribe) , Whisper1 (# [allow (dead_code)] RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelWhisper1) }
        Ok (match RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel :: deserialize (deserializer) ? { RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel :: Gpt4oTranscribe (_) => Self :: Gpt4oTranscribe , RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel :: Gpt4oMiniTranscribe (_) => Self :: Gpt4oMiniTranscribe , RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel :: Whisper1 (_) => Self :: Whisper1 })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oMiniTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelWhisper1 {
            #[default]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel<'a> {
            Gpt4oTranscribe (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oTranscribe) , Gpt4oMiniTranscribe (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelGpt4oMiniTranscribe) , Whisper1 (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModelWhisper1) }
        match self { Self :: Gpt4oTranscribe => { RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel :: Gpt4oTranscribe (& Default :: default ()) . serialize (serializer) } , Self :: Gpt4oMiniTranscribe => { RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel :: Gpt4oMiniTranscribe (& Default :: default ()) . serialize (serializer) } , Self :: Whisper1 => { RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel :: Whisper1 (& Default :: default ()) . serialize (serializer) } }
    }
}
#[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel {
    #[doc = "gpt-4o-transcribe"]
    Gpt4oTranscribe,
    #[doc = "gpt-4o-mini-transcribe"]
    Gpt4oMiniTranscribe,
    #[doc = "whisper-1"]
    Whisper1,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestInputAudioTranscription
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel>,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
        }
        let RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
            model,
            language,
            prompt,
            ..
        } = RealtimeTranscriptionSessionCreateRequestInputAudioTranscription::deserialize(
            deserializer,
        )?;
        Ok(Self {
            model,
            language,
            prompt,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateRequestInputAudioTranscription<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel>,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
        }
        let Self {
            model,
            language,
            prompt,
        } = self;
        RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
            model,
            language,
            prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for input audio transcription. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequestInputAudioTranscription {
    #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
    #[builder(default)]
    pub model: Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscriptionModel>,
    #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](https://platform.openai.com/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"]
    #[builder(default)]
    pub prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestTurnDetectionType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionType {
            ServerVad(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeServerVad,
            ),
            SemanticVad(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeSemanticVad,
            ),
        }
        Ok(
            match RealtimeTranscriptionSessionCreateRequestTurnDetectionType::deserialize(
                deserializer,
            )? {
                RealtimeTranscriptionSessionCreateRequestTurnDetectionType::ServerVad(_) => {
                    Self::ServerVad
                }
                RealtimeTranscriptionSessionCreateRequestTurnDetectionType::SemanticVad(_) => {
                    Self::SemanticVad
                }
            },
        )
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestTurnDetectionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeServerVad {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeSemanticVad {
            #[default]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionType<'a> {
            ServerVad(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeServerVad,
            ),
            SemanticVad(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionTypeSemanticVad,
            ),
        }
        match self {
            Self::ServerVad => {
                RealtimeTranscriptionSessionCreateRequestTurnDetectionType::ServerVad(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::SemanticVad => {
                RealtimeTranscriptionSessionCreateRequestTurnDetectionType::SemanticVad(
                    &Default::default(),
                )
                .serialize(serializer)
            }
        }
    }
}
#[doc = "Type of turn detection.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestTurnDetectionType {
    #[doc = "server_vad"]
    #[default]
    ServerVad,
    #[doc = "semantic_vad"]
    SemanticVad,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness {
            Low(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessLow,
            ),
            Medium(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessMedium,
            ),
            High(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessHigh,
            ),
            Auto(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessAuto,
            ),
        }
        Ok(
            match RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::deserialize(
                deserializer,
            )? {
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::Low(_) => {
                    Self::Low
                }
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::Medium(_) => {
                    Self::Medium
                }
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::High(_) => {
                    Self::High
                }
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::Auto(_) => {
                    Self::Auto
                }
            },
        )
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness<'a> {
            Low(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessLow,
            ),
            Medium(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessMedium,
            ),
            High(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessHigh,
            ),
            Auto(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestTurnDetectionEagernessAuto,
            ),
        }
        match self {
            Self::Low => RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::Low(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Medium => {
                RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::Medium(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::High => RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::High(
                &Default::default(),
            )
            .serialize(serializer),
            Self::Auto => RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness::Auto(
                &Default::default(),
            )
            .serialize(serializer),
        }
    }
}
#[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    #[default]
    Auto,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateRequestTurnDetection {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[allow(dead_code)]
            eagerness: Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
            #[serde(rename = "create_response")]
            #[allow(dead_code)]
            create_response: Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[allow(dead_code)]
            interrupt_response: Option<bool>,
        }
        let RealtimeTranscriptionSessionCreateRequestTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
            ..
        } = RealtimeTranscriptionSessionCreateRequestTurnDetection::deserialize(deserializer)?;
        Ok(Self {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateRequestTurnDetection<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionType>,
            #[serde(rename = "eagerness")]
            #[serde(skip_serializing_if = "Option::is_none")]
            eagerness: &'a Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
            #[serde(rename = "create_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            create_response: &'a Option<bool>,
            #[serde(rename = "interrupt_response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            interrupt_response: &'a Option<bool>,
        }
        let Self {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        } = self;
        RealtimeTranscriptionSessionCreateRequestTurnDetection {
            type_,
            eagerness,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            create_response,
            interrupt_response,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequestTurnDetection {
    #[doc = "Type of turn detection.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionType>,
    #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
    #[builder(default)]
    pub eagerness: Option<RealtimeTranscriptionSessionCreateRequestTurnDetectionEagerness>,
    #[doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
    #[doc = "Whether or not to automatically generate a response when a VAD stop event occurs. Not available for transcription sessions.\n"]
    #[builder(default)]
    pub create_response: Option<bool>,
    #[doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs. Not available for transcription sessions.\n"]
    #[builder(default)]
    pub interrupt_response: Option<bool>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType {
            NearField(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeNearField,
            ),
            FarField(
                #[allow(dead_code)]
                RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeFarField,
            ),
        }
        Ok (match RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType :: deserialize (deserializer) ? { RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType :: NearField (_) => Self :: NearField , RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType :: FarField (_) => Self :: FarField })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeNearField {
            #[default]
            #[serde(rename = "near_field")]
            NearField,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeFarField {
            #[default]
            #[serde(rename = "far_field")]
            FarField,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType<'a> {
            NearField(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeNearField,
            ),
            FarField(
                #[allow(dead_code)]
                &'a RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionTypeFarField,
            ),
        }
        match self {
            Self::NearField => {
                RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType::NearField(
                    &Default::default(),
                )
                .serialize(serializer)
            }
            Self::FarField => {
                RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType::FarField(
                    &Default::default(),
                )
                .serialize(serializer)
            }
        }
    }
}
#[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType {
    #[doc = "near_field"]
    NearField,
    #[doc = "far_field"]
    FarField,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType>,
        }
        let RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction { type_, .. } =
            RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction::deserialize(
                deserializer,
            )?;
        Ok(Self { type_ })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType>,
        }
        let Self { type_ } = self;
        RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction { type_ }
            .serialize(serializer)
    }
}
#[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction {
    #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
    #[builder(default)]
    pub type_: Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReductionType>,
}
#[doc = "The anchor point for the ephemeral token expiration. Only `created_at` is currently supported.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAtAnchor {
    #[default]
    #[serde(rename = "created_at")]
    CreatedAt,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: Option<RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAtAnchor>,
            #[serde(rename = "seconds")]
            #[allow(dead_code)]
            seconds: Option<u64>,
        }
        let RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt {
            anchor, seconds, ..
        } = RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt::deserialize(
            deserializer,
        )?;
        Ok(Self { anchor, seconds })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt<'a> {
            #[serde(rename = "anchor")]
            #[serde(skip_serializing_if = "Option::is_none")]
            anchor:
                &'a Option<RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAtAnchor>,
            #[serde(rename = "seconds")]
            #[serde(skip_serializing_if = "Option::is_none")]
            seconds: &'a Option<u64>,
        }
        let Self { anchor, seconds } = self;
        RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt { anchor, seconds }
            .serialize(serializer)
    }
}
#[doc = "Configuration for the ephemeral token expiration.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt {
    #[doc = "The anchor point for the ephemeral token expiration. Only `created_at` is currently supported.\n"]
    #[builder(default)]
    pub anchor: Option<RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAtAnchor>,
    #[doc = "The number of seconds from the anchor point to the expiration. Select a value between `10` and `7200`.\n"]
    #[builder(default)]
    pub seconds: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequestClientSecret {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateRequestClientSecret {
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt>,
        }
        let RealtimeTranscriptionSessionCreateRequestClientSecret { expires_at, .. } =
            RealtimeTranscriptionSessionCreateRequestClientSecret::deserialize(deserializer)?;
        Ok(Self { expires_at })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequestClientSecret {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateRequestClientSecret<'a> {
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt>,
        }
        let Self { expires_at } = self;
        RealtimeTranscriptionSessionCreateRequestClientSecret { expires_at }.serialize(serializer)
    }
}
#[doc = "Configuration options for the generated client secret.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequestClientSecret {
    #[doc = "Configuration for the ephemeral token expiration.\n"]
    #[builder(default)]
    pub expires_at: Option<RealtimeTranscriptionSessionCreateRequestClientSecretExpiresAt>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateRequest {
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeTranscriptionSessionCreateRequestModality>>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<RealtimeTranscriptionSessionCreateRequestInputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription:
                Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeTranscriptionSessionCreateRequestTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[allow(dead_code)]
            input_audio_noise_reduction:
                Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction>,
            #[serde(rename = "include")]
            #[allow(dead_code)]
            include: Option<Vec<String>>,
            #[serde(rename = "client_secret")]
            #[allow(dead_code)]
            client_secret: Option<RealtimeTranscriptionSessionCreateRequestClientSecret>,
        }
        let RealtimeTranscriptionSessionCreateRequest {
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            include,
            client_secret,
            ..
        } = RealtimeTranscriptionSessionCreateRequest::deserialize(deserializer)?;
        Ok(Self {
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            include,
            client_secret,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateRequest<'a> {
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeTranscriptionSessionCreateRequestModality>>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioFormat>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeTranscriptionSessionCreateRequestTurnDetection>,
            #[serde(rename = "input_audio_noise_reduction")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_noise_reduction:
                &'a Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction>,
            #[serde(rename = "include")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include: &'a Option<Vec<String>>,
            #[serde(rename = "client_secret")]
            #[serde(skip_serializing_if = "Option::is_none")]
            client_secret: &'a Option<RealtimeTranscriptionSessionCreateRequestClientSecret>,
        }
        let Self {
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            include,
            client_secret,
        } = self;
        RealtimeTranscriptionSessionCreateRequest {
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            input_audio_noise_reduction,
            include,
            client_secret,
        }
        .serialize(serializer)
    }
}
#[doc = "Realtime transcription session object configuration."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequest {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeTranscriptionSessionCreateRequestModality>>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
    #[builder(default)]
    pub input_audio_format: Option<RealtimeTranscriptionSessionCreateRequestInputAudioFormat>,
    #[doc = "Configuration for input audio transcription. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[builder(default)]
    pub input_audio_transcription:
        Option<RealtimeTranscriptionSessionCreateRequestInputAudioTranscription>,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjuction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeTranscriptionSessionCreateRequestTurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[builder(default)]
    pub input_audio_noise_reduction:
        Option<RealtimeTranscriptionSessionCreateRequestInputAudioNoiseReduction>,
    #[doc = "The set of items to include in the transcription. Current available items are:\n- `item.input_audio_transcription.logprobs`\n"]
    #[builder(default)]
    pub include: Option<Vec<String>>,
    #[doc = "Configuration options for the generated client secret.\n"]
    #[builder(default)]
    pub client_secret: Option<RealtimeTranscriptionSessionCreateRequestClientSecret>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateResponseClientSecret {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateResponseClientSecret {
            #[serde(rename = "value")]
            #[allow(dead_code)]
            value: String,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
        }
        let RealtimeTranscriptionSessionCreateResponseClientSecret {
            value, expires_at, ..
        } = RealtimeTranscriptionSessionCreateResponseClientSecret::deserialize(deserializer)?;
        Ok(Self { value, expires_at })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseClientSecret {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateResponseClientSecret<'a> {
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
        }
        let Self { value, expires_at } = self;
        RealtimeTranscriptionSessionCreateResponseClientSecret { value, expires_at }
            .serialize(serializer)
    }
}
#[doc = "Ephemeral key returned by the API. Only present when the session is\ncreated on the server via REST API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponseClientSecret {
    #[doc = "Ephemeral key usable in client environments to authenticate connections\nto the Realtime API. Use this in client-side environments rather than\na standard API token, which should only be used server-side.\n"]
    pub value: String,
    #[doc = "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"]
    pub expires_at: u64,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateResponseModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeTranscriptionSessionCreateResponseModality {
            Text(#[allow(dead_code)] RealtimeTranscriptionSessionCreateResponseModalityText),
            Audio(#[allow(dead_code)] RealtimeTranscriptionSessionCreateResponseModalityAudio),
        }
        Ok(
            match RealtimeTranscriptionSessionCreateResponseModality::deserialize(deserializer)? {
                RealtimeTranscriptionSessionCreateResponseModality::Text(_) => Self::Text,
                RealtimeTranscriptionSessionCreateResponseModality::Audio(_) => Self::Audio,
            },
        )
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeTranscriptionSessionCreateResponseModality<'a> {
            Text(#[allow(dead_code)] &'a RealtimeTranscriptionSessionCreateResponseModalityText),
            Audio(#[allow(dead_code)] &'a RealtimeTranscriptionSessionCreateResponseModalityAudio),
        }
        match self {
            Self::Text => {
                RealtimeTranscriptionSessionCreateResponseModality::Text(&Default::default())
                    .serialize(serializer)
            }
            Self::Audio => {
                RealtimeTranscriptionSessionCreateResponseModality::Audio(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateResponseModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oMiniTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelWhisper1 {
            #[default]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel {
            Gpt4oTranscribe (# [allow (dead_code)] RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oTranscribe) , Gpt4oMiniTranscribe (# [allow (dead_code)] RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oMiniTranscribe) , Whisper1 (# [allow (dead_code)] RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelWhisper1) }
        Ok (match RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel :: deserialize (deserializer) ? { RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel :: Gpt4oTranscribe (_) => Self :: Gpt4oTranscribe , RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel :: Gpt4oMiniTranscribe (_) => Self :: Gpt4oMiniTranscribe , RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel :: Whisper1 (_) => Self :: Whisper1 })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oMiniTranscribe {
            #[default]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelWhisper1 {
            #[default]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel<'a> {
            Gpt4oTranscribe (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oTranscribe) , Gpt4oMiniTranscribe (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelGpt4oMiniTranscribe) , Whisper1 (# [allow (dead_code)] & 'a RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModelWhisper1) }
        match self { Self :: Gpt4oTranscribe => { RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel :: Gpt4oTranscribe (& Default :: default ()) . serialize (serializer) } , Self :: Gpt4oMiniTranscribe => { RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel :: Gpt4oMiniTranscribe (& Default :: default ()) . serialize (serializer) } , Self :: Whisper1 => { RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel :: Whisper1 (& Default :: default ()) . serialize (serializer) } }
    }
}
#[doc = "The model to use for transcription. Can be `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, or `whisper-1`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel {
    #[doc = "gpt-4o-transcribe"]
    Gpt4oTranscribe,
    #[doc = "gpt-4o-mini-transcribe"]
    Gpt4oMiniTranscribe,
    #[doc = "whisper-1"]
    Whisper1,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeTranscriptionSessionCreateResponseInputAudioTranscription
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel>,
            #[serde(rename = "language")]
            #[allow(dead_code)]
            language: Option<String>,
            #[serde(rename = "prompt")]
            #[allow(dead_code)]
            prompt: Option<String>,
        }
        let RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
            model,
            language,
            prompt,
            ..
        } = RealtimeTranscriptionSessionCreateResponseInputAudioTranscription::deserialize(
            deserializer,
        )?;
        Ok(Self {
            model,
            language,
            prompt,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateResponseInputAudioTranscription<'a> {
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model:
                &'a Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel>,
            #[serde(rename = "language")]
            #[serde(skip_serializing_if = "Option::is_none")]
            language: &'a Option<String>,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<String>,
        }
        let Self {
            model,
            language,
            prompt,
        } = self;
        RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
            model,
            language,
            prompt,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration of the transcription model.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponseInputAudioTranscription {
    #[doc = "The model to use for transcription. Can be `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, or `whisper-1`.\n"]
    #[builder(default)]
    pub model: Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscriptionModel>,
    #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment. The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting) should match\nthe audio language.\n"]
    #[builder(default)]
    pub prompt: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateResponseTurnDetection {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateResponseTurnDetection {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
        }
        let RealtimeTranscriptionSessionCreateResponseTurnDetection {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
            ..
        } = RealtimeTranscriptionSessionCreateResponseTurnDetection::deserialize(deserializer)?;
        Ok(Self {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponseTurnDetection {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateResponseTurnDetection<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
        }
        let Self {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        } = self;
        RealtimeTranscriptionSessionCreateResponseTurnDetection {
            type_,
            threshold,
            prefix_padding_ms,
            silence_duration_ms,
        }
        .serialize(serializer)
    }
}
#[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponseTurnDetection {
    #[doc = "Type of turn detection, only `server_vad` is currently supported.\n"]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
    #[doc = "Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for RealtimeTranscriptionSessionCreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeTranscriptionSessionCreateResponse {
            #[serde(rename = "client_secret")]
            #[allow(dead_code)]
            client_secret: RealtimeTranscriptionSessionCreateResponseClientSecret,
            #[serde(rename = "modalities")]
            #[allow(dead_code)]
            modalities: Option<Vec<RealtimeTranscriptionSessionCreateResponseModality>>,
            #[serde(rename = "input_audio_format")]
            #[allow(dead_code)]
            input_audio_format: Option<String>,
            #[serde(rename = "input_audio_transcription")]
            #[allow(dead_code)]
            input_audio_transcription:
                Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[allow(dead_code)]
            turn_detection: Option<RealtimeTranscriptionSessionCreateResponseTurnDetection>,
        }
        let RealtimeTranscriptionSessionCreateResponse {
            client_secret,
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
            ..
        } = RealtimeTranscriptionSessionCreateResponse::deserialize(deserializer)?;
        Ok(Self {
            client_secret,
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
        })
    }
}
impl serde::Serialize for RealtimeTranscriptionSessionCreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeTranscriptionSessionCreateResponse<'a> {
            #[serde(rename = "client_secret")]
            client_secret: &'a RealtimeTranscriptionSessionCreateResponseClientSecret,
            #[serde(rename = "modalities")]
            #[serde(skip_serializing_if = "Option::is_none")]
            modalities: &'a Option<Vec<RealtimeTranscriptionSessionCreateResponseModality>>,
            #[serde(rename = "input_audio_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_format: &'a Option<String>,
            #[serde(rename = "input_audio_transcription")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_transcription:
                &'a Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscription>,
            #[serde(rename = "turn_detection")]
            #[serde(skip_serializing_if = "Option::is_none")]
            turn_detection: &'a Option<RealtimeTranscriptionSessionCreateResponseTurnDetection>,
        }
        let Self {
            client_secret,
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
        } = self;
        RealtimeTranscriptionSessionCreateResponse {
            client_secret,
            modalities,
            input_audio_format,
            input_audio_transcription,
            turn_detection,
        }
        .serialize(serializer)
    }
}
#[doc = "A new Realtime transcription session configuration.\n\nWhen a session is created on the server via REST API, the session object\nalso contains an ephemeral key. Default TTL for keys is 10 minutes. This \nproperty is not present when a session is updated via the WebSocket API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponse {
    #[doc = "Ephemeral key returned by the API. Only present when the session is\ncreated on the server via REST API.\n"]
    pub client_secret: RealtimeTranscriptionSessionCreateResponseClientSecret,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[builder(default)]
    pub modalities: Option<Vec<RealtimeTranscriptionSessionCreateResponseModality>>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[builder(default)]
    pub input_audio_format: Option<String>,
    #[doc = "Configuration of the transcription model.\n"]
    #[builder(default)]
    pub input_audio_transcription:
        Option<RealtimeTranscriptionSessionCreateResponseInputAudioTranscription>,
    #[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
    #[builder(default)]
    pub turn_detection: Option<RealtimeTranscriptionSessionCreateResponseTurnDetection>,
}
impl<'de> serde::Deserialize<'de> for ReasoningSummary {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryConcise {
            #[default]
            #[serde(rename = "concise")]
            Concise,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryDetailed {
            #[default]
            #[serde(rename = "detailed")]
            Detailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ReasoningSummary {
            Auto(#[allow(dead_code)] ReasoningSummaryAuto),
            Concise(#[allow(dead_code)] ReasoningSummaryConcise),
            Detailed(#[allow(dead_code)] ReasoningSummaryDetailed),
        }
        Ok(match ReasoningSummary::deserialize(deserializer)? {
            ReasoningSummary::Auto(_) => Self::Auto,
            ReasoningSummary::Concise(_) => Self::Concise,
            ReasoningSummary::Detailed(_) => Self::Detailed,
        })
    }
}
impl serde::Serialize for ReasoningSummary {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryConcise {
            #[default]
            #[serde(rename = "concise")]
            Concise,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningSummaryDetailed {
            #[default]
            #[serde(rename = "detailed")]
            Detailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ReasoningSummary<'a> {
            Auto(#[allow(dead_code)] &'a ReasoningSummaryAuto),
            Concise(#[allow(dead_code)] &'a ReasoningSummaryConcise),
            Detailed(#[allow(dead_code)] &'a ReasoningSummaryDetailed),
        }
        match self {
            Self::Auto => ReasoningSummary::Auto(&Default::default()).serialize(serializer),
            Self::Concise => ReasoningSummary::Concise(&Default::default()).serialize(serializer),
            Self::Detailed => ReasoningSummary::Detailed(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ReasoningSummary {
    #[doc = "auto"]
    Auto,
    #[doc = "concise"]
    Concise,
    #[doc = "detailed"]
    Detailed,
}
impl<'de> serde::Deserialize<'de> for ReasoningGenerateSummary {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryConcise {
            #[default]
            #[serde(rename = "concise")]
            Concise,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryDetailed {
            #[default]
            #[serde(rename = "detailed")]
            Detailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ReasoningGenerateSummary {
            Auto(#[allow(dead_code)] ReasoningGenerateSummaryAuto),
            Concise(#[allow(dead_code)] ReasoningGenerateSummaryConcise),
            Detailed(#[allow(dead_code)] ReasoningGenerateSummaryDetailed),
        }
        Ok(match ReasoningGenerateSummary::deserialize(deserializer)? {
            ReasoningGenerateSummary::Auto(_) => Self::Auto,
            ReasoningGenerateSummary::Concise(_) => Self::Concise,
            ReasoningGenerateSummary::Detailed(_) => Self::Detailed,
        })
    }
}
impl serde::Serialize for ReasoningGenerateSummary {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryConcise {
            #[default]
            #[serde(rename = "concise")]
            Concise,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningGenerateSummaryDetailed {
            #[default]
            #[serde(rename = "detailed")]
            Detailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ReasoningGenerateSummary<'a> {
            Auto(#[allow(dead_code)] &'a ReasoningGenerateSummaryAuto),
            Concise(#[allow(dead_code)] &'a ReasoningGenerateSummaryConcise),
            Detailed(#[allow(dead_code)] &'a ReasoningGenerateSummaryDetailed),
        }
        match self {
            Self::Auto => ReasoningGenerateSummary::Auto(&Default::default()).serialize(serializer),
            Self::Concise => {
                ReasoningGenerateSummary::Concise(&Default::default()).serialize(serializer)
            }
            Self::Detailed => {
                ReasoningGenerateSummary::Detailed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ReasoningGenerateSummary {
    #[doc = "auto"]
    Auto,
    #[doc = "concise"]
    Concise,
    #[doc = "detailed"]
    Detailed,
}
impl<'de> serde::Deserialize<'de> for Reasoning {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Reasoning {
            #[serde(rename = "effort")]
            #[allow(dead_code)]
            effort: Option<ReasoningEffort>,
            #[serde(rename = "summary")]
            #[allow(dead_code)]
            summary: Option<ReasoningSummary>,
            #[serde(rename = "generate_summary")]
            #[allow(dead_code)]
            generate_summary: Option<ReasoningGenerateSummary>,
        }
        let Reasoning {
            effort,
            summary,
            generate_summary,
            ..
        } = Reasoning::deserialize(deserializer)?;
        Ok(Self {
            effort,
            summary,
            generate_summary,
        })
    }
}
impl serde::Serialize for Reasoning {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Reasoning<'a> {
            #[serde(rename = "effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "summary")]
            #[serde(skip_serializing_if = "Option::is_none")]
            summary: &'a Option<ReasoningSummary>,
            #[serde(rename = "generate_summary")]
            #[serde(skip_serializing_if = "Option::is_none")]
            generate_summary: &'a Option<ReasoningGenerateSummary>,
        }
        let Self {
            effort,
            summary,
            generate_summary,
        } = self;
        Reasoning {
            effort,
            summary,
            generate_summary,
        }
        .serialize(serializer)
    }
}
#[doc = "**o-series models only**\n\nConfiguration options for \n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct Reasoning {
    #[builder(default)]
    pub effort: Option<ReasoningEffort>,
    #[doc = "A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
    #[builder(default)]
    pub summary: Option<ReasoningSummary>,
    #[doc = "**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
    #[builder(default)]
    pub generate_summary: Option<ReasoningGenerateSummary>,
}
impl<'de> serde::Deserialize<'de> for ReasoningEffort {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ReasoningEffort {
            Low(#[allow(dead_code)] ReasoningEffortLow),
            Medium(#[allow(dead_code)] ReasoningEffortMedium),
            High(#[allow(dead_code)] ReasoningEffortHigh),
        }
        Ok(match ReasoningEffort::deserialize(deserializer)? {
            ReasoningEffort::Low(_) => Self::Low,
            ReasoningEffort::Medium(_) => Self::Medium,
            ReasoningEffort::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for ReasoningEffort {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningEffortHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ReasoningEffort<'a> {
            Low(#[allow(dead_code)] &'a ReasoningEffortLow),
            Medium(#[allow(dead_code)] &'a ReasoningEffortMedium),
            High(#[allow(dead_code)] &'a ReasoningEffortHigh),
        }
        match self {
            Self::Low => ReasoningEffort::Low(&Default::default()).serialize(serializer),
            Self::Medium => ReasoningEffort::Medium(&Default::default()).serialize(serializer),
            Self::High => ReasoningEffort::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "**o-series models only** \n\nConstrains effort on reasoning for \n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\nCurrently supported values are `low`, `medium`, and `high`. Reducing\nreasoning effort can result in faster responses and fewer tokens used\non reasoning in a response.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ReasoningEffort {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    #[default]
    Medium,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for ReasoningItemSummary {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the object. Always `summary_text`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemSummaryType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ReasoningItemSummary {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ReasoningItemSummaryType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let ReasoningItemSummary { text, .. } = ReasoningItemSummary::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for ReasoningItemSummary {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the object. Always `summary_text`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemSummaryType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ReasoningItemSummary<'a> {
            #[serde(rename = "type")]
            type_: &'a ReasoningItemSummaryType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        ReasoningItemSummary {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ReasoningItemSummary {
    #[doc = "A short summary of the reasoning used by the model when generating\nthe response.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ReasoningItemStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ReasoningItemStatus {
            InProgress(#[allow(dead_code)] ReasoningItemStatusInProgress),
            Completed(#[allow(dead_code)] ReasoningItemStatusCompleted),
            Incomplete(#[allow(dead_code)] ReasoningItemStatusIncomplete),
        }
        Ok(match ReasoningItemStatus::deserialize(deserializer)? {
            ReasoningItemStatus::InProgress(_) => Self::InProgress,
            ReasoningItemStatus::Completed(_) => Self::Completed,
            ReasoningItemStatus::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for ReasoningItemStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ReasoningItemStatus<'a> {
            InProgress(#[allow(dead_code)] &'a ReasoningItemStatusInProgress),
            Completed(#[allow(dead_code)] &'a ReasoningItemStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a ReasoningItemStatusIncomplete),
        }
        match self {
            Self::InProgress => {
                ReasoningItemStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                ReasoningItemStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Incomplete => {
                ReasoningItemStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ReasoningItemStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ReasoningItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the object. Always `reasoning`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemType {
            #[default]
            #[serde(rename = "reasoning")]
            Reasoning,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ReasoningItem {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ReasoningItemType,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "encrypted_content")]
            #[allow(dead_code)]
            encrypted_content: Option<String>,
            #[serde(rename = "summary")]
            #[allow(dead_code)]
            summary: Vec<ReasoningItemSummary>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<ReasoningItemStatus>,
        }
        let ReasoningItem {
            id,
            encrypted_content,
            summary,
            status,
            ..
        } = ReasoningItem::deserialize(deserializer)?;
        Ok(Self {
            id,
            encrypted_content,
            summary,
            status,
        })
    }
}
impl serde::Serialize for ReasoningItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the object. Always `reasoning`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ReasoningItemType {
            #[default]
            #[serde(rename = "reasoning")]
            Reasoning,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ReasoningItem<'a> {
            #[serde(rename = "type")]
            type_: &'a ReasoningItemType,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "encrypted_content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            encrypted_content: &'a Option<String>,
            #[serde(rename = "summary")]
            summary: &'a Vec<ReasoningItemSummary>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<ReasoningItemStatus>,
        }
        let Self {
            id,
            encrypted_content,
            summary,
            status,
        } = self;
        ReasoningItem {
            type_: &Default::default(),
            id,
            encrypted_content,
            summary,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "A description of the chain of thought used by a reasoning model while generating\na response. Be sure to include these items in your `input` to the Responses API\nfor subsequent turns of a conversation if you are manually \n[managing context](https://platform.openai.com/docs/guides/conversation-state).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ReasoningItem {
    #[doc = "The unique identifier of the reasoning content.\n"]
    pub id: String,
    #[doc = "The encrypted content of the reasoning item - populated when a response is\ngenerated with `reasoning.encrypted_content` in the `include` parameter.\n"]
    #[builder(default)]
    pub encrypted_content: Option<String>,
    #[doc = "Reasoning text contents.\n"]
    pub summary: Vec<ReasoningItemSummary>,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<ReasoningItemStatus>,
}
impl<'de> serde::Deserialize<'de> for ResponseStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ResponseStatus {
            Completed(#[allow(dead_code)] ResponseStatusCompleted),
            Failed(#[allow(dead_code)] ResponseStatusFailed),
            InProgress(#[allow(dead_code)] ResponseStatusInProgress),
            Cancelled(#[allow(dead_code)] ResponseStatusCancelled),
            Queued(#[allow(dead_code)] ResponseStatusQueued),
            Incomplete(#[allow(dead_code)] ResponseStatusIncomplete),
        }
        Ok(match ResponseStatus::deserialize(deserializer)? {
            ResponseStatus::Completed(_) => Self::Completed,
            ResponseStatus::Failed(_) => Self::Failed,
            ResponseStatus::InProgress(_) => Self::InProgress,
            ResponseStatus::Cancelled(_) => Self::Cancelled,
            ResponseStatus::Queued(_) => Self::Queued,
            ResponseStatus::Incomplete(_) => Self::Incomplete,
        })
    }
}
impl serde::Serialize for ResponseStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ResponseStatus<'a> {
            Completed(#[allow(dead_code)] &'a ResponseStatusCompleted),
            Failed(#[allow(dead_code)] &'a ResponseStatusFailed),
            InProgress(#[allow(dead_code)] &'a ResponseStatusInProgress),
            Cancelled(#[allow(dead_code)] &'a ResponseStatusCancelled),
            Queued(#[allow(dead_code)] &'a ResponseStatusQueued),
            Incomplete(#[allow(dead_code)] &'a ResponseStatusIncomplete),
        }
        match self {
            Self::Completed => ResponseStatus::Completed(&Default::default()).serialize(serializer),
            Self::Failed => ResponseStatus::Failed(&Default::default()).serialize(serializer),
            Self::InProgress => {
                ResponseStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Cancelled => ResponseStatus::Cancelled(&Default::default()).serialize(serializer),
            Self::Queued => ResponseStatus::Queued(&Default::default()).serialize(serializer),
            Self::Incomplete => {
                ResponseStatus::Incomplete(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the response generation. One of `completed`, `failed`, \n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseStatus {
    #[doc = "completed"]
    Completed,
    #[doc = "failed"]
    Failed,
    #[doc = "in_progress"]
    InProgress,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "queued"]
    Queued,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ResponseIncompleteDetailsReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteDetailsReasonMaxOutputTokens {
            #[default]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ResponseIncompleteDetailsReason {
            MaxOutputTokens(#[allow(dead_code)] ResponseIncompleteDetailsReasonMaxOutputTokens),
            ContentFilter(#[allow(dead_code)] ResponseIncompleteDetailsReasonContentFilter),
        }
        Ok(
            match ResponseIncompleteDetailsReason::deserialize(deserializer)? {
                ResponseIncompleteDetailsReason::MaxOutputTokens(_) => Self::MaxOutputTokens,
                ResponseIncompleteDetailsReason::ContentFilter(_) => Self::ContentFilter,
            },
        )
    }
}
impl serde::Serialize for ResponseIncompleteDetailsReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteDetailsReasonMaxOutputTokens {
            #[default]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteDetailsReasonContentFilter {
            #[default]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ResponseIncompleteDetailsReason<'a> {
            MaxOutputTokens(#[allow(dead_code)] &'a ResponseIncompleteDetailsReasonMaxOutputTokens),
            ContentFilter(#[allow(dead_code)] &'a ResponseIncompleteDetailsReasonContentFilter),
        }
        match self {
            Self::MaxOutputTokens => {
                ResponseIncompleteDetailsReason::MaxOutputTokens(&Default::default())
                    .serialize(serializer)
            }
            Self::ContentFilter => {
                ResponseIncompleteDetailsReason::ContentFilter(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The reason why the response is incomplete."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseIncompleteDetailsReason {
    #[doc = "max_output_tokens"]
    MaxOutputTokens,
    #[doc = "content_filter"]
    ContentFilter,
}
impl<'de> serde::Deserialize<'de> for ResponseIncompleteDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseIncompleteDetails {
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: Option<ResponseIncompleteDetailsReason>,
        }
        let ResponseIncompleteDetails { reason, .. } =
            ResponseIncompleteDetails::deserialize(deserializer)?;
        Ok(Self { reason })
    }
}
impl serde::Serialize for ResponseIncompleteDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseIncompleteDetails<'a> {
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<ResponseIncompleteDetailsReason>,
        }
        let Self { reason } = self;
        ResponseIncompleteDetails { reason }.serialize(serializer)
    }
}
#[doc = "Details about why the response is incomplete.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ResponseIncompleteDetails {
    #[doc = "The reason why the response is incomplete."]
    #[builder(default)]
    pub reason: Option<ResponseIncompleteDetailsReason>,
}
impl<'de> serde::Deserialize<'de> for Response {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type of this resource - always set to `response`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseObject {
            #[default]
            #[serde(rename = "response")]
            Response,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Response {
            #[serde(flatten)]
            #[allow(dead_code)]
            model_response_properties: ModelResponseProperties,
            #[serde(flatten)]
            #[allow(dead_code)]
            response_properties: ResponseProperties,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ResponseObject,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<ResponseStatus>,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "error")]
            #[allow(dead_code)]
            error: Option<ResponseError>,
            #[serde(rename = "incomplete_details")]
            #[allow(dead_code)]
            incomplete_details: Option<ResponseIncompleteDetails>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Vec<OutputItem>,
            #[serde(rename = "output_text")]
            #[allow(dead_code)]
            output_text: Option<String>,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<ResponseUsage>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: bool,
        }
        let Response {
            model_response_properties,
            response_properties,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            output_text,
            usage,
            parallel_tool_calls,
            ..
        } = Response::deserialize(deserializer)?;
        Ok(Self {
            model_response_properties,
            response_properties,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            output_text,
            usage,
            parallel_tool_calls,
        })
    }
}
impl serde::Serialize for Response {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type of this resource - always set to `response`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseObject {
            #[default]
            #[serde(rename = "response")]
            Response,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Response<'a> {
            #[serde(flatten)]
            model_response_properties: &'a ModelResponseProperties,
            #[serde(flatten)]
            response_properties: &'a ResponseProperties,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a ResponseObject,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<ResponseStatus>,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<ResponseError>,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<ResponseIncompleteDetails>,
            #[serde(rename = "output")]
            output: &'a Vec<OutputItem>,
            #[serde(rename = "output_text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_text: &'a Option<String>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<ResponseUsage>,
            #[serde(rename = "parallel_tool_calls")]
            parallel_tool_calls: &'a bool,
        }
        let Self {
            model_response_properties,
            response_properties,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            output_text,
            usage,
            parallel_tool_calls,
        } = self;
        Response {
            model_response_properties,
            response_properties,
            id,
            object: &Default::default(),
            status,
            created_at,
            error,
            incomplete_details,
            output,
            output_text,
            usage,
            parallel_tool_calls,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Response {
    #[builder(default)]
    pub model_response_properties: ModelResponseProperties,
    #[builder(default)]
    pub response_properties: ResponseProperties,
    #[doc = "Unique identifier for this Response.\n"]
    pub id: String,
    #[doc = "The status of the response generation. One of `completed`, `failed`, \n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"]
    #[builder(default)]
    pub status: Option<ResponseStatus>,
    #[doc = "Unix timestamp (in seconds) of when this Response was created.\n"]
    pub created_at: u64,
    #[builder(default)]
    pub error: Option<ResponseError>,
    #[doc = "Details about why the response is incomplete.\n"]
    #[builder(default)]
    pub incomplete_details: Option<ResponseIncompleteDetails>,
    #[doc = "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and \n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"]
    pub output: Vec<OutputItem>,
    #[doc = "SDK-only convenience property that contains the aggregated text output \nfrom all `output_text` items in the `output` array, if any are present. \nSupported in the Python and JavaScript SDKs.\n"]
    #[builder(default)]
    pub output_text: Option<String>,
    #[builder(default)]
    pub usage: Option<ResponseUsage>,
    #[doc = "Whether to allow the model to run tool calls in parallel.\n"]
    pub parallel_tool_calls: bool,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.audio.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioDeltaEventType {
            #[default]
            #[serde(rename = "response.audio.delta")]
            ResponseAudioDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseAudioDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseAudioDeltaEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let ResponseAudioDeltaEvent {
            sequence_number,
            delta,
            ..
        } = ResponseAudioDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            delta,
        })
    }
}
impl serde::Serialize for ResponseAudioDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.audio.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioDeltaEventType {
            #[default]
            #[serde(rename = "response.audio.delta")]
            ResponseAudioDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseAudioDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseAudioDeltaEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            sequence_number,
            delta,
        } = self;
        ResponseAudioDeltaEvent {
            type_: &Default::default(),
            sequence_number,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a partial audio response."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseAudioDeltaEvent {
    #[doc = "A sequence number for this chunk of the stream response.\n"]
    pub sequence_number: u64,
    #[doc = "A chunk of Base64 encoded response audio bytes.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.audio.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioDoneEventType {
            #[default]
            #[serde(rename = "response.audio.done")]
            ResponseAudioDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseAudioDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseAudioDoneEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseAudioDoneEvent {
            sequence_number, ..
        } = ResponseAudioDoneEvent::deserialize(deserializer)?;
        Ok(Self { sequence_number })
    }
}
impl serde::Serialize for ResponseAudioDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.audio.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioDoneEventType {
            #[default]
            #[serde(rename = "response.audio.done")]
            ResponseAudioDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseAudioDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseAudioDoneEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self { sequence_number } = self;
        ResponseAudioDoneEvent {
            type_: &Default::default(),
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the audio response is complete."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseAudioDoneEvent {
    #[doc = "The sequence number of the delta.\n"]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioTranscriptDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.audio.transcript.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioTranscriptDeltaEventType {
            #[default]
            #[serde(rename = "response.audio.transcript.delta")]
            ResponseAudioTranscriptDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseAudioTranscriptDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseAudioTranscriptDeltaEventType,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseAudioTranscriptDeltaEvent {
            delta,
            sequence_number,
            ..
        } = ResponseAudioTranscriptDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseAudioTranscriptDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.audio.transcript.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioTranscriptDeltaEventType {
            #[default]
            #[serde(rename = "response.audio.transcript.delta")]
            ResponseAudioTranscriptDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseAudioTranscriptDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseAudioTranscriptDeltaEventType,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            delta,
            sequence_number,
        } = self;
        ResponseAudioTranscriptDeltaEvent {
            type_: &Default::default(),
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a partial transcript of audio."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseAudioTranscriptDeltaEvent {
    #[doc = "The partial transcript of the audio response.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioTranscriptDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.audio.transcript.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioTranscriptDoneEventType {
            #[default]
            #[serde(rename = "response.audio.transcript.done")]
            ResponseAudioTranscriptDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseAudioTranscriptDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseAudioTranscriptDoneEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseAudioTranscriptDoneEvent {
            sequence_number, ..
        } = ResponseAudioTranscriptDoneEvent::deserialize(deserializer)?;
        Ok(Self { sequence_number })
    }
}
impl serde::Serialize for ResponseAudioTranscriptDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.audio.transcript.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseAudioTranscriptDoneEventType {
            #[default]
            #[serde(rename = "response.audio.transcript.done")]
            ResponseAudioTranscriptDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseAudioTranscriptDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseAudioTranscriptDoneEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self { sequence_number } = self;
        ResponseAudioTranscriptDoneEvent {
            type_: &Default::default(),
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the full audio transcript is completed."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseAudioTranscriptDoneEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCodeDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call_code.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCodeDeltaEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call_code.delta")]
            ResponseCodeInterpreterCallCodeDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallCodeDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallCodeDeltaEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseCodeInterpreterCallCodeDeltaEvent {
            output_index,
            delta,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallCodeDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCodeDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call_code.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCodeDeltaEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call_code.delta")]
            ResponseCodeInterpreterCallCodeDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallCodeDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallCodeDeltaEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            delta,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallCodeDeltaEvent {
            type_: &Default::default(),
            output_index,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a partial code snippet is added by the code interpreter."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCodeDeltaEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    #[doc = "The partial code snippet added by the code interpreter.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCodeDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call_code.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCodeDoneEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call_code.done")]
            ResponseCodeInterpreterCallCodeDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallCodeDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallCodeDoneEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseCodeInterpreterCallCodeDoneEvent {
            output_index,
            code,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallCodeDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            code,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCodeDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call_code.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCodeDoneEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call_code.done")]
            ResponseCodeInterpreterCallCodeDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallCodeDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallCodeDoneEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            code,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallCodeDoneEvent {
            type_: &Default::default(),
            output_index,
            code,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when code snippet output is finalized by the code interpreter."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCodeDoneEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    #[doc = "The final code snippet output by the code interpreter.\n"]
    pub code: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCompletedEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.completed")]
            ResponseCodeInterpreterCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallCompletedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "code_interpreter_call")]
            #[allow(dead_code)]
            code_interpreter_call: CodeInterpreterToolCall,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseCodeInterpreterCallCompletedEvent {
            output_index,
            code_interpreter_call,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            code_interpreter_call,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallCompletedEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.completed")]
            ResponseCodeInterpreterCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallCompletedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "code_interpreter_call")]
            code_interpreter_call: &'a CodeInterpreterToolCall,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            code_interpreter_call,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallCompletedEvent {
            type_: &Default::default(),
            output_index,
            code_interpreter_call,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the code interpreter call is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCompletedEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    pub code_interpreter_call: CodeInterpreterToolCall,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallInProgressEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.in_progress")]
            ResponseCodeInterpreterCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallInProgressEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "code_interpreter_call")]
            #[allow(dead_code)]
            code_interpreter_call: CodeInterpreterToolCall,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseCodeInterpreterCallInProgressEvent {
            output_index,
            code_interpreter_call,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            code_interpreter_call,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallInProgressEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.in_progress")]
            ResponseCodeInterpreterCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallInProgressEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "code_interpreter_call")]
            code_interpreter_call: &'a CodeInterpreterToolCall,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            code_interpreter_call,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallInProgressEvent {
            type_: &Default::default(),
            output_index,
            code_interpreter_call,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a code interpreter call is in progress."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallInProgressEvent {
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    pub code_interpreter_call: CodeInterpreterToolCall,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallInterpretingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.interpreting`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallInterpretingEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.interpreting")]
            ResponseCodeInterpreterCallInterpreting,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallInterpretingEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCodeInterpreterCallInterpretingEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "code_interpreter_call")]
            #[allow(dead_code)]
            code_interpreter_call: CodeInterpreterToolCall,
        }
        let ResponseCodeInterpreterCallInterpretingEvent {
            sequence_number,
            output_index,
            code_interpreter_call,
            ..
        } = ResponseCodeInterpreterCallInterpretingEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            output_index,
            code_interpreter_call,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallInterpretingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.code_interpreter_call.interpreting`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCodeInterpreterCallInterpretingEventType {
            #[default]
            #[serde(rename = "response.code_interpreter_call.interpreting")]
            ResponseCodeInterpreterCallInterpreting,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallInterpretingEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCodeInterpreterCallInterpretingEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "code_interpreter_call")]
            code_interpreter_call: &'a CodeInterpreterToolCall,
        }
        let Self {
            sequence_number,
            output_index,
            code_interpreter_call,
        } = self;
        ResponseCodeInterpreterCallInterpretingEvent {
            type_: &Default::default(),
            sequence_number,
            output_index,
            code_interpreter_call,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the code interpreter is actively interpreting the code snippet."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallInterpretingEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The index of the output item that the code interpreter call is in progress.\n"]
    pub output_index: u64,
    pub code_interpreter_call: CodeInterpreterToolCall,
}
impl<'de> serde::Deserialize<'de> for ResponseCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCompletedEventType {
            #[default]
            #[serde(rename = "response.completed")]
            ResponseCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCompletedEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseCompletedEvent {
            response,
            sequence_number,
            ..
        } = ResponseCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCompletedEventType {
            #[default]
            #[serde(rename = "response.completed")]
            ResponseCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCompletedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCompletedEventType,
            #[serde(rename = "response")]
            response: &'a Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseCompletedEvent {
            type_: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the model response is complete."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCompletedEvent {
    #[doc = "Properties of the completed response.\n"]
    pub response: Response,
    #[doc = "The sequence number for this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseContentPartAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.content_part.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseContentPartAddedEventType {
            #[default]
            #[serde(rename = "response.content_part.added")]
            ResponseContentPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseContentPartAddedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseContentPartAddedEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: OutputContent,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseContentPartAddedEvent {
            item_id,
            output_index,
            content_index,
            part,
            sequence_number,
            ..
        } = ResponseContentPartAddedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            part,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseContentPartAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.content_part.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseContentPartAddedEventType {
            #[default]
            #[serde(rename = "response.content_part.added")]
            ResponseContentPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseContentPartAddedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseContentPartAddedEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "part")]
            part: &'a OutputContent,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            part,
            sequence_number,
        } = self;
        ResponseContentPartAddedEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            part,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a new content part is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseContentPartAddedEvent {
    #[doc = "The ID of the output item that the content part was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the content part was added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that was added.\n"]
    pub content_index: u64,
    #[doc = "The content part that was added.\n"]
    pub part: OutputContent,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseContentPartDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.content_part.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseContentPartDoneEventType {
            #[default]
            #[serde(rename = "response.content_part.done")]
            ResponseContentPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseContentPartDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseContentPartDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: OutputContent,
        }
        let ResponseContentPartDoneEvent {
            item_id,
            output_index,
            content_index,
            sequence_number,
            part,
            ..
        } = ResponseContentPartDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            sequence_number,
            part,
        })
    }
}
impl serde::Serialize for ResponseContentPartDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.content_part.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseContentPartDoneEventType {
            #[default]
            #[serde(rename = "response.content_part.done")]
            ResponseContentPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseContentPartDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseContentPartDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "part")]
            part: &'a OutputContent,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            sequence_number,
            part,
        } = self;
        ResponseContentPartDoneEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            sequence_number,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a content part is done."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseContentPartDoneEvent {
    #[doc = "The ID of the output item that the content part was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the content part was added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that is done.\n"]
    pub content_index: u64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The content part that is done.\n"]
    pub part: OutputContent,
}
impl<'de> serde::Deserialize<'de> for ResponseCreatedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.created`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCreatedEventType {
            #[default]
            #[serde(rename = "response.created")]
            ResponseCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCreatedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseCreatedEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseCreatedEvent {
            response,
            sequence_number,
            ..
        } = ResponseCreatedEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCreatedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.created`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseCreatedEventType {
            #[default]
            #[serde(rename = "response.created")]
            ResponseCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCreatedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseCreatedEventType,
            #[serde(rename = "response")]
            response: &'a Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseCreatedEvent {
            type_: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "An event that is emitted when a response is created.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCreatedEvent {
    #[doc = "The response that was created.\n"]
    pub response: Response,
    #[doc = "The sequence number for this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseError {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: ResponseErrorCode,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let ResponseError { code, message, .. } = ResponseError::deserialize(deserializer)?;
        Ok(Self { code, message })
    }
}
impl serde::Serialize for ResponseError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseError<'a> {
            #[serde(rename = "code")]
            code: &'a ResponseErrorCode,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let Self { code, message } = self;
        ResponseError { code, message }.serialize(serializer)
    }
}
#[doc = "An error object returned when the model fails to generate a Response.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseError {
    pub code: ResponseErrorCode,
    #[doc = "A human-readable description of the error.\n"]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for ResponseErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidPrompt {
            #[default]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeVectorStoreTimeout {
            #[default]
            #[serde(rename = "vector_store_timeout")]
            VectorStoreTimeout,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImage {
            #[default]
            #[serde(rename = "invalid_image")]
            InvalidImage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageFormat {
            #[default]
            #[serde(rename = "invalid_image_format")]
            InvalidImageFormat,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidBase64Image {
            #[default]
            #[serde(rename = "invalid_base64_image")]
            InvalidBase64Image,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageUrl {
            #[default]
            #[serde(rename = "invalid_image_url")]
            InvalidImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageTooLarge {
            #[default]
            #[serde(rename = "image_too_large")]
            ImageTooLarge,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageTooSmall {
            #[default]
            #[serde(rename = "image_too_small")]
            ImageTooSmall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageParseError {
            #[default]
            #[serde(rename = "image_parse_error")]
            ImageParseError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageContentPolicyViolation {
            #[default]
            #[serde(rename = "image_content_policy_violation")]
            ImageContentPolicyViolation,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageMode {
            #[default]
            #[serde(rename = "invalid_image_mode")]
            InvalidImageMode,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageFileTooLarge {
            #[default]
            #[serde(rename = "image_file_too_large")]
            ImageFileTooLarge,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeUnsupportedImageMediaType {
            #[default]
            #[serde(rename = "unsupported_image_media_type")]
            UnsupportedImageMediaType,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeEmptyImageFile {
            #[default]
            #[serde(rename = "empty_image_file")]
            EmptyImageFile,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeFailedToDownloadImage {
            #[default]
            #[serde(rename = "failed_to_download_image")]
            FailedToDownloadImage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageFileNotFound {
            #[default]
            #[serde(rename = "image_file_not_found")]
            ImageFileNotFound,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ResponseErrorCode {
            ServerError(#[allow(dead_code)] ResponseErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] ResponseErrorCodeRateLimitExceeded),
            InvalidPrompt(#[allow(dead_code)] ResponseErrorCodeInvalidPrompt),
            VectorStoreTimeout(#[allow(dead_code)] ResponseErrorCodeVectorStoreTimeout),
            InvalidImage(#[allow(dead_code)] ResponseErrorCodeInvalidImage),
            InvalidImageFormat(#[allow(dead_code)] ResponseErrorCodeInvalidImageFormat),
            InvalidBase64Image(#[allow(dead_code)] ResponseErrorCodeInvalidBase64Image),
            InvalidImageUrl(#[allow(dead_code)] ResponseErrorCodeInvalidImageUrl),
            ImageTooLarge(#[allow(dead_code)] ResponseErrorCodeImageTooLarge),
            ImageTooSmall(#[allow(dead_code)] ResponseErrorCodeImageTooSmall),
            ImageParseError(#[allow(dead_code)] ResponseErrorCodeImageParseError),
            ImageContentPolicyViolation(
                #[allow(dead_code)] ResponseErrorCodeImageContentPolicyViolation,
            ),
            InvalidImageMode(#[allow(dead_code)] ResponseErrorCodeInvalidImageMode),
            ImageFileTooLarge(#[allow(dead_code)] ResponseErrorCodeImageFileTooLarge),
            UnsupportedImageMediaType(
                #[allow(dead_code)] ResponseErrorCodeUnsupportedImageMediaType,
            ),
            EmptyImageFile(#[allow(dead_code)] ResponseErrorCodeEmptyImageFile),
            FailedToDownloadImage(#[allow(dead_code)] ResponseErrorCodeFailedToDownloadImage),
            ImageFileNotFound(#[allow(dead_code)] ResponseErrorCodeImageFileNotFound),
        }
        Ok(match ResponseErrorCode::deserialize(deserializer)? {
            ResponseErrorCode::ServerError(_) => Self::ServerError,
            ResponseErrorCode::RateLimitExceeded(_) => Self::RateLimitExceeded,
            ResponseErrorCode::InvalidPrompt(_) => Self::InvalidPrompt,
            ResponseErrorCode::VectorStoreTimeout(_) => Self::VectorStoreTimeout,
            ResponseErrorCode::InvalidImage(_) => Self::InvalidImage,
            ResponseErrorCode::InvalidImageFormat(_) => Self::InvalidImageFormat,
            ResponseErrorCode::InvalidBase64Image(_) => Self::InvalidBase64Image,
            ResponseErrorCode::InvalidImageUrl(_) => Self::InvalidImageUrl,
            ResponseErrorCode::ImageTooLarge(_) => Self::ImageTooLarge,
            ResponseErrorCode::ImageTooSmall(_) => Self::ImageTooSmall,
            ResponseErrorCode::ImageParseError(_) => Self::ImageParseError,
            ResponseErrorCode::ImageContentPolicyViolation(_) => Self::ImageContentPolicyViolation,
            ResponseErrorCode::InvalidImageMode(_) => Self::InvalidImageMode,
            ResponseErrorCode::ImageFileTooLarge(_) => Self::ImageFileTooLarge,
            ResponseErrorCode::UnsupportedImageMediaType(_) => Self::UnsupportedImageMediaType,
            ResponseErrorCode::EmptyImageFile(_) => Self::EmptyImageFile,
            ResponseErrorCode::FailedToDownloadImage(_) => Self::FailedToDownloadImage,
            ResponseErrorCode::ImageFileNotFound(_) => Self::ImageFileNotFound,
        })
    }
}
impl serde::Serialize for ResponseErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidPrompt {
            #[default]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeVectorStoreTimeout {
            #[default]
            #[serde(rename = "vector_store_timeout")]
            VectorStoreTimeout,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImage {
            #[default]
            #[serde(rename = "invalid_image")]
            InvalidImage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageFormat {
            #[default]
            #[serde(rename = "invalid_image_format")]
            InvalidImageFormat,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidBase64Image {
            #[default]
            #[serde(rename = "invalid_base64_image")]
            InvalidBase64Image,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageUrl {
            #[default]
            #[serde(rename = "invalid_image_url")]
            InvalidImageUrl,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageTooLarge {
            #[default]
            #[serde(rename = "image_too_large")]
            ImageTooLarge,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageTooSmall {
            #[default]
            #[serde(rename = "image_too_small")]
            ImageTooSmall,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageParseError {
            #[default]
            #[serde(rename = "image_parse_error")]
            ImageParseError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageContentPolicyViolation {
            #[default]
            #[serde(rename = "image_content_policy_violation")]
            ImageContentPolicyViolation,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeInvalidImageMode {
            #[default]
            #[serde(rename = "invalid_image_mode")]
            InvalidImageMode,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageFileTooLarge {
            #[default]
            #[serde(rename = "image_file_too_large")]
            ImageFileTooLarge,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeUnsupportedImageMediaType {
            #[default]
            #[serde(rename = "unsupported_image_media_type")]
            UnsupportedImageMediaType,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeEmptyImageFile {
            #[default]
            #[serde(rename = "empty_image_file")]
            EmptyImageFile,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeFailedToDownloadImage {
            #[default]
            #[serde(rename = "failed_to_download_image")]
            FailedToDownloadImage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorCodeImageFileNotFound {
            #[default]
            #[serde(rename = "image_file_not_found")]
            ImageFileNotFound,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ResponseErrorCode<'a> {
            ServerError(#[allow(dead_code)] &'a ResponseErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] &'a ResponseErrorCodeRateLimitExceeded),
            InvalidPrompt(#[allow(dead_code)] &'a ResponseErrorCodeInvalidPrompt),
            VectorStoreTimeout(#[allow(dead_code)] &'a ResponseErrorCodeVectorStoreTimeout),
            InvalidImage(#[allow(dead_code)] &'a ResponseErrorCodeInvalidImage),
            InvalidImageFormat(#[allow(dead_code)] &'a ResponseErrorCodeInvalidImageFormat),
            InvalidBase64Image(#[allow(dead_code)] &'a ResponseErrorCodeInvalidBase64Image),
            InvalidImageUrl(#[allow(dead_code)] &'a ResponseErrorCodeInvalidImageUrl),
            ImageTooLarge(#[allow(dead_code)] &'a ResponseErrorCodeImageTooLarge),
            ImageTooSmall(#[allow(dead_code)] &'a ResponseErrorCodeImageTooSmall),
            ImageParseError(#[allow(dead_code)] &'a ResponseErrorCodeImageParseError),
            ImageContentPolicyViolation(
                #[allow(dead_code)] &'a ResponseErrorCodeImageContentPolicyViolation,
            ),
            InvalidImageMode(#[allow(dead_code)] &'a ResponseErrorCodeInvalidImageMode),
            ImageFileTooLarge(#[allow(dead_code)] &'a ResponseErrorCodeImageFileTooLarge),
            UnsupportedImageMediaType(
                #[allow(dead_code)] &'a ResponseErrorCodeUnsupportedImageMediaType,
            ),
            EmptyImageFile(#[allow(dead_code)] &'a ResponseErrorCodeEmptyImageFile),
            FailedToDownloadImage(#[allow(dead_code)] &'a ResponseErrorCodeFailedToDownloadImage),
            ImageFileNotFound(#[allow(dead_code)] &'a ResponseErrorCodeImageFileNotFound),
        }
        match self {
            Self::ServerError => {
                ResponseErrorCode::ServerError(&Default::default()).serialize(serializer)
            }
            Self::RateLimitExceeded => {
                ResponseErrorCode::RateLimitExceeded(&Default::default()).serialize(serializer)
            }
            Self::InvalidPrompt => {
                ResponseErrorCode::InvalidPrompt(&Default::default()).serialize(serializer)
            }
            Self::VectorStoreTimeout => {
                ResponseErrorCode::VectorStoreTimeout(&Default::default()).serialize(serializer)
            }
            Self::InvalidImage => {
                ResponseErrorCode::InvalidImage(&Default::default()).serialize(serializer)
            }
            Self::InvalidImageFormat => {
                ResponseErrorCode::InvalidImageFormat(&Default::default()).serialize(serializer)
            }
            Self::InvalidBase64Image => {
                ResponseErrorCode::InvalidBase64Image(&Default::default()).serialize(serializer)
            }
            Self::InvalidImageUrl => {
                ResponseErrorCode::InvalidImageUrl(&Default::default()).serialize(serializer)
            }
            Self::ImageTooLarge => {
                ResponseErrorCode::ImageTooLarge(&Default::default()).serialize(serializer)
            }
            Self::ImageTooSmall => {
                ResponseErrorCode::ImageTooSmall(&Default::default()).serialize(serializer)
            }
            Self::ImageParseError => {
                ResponseErrorCode::ImageParseError(&Default::default()).serialize(serializer)
            }
            Self::ImageContentPolicyViolation => {
                ResponseErrorCode::ImageContentPolicyViolation(&Default::default())
                    .serialize(serializer)
            }
            Self::InvalidImageMode => {
                ResponseErrorCode::InvalidImageMode(&Default::default()).serialize(serializer)
            }
            Self::ImageFileTooLarge => {
                ResponseErrorCode::ImageFileTooLarge(&Default::default()).serialize(serializer)
            }
            Self::UnsupportedImageMediaType => {
                ResponseErrorCode::UnsupportedImageMediaType(&Default::default())
                    .serialize(serializer)
            }
            Self::EmptyImageFile => {
                ResponseErrorCode::EmptyImageFile(&Default::default()).serialize(serializer)
            }
            Self::FailedToDownloadImage => {
                ResponseErrorCode::FailedToDownloadImage(&Default::default()).serialize(serializer)
            }
            Self::ImageFileNotFound => {
                ResponseErrorCode::ImageFileNotFound(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The error code for the response.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseErrorCode {
    #[doc = "server_error"]
    ServerError,
    #[doc = "rate_limit_exceeded"]
    RateLimitExceeded,
    #[doc = "invalid_prompt"]
    InvalidPrompt,
    #[doc = "vector_store_timeout"]
    VectorStoreTimeout,
    #[doc = "invalid_image"]
    InvalidImage,
    #[doc = "invalid_image_format"]
    InvalidImageFormat,
    #[doc = "invalid_base64_image"]
    InvalidBase64Image,
    #[doc = "invalid_image_url"]
    InvalidImageUrl,
    #[doc = "image_too_large"]
    ImageTooLarge,
    #[doc = "image_too_small"]
    ImageTooSmall,
    #[doc = "image_parse_error"]
    ImageParseError,
    #[doc = "image_content_policy_violation"]
    ImageContentPolicyViolation,
    #[doc = "invalid_image_mode"]
    InvalidImageMode,
    #[doc = "image_file_too_large"]
    ImageFileTooLarge,
    #[doc = "unsupported_image_media_type"]
    UnsupportedImageMediaType,
    #[doc = "empty_image_file"]
    EmptyImageFile,
    #[doc = "failed_to_download_image"]
    FailedToDownloadImage,
    #[doc = "image_file_not_found"]
    ImageFileNotFound,
}
impl<'de> serde::Deserialize<'de> for ResponseErrorEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `error`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorEventType {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseErrorEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseErrorEventType,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseErrorEvent {
            code,
            message,
            param,
            sequence_number,
            ..
        } = ResponseErrorEvent::deserialize(deserializer)?;
        Ok(Self {
            code,
            message,
            param,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseErrorEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `error`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseErrorEventType {
            #[default]
            #[serde(rename = "error")]
            Error,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseErrorEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseErrorEventType,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            code,
            message,
            param,
            sequence_number,
        } = self;
        ResponseErrorEvent {
            type_: &Default::default(),
            code,
            message,
            param,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an error occurs."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseErrorEvent {
    #[doc = "The error code.\n"]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "The error message.\n"]
    pub message: String,
    #[doc = "The error parameter.\n"]
    #[builder(default)]
    pub param: Option<String>,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseFailedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.failed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFailedEventType {
            #[default]
            #[serde(rename = "response.failed")]
            ResponseFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFailedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFailedEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
        }
        let ResponseFailedEvent {
            sequence_number,
            response,
            ..
        } = ResponseFailedEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            response,
        })
    }
}
impl serde::Serialize for ResponseFailedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.failed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFailedEventType {
            #[default]
            #[serde(rename = "response.failed")]
            ResponseFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFailedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFailedEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "response")]
            response: &'a Response,
        }
        let Self {
            sequence_number,
            response,
        } = self;
        ResponseFailedEvent {
            type_: &Default::default(),
            sequence_number,
            response,
        }
        .serialize(serializer)
    }
}
#[doc = "An event that is emitted when a response fails.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFailedEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The response that failed.\n"]
    pub response: Response,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.file_search_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallCompletedEventType {
            #[default]
            #[serde(rename = "response.file_search_call.completed")]
            ResponseFileSearchCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFileSearchCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFileSearchCallCompletedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseFileSearchCallCompletedEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseFileSearchCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.file_search_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallCompletedEventType {
            #[default]
            #[serde(rename = "response.file_search_call.completed")]
            ResponseFileSearchCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFileSearchCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFileSearchCallCompletedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseFileSearchCallCompletedEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a file search call is completed (results found)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallCompletedEvent {
    #[doc = "The index of the output item that the file search call is initiated.\n"]
    pub output_index: u64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.file_search_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallInProgressEventType {
            #[default]
            #[serde(rename = "response.file_search_call.in_progress")]
            ResponseFileSearchCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFileSearchCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFileSearchCallInProgressEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseFileSearchCallInProgressEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseFileSearchCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.file_search_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallInProgressEventType {
            #[default]
            #[serde(rename = "response.file_search_call.in_progress")]
            ResponseFileSearchCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFileSearchCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFileSearchCallInProgressEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseFileSearchCallInProgressEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a file search call is initiated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallInProgressEvent {
    #[doc = "The index of the output item that the file search call is initiated.\n"]
    pub output_index: u64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallSearchingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.file_search_call.searching`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallSearchingEventType {
            #[default]
            #[serde(rename = "response.file_search_call.searching")]
            ResponseFileSearchCallSearching,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFileSearchCallSearchingEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFileSearchCallSearchingEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseFileSearchCallSearchingEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseFileSearchCallSearchingEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallSearchingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.file_search_call.searching`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFileSearchCallSearchingEventType {
            #[default]
            #[serde(rename = "response.file_search_call.searching")]
            ResponseFileSearchCallSearching,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFileSearchCallSearchingEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFileSearchCallSearchingEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseFileSearchCallSearchingEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a file search is currently searching."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallSearchingEvent {
    #[doc = "The index of the output item that the file search call is searching.\n"]
    pub output_index: u64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseFormatJsonObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of response format being defined. Always `json_object`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatJsonObjectType {
            #[default]
            #[serde(rename = "json_object")]
            JsonObject,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatJsonObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFormatJsonObjectType,
        }
        let ResponseFormatJsonObject { .. } = ResponseFormatJsonObject::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for ResponseFormatJsonObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of response format being defined. Always `json_object`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatJsonObjectType {
            #[default]
            #[serde(rename = "json_object")]
            JsonObject,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatJsonObject<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFormatJsonObjectType,
        }
        let Self {} = self;
        ResponseFormatJsonObject {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "JSON object response format. An older method of generating JSON responses.\nUsing `json_schema` is recommended for models that support it. Note that the\nmodel will not generate JSON without a system or user message instructing it\nto do so.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ResponseFormatJsonObject {}
impl<'de> serde::Deserialize<'de> for ResponseFormatJsonSchemaJsonSchema {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatJsonSchemaJsonSchema {
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: Option<ResponseFormatJsonSchemaSchema>,
            #[serde(rename = "strict")]
            #[allow(dead_code)]
            strict: Option<bool>,
        }
        let ResponseFormatJsonSchemaJsonSchema {
            description,
            name,
            schema,
            strict,
            ..
        } = ResponseFormatJsonSchemaJsonSchema::deserialize(deserializer)?;
        Ok(Self {
            description,
            name,
            schema,
            strict,
        })
    }
}
impl serde::Serialize for ResponseFormatJsonSchemaJsonSchema {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatJsonSchemaJsonSchema<'a> {
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "schema")]
            #[serde(skip_serializing_if = "Option::is_none")]
            schema: &'a Option<ResponseFormatJsonSchemaSchema>,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let Self {
            description,
            name,
            schema,
            strict,
        } = self;
        ResponseFormatJsonSchemaJsonSchema {
            description,
            name,
            schema,
            strict,
        }
        .serialize(serializer)
    }
}
#[doc = "Structured Outputs configuration options, including a JSON Schema.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatJsonSchemaJsonSchema {
    #[doc = "A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n"]
    pub name: String,
    #[builder(default)]
    pub schema: Option<ResponseFormatJsonSchemaSchema>,
    #[doc = "Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n"]
    #[builder(default)]
    pub strict: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ResponseFormatJsonSchema {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of response format being defined. Always `json_schema`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatJsonSchemaType {
            #[default]
            #[serde(rename = "json_schema")]
            JsonSchema,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatJsonSchema {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFormatJsonSchemaType,
            #[serde(rename = "json_schema")]
            #[allow(dead_code)]
            json_schema: ResponseFormatJsonSchemaJsonSchema,
        }
        let ResponseFormatJsonSchema { json_schema, .. } =
            ResponseFormatJsonSchema::deserialize(deserializer)?;
        Ok(Self { json_schema })
    }
}
impl serde::Serialize for ResponseFormatJsonSchema {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of response format being defined. Always `json_schema`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatJsonSchemaType {
            #[default]
            #[serde(rename = "json_schema")]
            JsonSchema,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatJsonSchema<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFormatJsonSchemaType,
            #[serde(rename = "json_schema")]
            json_schema: &'a ResponseFormatJsonSchemaJsonSchema,
        }
        let Self { json_schema } = self;
        ResponseFormatJsonSchema {
            type_: &Default::default(),
            json_schema,
        }
        .serialize(serializer)
    }
}
#[doc = "JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatJsonSchema {
    #[doc = "Structured Outputs configuration options, including a JSON Schema.\n"]
    pub json_schema: ResponseFormatJsonSchemaJsonSchema,
}
#[doc = "The schema for the response format, described as a JSON Schema object.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
pub type ResponseFormatJsonSchemaSchema = std::collections::HashMap<String, serde_json::Value>;
impl<'de> serde::Deserialize<'de> for ResponseFormatText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of response format being defined. Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatTextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatText {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFormatTextType,
        }
        let ResponseFormatText { .. } = ResponseFormatText::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for ResponseFormatText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of response format being defined. Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFormatTextType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatText<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFormatTextType,
        }
        let Self {} = self;
        ResponseFormatText {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "Default response format. Used to generate text responses.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct ResponseFormatText {}
impl<'de> serde::Deserialize<'de> for ResponseFunctionCallArgumentsDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.function_call_arguments.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFunctionCallArgumentsDeltaEventType {
            #[default]
            #[serde(rename = "response.function_call_arguments.delta")]
            ResponseFunctionCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFunctionCallArgumentsDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFunctionCallArgumentsDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
        }
        let ResponseFunctionCallArgumentsDeltaEvent {
            item_id,
            output_index,
            sequence_number,
            delta,
            ..
        } = ResponseFunctionCallArgumentsDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
            delta,
        })
    }
}
impl serde::Serialize for ResponseFunctionCallArgumentsDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.function_call_arguments.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFunctionCallArgumentsDeltaEventType {
            #[default]
            #[serde(rename = "response.function_call_arguments.delta")]
            ResponseFunctionCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFunctionCallArgumentsDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFunctionCallArgumentsDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
            delta,
        } = self;
        ResponseFunctionCallArgumentsDeltaEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            sequence_number,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a partial function-call arguments delta."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFunctionCallArgumentsDeltaEvent {
    #[doc = "The ID of the output item that the function-call arguments delta is added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the function-call arguments delta is added to.\n"]
    pub output_index: u64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The function-call arguments delta that is added.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseFunctionCallArgumentsDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFunctionCallArgumentsDoneEventType {
            #[default]
            #[serde(rename = "response.function_call_arguments.done")]
            ResponseFunctionCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFunctionCallArgumentsDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseFunctionCallArgumentsDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let ResponseFunctionCallArgumentsDoneEvent {
            item_id,
            output_index,
            sequence_number,
            arguments,
            ..
        } = ResponseFunctionCallArgumentsDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
            arguments,
        })
    }
}
impl serde::Serialize for ResponseFunctionCallArgumentsDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseFunctionCallArgumentsDoneEventType {
            #[default]
            #[serde(rename = "response.function_call_arguments.done")]
            ResponseFunctionCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFunctionCallArgumentsDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseFunctionCallArgumentsDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
            arguments,
        } = self;
        ResponseFunctionCallArgumentsDoneEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            sequence_number,
            arguments,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when function-call arguments are finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFunctionCallArgumentsDoneEvent {
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item."]
    pub output_index: u64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The function-call arguments."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for ResponseImageGenCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.image_generation_call.completed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseImageGenCallCompletedEventType {
            #[default]
            #[serde(rename = "response.image_generation_call.completed")]
            ResponseImageGenerationCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseImageGenCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseImageGenCallCompletedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let ResponseImageGenCallCompletedEvent {
            output_index,
            sequence_number,
            item_id,
            ..
        } = ResponseImageGenCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            sequence_number,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseImageGenCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.image_generation_call.completed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseImageGenCallCompletedEventType {
            #[default]
            #[serde(rename = "response.image_generation_call.completed")]
            ResponseImageGenerationCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseImageGenCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseImageGenCallCompletedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            output_index,
            sequence_number,
            item_id,
        } = self;
        ResponseImageGenCallCompletedEvent {
            type_: &Default::default(),
            output_index,
            sequence_number,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an image generation tool call has completed and the final image is available.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseImageGenCallCompletedEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The unique identifier of the image generation item being processed."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseImageGenCallGeneratingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.image_generation_call.generating'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseImageGenCallGeneratingEventType {
            #[default]
            #[serde(rename = "response.image_generation_call.generating")]
            ResponseImageGenerationCallGenerating,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseImageGenCallGeneratingEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseImageGenCallGeneratingEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseImageGenCallGeneratingEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseImageGenCallGeneratingEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseImageGenCallGeneratingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.image_generation_call.generating'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseImageGenCallGeneratingEventType {
            #[default]
            #[serde(rename = "response.image_generation_call.generating")]
            ResponseImageGenerationCallGenerating,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseImageGenCallGeneratingEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseImageGenCallGeneratingEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseImageGenCallGeneratingEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an image generation tool call is actively generating an image (intermediate state).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseImageGenCallGeneratingEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The unique identifier of the image generation item being processed."]
    pub item_id: String,
    #[doc = "The sequence number of the image generation item being processed."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseImageGenCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.image_generation_call.in_progress'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseImageGenCallInProgressEventType {
            #[default]
            #[serde(rename = "response.image_generation_call.in_progress")]
            ResponseImageGenerationCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseImageGenCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseImageGenCallInProgressEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseImageGenCallInProgressEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseImageGenCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseImageGenCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.image_generation_call.in_progress'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseImageGenCallInProgressEventType {
            #[default]
            #[serde(rename = "response.image_generation_call.in_progress")]
            ResponseImageGenerationCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseImageGenCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseImageGenCallInProgressEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseImageGenCallInProgressEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an image generation tool call is in progress.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseImageGenCallInProgressEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The unique identifier of the image generation item being processed."]
    pub item_id: String,
    #[doc = "The sequence number of the image generation item being processed."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseImageGenCallPartialImageEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.image_generation_call.partial_image'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseImageGenCallPartialImageEventType {
            #[default]
            #[serde(rename = "response.image_generation_call.partial_image")]
            ResponseImageGenerationCallPartialImage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseImageGenCallPartialImageEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseImageGenCallPartialImageEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "partial_image_index")]
            #[allow(dead_code)]
            partial_image_index: u64,
            #[serde(rename = "partial_image_b64")]
            #[allow(dead_code)]
            partial_image_b64: String,
        }
        let ResponseImageGenCallPartialImageEvent {
            output_index,
            item_id,
            sequence_number,
            partial_image_index,
            partial_image_b64,
            ..
        } = ResponseImageGenCallPartialImageEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
            partial_image_index,
            partial_image_b64,
        })
    }
}
impl serde::Serialize for ResponseImageGenCallPartialImageEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.image_generation_call.partial_image'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseImageGenCallPartialImageEventType {
            #[default]
            #[serde(rename = "response.image_generation_call.partial_image")]
            ResponseImageGenerationCallPartialImage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseImageGenCallPartialImageEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseImageGenCallPartialImageEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "partial_image_index")]
            partial_image_index: &'a u64,
            #[serde(rename = "partial_image_b64")]
            partial_image_b64: &'a String,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
            partial_image_index,
            partial_image_b64,
        } = self;
        ResponseImageGenCallPartialImageEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
            partial_image_index,
            partial_image_b64,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a partial image is available during image generation streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseImageGenCallPartialImageEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The unique identifier of the image generation item being processed."]
    pub item_id: String,
    #[doc = "The sequence number of the image generation item being processed."]
    pub sequence_number: u64,
    #[doc = "0-based index for the partial image (backend is 1-based, but this is 0-based for the user)."]
    pub partial_image_index: u64,
    #[doc = "Base64-encoded partial image data, suitable for rendering as an image."]
    pub partial_image_b64: String,
}
impl<'de> serde::Deserialize<'de> for ResponseInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseInProgressEventType {
            #[default]
            #[serde(rename = "response.in_progress")]
            ResponseInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseInProgressEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseInProgressEvent {
            response,
            sequence_number,
            ..
        } = ResponseInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseInProgressEventType {
            #[default]
            #[serde(rename = "response.in_progress")]
            ResponseInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseInProgressEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseInProgressEventType,
            #[serde(rename = "response")]
            response: &'a Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseInProgressEvent {
            type_: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the response is in progress."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseInProgressEvent {
    #[doc = "The response that is in progress.\n"]
    pub response: Response,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseIncompleteEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.incomplete`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteEventType {
            #[default]
            #[serde(rename = "response.incomplete")]
            ResponseIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseIncompleteEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseIncompleteEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseIncompleteEvent {
            response,
            sequence_number,
            ..
        } = ResponseIncompleteEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseIncompleteEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.incomplete`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseIncompleteEventType {
            #[default]
            #[serde(rename = "response.incomplete")]
            ResponseIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseIncompleteEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseIncompleteEventType,
            #[serde(rename = "response")]
            response: &'a Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseIncompleteEvent {
            type_: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "An event that is emitted when a response finishes as incomplete.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseIncompleteEvent {
    #[doc = "The response that was incomplete.\n"]
    pub response: Response,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseItemList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of object returned, must be `list`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseItemListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseItemList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ResponseItemListObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<ItemResource>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
        }
        let ResponseItemList {
            data,
            has_more,
            first_id,
            last_id,
            ..
        } = ResponseItemList::deserialize(deserializer)?;
        Ok(Self {
            data,
            has_more,
            first_id,
            last_id,
        })
    }
}
impl serde::Serialize for ResponseItemList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of object returned, must be `list`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseItemListObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseItemList<'a> {
            #[serde(rename = "object")]
            object: &'a ResponseItemListObject,
            #[serde(rename = "data")]
            data: &'a Vec<ItemResource>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
        }
        let Self {
            data,
            has_more,
            first_id,
            last_id,
        } = self;
        ResponseItemList {
            object: &Default::default(),
            data,
            has_more,
            first_id,
            last_id,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of Response items."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseItemList {
    #[doc = "A list of items used to generate this response."]
    pub data: Vec<ItemResource>,
    #[doc = "Whether there are more items available."]
    pub has_more: bool,
    #[doc = "The ID of the first item in the list."]
    pub first_id: String,
    #[doc = "The ID of the last item in the list."]
    pub last_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallArgumentsDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.arguments_delta'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallArgumentsDeltaEventType {
            #[default]
            #[serde(rename = "response.mcp_call.arguments_delta")]
            ResponseMcpCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallArgumentsDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseMcpCallArgumentsDeltaEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseMcpCallArgumentsDeltaEvent {
            output_index,
            item_id,
            delta,
            sequence_number,
            ..
        } = ResponseMcpCallArgumentsDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpCallArgumentsDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.arguments_delta'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallArgumentsDeltaEventType {
            #[default]
            #[serde(rename = "response.mcp_call.arguments_delta")]
            ResponseMcpCallArgumentsDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallArgumentsDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseMcpCallArgumentsDeltaEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "delta")]
            delta: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            delta,
            sequence_number,
        } = self;
        ResponseMcpCallArgumentsDeltaEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a delta (partial update) to the arguments of an MCP tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallArgumentsDeltaEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The unique identifier of the MCP tool call item being processed."]
    pub item_id: String,
    #[doc = "The partial update to the arguments for the MCP tool call."]
    pub delta: std::collections::HashMap<String, serde_json::Value>,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallArgumentsDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.arguments_done'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallArgumentsDoneEventType {
            #[default]
            #[serde(rename = "response.mcp_call.arguments_done")]
            ResponseMcpCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallArgumentsDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseMcpCallArgumentsDoneEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseMcpCallArgumentsDoneEvent {
            output_index,
            item_id,
            arguments,
            sequence_number,
            ..
        } = ResponseMcpCallArgumentsDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            arguments,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpCallArgumentsDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.arguments_done'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallArgumentsDoneEventType {
            #[default]
            #[serde(rename = "response.mcp_call.arguments_done")]
            ResponseMcpCallArgumentsDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallArgumentsDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseMcpCallArgumentsDoneEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            arguments,
            sequence_number,
        } = self;
        ResponseMcpCallArgumentsDoneEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            arguments,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the arguments for an MCP tool call are finalized.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallArgumentsDoneEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The unique identifier of the MCP tool call item being processed."]
    pub item_id: String,
    #[doc = "The finalized arguments for the MCP tool call."]
    pub arguments: std::collections::HashMap<String, serde_json::Value>,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.completed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallCompletedEventType {
            #[default]
            #[serde(rename = "response.mcp_call.completed")]
            ResponseMcpCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseMcpCallCompletedEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseMcpCallCompletedEvent {
            sequence_number, ..
        } = ResponseMcpCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self { sequence_number })
    }
}
impl serde::Serialize for ResponseMcpCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.completed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallCompletedEventType {
            #[default]
            #[serde(rename = "response.mcp_call.completed")]
            ResponseMcpCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseMcpCallCompletedEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self { sequence_number } = self;
        ResponseMcpCallCompletedEvent {
            type_: &Default::default(),
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an MCP  tool call has completed successfully.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallCompletedEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallFailedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.failed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallFailedEventType {
            #[default]
            #[serde(rename = "response.mcp_call.failed")]
            ResponseMcpCallFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallFailedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseMcpCallFailedEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseMcpCallFailedEvent {
            sequence_number, ..
        } = ResponseMcpCallFailedEvent::deserialize(deserializer)?;
        Ok(Self { sequence_number })
    }
}
impl serde::Serialize for ResponseMcpCallFailedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.failed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallFailedEventType {
            #[default]
            #[serde(rename = "response.mcp_call.failed")]
            ResponseMcpCallFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallFailedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseMcpCallFailedEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self { sequence_number } = self;
        ResponseMcpCallFailedEvent {
            type_: &Default::default(),
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an MCP  tool call has failed.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallFailedEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.in_progress'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallInProgressEventType {
            #[default]
            #[serde(rename = "response.mcp_call.in_progress")]
            ResponseMcpCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseMcpCallInProgressEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
        }
        let ResponseMcpCallInProgressEvent {
            sequence_number,
            output_index,
            item_id,
            ..
        } = ResponseMcpCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            output_index,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseMcpCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.mcp_call.in_progress'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpCallInProgressEventType {
            #[default]
            #[serde(rename = "response.mcp_call.in_progress")]
            ResponseMcpCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseMcpCallInProgressEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            sequence_number,
            output_index,
            item_id,
        } = self;
        ResponseMcpCallInProgressEvent {
            type_: &Default::default(),
            sequence_number,
            output_index,
            item_id,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an MCP  tool call is in progress.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallInProgressEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The unique identifier of the MCP tool call item being processed."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpListToolsCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.mcp_list_tools.completed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpListToolsCompletedEventType {
            #[default]
            #[serde(rename = "response.mcp_list_tools.completed")]
            ResponseMcpListToolsCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpListToolsCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseMcpListToolsCompletedEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseMcpListToolsCompletedEvent {
            sequence_number, ..
        } = ResponseMcpListToolsCompletedEvent::deserialize(deserializer)?;
        Ok(Self { sequence_number })
    }
}
impl serde::Serialize for ResponseMcpListToolsCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.mcp_list_tools.completed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpListToolsCompletedEventType {
            #[default]
            #[serde(rename = "response.mcp_list_tools.completed")]
            ResponseMcpListToolsCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpListToolsCompletedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseMcpListToolsCompletedEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self { sequence_number } = self;
        ResponseMcpListToolsCompletedEvent {
            type_: &Default::default(),
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the list of available MCP tools has been successfully retrieved.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseMcpListToolsCompletedEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpListToolsFailedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.mcp_list_tools.failed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpListToolsFailedEventType {
            #[default]
            #[serde(rename = "response.mcp_list_tools.failed")]
            ResponseMcpListToolsFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpListToolsFailedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseMcpListToolsFailedEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseMcpListToolsFailedEvent {
            sequence_number, ..
        } = ResponseMcpListToolsFailedEvent::deserialize(deserializer)?;
        Ok(Self { sequence_number })
    }
}
impl serde::Serialize for ResponseMcpListToolsFailedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.mcp_list_tools.failed'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpListToolsFailedEventType {
            #[default]
            #[serde(rename = "response.mcp_list_tools.failed")]
            ResponseMcpListToolsFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpListToolsFailedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseMcpListToolsFailedEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self { sequence_number } = self;
        ResponseMcpListToolsFailedEvent {
            type_: &Default::default(),
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the attempt to list available MCP tools has failed.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseMcpListToolsFailedEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpListToolsInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.mcp_list_tools.in_progress'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpListToolsInProgressEventType {
            #[default]
            #[serde(rename = "response.mcp_list_tools.in_progress")]
            ResponseMcpListToolsInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpListToolsInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseMcpListToolsInProgressEventType,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseMcpListToolsInProgressEvent {
            sequence_number, ..
        } = ResponseMcpListToolsInProgressEvent::deserialize(deserializer)?;
        Ok(Self { sequence_number })
    }
}
impl serde::Serialize for ResponseMcpListToolsInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.mcp_list_tools.in_progress'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseMcpListToolsInProgressEventType {
            #[default]
            #[serde(rename = "response.mcp_list_tools.in_progress")]
            ResponseMcpListToolsInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpListToolsInProgressEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseMcpListToolsInProgressEventType,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self { sequence_number } = self;
        ResponseMcpListToolsInProgressEvent {
            type_: &Default::default(),
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the system is in the process of retrieving the list of available MCP tools.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseMcpListToolsInProgressEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseModality {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ResponseModality {
            Text(#[allow(dead_code)] ResponseModalityText),
            Audio(#[allow(dead_code)] ResponseModalityAudio),
        }
        Ok(match ResponseModality::deserialize(deserializer)? {
            ResponseModality::Text(_) => Self::Text,
            ResponseModality::Audio(_) => Self::Audio,
        })
    }
}
impl serde::Serialize for ResponseModality {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseModalityText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseModalityAudio {
            #[default]
            #[serde(rename = "audio")]
            Audio,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ResponseModality<'a> {
            Text(#[allow(dead_code)] &'a ResponseModalityText),
            Audio(#[allow(dead_code)] &'a ResponseModalityAudio),
        }
        match self {
            Self::Text => ResponseModality::Text(&Default::default()).serialize(serializer),
            Self::Audio => ResponseModality::Audio(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseModality {
    #[doc = "text"]
    Text,
    #[doc = "audio"]
    Audio,
}
#[doc = "Output types that you would like the model to generate.\nMost models are capable of generating text, which is the default:\n\n`[\"text\"]`\n\nThe `gpt-4o-audio-preview` model can also be used to \n[generate audio](https://platform.openai.com/docs/guides/audio). To request that this model generate \nboth text and audio responses, you can use:\n\n`[\"text\", \"audio\"]`\n"]
pub type ResponseModalities = Vec<ResponseModality>;
impl<'de> serde::Deserialize<'de> for ResponseOutputItemAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_item.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputItemAddedEventType {
            #[default]
            #[serde(rename = "response.output_item.added")]
            ResponseOutputItemAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseOutputItemAddedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseOutputItemAddedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: OutputItem,
        }
        let ResponseOutputItemAddedEvent {
            output_index,
            sequence_number,
            item,
            ..
        } = ResponseOutputItemAddedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            sequence_number,
            item,
        })
    }
}
impl serde::Serialize for ResponseOutputItemAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_item.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputItemAddedEventType {
            #[default]
            #[serde(rename = "response.output_item.added")]
            ResponseOutputItemAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseOutputItemAddedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseOutputItemAddedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "item")]
            item: &'a OutputItem,
        }
        let Self {
            output_index,
            sequence_number,
            item,
        } = self;
        ResponseOutputItemAddedEvent {
            type_: &Default::default(),
            output_index,
            sequence_number,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a new output item is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseOutputItemAddedEvent {
    #[doc = "The index of the output item that was added.\n"]
    pub output_index: u64,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: u64,
    #[doc = "The output item that was added.\n"]
    pub item: OutputItem,
}
impl<'de> serde::Deserialize<'de> for ResponseOutputItemDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_item.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputItemDoneEventType {
            #[default]
            #[serde(rename = "response.output_item.done")]
            ResponseOutputItemDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseOutputItemDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseOutputItemDoneEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: OutputItem,
        }
        let ResponseOutputItemDoneEvent {
            output_index,
            sequence_number,
            item,
            ..
        } = ResponseOutputItemDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            sequence_number,
            item,
        })
    }
}
impl serde::Serialize for ResponseOutputItemDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_item.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputItemDoneEventType {
            #[default]
            #[serde(rename = "response.output_item.done")]
            ResponseOutputItemDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseOutputItemDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseOutputItemDoneEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "item")]
            item: &'a OutputItem,
        }
        let Self {
            output_index,
            sequence_number,
            item,
        } = self;
        ResponseOutputItemDoneEvent {
            type_: &Default::default(),
            output_index,
            sequence_number,
            item,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an output item is marked done."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseOutputItemDoneEvent {
    #[doc = "The index of the output item that was marked done.\n"]
    pub output_index: u64,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: u64,
    #[doc = "The output item that was marked done.\n"]
    pub item: OutputItem,
}
impl<'de> serde::Deserialize<'de> for ResponseOutputTextAnnotationAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.output_text_annotation.added'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputTextAnnotationAddedEventType {
            #[default]
            #[serde(rename = "response.output_text_annotation.added")]
            ResponseOutputTextAnnotationAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseOutputTextAnnotationAddedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseOutputTextAnnotationAddedEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "annotation_index")]
            #[allow(dead_code)]
            annotation_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "annotation")]
            #[allow(dead_code)]
            annotation: std::collections::HashMap<String, serde_json::Value>,
        }
        let ResponseOutputTextAnnotationAddedEvent {
            item_id,
            output_index,
            content_index,
            annotation_index,
            sequence_number,
            annotation,
            ..
        } = ResponseOutputTextAnnotationAddedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            annotation_index,
            sequence_number,
            annotation,
        })
    }
}
impl serde::Serialize for ResponseOutputTextAnnotationAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.output_text_annotation.added'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseOutputTextAnnotationAddedEventType {
            #[default]
            #[serde(rename = "response.output_text_annotation.added")]
            ResponseOutputTextAnnotationAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseOutputTextAnnotationAddedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseOutputTextAnnotationAddedEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "annotation_index")]
            annotation_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "annotation")]
            annotation: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            annotation_index,
            sequence_number,
            annotation,
        } = self;
        ResponseOutputTextAnnotationAddedEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            annotation_index,
            sequence_number,
            annotation,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when an annotation is added to output text content.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseOutputTextAnnotationAddedEvent {
    #[doc = "The unique identifier of the item to which the annotation is being added."]
    pub item_id: String,
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The index of the content part within the output item."]
    pub content_index: u64,
    #[doc = "The index of the annotation within the content part."]
    pub annotation_index: u64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The annotation object being added. (See annotation schema for details.)"]
    pub annotation: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for ResponsePropertiesText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponsePropertiesText {
            #[serde(rename = "format")]
            #[allow(dead_code)]
            format: Option<TextResponseFormatConfiguration>,
        }
        let ResponsePropertiesText { format, .. } =
            ResponsePropertiesText::deserialize(deserializer)?;
        Ok(Self { format })
    }
}
impl serde::Serialize for ResponsePropertiesText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponsePropertiesText<'a> {
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            format: &'a Option<TextResponseFormatConfiguration>,
        }
        let Self { format } = self;
        ResponsePropertiesText { format }.serialize(serializer)
    }
}
#[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ResponsePropertiesText {
    #[builder(default)]
    pub format: Option<TextResponseFormatConfiguration>,
}
impl<'de> serde::Deserialize<'de> for ResponsePropertiesToolChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ResponsePropertiesToolChoice {
            ToolChoiceOptions(#[allow(dead_code)] ToolChoiceOptions),
            ToolChoiceTypes(#[allow(dead_code)] ToolChoiceTypes),
            ToolChoiceFunction(#[allow(dead_code)] ToolChoiceFunction),
        }
        Ok(
            match ResponsePropertiesToolChoice::deserialize(deserializer)? {
                ResponsePropertiesToolChoice::ToolChoiceOptions(_v) => Self::ToolChoiceOptions(_v),
                ResponsePropertiesToolChoice::ToolChoiceTypes(_v) => Self::ToolChoiceTypes(_v),
                ResponsePropertiesToolChoice::ToolChoiceFunction(_v) => {
                    Self::ToolChoiceFunction(_v)
                }
            },
        )
    }
}
impl serde::Serialize for ResponsePropertiesToolChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ResponsePropertiesToolChoice<'a> {
            ToolChoiceOptions(#[allow(dead_code)] &'a ToolChoiceOptions),
            ToolChoiceTypes(#[allow(dead_code)] &'a ToolChoiceTypes),
            ToolChoiceFunction(#[allow(dead_code)] &'a ToolChoiceFunction),
        }
        match self {
            Self::ToolChoiceOptions(_v) => {
                ResponsePropertiesToolChoice::ToolChoiceOptions(_v).serialize(serializer)
            }
            Self::ToolChoiceTypes(_v) => {
                ResponsePropertiesToolChoice::ToolChoiceTypes(_v).serialize(serializer)
            }
            Self::ToolChoiceFunction(_v) => {
                ResponsePropertiesToolChoice::ToolChoiceFunction(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ResponsePropertiesToolChoice {
    ToolChoiceOptions(ToolChoiceOptions),
    ToolChoiceTypes(ToolChoiceTypes),
    ToolChoiceFunction(ToolChoiceFunction),
}
impl<'de> serde::Deserialize<'de> for ResponsePropertiesTruncation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponsePropertiesTruncationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponsePropertiesTruncationDisabled {
            #[default]
            #[serde(rename = "disabled")]
            Disabled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ResponsePropertiesTruncation {
            Auto(#[allow(dead_code)] ResponsePropertiesTruncationAuto),
            Disabled(#[allow(dead_code)] ResponsePropertiesTruncationDisabled),
        }
        Ok(
            match ResponsePropertiesTruncation::deserialize(deserializer)? {
                ResponsePropertiesTruncation::Auto(_) => Self::Auto,
                ResponsePropertiesTruncation::Disabled(_) => Self::Disabled,
            },
        )
    }
}
impl serde::Serialize for ResponsePropertiesTruncation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponsePropertiesTruncationAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponsePropertiesTruncationDisabled {
            #[default]
            #[serde(rename = "disabled")]
            Disabled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ResponsePropertiesTruncation<'a> {
            Auto(#[allow(dead_code)] &'a ResponsePropertiesTruncationAuto),
            Disabled(#[allow(dead_code)] &'a ResponsePropertiesTruncationDisabled),
        }
        match self {
            Self::Auto => {
                ResponsePropertiesTruncation::Auto(&Default::default()).serialize(serializer)
            }
            Self::Disabled => {
                ResponsePropertiesTruncation::Disabled(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the \n  response to fit the context window by dropping input items in the\n  middle of the conversation. \n- `disabled` (default): If a model response will exceed the context window \n  size for a model, the request will fail with a 400 error.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ResponsePropertiesTruncation {
    #[doc = "auto"]
    Auto,
    #[doc = "disabled"]
    #[default]
    Disabled,
}
impl<'de> serde::Deserialize<'de> for ResponseProperties {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseProperties {
            #[serde(rename = "previous_response_id")]
            #[allow(dead_code)]
            previous_response_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<ModelIdsResponses>,
            #[serde(rename = "reasoning")]
            #[allow(dead_code)]
            reasoning: Option<Reasoning>,
            #[serde(rename = "background")]
            #[allow(dead_code)]
            background: Option<bool>,
            #[serde(rename = "max_output_tokens")]
            #[allow(dead_code)]
            max_output_tokens: Option<u64>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<ResponsePropertiesText>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<Tool>>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<ResponsePropertiesToolChoice>,
            #[serde(rename = "truncation")]
            #[allow(dead_code)]
            truncation: Option<ResponsePropertiesTruncation>,
        }
        let ResponseProperties {
            previous_response_id,
            model,
            reasoning,
            background,
            max_output_tokens,
            instructions,
            text,
            tools,
            tool_choice,
            truncation,
            ..
        } = ResponseProperties::deserialize(deserializer)?;
        Ok(Self {
            previous_response_id,
            model,
            reasoning,
            background,
            max_output_tokens,
            instructions,
            text,
            tools,
            tool_choice,
            truncation,
        })
    }
}
impl serde::Serialize for ResponseProperties {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseProperties<'a> {
            #[serde(rename = "previous_response_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            previous_response_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<ModelIdsResponses>,
            #[serde(rename = "reasoning")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning: &'a Option<Reasoning>,
            #[serde(rename = "background")]
            #[serde(skip_serializing_if = "Option::is_none")]
            background: &'a Option<bool>,
            #[serde(rename = "max_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_output_tokens: &'a Option<u64>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<ResponsePropertiesText>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<Tool>>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<ResponsePropertiesToolChoice>,
            #[serde(rename = "truncation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation: &'a Option<ResponsePropertiesTruncation>,
        }
        let Self {
            previous_response_id,
            model,
            reasoning,
            background,
            max_output_tokens,
            instructions,
            text,
            tools,
            tool_choice,
            truncation,
        } = self;
        ResponseProperties {
            previous_response_id,
            model,
            reasoning,
            background,
            max_output_tokens,
            instructions,
            text,
            tools,
            tool_choice,
            truncation,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ResponseProperties {
    #[doc = "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about \n[conversation state](https://platform.openai.com/docs/guides/conversation-state).\n"]
    #[builder(default)]
    pub previous_response_id: Option<String>,
    #[doc = "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\nto browse and compare available models.\n"]
    #[builder(default)]
    pub model: Option<ModelIdsResponses>,
    #[builder(default)]
    pub reasoning: Option<Reasoning>,
    #[doc = "Whether to run the model response in the background. \n[Learn more](https://platform.openai.com/docs/guides/background).\n"]
    #[builder(default)]
    pub background: Option<bool>,
    #[doc = "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\n"]
    #[builder(default)]
    pub max_output_tokens: Option<u64>,
    #[doc = "Inserts a system (or developer) message as the first item in the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
    #[builder(default)]
    pub text: Option<ResponsePropertiesText>,
    #[doc = "An array of tools the model may call while generating a response. You \ncan specify which tool to use by setting the `tool_choice` parameter.\n\nThe two categories of tools you can provide the model are:\n\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code. Learn more about\n  [function calling](https://platform.openai.com/docs/guides/function-calling).\n"]
    #[builder(default)]
    pub tools: Option<Vec<Tool>>,
    #[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
    #[builder(default)]
    pub tool_choice: Option<ResponsePropertiesToolChoice>,
    #[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the \n  response to fit the context window by dropping input items in the\n  middle of the conversation. \n- `disabled` (default): If a model response will exceed the context window \n  size for a model, the request will fail with a 400 error.\n"]
    #[builder(default)]
    pub truncation: Option<ResponsePropertiesTruncation>,
}
impl<'de> serde::Deserialize<'de> for ResponseQueuedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.queued'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseQueuedEventType {
            #[default]
            #[serde(rename = "response.queued")]
            ResponseQueued,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseQueuedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseQueuedEventType,
            #[serde(rename = "response")]
            #[allow(dead_code)]
            response: Response,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseQueuedEvent {
            response,
            sequence_number,
            ..
        } = ResponseQueuedEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseQueuedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.queued'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseQueuedEventType {
            #[default]
            #[serde(rename = "response.queued")]
            ResponseQueued,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseQueuedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseQueuedEventType,
            #[serde(rename = "response")]
            response: &'a Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseQueuedEvent {
            type_: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a response is queued and waiting to be processed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseQueuedEvent {
    #[doc = "The full response object that is queued."]
    pub response: Response,
    #[doc = "The sequence number for this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.reasoning.delta'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningDeltaEventType {
            #[default]
            #[serde(rename = "response.reasoning.delta")]
            ResponseReasoningDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseReasoningDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            ..
        } = ResponseReasoningDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.reasoning.delta'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningDeltaEventType {
            #[default]
            #[serde(rename = "response.reasoning.delta")]
            ResponseReasoningDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        } = self;
        ResponseReasoningDeltaEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a delta (partial update) to the reasoning content.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningDeltaEvent {
    #[doc = "The unique identifier of the item for which reasoning is being updated."]
    pub item_id: String,
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The index of the reasoning content part within the output item."]
    pub content_index: u64,
    #[doc = "The partial update to the reasoning content."]
    pub delta: std::collections::HashMap<String, serde_json::Value>,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.reasoning.done'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning.done")]
            ResponseReasoningDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseReasoningDoneEvent {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
            ..
        } = ResponseReasoningDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.reasoning.done'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning.done")]
            ResponseReasoningDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        } = self;
        ResponseReasoningDoneEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the reasoning content is finalized for an item.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningDoneEvent {
    #[doc = "The unique identifier of the item for which reasoning is finalized."]
    pub item_id: String,
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The index of the reasoning content part within the output item."]
    pub content_index: u64,
    #[doc = "The finalized reasoning text."]
    pub text: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.reasoning_summary.delta'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryDeltaEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary.delta")]
            ResponseReasoningSummaryDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: std::collections::HashMap<String, serde_json::Value>,
        }
        let ResponseReasoningSummaryDeltaEvent {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            delta,
            ..
        } = ResponseReasoningSummaryDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            delta,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.reasoning_summary.delta'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryDeltaEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary.delta")]
            ResponseReasoningSummaryDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            delta,
        } = self;
        ResponseReasoningSummaryDeltaEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            sequence_number,
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a delta (partial update) to the reasoning summary content.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryDeltaEvent {
    #[doc = "The unique identifier of the item for which the reasoning summary is being updated."]
    pub item_id: String,
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The index of the summary part within the output item."]
    pub summary_index: u64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
    #[doc = "The partial update to the reasoning summary content."]
    pub delta: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always 'response.reasoning_summary.done'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary.done")]
            ResponseReasoningSummaryDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseReasoningSummaryDoneEvent {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
            ..
        } = ResponseReasoningSummaryDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always 'response.reasoning_summary.done'."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary.done")]
            ResponseReasoningSummaryDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        } = self;
        ResponseReasoningSummaryDoneEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the reasoning summary content is finalized for an item.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryDoneEvent {
    #[doc = "The unique identifier of the item for which the reasoning summary is finalized."]
    pub item_id: String,
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: u64,
    #[doc = "The index of the summary part within the output item."]
    pub summary_index: u64,
    #[doc = "The finalized reasoning summary text."]
    pub text: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartAddedEventPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartAddedEventPartType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryPartAddedEventPart {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryPartAddedEventPartType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let ResponseReasoningSummaryPartAddedEventPart { text, .. } =
            ResponseReasoningSummaryPartAddedEventPart::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartAddedEventPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartAddedEventPartType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryPartAddedEventPart<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryPartAddedEventPartType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        ResponseReasoningSummaryPartAddedEventPart {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The summary part that was added.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartAddedEventPart {
    #[doc = "The text of the summary part."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_part.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartAddedEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_part.added")]
            ResponseReasoningSummaryPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryPartAddedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryPartAddedEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: ResponseReasoningSummaryPartAddedEventPart,
        }
        let ResponseReasoningSummaryPartAddedEvent {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
            ..
        } = ResponseReasoningSummaryPartAddedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_part.added`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartAddedEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_part.added")]
            ResponseReasoningSummaryPartAdded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryPartAddedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryPartAddedEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "part")]
            part: &'a ResponseReasoningSummaryPartAddedEventPart,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        } = self;
        ResponseReasoningSummaryPartAddedEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a new reasoning summary part is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartAddedEvent {
    #[doc = "The ID of the item this summary part is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary part is associated with.\n"]
    pub output_index: u64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: u64,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: u64,
    #[doc = "The summary part that was added.\n"]
    pub part: ResponseReasoningSummaryPartAddedEventPart,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartDoneEventPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartDoneEventPartType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryPartDoneEventPart {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryPartDoneEventPartType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let ResponseReasoningSummaryPartDoneEventPart { text, .. } =
            ResponseReasoningSummaryPartDoneEventPart::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartDoneEventPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartDoneEventPartType {
            #[default]
            #[serde(rename = "summary_text")]
            SummaryText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryPartDoneEventPart<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryPartDoneEventPartType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        ResponseReasoningSummaryPartDoneEventPart {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The completed summary part.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartDoneEventPart {
    #[doc = "The text of the summary part."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_part.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_part.done")]
            ResponseReasoningSummaryPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryPartDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryPartDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
            #[serde(rename = "part")]
            #[allow(dead_code)]
            part: ResponseReasoningSummaryPartDoneEventPart,
        }
        let ResponseReasoningSummaryPartDoneEvent {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
            ..
        } = ResponseReasoningSummaryPartDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_part.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryPartDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_part.done")]
            ResponseReasoningSummaryPartDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryPartDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryPartDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
            #[serde(rename = "part")]
            part: &'a ResponseReasoningSummaryPartDoneEventPart,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        } = self;
        ResponseReasoningSummaryPartDoneEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a reasoning summary part is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartDoneEvent {
    #[doc = "The ID of the item this summary part is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary part is associated with.\n"]
    pub output_index: u64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: u64,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: u64,
    #[doc = "The completed summary part.\n"]
    pub part: ResponseReasoningSummaryPartDoneEventPart,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryTextDeltaEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_text.delta")]
            ResponseReasoningSummaryTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryTextDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryTextDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseReasoningSummaryTextDeltaEvent {
            item_id,
            output_index,
            summary_index,
            delta,
            sequence_number,
            ..
        } = ResponseReasoningSummaryTextDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryTextDeltaEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_text.delta")]
            ResponseReasoningSummaryTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryTextDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryTextDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            delta,
            sequence_number,
        } = self;
        ResponseReasoningSummaryTextDeltaEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a delta is added to a reasoning summary text."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryTextDeltaEvent {
    #[doc = "The ID of the item this summary text delta is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary text delta is associated with.\n"]
    pub output_index: u64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: u64,
    #[doc = "The text delta that was added to the summary.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryTextDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_text.done")]
            ResponseReasoningSummaryTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryTextDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseReasoningSummaryTextDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "summary_index")]
            #[allow(dead_code)]
            summary_index: u64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseReasoningSummaryTextDoneEvent {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
            ..
        } = ResponseReasoningSummaryTextDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.reasoning_summary_text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseReasoningSummaryTextDoneEventType {
            #[default]
            #[serde(rename = "response.reasoning_summary_text.done")]
            ResponseReasoningSummaryTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryTextDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseReasoningSummaryTextDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "summary_index")]
            summary_index: &'a u64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        } = self;
        ResponseReasoningSummaryTextDoneEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a reasoning summary text is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryTextDoneEvent {
    #[doc = "The ID of the item this summary text is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary text is associated with.\n"]
    pub output_index: u64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: u64,
    #[doc = "The full text of the completed reasoning summary.\n"]
    pub text: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseRefusalDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.refusal.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseRefusalDeltaEventType {
            #[default]
            #[serde(rename = "response.refusal.delta")]
            ResponseRefusalDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseRefusalDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseRefusalDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseRefusalDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            ..
        } = ResponseRefusalDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseRefusalDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.refusal.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseRefusalDeltaEventType {
            #[default]
            #[serde(rename = "response.refusal.delta")]
            ResponseRefusalDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseRefusalDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseRefusalDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        } = self;
        ResponseRefusalDeltaEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is a partial refusal text."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseRefusalDeltaEvent {
    #[doc = "The ID of the output item that the refusal text is added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the refusal text is added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the refusal text is added to.\n"]
    pub content_index: u64,
    #[doc = "The refusal text that is added.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseRefusalDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.refusal.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseRefusalDoneEventType {
            #[default]
            #[serde(rename = "response.refusal.done")]
            ResponseRefusalDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseRefusalDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseRefusalDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseRefusalDoneEvent {
            item_id,
            output_index,
            content_index,
            refusal,
            sequence_number,
            ..
        } = ResponseRefusalDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            refusal,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseRefusalDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.refusal.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseRefusalDoneEventType {
            #[default]
            #[serde(rename = "response.refusal.done")]
            ResponseRefusalDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseRefusalDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseRefusalDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "refusal")]
            refusal: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            refusal,
            sequence_number,
        } = self;
        ResponseRefusalDoneEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            refusal,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when refusal text is finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseRefusalDoneEvent {
    #[doc = "The ID of the output item that the refusal text is finalized.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the refusal text is finalized.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the refusal text is finalized.\n"]
    pub content_index: u64,
    #[doc = "The refusal text that is finalized.\n"]
    pub refusal: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ResponseStreamEvent {
            ResponseAudioDelta(#[allow(dead_code)] ResponseAudioDeltaEvent),
            ResponseAudioDone(#[allow(dead_code)] ResponseAudioDoneEvent),
            ResponseAudioTranscriptDelta(#[allow(dead_code)] ResponseAudioTranscriptDeltaEvent),
            ResponseAudioTranscriptDone(#[allow(dead_code)] ResponseAudioTranscriptDoneEvent),
            ResponseCodeInterpreterCallCodeDelta(
                #[allow(dead_code)] ResponseCodeInterpreterCallCodeDeltaEvent,
            ),
            ResponseCodeInterpreterCallCodeDone(
                #[allow(dead_code)] ResponseCodeInterpreterCallCodeDoneEvent,
            ),
            ResponseCodeInterpreterCallCompleted(
                #[allow(dead_code)] ResponseCodeInterpreterCallCompletedEvent,
            ),
            ResponseCodeInterpreterCallInProgress(
                #[allow(dead_code)] ResponseCodeInterpreterCallInProgressEvent,
            ),
            ResponseCodeInterpreterCallInterpreting(
                #[allow(dead_code)] ResponseCodeInterpreterCallInterpretingEvent,
            ),
            ResponseCompleted(#[allow(dead_code)] ResponseCompletedEvent),
            ResponseContentPartAdded(#[allow(dead_code)] ResponseContentPartAddedEvent),
            ResponseContentPartDone(#[allow(dead_code)] ResponseContentPartDoneEvent),
            ResponseCreated(#[allow(dead_code)] ResponseCreatedEvent),
            Error(#[allow(dead_code)] ResponseErrorEvent),
            ResponseFileSearchCallCompleted(
                #[allow(dead_code)] ResponseFileSearchCallCompletedEvent,
            ),
            ResponseFileSearchCallInProgress(
                #[allow(dead_code)] ResponseFileSearchCallInProgressEvent,
            ),
            ResponseFileSearchCallSearching(
                #[allow(dead_code)] ResponseFileSearchCallSearchingEvent,
            ),
            ResponseFunctionCallArgumentsDelta(
                #[allow(dead_code)] ResponseFunctionCallArgumentsDeltaEvent,
            ),
            ResponseFunctionCallArgumentsDone(
                #[allow(dead_code)] ResponseFunctionCallArgumentsDoneEvent,
            ),
            ResponseInProgress(#[allow(dead_code)] ResponseInProgressEvent),
            ResponseFailed(#[allow(dead_code)] ResponseFailedEvent),
            ResponseIncomplete(#[allow(dead_code)] ResponseIncompleteEvent),
            ResponseOutputItemAdded(#[allow(dead_code)] ResponseOutputItemAddedEvent),
            ResponseOutputItemDone(#[allow(dead_code)] ResponseOutputItemDoneEvent),
            ResponseReasoningSummaryPartAdded(
                #[allow(dead_code)] ResponseReasoningSummaryPartAddedEvent,
            ),
            ResponseReasoningSummaryPartDone(
                #[allow(dead_code)] ResponseReasoningSummaryPartDoneEvent,
            ),
            ResponseReasoningSummaryTextDelta(
                #[allow(dead_code)] ResponseReasoningSummaryTextDeltaEvent,
            ),
            ResponseReasoningSummaryTextDone(
                #[allow(dead_code)] ResponseReasoningSummaryTextDoneEvent,
            ),
            ResponseRefusalDelta(#[allow(dead_code)] ResponseRefusalDeltaEvent),
            ResponseRefusalDone(#[allow(dead_code)] ResponseRefusalDoneEvent),
            ResponseOutputTextDelta(#[allow(dead_code)] ResponseTextDeltaEvent),
            ResponseOutputTextDone(#[allow(dead_code)] ResponseTextDoneEvent),
            ResponseWebSearchCallCompleted(#[allow(dead_code)] ResponseWebSearchCallCompletedEvent),
            ResponseWebSearchCallInProgress(
                #[allow(dead_code)] ResponseWebSearchCallInProgressEvent,
            ),
            ResponseWebSearchCallSearching(#[allow(dead_code)] ResponseWebSearchCallSearchingEvent),
            ResponseImageGenerationCallCompleted(
                #[allow(dead_code)] ResponseImageGenCallCompletedEvent,
            ),
            ResponseImageGenerationCallGenerating(
                #[allow(dead_code)] ResponseImageGenCallGeneratingEvent,
            ),
            ResponseImageGenerationCallInProgress(
                #[allow(dead_code)] ResponseImageGenCallInProgressEvent,
            ),
            ResponseImageGenerationCallPartialImage(
                #[allow(dead_code)] ResponseImageGenCallPartialImageEvent,
            ),
            ResponseMcpCallArgumentsDelta(#[allow(dead_code)] ResponseMcpCallArgumentsDeltaEvent),
            ResponseMcpCallArgumentsDone(#[allow(dead_code)] ResponseMcpCallArgumentsDoneEvent),
            ResponseMcpCallCompleted(#[allow(dead_code)] ResponseMcpCallCompletedEvent),
            ResponseMcpCallFailed(#[allow(dead_code)] ResponseMcpCallFailedEvent),
            ResponseMcpCallInProgress(#[allow(dead_code)] ResponseMcpCallInProgressEvent),
            ResponseMcpListToolsCompleted(#[allow(dead_code)] ResponseMcpListToolsCompletedEvent),
            ResponseMcpListToolsFailed(#[allow(dead_code)] ResponseMcpListToolsFailedEvent),
            ResponseMcpListToolsInProgress(#[allow(dead_code)] ResponseMcpListToolsInProgressEvent),
            ResponseOutputTextAnnotationAdded(
                #[allow(dead_code)] ResponseOutputTextAnnotationAddedEvent,
            ),
            ResponseQueued(#[allow(dead_code)] ResponseQueuedEvent),
            ResponseReasoningDelta(#[allow(dead_code)] ResponseReasoningDeltaEvent),
            ResponseReasoningDone(#[allow(dead_code)] ResponseReasoningDoneEvent),
            ResponseReasoningSummaryDelta(#[allow(dead_code)] ResponseReasoningSummaryDeltaEvent),
            ResponseReasoningSummaryDone(#[allow(dead_code)] ResponseReasoningSummaryDoneEvent),
        }
        Ok(match ResponseStreamEvent::deserialize(deserializer)? {
            ResponseStreamEvent::ResponseAudioDelta(_v) => Self::ResponseAudioDelta(_v),
            ResponseStreamEvent::ResponseAudioDone(_v) => Self::ResponseAudioDone(_v),
            ResponseStreamEvent::ResponseAudioTranscriptDelta(_v) => {
                Self::ResponseAudioTranscriptDelta(_v)
            }
            ResponseStreamEvent::ResponseAudioTranscriptDone(_v) => {
                Self::ResponseAudioTranscriptDone(_v)
            }
            ResponseStreamEvent::ResponseCodeInterpreterCallCodeDelta(_v) => {
                Self::ResponseCodeInterpreterCallCodeDelta(_v)
            }
            ResponseStreamEvent::ResponseCodeInterpreterCallCodeDone(_v) => {
                Self::ResponseCodeInterpreterCallCodeDone(_v)
            }
            ResponseStreamEvent::ResponseCodeInterpreterCallCompleted(_v) => {
                Self::ResponseCodeInterpreterCallCompleted(_v)
            }
            ResponseStreamEvent::ResponseCodeInterpreterCallInProgress(_v) => {
                Self::ResponseCodeInterpreterCallInProgress(_v)
            }
            ResponseStreamEvent::ResponseCodeInterpreterCallInterpreting(_v) => {
                Self::ResponseCodeInterpreterCallInterpreting(_v)
            }
            ResponseStreamEvent::ResponseCompleted(_v) => Self::ResponseCompleted(_v),
            ResponseStreamEvent::ResponseContentPartAdded(_v) => Self::ResponseContentPartAdded(_v),
            ResponseStreamEvent::ResponseContentPartDone(_v) => Self::ResponseContentPartDone(_v),
            ResponseStreamEvent::ResponseCreated(_v) => Self::ResponseCreated(_v),
            ResponseStreamEvent::Error(_v) => Self::Error(_v),
            ResponseStreamEvent::ResponseFileSearchCallCompleted(_v) => {
                Self::ResponseFileSearchCallCompleted(_v)
            }
            ResponseStreamEvent::ResponseFileSearchCallInProgress(_v) => {
                Self::ResponseFileSearchCallInProgress(_v)
            }
            ResponseStreamEvent::ResponseFileSearchCallSearching(_v) => {
                Self::ResponseFileSearchCallSearching(_v)
            }
            ResponseStreamEvent::ResponseFunctionCallArgumentsDelta(_v) => {
                Self::ResponseFunctionCallArgumentsDelta(_v)
            }
            ResponseStreamEvent::ResponseFunctionCallArgumentsDone(_v) => {
                Self::ResponseFunctionCallArgumentsDone(_v)
            }
            ResponseStreamEvent::ResponseInProgress(_v) => Self::ResponseInProgress(_v),
            ResponseStreamEvent::ResponseFailed(_v) => Self::ResponseFailed(_v),
            ResponseStreamEvent::ResponseIncomplete(_v) => Self::ResponseIncomplete(_v),
            ResponseStreamEvent::ResponseOutputItemAdded(_v) => Self::ResponseOutputItemAdded(_v),
            ResponseStreamEvent::ResponseOutputItemDone(_v) => Self::ResponseOutputItemDone(_v),
            ResponseStreamEvent::ResponseReasoningSummaryPartAdded(_v) => {
                Self::ResponseReasoningSummaryPartAdded(_v)
            }
            ResponseStreamEvent::ResponseReasoningSummaryPartDone(_v) => {
                Self::ResponseReasoningSummaryPartDone(_v)
            }
            ResponseStreamEvent::ResponseReasoningSummaryTextDelta(_v) => {
                Self::ResponseReasoningSummaryTextDelta(_v)
            }
            ResponseStreamEvent::ResponseReasoningSummaryTextDone(_v) => {
                Self::ResponseReasoningSummaryTextDone(_v)
            }
            ResponseStreamEvent::ResponseRefusalDelta(_v) => Self::ResponseRefusalDelta(_v),
            ResponseStreamEvent::ResponseRefusalDone(_v) => Self::ResponseRefusalDone(_v),
            ResponseStreamEvent::ResponseOutputTextDelta(_v) => Self::ResponseOutputTextDelta(_v),
            ResponseStreamEvent::ResponseOutputTextDone(_v) => Self::ResponseOutputTextDone(_v),
            ResponseStreamEvent::ResponseWebSearchCallCompleted(_v) => {
                Self::ResponseWebSearchCallCompleted(_v)
            }
            ResponseStreamEvent::ResponseWebSearchCallInProgress(_v) => {
                Self::ResponseWebSearchCallInProgress(_v)
            }
            ResponseStreamEvent::ResponseWebSearchCallSearching(_v) => {
                Self::ResponseWebSearchCallSearching(_v)
            }
            ResponseStreamEvent::ResponseImageGenerationCallCompleted(_v) => {
                Self::ResponseImageGenerationCallCompleted(_v)
            }
            ResponseStreamEvent::ResponseImageGenerationCallGenerating(_v) => {
                Self::ResponseImageGenerationCallGenerating(_v)
            }
            ResponseStreamEvent::ResponseImageGenerationCallInProgress(_v) => {
                Self::ResponseImageGenerationCallInProgress(_v)
            }
            ResponseStreamEvent::ResponseImageGenerationCallPartialImage(_v) => {
                Self::ResponseImageGenerationCallPartialImage(_v)
            }
            ResponseStreamEvent::ResponseMcpCallArgumentsDelta(_v) => {
                Self::ResponseMcpCallArgumentsDelta(_v)
            }
            ResponseStreamEvent::ResponseMcpCallArgumentsDone(_v) => {
                Self::ResponseMcpCallArgumentsDone(_v)
            }
            ResponseStreamEvent::ResponseMcpCallCompleted(_v) => Self::ResponseMcpCallCompleted(_v),
            ResponseStreamEvent::ResponseMcpCallFailed(_v) => Self::ResponseMcpCallFailed(_v),
            ResponseStreamEvent::ResponseMcpCallInProgress(_v) => {
                Self::ResponseMcpCallInProgress(_v)
            }
            ResponseStreamEvent::ResponseMcpListToolsCompleted(_v) => {
                Self::ResponseMcpListToolsCompleted(_v)
            }
            ResponseStreamEvent::ResponseMcpListToolsFailed(_v) => {
                Self::ResponseMcpListToolsFailed(_v)
            }
            ResponseStreamEvent::ResponseMcpListToolsInProgress(_v) => {
                Self::ResponseMcpListToolsInProgress(_v)
            }
            ResponseStreamEvent::ResponseOutputTextAnnotationAdded(_v) => {
                Self::ResponseOutputTextAnnotationAdded(_v)
            }
            ResponseStreamEvent::ResponseQueued(_v) => Self::ResponseQueued(_v),
            ResponseStreamEvent::ResponseReasoningDelta(_v) => Self::ResponseReasoningDelta(_v),
            ResponseStreamEvent::ResponseReasoningDone(_v) => Self::ResponseReasoningDone(_v),
            ResponseStreamEvent::ResponseReasoningSummaryDelta(_v) => {
                Self::ResponseReasoningSummaryDelta(_v)
            }
            ResponseStreamEvent::ResponseReasoningSummaryDone(_v) => {
                Self::ResponseReasoningSummaryDone(_v)
            }
        })
    }
}
impl serde::Serialize for ResponseStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ResponseStreamEvent<'a> {
            ResponseAudioDelta(#[allow(dead_code)] &'a ResponseAudioDeltaEvent),
            ResponseAudioDone(#[allow(dead_code)] &'a ResponseAudioDoneEvent),
            ResponseAudioTranscriptDelta(#[allow(dead_code)] &'a ResponseAudioTranscriptDeltaEvent),
            ResponseAudioTranscriptDone(#[allow(dead_code)] &'a ResponseAudioTranscriptDoneEvent),
            ResponseCodeInterpreterCallCodeDelta(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallCodeDeltaEvent,
            ),
            ResponseCodeInterpreterCallCodeDone(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallCodeDoneEvent,
            ),
            ResponseCodeInterpreterCallCompleted(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallCompletedEvent,
            ),
            ResponseCodeInterpreterCallInProgress(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallInProgressEvent,
            ),
            ResponseCodeInterpreterCallInterpreting(
                #[allow(dead_code)] &'a ResponseCodeInterpreterCallInterpretingEvent,
            ),
            ResponseCompleted(#[allow(dead_code)] &'a ResponseCompletedEvent),
            ResponseContentPartAdded(#[allow(dead_code)] &'a ResponseContentPartAddedEvent),
            ResponseContentPartDone(#[allow(dead_code)] &'a ResponseContentPartDoneEvent),
            ResponseCreated(#[allow(dead_code)] &'a ResponseCreatedEvent),
            Error(#[allow(dead_code)] &'a ResponseErrorEvent),
            ResponseFileSearchCallCompleted(
                #[allow(dead_code)] &'a ResponseFileSearchCallCompletedEvent,
            ),
            ResponseFileSearchCallInProgress(
                #[allow(dead_code)] &'a ResponseFileSearchCallInProgressEvent,
            ),
            ResponseFileSearchCallSearching(
                #[allow(dead_code)] &'a ResponseFileSearchCallSearchingEvent,
            ),
            ResponseFunctionCallArgumentsDelta(
                #[allow(dead_code)] &'a ResponseFunctionCallArgumentsDeltaEvent,
            ),
            ResponseFunctionCallArgumentsDone(
                #[allow(dead_code)] &'a ResponseFunctionCallArgumentsDoneEvent,
            ),
            ResponseInProgress(#[allow(dead_code)] &'a ResponseInProgressEvent),
            ResponseFailed(#[allow(dead_code)] &'a ResponseFailedEvent),
            ResponseIncomplete(#[allow(dead_code)] &'a ResponseIncompleteEvent),
            ResponseOutputItemAdded(#[allow(dead_code)] &'a ResponseOutputItemAddedEvent),
            ResponseOutputItemDone(#[allow(dead_code)] &'a ResponseOutputItemDoneEvent),
            ResponseReasoningSummaryPartAdded(
                #[allow(dead_code)] &'a ResponseReasoningSummaryPartAddedEvent,
            ),
            ResponseReasoningSummaryPartDone(
                #[allow(dead_code)] &'a ResponseReasoningSummaryPartDoneEvent,
            ),
            ResponseReasoningSummaryTextDelta(
                #[allow(dead_code)] &'a ResponseReasoningSummaryTextDeltaEvent,
            ),
            ResponseReasoningSummaryTextDone(
                #[allow(dead_code)] &'a ResponseReasoningSummaryTextDoneEvent,
            ),
            ResponseRefusalDelta(#[allow(dead_code)] &'a ResponseRefusalDeltaEvent),
            ResponseRefusalDone(#[allow(dead_code)] &'a ResponseRefusalDoneEvent),
            ResponseOutputTextDelta(#[allow(dead_code)] &'a ResponseTextDeltaEvent),
            ResponseOutputTextDone(#[allow(dead_code)] &'a ResponseTextDoneEvent),
            ResponseWebSearchCallCompleted(
                #[allow(dead_code)] &'a ResponseWebSearchCallCompletedEvent,
            ),
            ResponseWebSearchCallInProgress(
                #[allow(dead_code)] &'a ResponseWebSearchCallInProgressEvent,
            ),
            ResponseWebSearchCallSearching(
                #[allow(dead_code)] &'a ResponseWebSearchCallSearchingEvent,
            ),
            ResponseImageGenerationCallCompleted(
                #[allow(dead_code)] &'a ResponseImageGenCallCompletedEvent,
            ),
            ResponseImageGenerationCallGenerating(
                #[allow(dead_code)] &'a ResponseImageGenCallGeneratingEvent,
            ),
            ResponseImageGenerationCallInProgress(
                #[allow(dead_code)] &'a ResponseImageGenCallInProgressEvent,
            ),
            ResponseImageGenerationCallPartialImage(
                #[allow(dead_code)] &'a ResponseImageGenCallPartialImageEvent,
            ),
            ResponseMcpCallArgumentsDelta(
                #[allow(dead_code)] &'a ResponseMcpCallArgumentsDeltaEvent,
            ),
            ResponseMcpCallArgumentsDone(#[allow(dead_code)] &'a ResponseMcpCallArgumentsDoneEvent),
            ResponseMcpCallCompleted(#[allow(dead_code)] &'a ResponseMcpCallCompletedEvent),
            ResponseMcpCallFailed(#[allow(dead_code)] &'a ResponseMcpCallFailedEvent),
            ResponseMcpCallInProgress(#[allow(dead_code)] &'a ResponseMcpCallInProgressEvent),
            ResponseMcpListToolsCompleted(
                #[allow(dead_code)] &'a ResponseMcpListToolsCompletedEvent,
            ),
            ResponseMcpListToolsFailed(#[allow(dead_code)] &'a ResponseMcpListToolsFailedEvent),
            ResponseMcpListToolsInProgress(
                #[allow(dead_code)] &'a ResponseMcpListToolsInProgressEvent,
            ),
            ResponseOutputTextAnnotationAdded(
                #[allow(dead_code)] &'a ResponseOutputTextAnnotationAddedEvent,
            ),
            ResponseQueued(#[allow(dead_code)] &'a ResponseQueuedEvent),
            ResponseReasoningDelta(#[allow(dead_code)] &'a ResponseReasoningDeltaEvent),
            ResponseReasoningDone(#[allow(dead_code)] &'a ResponseReasoningDoneEvent),
            ResponseReasoningSummaryDelta(
                #[allow(dead_code)] &'a ResponseReasoningSummaryDeltaEvent,
            ),
            ResponseReasoningSummaryDone(#[allow(dead_code)] &'a ResponseReasoningSummaryDoneEvent),
        }
        match self {
            Self::ResponseAudioDelta(_v) => {
                ResponseStreamEvent::ResponseAudioDelta(_v).serialize(serializer)
            }
            Self::ResponseAudioDone(_v) => {
                ResponseStreamEvent::ResponseAudioDone(_v).serialize(serializer)
            }
            Self::ResponseAudioTranscriptDelta(_v) => {
                ResponseStreamEvent::ResponseAudioTranscriptDelta(_v).serialize(serializer)
            }
            Self::ResponseAudioTranscriptDone(_v) => {
                ResponseStreamEvent::ResponseAudioTranscriptDone(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallCodeDelta(_v) => {
                ResponseStreamEvent::ResponseCodeInterpreterCallCodeDelta(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallCodeDone(_v) => {
                ResponseStreamEvent::ResponseCodeInterpreterCallCodeDone(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallCompleted(_v) => {
                ResponseStreamEvent::ResponseCodeInterpreterCallCompleted(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallInProgress(_v) => {
                ResponseStreamEvent::ResponseCodeInterpreterCallInProgress(_v).serialize(serializer)
            }
            Self::ResponseCodeInterpreterCallInterpreting(_v) => {
                ResponseStreamEvent::ResponseCodeInterpreterCallInterpreting(_v)
                    .serialize(serializer)
            }
            Self::ResponseCompleted(_v) => {
                ResponseStreamEvent::ResponseCompleted(_v).serialize(serializer)
            }
            Self::ResponseContentPartAdded(_v) => {
                ResponseStreamEvent::ResponseContentPartAdded(_v).serialize(serializer)
            }
            Self::ResponseContentPartDone(_v) => {
                ResponseStreamEvent::ResponseContentPartDone(_v).serialize(serializer)
            }
            Self::ResponseCreated(_v) => {
                ResponseStreamEvent::ResponseCreated(_v).serialize(serializer)
            }
            Self::Error(_v) => ResponseStreamEvent::Error(_v).serialize(serializer),
            Self::ResponseFileSearchCallCompleted(_v) => {
                ResponseStreamEvent::ResponseFileSearchCallCompleted(_v).serialize(serializer)
            }
            Self::ResponseFileSearchCallInProgress(_v) => {
                ResponseStreamEvent::ResponseFileSearchCallInProgress(_v).serialize(serializer)
            }
            Self::ResponseFileSearchCallSearching(_v) => {
                ResponseStreamEvent::ResponseFileSearchCallSearching(_v).serialize(serializer)
            }
            Self::ResponseFunctionCallArgumentsDelta(_v) => {
                ResponseStreamEvent::ResponseFunctionCallArgumentsDelta(_v).serialize(serializer)
            }
            Self::ResponseFunctionCallArgumentsDone(_v) => {
                ResponseStreamEvent::ResponseFunctionCallArgumentsDone(_v).serialize(serializer)
            }
            Self::ResponseInProgress(_v) => {
                ResponseStreamEvent::ResponseInProgress(_v).serialize(serializer)
            }
            Self::ResponseFailed(_v) => {
                ResponseStreamEvent::ResponseFailed(_v).serialize(serializer)
            }
            Self::ResponseIncomplete(_v) => {
                ResponseStreamEvent::ResponseIncomplete(_v).serialize(serializer)
            }
            Self::ResponseOutputItemAdded(_v) => {
                ResponseStreamEvent::ResponseOutputItemAdded(_v).serialize(serializer)
            }
            Self::ResponseOutputItemDone(_v) => {
                ResponseStreamEvent::ResponseOutputItemDone(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryPartAdded(_v) => {
                ResponseStreamEvent::ResponseReasoningSummaryPartAdded(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryPartDone(_v) => {
                ResponseStreamEvent::ResponseReasoningSummaryPartDone(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryTextDelta(_v) => {
                ResponseStreamEvent::ResponseReasoningSummaryTextDelta(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryTextDone(_v) => {
                ResponseStreamEvent::ResponseReasoningSummaryTextDone(_v).serialize(serializer)
            }
            Self::ResponseRefusalDelta(_v) => {
                ResponseStreamEvent::ResponseRefusalDelta(_v).serialize(serializer)
            }
            Self::ResponseRefusalDone(_v) => {
                ResponseStreamEvent::ResponseRefusalDone(_v).serialize(serializer)
            }
            Self::ResponseOutputTextDelta(_v) => {
                ResponseStreamEvent::ResponseOutputTextDelta(_v).serialize(serializer)
            }
            Self::ResponseOutputTextDone(_v) => {
                ResponseStreamEvent::ResponseOutputTextDone(_v).serialize(serializer)
            }
            Self::ResponseWebSearchCallCompleted(_v) => {
                ResponseStreamEvent::ResponseWebSearchCallCompleted(_v).serialize(serializer)
            }
            Self::ResponseWebSearchCallInProgress(_v) => {
                ResponseStreamEvent::ResponseWebSearchCallInProgress(_v).serialize(serializer)
            }
            Self::ResponseWebSearchCallSearching(_v) => {
                ResponseStreamEvent::ResponseWebSearchCallSearching(_v).serialize(serializer)
            }
            Self::ResponseImageGenerationCallCompleted(_v) => {
                ResponseStreamEvent::ResponseImageGenerationCallCompleted(_v).serialize(serializer)
            }
            Self::ResponseImageGenerationCallGenerating(_v) => {
                ResponseStreamEvent::ResponseImageGenerationCallGenerating(_v).serialize(serializer)
            }
            Self::ResponseImageGenerationCallInProgress(_v) => {
                ResponseStreamEvent::ResponseImageGenerationCallInProgress(_v).serialize(serializer)
            }
            Self::ResponseImageGenerationCallPartialImage(_v) => {
                ResponseStreamEvent::ResponseImageGenerationCallPartialImage(_v)
                    .serialize(serializer)
            }
            Self::ResponseMcpCallArgumentsDelta(_v) => {
                ResponseStreamEvent::ResponseMcpCallArgumentsDelta(_v).serialize(serializer)
            }
            Self::ResponseMcpCallArgumentsDone(_v) => {
                ResponseStreamEvent::ResponseMcpCallArgumentsDone(_v).serialize(serializer)
            }
            Self::ResponseMcpCallCompleted(_v) => {
                ResponseStreamEvent::ResponseMcpCallCompleted(_v).serialize(serializer)
            }
            Self::ResponseMcpCallFailed(_v) => {
                ResponseStreamEvent::ResponseMcpCallFailed(_v).serialize(serializer)
            }
            Self::ResponseMcpCallInProgress(_v) => {
                ResponseStreamEvent::ResponseMcpCallInProgress(_v).serialize(serializer)
            }
            Self::ResponseMcpListToolsCompleted(_v) => {
                ResponseStreamEvent::ResponseMcpListToolsCompleted(_v).serialize(serializer)
            }
            Self::ResponseMcpListToolsFailed(_v) => {
                ResponseStreamEvent::ResponseMcpListToolsFailed(_v).serialize(serializer)
            }
            Self::ResponseMcpListToolsInProgress(_v) => {
                ResponseStreamEvent::ResponseMcpListToolsInProgress(_v).serialize(serializer)
            }
            Self::ResponseOutputTextAnnotationAdded(_v) => {
                ResponseStreamEvent::ResponseOutputTextAnnotationAdded(_v).serialize(serializer)
            }
            Self::ResponseQueued(_v) => {
                ResponseStreamEvent::ResponseQueued(_v).serialize(serializer)
            }
            Self::ResponseReasoningDelta(_v) => {
                ResponseStreamEvent::ResponseReasoningDelta(_v).serialize(serializer)
            }
            Self::ResponseReasoningDone(_v) => {
                ResponseStreamEvent::ResponseReasoningDone(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryDelta(_v) => {
                ResponseStreamEvent::ResponseReasoningSummaryDelta(_v).serialize(serializer)
            }
            Self::ResponseReasoningSummaryDone(_v) => {
                ResponseStreamEvent::ResponseReasoningSummaryDone(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseStreamEvent {
    ResponseAudioDelta(ResponseAudioDeltaEvent),
    ResponseAudioDone(ResponseAudioDoneEvent),
    ResponseAudioTranscriptDelta(ResponseAudioTranscriptDeltaEvent),
    ResponseAudioTranscriptDone(ResponseAudioTranscriptDoneEvent),
    ResponseCodeInterpreterCallCodeDelta(ResponseCodeInterpreterCallCodeDeltaEvent),
    ResponseCodeInterpreterCallCodeDone(ResponseCodeInterpreterCallCodeDoneEvent),
    ResponseCodeInterpreterCallCompleted(ResponseCodeInterpreterCallCompletedEvent),
    ResponseCodeInterpreterCallInProgress(ResponseCodeInterpreterCallInProgressEvent),
    ResponseCodeInterpreterCallInterpreting(ResponseCodeInterpreterCallInterpretingEvent),
    ResponseCompleted(ResponseCompletedEvent),
    ResponseContentPartAdded(ResponseContentPartAddedEvent),
    ResponseContentPartDone(ResponseContentPartDoneEvent),
    ResponseCreated(ResponseCreatedEvent),
    Error(ResponseErrorEvent),
    ResponseFileSearchCallCompleted(ResponseFileSearchCallCompletedEvent),
    ResponseFileSearchCallInProgress(ResponseFileSearchCallInProgressEvent),
    ResponseFileSearchCallSearching(ResponseFileSearchCallSearchingEvent),
    ResponseFunctionCallArgumentsDelta(ResponseFunctionCallArgumentsDeltaEvent),
    ResponseFunctionCallArgumentsDone(ResponseFunctionCallArgumentsDoneEvent),
    ResponseInProgress(ResponseInProgressEvent),
    ResponseFailed(ResponseFailedEvent),
    ResponseIncomplete(ResponseIncompleteEvent),
    ResponseOutputItemAdded(ResponseOutputItemAddedEvent),
    ResponseOutputItemDone(ResponseOutputItemDoneEvent),
    ResponseReasoningSummaryPartAdded(ResponseReasoningSummaryPartAddedEvent),
    ResponseReasoningSummaryPartDone(ResponseReasoningSummaryPartDoneEvent),
    ResponseReasoningSummaryTextDelta(ResponseReasoningSummaryTextDeltaEvent),
    ResponseReasoningSummaryTextDone(ResponseReasoningSummaryTextDoneEvent),
    ResponseRefusalDelta(ResponseRefusalDeltaEvent),
    ResponseRefusalDone(ResponseRefusalDoneEvent),
    ResponseOutputTextDelta(ResponseTextDeltaEvent),
    ResponseOutputTextDone(ResponseTextDoneEvent),
    ResponseWebSearchCallCompleted(ResponseWebSearchCallCompletedEvent),
    ResponseWebSearchCallInProgress(ResponseWebSearchCallInProgressEvent),
    ResponseWebSearchCallSearching(ResponseWebSearchCallSearchingEvent),
    ResponseImageGenerationCallCompleted(ResponseImageGenCallCompletedEvent),
    ResponseImageGenerationCallGenerating(ResponseImageGenCallGeneratingEvent),
    ResponseImageGenerationCallInProgress(ResponseImageGenCallInProgressEvent),
    ResponseImageGenerationCallPartialImage(ResponseImageGenCallPartialImageEvent),
    ResponseMcpCallArgumentsDelta(ResponseMcpCallArgumentsDeltaEvent),
    ResponseMcpCallArgumentsDone(ResponseMcpCallArgumentsDoneEvent),
    ResponseMcpCallCompleted(ResponseMcpCallCompletedEvent),
    ResponseMcpCallFailed(ResponseMcpCallFailedEvent),
    ResponseMcpCallInProgress(ResponseMcpCallInProgressEvent),
    ResponseMcpListToolsCompleted(ResponseMcpListToolsCompletedEvent),
    ResponseMcpListToolsFailed(ResponseMcpListToolsFailedEvent),
    ResponseMcpListToolsInProgress(ResponseMcpListToolsInProgressEvent),
    ResponseOutputTextAnnotationAdded(ResponseOutputTextAnnotationAddedEvent),
    ResponseQueued(ResponseQueuedEvent),
    ResponseReasoningDelta(ResponseReasoningDeltaEvent),
    ResponseReasoningDone(ResponseReasoningDoneEvent),
    ResponseReasoningSummaryDelta(ResponseReasoningSummaryDeltaEvent),
    ResponseReasoningSummaryDone(ResponseReasoningSummaryDoneEvent),
}
impl<'de> serde::Deserialize<'de> for ResponseTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextDeltaEventType {
            #[default]
            #[serde(rename = "response.output_text.delta")]
            ResponseOutputTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseTextDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseTextDeltaEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseTextDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            ..
        } = ResponseTextDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextDeltaEventType {
            #[default]
            #[serde(rename = "response.output_text.delta")]
            ResponseOutputTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseTextDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseTextDeltaEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        } = self;
        ResponseTextDeltaEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is an additional text delta."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseTextDeltaEvent {
    #[doc = "The ID of the output item that the text delta was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the text delta was added to.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the text delta was added to.\n"]
    pub content_index: u64,
    #[doc = "The text delta that was added.\n"]
    pub delta: String,
    #[doc = "The sequence number for this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.output_text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextDoneEventType {
            #[default]
            #[serde(rename = "response.output_text.done")]
            ResponseOutputTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseTextDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseTextDoneEventType,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "content_index")]
            #[allow(dead_code)]
            content_index: u64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseTextDoneEvent {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
            ..
        } = ResponseTextDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.output_text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseTextDoneEventType {
            #[default]
            #[serde(rename = "response.output_text.done")]
            ResponseOutputTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseTextDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseTextDoneEventType,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "content_index")]
            content_index: &'a u64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        } = self;
        ResponseTextDoneEvent {
            type_: &Default::default(),
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when text content is finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseTextDoneEvent {
    #[doc = "The ID of the output item that the text content is finalized.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the text content is finalized.\n"]
    pub output_index: u64,
    #[doc = "The index of the content part that the text content is finalized.\n"]
    pub content_index: u64,
    #[doc = "The text content that is finalized.\n"]
    pub text: String,
    #[doc = "The sequence number for this event."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseUsageInputTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseUsageInputTokensDetails {
            #[serde(rename = "cached_tokens")]
            #[allow(dead_code)]
            cached_tokens: u64,
        }
        let ResponseUsageInputTokensDetails { cached_tokens, .. } =
            ResponseUsageInputTokensDetails::deserialize(deserializer)?;
        Ok(Self { cached_tokens })
    }
}
impl serde::Serialize for ResponseUsageInputTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseUsageInputTokensDetails<'a> {
            #[serde(rename = "cached_tokens")]
            cached_tokens: &'a u64,
        }
        let Self { cached_tokens } = self;
        ResponseUsageInputTokensDetails { cached_tokens }.serialize(serializer)
    }
}
#[doc = "A detailed breakdown of the input tokens."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseUsageInputTokensDetails {
    #[doc = "The number of tokens that were retrieved from the cache. \n[More on prompt caching](https://platform.openai.com/docs/guides/prompt-caching).\n"]
    pub cached_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseUsageOutputTokensDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseUsageOutputTokensDetails {
            #[serde(rename = "reasoning_tokens")]
            #[allow(dead_code)]
            reasoning_tokens: u64,
        }
        let ResponseUsageOutputTokensDetails {
            reasoning_tokens, ..
        } = ResponseUsageOutputTokensDetails::deserialize(deserializer)?;
        Ok(Self { reasoning_tokens })
    }
}
impl serde::Serialize for ResponseUsageOutputTokensDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseUsageOutputTokensDetails<'a> {
            #[serde(rename = "reasoning_tokens")]
            reasoning_tokens: &'a u64,
        }
        let Self { reasoning_tokens } = self;
        ResponseUsageOutputTokensDetails { reasoning_tokens }.serialize(serializer)
    }
}
#[doc = "A detailed breakdown of the output tokens."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseUsageOutputTokensDetails {
    #[doc = "The number of reasoning tokens."]
    pub reasoning_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseUsage {
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "input_tokens_details")]
            #[allow(dead_code)]
            input_tokens_details: ResponseUsageInputTokensDetails,
            #[serde(rename = "output_tokens")]
            #[allow(dead_code)]
            output_tokens: u64,
            #[serde(rename = "output_tokens_details")]
            #[allow(dead_code)]
            output_tokens_details: ResponseUsageOutputTokensDetails,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
        }
        let ResponseUsage {
            input_tokens,
            input_tokens_details,
            output_tokens,
            output_tokens_details,
            total_tokens,
            ..
        } = ResponseUsage::deserialize(deserializer)?;
        Ok(Self {
            input_tokens,
            input_tokens_details,
            output_tokens,
            output_tokens_details,
            total_tokens,
        })
    }
}
impl serde::Serialize for ResponseUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseUsage<'a> {
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "input_tokens_details")]
            input_tokens_details: &'a ResponseUsageInputTokensDetails,
            #[serde(rename = "output_tokens")]
            output_tokens: &'a u64,
            #[serde(rename = "output_tokens_details")]
            output_tokens_details: &'a ResponseUsageOutputTokensDetails,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
        }
        let Self {
            input_tokens,
            input_tokens_details,
            output_tokens,
            output_tokens_details,
            total_tokens,
        } = self;
        ResponseUsage {
            input_tokens,
            input_tokens_details,
            output_tokens,
            output_tokens_details,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents token usage details including input tokens, output tokens,\na breakdown of output tokens, and the total tokens used.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ResponseUsage {
    #[doc = "The number of input tokens."]
    pub input_tokens: u64,
    #[doc = "A detailed breakdown of the input tokens."]
    pub input_tokens_details: ResponseUsageInputTokensDetails,
    #[doc = "The number of output tokens."]
    pub output_tokens: u64,
    #[doc = "A detailed breakdown of the output tokens."]
    pub output_tokens_details: ResponseUsageOutputTokensDetails,
    #[doc = "The total number of tokens used."]
    pub total_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.web_search_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallCompletedEventType {
            #[default]
            #[serde(rename = "response.web_search_call.completed")]
            ResponseWebSearchCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseWebSearchCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseWebSearchCallCompletedEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseWebSearchCallCompletedEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseWebSearchCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.web_search_call.completed`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallCompletedEventType {
            #[default]
            #[serde(rename = "response.web_search_call.completed")]
            ResponseWebSearchCallCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseWebSearchCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseWebSearchCallCompletedEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseWebSearchCallCompletedEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a web search call is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallCompletedEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: u64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
    #[doc = "The sequence number of the web search call being processed."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.web_search_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallInProgressEventType {
            #[default]
            #[serde(rename = "response.web_search_call.in_progress")]
            ResponseWebSearchCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseWebSearchCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseWebSearchCallInProgressEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseWebSearchCallInProgressEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseWebSearchCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.web_search_call.in_progress`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallInProgressEventType {
            #[default]
            #[serde(rename = "response.web_search_call.in_progress")]
            ResponseWebSearchCallInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseWebSearchCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseWebSearchCallInProgressEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseWebSearchCallInProgressEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a web search call is initiated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallInProgressEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: u64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
    #[doc = "The sequence number of the web search call being processed."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallSearchingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `response.web_search_call.searching`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallSearchingEventType {
            #[default]
            #[serde(rename = "response.web_search_call.searching")]
            ResponseWebSearchCallSearching,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseWebSearchCallSearchingEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ResponseWebSearchCallSearchingEventType,
            #[serde(rename = "output_index")]
            #[allow(dead_code)]
            output_index: u64,
            #[serde(rename = "item_id")]
            #[allow(dead_code)]
            item_id: String,
            #[serde(rename = "sequence_number")]
            #[allow(dead_code)]
            sequence_number: u64,
        }
        let ResponseWebSearchCallSearchingEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseWebSearchCallSearchingEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallSearchingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `response.web_search_call.searching`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ResponseWebSearchCallSearchingEventType {
            #[default]
            #[serde(rename = "response.web_search_call.searching")]
            ResponseWebSearchCallSearching,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseWebSearchCallSearchingEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a ResponseWebSearchCallSearchingEventType,
            #[serde(rename = "output_index")]
            output_index: &'a u64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a u64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseWebSearchCallSearchingEvent {
            type_: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when a web search call is executing."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallSearchingEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: u64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
    #[doc = "The sequence number of the web search call being processed."]
    pub sequence_number: u64,
}
impl<'de> serde::Deserialize<'de> for RunCompletionUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunCompletionUsage {
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
        }
        let RunCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            ..
        } = RunCompletionUsage::deserialize(deserializer)?;
        Ok(Self {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        })
    }
}
impl serde::Serialize for RunCompletionUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunCompletionUsage<'a> {
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
        }
        let Self {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        } = self;
        RunCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.)."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct RunCompletionUsage {
    #[doc = "Number of completion tokens used over the course of the run."]
    pub completion_tokens: u64,
    #[doc = "Number of prompt tokens used over the course of the run."]
    pub prompt_tokens: u64,
    #[doc = "Total number of tokens used (prompt + completion)."]
    pub total_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for RunGraderRequestGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunGraderRequestGrader {
            StringCheck(#[allow(dead_code)] GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] GraderTextSimilarity),
            Python(#[allow(dead_code)] GraderPython),
            ScoreModel(#[allow(dead_code)] GraderScoreModel),
            Multi(#[allow(dead_code)] GraderMulti),
        }
        Ok(match RunGraderRequestGrader::deserialize(deserializer)? {
            RunGraderRequestGrader::StringCheck(_v) => Self::StringCheck(_v),
            RunGraderRequestGrader::TextSimilarity(_v) => Self::TextSimilarity(_v),
            RunGraderRequestGrader::Python(_v) => Self::Python(_v),
            RunGraderRequestGrader::ScoreModel(_v) => Self::ScoreModel(_v),
            RunGraderRequestGrader::Multi(_v) => Self::Multi(_v),
        })
    }
}
impl serde::Serialize for RunGraderRequestGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunGraderRequestGrader<'a> {
            StringCheck(#[allow(dead_code)] &'a GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] &'a GraderTextSimilarity),
            Python(#[allow(dead_code)] &'a GraderPython),
            ScoreModel(#[allow(dead_code)] &'a GraderScoreModel),
            Multi(#[allow(dead_code)] &'a GraderMulti),
        }
        match self {
            Self::StringCheck(_v) => RunGraderRequestGrader::StringCheck(_v).serialize(serializer),
            Self::TextSimilarity(_v) => {
                RunGraderRequestGrader::TextSimilarity(_v).serialize(serializer)
            }
            Self::Python(_v) => RunGraderRequestGrader::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => RunGraderRequestGrader::ScoreModel(_v).serialize(serializer),
            Self::Multi(_v) => RunGraderRequestGrader::Multi(_v).serialize(serializer),
        }
    }
}
#[doc = "The grader used for the fine-tuning job."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunGraderRequestGrader {
    StringCheck(GraderStringCheck),
    TextSimilarity(GraderTextSimilarity),
    Python(GraderPython),
    ScoreModel(GraderScoreModel),
    Multi(GraderMulti),
}
impl<'de> serde::Deserialize<'de> for RunGraderRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunGraderRequest {
            #[serde(rename = "grader")]
            #[allow(dead_code)]
            grader: RunGraderRequestGrader,
            #[serde(rename = "item")]
            #[allow(dead_code)]
            item: Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "model_sample")]
            #[allow(dead_code)]
            model_sample: String,
        }
        let RunGraderRequest {
            grader,
            item,
            model_sample,
            ..
        } = RunGraderRequest::deserialize(deserializer)?;
        Ok(Self {
            grader,
            item,
            model_sample,
        })
    }
}
impl serde::Serialize for RunGraderRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunGraderRequest<'a> {
            #[serde(rename = "grader")]
            grader: &'a RunGraderRequestGrader,
            #[serde(rename = "item")]
            #[serde(skip_serializing_if = "Option::is_none")]
            item: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "model_sample")]
            model_sample: &'a String,
        }
        let Self {
            grader,
            item,
            model_sample,
        } = self;
        RunGraderRequest {
            grader,
            item,
            model_sample,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunGraderRequest {
    #[doc = "The grader used for the fine-tuning job."]
    pub grader: RunGraderRequestGrader,
    #[doc = "The dataset item provided to the grader. This will be used to populate \nthe `item` namespace. See [the guide](https://platform.openai.com/docs/guides/graders) for more details. \n"]
    #[builder(default)]
    pub item: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[doc = "The model sample to be evaluated. This value will be used to populate \nthe `sample` namespace. See [the guide](https://platform.openai.com/docs/guides/graders) for more details.\nThe `output_json` variable will be populated if the model sample is a \nvalid JSON string.\n \n"]
    pub model_sample: String,
}
impl<'de> serde::Deserialize<'de> for RunGraderResponseMetadataErrors {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunGraderResponseMetadataErrors {
            #[serde(rename = "formula_parse_error")]
            #[allow(dead_code)]
            formula_parse_error: bool,
            #[serde(rename = "sample_parse_error")]
            #[allow(dead_code)]
            sample_parse_error: bool,
            #[serde(rename = "truncated_observation_error")]
            #[allow(dead_code)]
            truncated_observation_error: bool,
            #[serde(rename = "unresponsive_reward_error")]
            #[allow(dead_code)]
            unresponsive_reward_error: bool,
            #[serde(rename = "invalid_variable_error")]
            #[allow(dead_code)]
            invalid_variable_error: bool,
            #[serde(rename = "other_error")]
            #[allow(dead_code)]
            other_error: bool,
            #[serde(rename = "python_grader_server_error")]
            #[allow(dead_code)]
            python_grader_server_error: bool,
            #[serde(rename = "python_grader_server_error_type")]
            #[allow(dead_code)]
            python_grader_server_error_type: Option<String>,
            #[serde(rename = "python_grader_runtime_error")]
            #[allow(dead_code)]
            python_grader_runtime_error: bool,
            #[serde(rename = "python_grader_runtime_error_details")]
            #[allow(dead_code)]
            python_grader_runtime_error_details: Option<String>,
            #[serde(rename = "model_grader_server_error")]
            #[allow(dead_code)]
            model_grader_server_error: bool,
            #[serde(rename = "model_grader_refusal_error")]
            #[allow(dead_code)]
            model_grader_refusal_error: bool,
            #[serde(rename = "model_grader_parse_error")]
            #[allow(dead_code)]
            model_grader_parse_error: bool,
            #[serde(rename = "model_grader_server_error_details")]
            #[allow(dead_code)]
            model_grader_server_error_details: Option<String>,
        }
        let RunGraderResponseMetadataErrors {
            formula_parse_error,
            sample_parse_error,
            truncated_observation_error,
            unresponsive_reward_error,
            invalid_variable_error,
            other_error,
            python_grader_server_error,
            python_grader_server_error_type,
            python_grader_runtime_error,
            python_grader_runtime_error_details,
            model_grader_server_error,
            model_grader_refusal_error,
            model_grader_parse_error,
            model_grader_server_error_details,
            ..
        } = RunGraderResponseMetadataErrors::deserialize(deserializer)?;
        Ok(Self {
            formula_parse_error,
            sample_parse_error,
            truncated_observation_error,
            unresponsive_reward_error,
            invalid_variable_error,
            other_error,
            python_grader_server_error,
            python_grader_server_error_type,
            python_grader_runtime_error,
            python_grader_runtime_error_details,
            model_grader_server_error,
            model_grader_refusal_error,
            model_grader_parse_error,
            model_grader_server_error_details,
        })
    }
}
impl serde::Serialize for RunGraderResponseMetadataErrors {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunGraderResponseMetadataErrors<'a> {
            #[serde(rename = "formula_parse_error")]
            formula_parse_error: &'a bool,
            #[serde(rename = "sample_parse_error")]
            sample_parse_error: &'a bool,
            #[serde(rename = "truncated_observation_error")]
            truncated_observation_error: &'a bool,
            #[serde(rename = "unresponsive_reward_error")]
            unresponsive_reward_error: &'a bool,
            #[serde(rename = "invalid_variable_error")]
            invalid_variable_error: &'a bool,
            #[serde(rename = "other_error")]
            other_error: &'a bool,
            #[serde(rename = "python_grader_server_error")]
            python_grader_server_error: &'a bool,
            #[serde(rename = "python_grader_server_error_type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            python_grader_server_error_type: &'a Option<String>,
            #[serde(rename = "python_grader_runtime_error")]
            python_grader_runtime_error: &'a bool,
            #[serde(rename = "python_grader_runtime_error_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            python_grader_runtime_error_details: &'a Option<String>,
            #[serde(rename = "model_grader_server_error")]
            model_grader_server_error: &'a bool,
            #[serde(rename = "model_grader_refusal_error")]
            model_grader_refusal_error: &'a bool,
            #[serde(rename = "model_grader_parse_error")]
            model_grader_parse_error: &'a bool,
            #[serde(rename = "model_grader_server_error_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model_grader_server_error_details: &'a Option<String>,
        }
        let Self {
            formula_parse_error,
            sample_parse_error,
            truncated_observation_error,
            unresponsive_reward_error,
            invalid_variable_error,
            other_error,
            python_grader_server_error,
            python_grader_server_error_type,
            python_grader_runtime_error,
            python_grader_runtime_error_details,
            model_grader_server_error,
            model_grader_refusal_error,
            model_grader_parse_error,
            model_grader_server_error_details,
        } = self;
        RunGraderResponseMetadataErrors {
            formula_parse_error,
            sample_parse_error,
            truncated_observation_error,
            unresponsive_reward_error,
            invalid_variable_error,
            other_error,
            python_grader_server_error,
            python_grader_server_error_type,
            python_grader_runtime_error,
            python_grader_runtime_error_details,
            model_grader_server_error,
            model_grader_refusal_error,
            model_grader_parse_error,
            model_grader_server_error_details,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunGraderResponseMetadataErrors {
    pub formula_parse_error: bool,
    pub sample_parse_error: bool,
    pub truncated_observation_error: bool,
    pub unresponsive_reward_error: bool,
    pub invalid_variable_error: bool,
    pub other_error: bool,
    pub python_grader_server_error: bool,
    #[builder(default)]
    pub python_grader_server_error_type: Option<String>,
    pub python_grader_runtime_error: bool,
    #[builder(default)]
    pub python_grader_runtime_error_details: Option<String>,
    pub model_grader_server_error: bool,
    pub model_grader_refusal_error: bool,
    pub model_grader_parse_error: bool,
    #[builder(default)]
    pub model_grader_server_error_details: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunGraderResponseMetadata {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunGraderResponseMetadata {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: String,
            #[serde(rename = "errors")]
            #[allow(dead_code)]
            errors: RunGraderResponseMetadataErrors,
            #[serde(rename = "execution_time")]
            #[allow(dead_code)]
            execution_time: f64,
            #[serde(rename = "scores")]
            #[allow(dead_code)]
            scores: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "token_usage")]
            #[allow(dead_code)]
            token_usage: Option<u64>,
            #[serde(rename = "sampled_model_name")]
            #[allow(dead_code)]
            sampled_model_name: Option<String>,
        }
        let RunGraderResponseMetadata {
            name,
            type_,
            errors,
            execution_time,
            scores,
            token_usage,
            sampled_model_name,
            ..
        } = RunGraderResponseMetadata::deserialize(deserializer)?;
        Ok(Self {
            name,
            type_,
            errors,
            execution_time,
            scores,
            token_usage,
            sampled_model_name,
        })
    }
}
impl serde::Serialize for RunGraderResponseMetadata {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunGraderResponseMetadata<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "type")]
            type_: &'a String,
            #[serde(rename = "errors")]
            errors: &'a RunGraderResponseMetadataErrors,
            #[serde(rename = "execution_time")]
            execution_time: &'a f64,
            #[serde(rename = "scores")]
            scores: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "token_usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token_usage: &'a Option<u64>,
            #[serde(rename = "sampled_model_name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampled_model_name: &'a Option<String>,
        }
        let Self {
            name,
            type_,
            errors,
            execution_time,
            scores,
            token_usage,
            sampled_model_name,
        } = self;
        RunGraderResponseMetadata {
            name,
            type_,
            errors,
            execution_time,
            scores,
            token_usage,
            sampled_model_name,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunGraderResponseMetadata {
    pub name: String,
    pub type_: String,
    pub errors: RunGraderResponseMetadataErrors,
    pub execution_time: f64,
    pub scores: std::collections::HashMap<String, serde_json::Value>,
    #[builder(default)]
    pub token_usage: Option<u64>,
    #[builder(default)]
    pub sampled_model_name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunGraderResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunGraderResponse {
            #[serde(rename = "reward")]
            #[allow(dead_code)]
            reward: f64,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: RunGraderResponseMetadata,
            #[serde(rename = "sub_rewards")]
            #[allow(dead_code)]
            sub_rewards: std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "model_grader_token_usage_per_model")]
            #[allow(dead_code)]
            model_grader_token_usage_per_model:
                std::collections::HashMap<String, serde_json::Value>,
        }
        let RunGraderResponse {
            reward,
            metadata,
            sub_rewards,
            model_grader_token_usage_per_model,
            ..
        } = RunGraderResponse::deserialize(deserializer)?;
        Ok(Self {
            reward,
            metadata,
            sub_rewards,
            model_grader_token_usage_per_model,
        })
    }
}
impl serde::Serialize for RunGraderResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunGraderResponse<'a> {
            #[serde(rename = "reward")]
            reward: &'a f64,
            #[serde(rename = "metadata")]
            metadata: &'a RunGraderResponseMetadata,
            #[serde(rename = "sub_rewards")]
            sub_rewards: &'a std::collections::HashMap<String, serde_json::Value>,
            #[serde(rename = "model_grader_token_usage_per_model")]
            model_grader_token_usage_per_model:
                &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let Self {
            reward,
            metadata,
            sub_rewards,
            model_grader_token_usage_per_model,
        } = self;
        RunGraderResponse {
            reward,
            metadata,
            sub_rewards,
            model_grader_token_usage_per_model,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunGraderResponse {
    pub reward: f64,
    pub metadata: RunGraderResponseMetadata,
    pub sub_rewards: std::collections::HashMap<String, serde_json::Value>,
    pub model_grader_token_usage_per_model: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for RunObjectRequiredActionSubmitToolOutputs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunObjectRequiredActionSubmitToolOutputs {
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Vec<RunToolCallObject>,
        }
        let RunObjectRequiredActionSubmitToolOutputs { tool_calls, .. } =
            RunObjectRequiredActionSubmitToolOutputs::deserialize(deserializer)?;
        Ok(Self { tool_calls })
    }
}
impl serde::Serialize for RunObjectRequiredActionSubmitToolOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunObjectRequiredActionSubmitToolOutputs<'a> {
            #[serde(rename = "tool_calls")]
            tool_calls: &'a Vec<RunToolCallObject>,
        }
        let Self { tool_calls } = self;
        RunObjectRequiredActionSubmitToolOutputs { tool_calls }.serialize(serializer)
    }
}
#[doc = "Details on the tool outputs needed for this run to continue."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObjectRequiredActionSubmitToolOutputs {
    #[doc = "A list of the relevant tool calls."]
    pub tool_calls: Vec<RunToolCallObject>,
}
impl<'de> serde::Deserialize<'de> for RunObjectRequiredAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "For now, this is always `submit_tool_outputs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectRequiredActionType {
            #[default]
            #[serde(rename = "submit_tool_outputs")]
            SubmitToolOutputs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunObjectRequiredAction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunObjectRequiredActionType,
            #[serde(rename = "submit_tool_outputs")]
            #[allow(dead_code)]
            submit_tool_outputs: RunObjectRequiredActionSubmitToolOutputs,
        }
        let RunObjectRequiredAction {
            submit_tool_outputs,
            ..
        } = RunObjectRequiredAction::deserialize(deserializer)?;
        Ok(Self {
            submit_tool_outputs,
        })
    }
}
impl serde::Serialize for RunObjectRequiredAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "For now, this is always `submit_tool_outputs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectRequiredActionType {
            #[default]
            #[serde(rename = "submit_tool_outputs")]
            SubmitToolOutputs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunObjectRequiredAction<'a> {
            #[serde(rename = "type")]
            type_: &'a RunObjectRequiredActionType,
            #[serde(rename = "submit_tool_outputs")]
            submit_tool_outputs: &'a RunObjectRequiredActionSubmitToolOutputs,
        }
        let Self {
            submit_tool_outputs,
        } = self;
        RunObjectRequiredAction {
            type_: &Default::default(),
            submit_tool_outputs,
        }
        .serialize(serializer)
    }
}
#[doc = "Details on the action required to continue the run. Will be `null` if no action is required."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObjectRequiredAction {
    #[doc = "Details on the tool outputs needed for this run to continue."]
    pub submit_tool_outputs: RunObjectRequiredActionSubmitToolOutputs,
}
impl<'de> serde::Deserialize<'de> for RunObjectLastErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeInvalidPrompt {
            #[default]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunObjectLastErrorCode {
            ServerError(#[allow(dead_code)] RunObjectLastErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] RunObjectLastErrorCodeRateLimitExceeded),
            InvalidPrompt(#[allow(dead_code)] RunObjectLastErrorCodeInvalidPrompt),
        }
        Ok(match RunObjectLastErrorCode::deserialize(deserializer)? {
            RunObjectLastErrorCode::ServerError(_) => Self::ServerError,
            RunObjectLastErrorCode::RateLimitExceeded(_) => Self::RateLimitExceeded,
            RunObjectLastErrorCode::InvalidPrompt(_) => Self::InvalidPrompt,
        })
    }
}
impl serde::Serialize for RunObjectLastErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectLastErrorCodeInvalidPrompt {
            #[default]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunObjectLastErrorCode<'a> {
            ServerError(#[allow(dead_code)] &'a RunObjectLastErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] &'a RunObjectLastErrorCodeRateLimitExceeded),
            InvalidPrompt(#[allow(dead_code)] &'a RunObjectLastErrorCodeInvalidPrompt),
        }
        match self {
            Self::ServerError => {
                RunObjectLastErrorCode::ServerError(&Default::default()).serialize(serializer)
            }
            Self::RateLimitExceeded => {
                RunObjectLastErrorCode::RateLimitExceeded(&Default::default()).serialize(serializer)
            }
            Self::InvalidPrompt => {
                RunObjectLastErrorCode::InvalidPrompt(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunObjectLastErrorCode {
    #[doc = "server_error"]
    ServerError,
    #[doc = "rate_limit_exceeded"]
    RateLimitExceeded,
    #[doc = "invalid_prompt"]
    InvalidPrompt,
}
impl<'de> serde::Deserialize<'de> for RunObjectLastError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunObjectLastError {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: RunObjectLastErrorCode,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let RunObjectLastError { code, message, .. } =
            RunObjectLastError::deserialize(deserializer)?;
        Ok(Self { code, message })
    }
}
impl serde::Serialize for RunObjectLastError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunObjectLastError<'a> {
            #[serde(rename = "code")]
            code: &'a RunObjectLastErrorCode,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let Self { code, message } = self;
        RunObjectLastError { code, message }.serialize(serializer)
    }
}
#[doc = "The last error associated with this run. Will be `null` if there are no errors."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObjectLastError {
    #[doc = "One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`."]
    pub code: RunObjectLastErrorCode,
    #[doc = "A human-readable description of the error."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for RunObjectIncompleteDetailsReason {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectIncompleteDetailsReasonMaxCompletionTokens {
            #[default]
            #[serde(rename = "max_completion_tokens")]
            MaxCompletionTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectIncompleteDetailsReasonMaxPromptTokens {
            #[default]
            #[serde(rename = "max_prompt_tokens")]
            MaxPromptTokens,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunObjectIncompleteDetailsReason {
            MaxCompletionTokens(
                #[allow(dead_code)] RunObjectIncompleteDetailsReasonMaxCompletionTokens,
            ),
            MaxPromptTokens(#[allow(dead_code)] RunObjectIncompleteDetailsReasonMaxPromptTokens),
        }
        Ok(
            match RunObjectIncompleteDetailsReason::deserialize(deserializer)? {
                RunObjectIncompleteDetailsReason::MaxCompletionTokens(_) => {
                    Self::MaxCompletionTokens
                }
                RunObjectIncompleteDetailsReason::MaxPromptTokens(_) => Self::MaxPromptTokens,
            },
        )
    }
}
impl serde::Serialize for RunObjectIncompleteDetailsReason {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectIncompleteDetailsReasonMaxCompletionTokens {
            #[default]
            #[serde(rename = "max_completion_tokens")]
            MaxCompletionTokens,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectIncompleteDetailsReasonMaxPromptTokens {
            #[default]
            #[serde(rename = "max_prompt_tokens")]
            MaxPromptTokens,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunObjectIncompleteDetailsReason<'a> {
            MaxCompletionTokens(
                #[allow(dead_code)] &'a RunObjectIncompleteDetailsReasonMaxCompletionTokens,
            ),
            MaxPromptTokens(
                #[allow(dead_code)] &'a RunObjectIncompleteDetailsReasonMaxPromptTokens,
            ),
        }
        match self {
            Self::MaxCompletionTokens => {
                RunObjectIncompleteDetailsReason::MaxCompletionTokens(&Default::default())
                    .serialize(serializer)
            }
            Self::MaxPromptTokens => {
                RunObjectIncompleteDetailsReason::MaxPromptTokens(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunObjectIncompleteDetailsReason {
    #[doc = "max_completion_tokens"]
    MaxCompletionTokens,
    #[doc = "max_prompt_tokens"]
    MaxPromptTokens,
}
impl<'de> serde::Deserialize<'de> for RunObjectIncompleteDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunObjectIncompleteDetails {
            #[serde(rename = "reason")]
            #[allow(dead_code)]
            reason: Option<RunObjectIncompleteDetailsReason>,
        }
        let RunObjectIncompleteDetails { reason, .. } =
            RunObjectIncompleteDetails::deserialize(deserializer)?;
        Ok(Self { reason })
    }
}
impl serde::Serialize for RunObjectIncompleteDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunObjectIncompleteDetails<'a> {
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<RunObjectIncompleteDetailsReason>,
        }
        let Self { reason } = self;
        RunObjectIncompleteDetails { reason }.serialize(serializer)
    }
}
#[doc = "Details on why the run is incomplete. Will be `null` if the run is not incomplete."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RunObjectIncompleteDetails {
    #[doc = "The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run."]
    #[builder(default)]
    pub reason: Option<RunObjectIncompleteDetailsReason>,
}
impl<'de> serde::Deserialize<'de> for RunObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.run`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectObject {
            #[default]
            #[serde(rename = "thread.run")]
            ThreadRun,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: RunObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "thread_id")]
            #[allow(dead_code)]
            thread_id: String,
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: RunStatus,
            #[serde(rename = "required_action")]
            #[allow(dead_code)]
            required_action: Option<RunObjectRequiredAction>,
            #[serde(rename = "last_error")]
            #[allow(dead_code)]
            last_error: Option<RunObjectLastError>,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "started_at")]
            #[allow(dead_code)]
            started_at: Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[allow(dead_code)]
            cancelled_at: Option<u64>,
            #[serde(rename = "failed_at")]
            #[allow(dead_code)]
            failed_at: Option<u64>,
            #[serde(rename = "completed_at")]
            #[allow(dead_code)]
            completed_at: Option<u64>,
            #[serde(rename = "incomplete_details")]
            #[allow(dead_code)]
            incomplete_details: Option<RunObjectIncompleteDetails>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: String,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Vec<AssistantTool>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<RunCompletionUsage>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "max_prompt_tokens")]
            #[allow(dead_code)]
            max_prompt_tokens: Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[allow(dead_code)]
            truncation_strategy: Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: ParallelToolCalls,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let RunObject {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = RunObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for RunObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.run`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunObjectObject {
            #[default]
            #[serde(rename = "thread.run")]
            ThreadRun,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a RunObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "status")]
            status: &'a RunStatus,
            #[serde(rename = "required_action")]
            #[serde(skip_serializing_if = "Option::is_none")]
            required_action: &'a Option<RunObjectRequiredAction>,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<RunObjectLastError>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "started_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            started_at: &'a Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<u64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<u64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<u64>,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<RunObjectIncompleteDetails>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "instructions")]
            instructions: &'a String,
            #[serde(rename = "tools")]
            tools: &'a Vec<AssistantTool>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<RunCompletionUsage>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            parallel_tool_calls: &'a ParallelToolCalls,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let Self {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        RunObject {
            id,
            object: &Default::default(),
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an execution run on a [thread](https://platform.openai.com/docs/api-reference/threads)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the run was created."]
    pub created_at: u64,
    #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run."]
    pub thread_id: String,
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run."]
    pub assistant_id: String,
    pub status: RunStatus,
    #[doc = "Details on the action required to continue the run. Will be `null` if no action is required."]
    #[builder(default)]
    pub required_action: Option<RunObjectRequiredAction>,
    #[doc = "The last error associated with this run. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<RunObjectLastError>,
    #[doc = "The Unix timestamp (in seconds) for when the run will expire."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was started."]
    #[builder(default)]
    pub started_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run failed."]
    #[builder(default)]
    pub failed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was completed."]
    #[builder(default)]
    pub completed_at: Option<u64>,
    #[doc = "Details on why the run is incomplete. Will be `null` if the run is not incomplete."]
    #[builder(default)]
    pub incomplete_details: Option<RunObjectIncompleteDetails>,
    #[doc = "The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub model: String,
    #[doc = "The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub instructions: String,
    #[doc = "The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub tools: Vec<AssistantTool>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[builder(default)]
    pub usage: Option<RunCompletionUsage>,
    #[doc = "The sampling temperature used for this run. If not set, defaults to 1."]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "The nucleus sampling value used for this run. If not set, defaults to 1."]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "The maximum number of prompt tokens specified to have been used over the course of the run.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<u64>,
    #[doc = "The maximum number of completion tokens specified to have been used over the course of the run.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[builder(default)]
    pub truncation_strategy: Option<TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<AssistantsApiToolChoiceOption>,
    pub parallel_tool_calls: ParallelToolCalls,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for RunStepCompletionUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepCompletionUsage {
            #[serde(rename = "completion_tokens")]
            #[allow(dead_code)]
            completion_tokens: u64,
            #[serde(rename = "prompt_tokens")]
            #[allow(dead_code)]
            prompt_tokens: u64,
            #[serde(rename = "total_tokens")]
            #[allow(dead_code)]
            total_tokens: u64,
        }
        let RunStepCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
            ..
        } = RunStepCompletionUsage::deserialize(deserializer)?;
        Ok(Self {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        })
    }
}
impl serde::Serialize for RunStepCompletionUsage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepCompletionUsage<'a> {
            #[serde(rename = "completion_tokens")]
            completion_tokens: &'a u64,
            #[serde(rename = "prompt_tokens")]
            prompt_tokens: &'a u64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a u64,
        }
        let Self {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        } = self;
        RunStepCompletionUsage {
            completion_tokens,
            prompt_tokens,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct RunStepCompletionUsage {
    #[doc = "Number of completion tokens used over the course of the run step."]
    pub completion_tokens: u64,
    #[doc = "Number of prompt tokens used over the course of the run step."]
    pub prompt_tokens: u64,
    #[doc = "Total number of tokens used (prompt + completion)."]
    pub total_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.run.step.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaObjectObject {
            #[default]
            #[serde(rename = "thread.run.step.delta")]
            ThreadRunStepDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: RunStepDeltaObjectObject,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: RunStepDeltaObjectDelta,
        }
        let RunStepDeltaObject { id, delta, .. } = RunStepDeltaObject::deserialize(deserializer)?;
        Ok(Self { id, delta })
    }
}
impl serde::Serialize for RunStepDeltaObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.run.step.delta`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaObjectObject {
            #[default]
            #[serde(rename = "thread.run.step.delta")]
            ThreadRunStepDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a RunStepDeltaObjectObject,
            #[serde(rename = "delta")]
            delta: &'a RunStepDeltaObjectDelta,
        }
        let Self { id, delta } = self;
        RunStepDeltaObject {
            id,
            object: &Default::default(),
            delta,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a run step delta i.e. any changed fields on a run step during streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaObject {
    #[doc = "The identifier of the run step, which can be referenced in API endpoints."]
    pub id: String,
    #[builder(default)]
    pub delta: RunStepDeltaObjectDelta,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
            #[serde(rename = "message_id")]
            #[allow(dead_code)]
            message_id: Option<String>,
        }
        let RunStepDeltaStepDetailsMessageCreationObjectMessageCreation { message_id, .. } =
            RunStepDeltaStepDetailsMessageCreationObjectMessageCreation::deserialize(deserializer)?;
        Ok(Self { message_id })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsMessageCreationObjectMessageCreation<'a> {
            #[serde(rename = "message_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message_id: &'a Option<String>,
        }
        let Self { message_id } = self;
        RunStepDeltaStepDetailsMessageCreationObjectMessageCreation { message_id }
            .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsMessageCreationObjectMessageCreation {
    #[doc = "The ID of the message that was created by this run step."]
    #[builder(default)]
    pub message_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsMessageCreationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `message_creation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsMessageCreationObjectType {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsMessageCreationObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsMessageCreationObjectType,
            #[serde(rename = "message_creation")]
            #[allow(dead_code)]
            message_creation: Option<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,
        }
        let RunStepDeltaStepDetailsMessageCreationObject {
            message_creation, ..
        } = RunStepDeltaStepDetailsMessageCreationObject::deserialize(deserializer)?;
        Ok(Self { message_creation })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsMessageCreationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `message_creation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsMessageCreationObjectType {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsMessageCreationObject<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsMessageCreationObjectType,
            #[serde(rename = "message_creation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message_creation:
                &'a Option<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,
        }
        let Self { message_creation } = self;
        RunStepDeltaStepDetailsMessageCreationObject {
            type_: &Default::default(),
            message_creation,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the message creation by the run step."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsMessageCreationObject {
    #[builder(default)]
    pub message_creation: Option<RunStepDeltaStepDetailsMessageCreationObjectMessageCreation>,
}
impl<'de> serde::Deserialize<'de>
    for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
            Logs(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject),
            Image(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsCodeOutputImageObject),
        }
        Ok(
            match RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::deserialize(
                deserializer,
            )? {
                RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::Logs(_v) => {
                    Self::Logs(_v)
                }
                RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::Image(_v) => {
                    Self::Image(_v)
                }
            },
        )
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs<'a> {
            Logs(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject),
            Image(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsCodeOutputImageObject),
        }
        match self {
            Self::Logs(_v) => {
                RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::Logs(_v)
                    .serialize(serializer)
            }
            Self::Image(_v) => {
                RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::Image(_v)
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    Logs(RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject),
    Image(RunStepDeltaStepDetailsToolCallsCodeOutputImageObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: Option<String>,
            #[serde(rename = "outputs")]
            #[allow(dead_code)]
            outputs: Option<Vec<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter { input, outputs, .. } =
            RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { input, outputs })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter<'a> {
            #[serde(rename = "input")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input: &'a Option<String>,
            #[serde(rename = "outputs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            outputs:
                &'a Option<Vec<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>>,
        }
        let Self { input, outputs } = self;
        RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter { input, outputs }
            .serialize(serializer)
    }
}
#[doc = "The Code Interpreter tool call definition."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter {
    #[doc = "The input to the Code Interpreter tool call."]
    #[builder(default)]
    pub input: Option<String>,
    #[doc = "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type."]
    #[builder(default)]
    pub outputs: Option<Vec<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeObjectType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsCodeObjectType,
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeObject {
            index,
            id,
            code_interpreter,
            ..
        } = RunStepDeltaStepDetailsToolCallsCodeObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            id,
            code_interpreter,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeObjectType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsCodeObjectType,
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,
        }
        let Self {
            index,
            id,
            code_interpreter,
        } = self;
        RunStepDeltaStepDetailsToolCallsCodeObject {
            index,
            id,
            type_: &Default::default(),
            code_interpreter,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the Code Interpreter tool call the run step was involved in."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: u64,
    #[doc = "The ID of the tool call."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The Code Interpreter tool call definition."]
    #[builder(default)]
    pub code_interpreter: Option<RunStepDeltaStepDetailsToolCallsCodeObjectCodeInterpreter>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage { file_id, .. } =
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage::deserialize(deserializer)?;
        Ok(Self { file_id })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage<'a> {
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let Self { file_id } = self;
        RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage {
    #[doc = "The [file](https://platform.openai.com/docs/api-reference/files) ID of the image."]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectType {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectType,
            #[serde(rename = "image")]
            #[allow(dead_code)]
            image: Option<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeOutputImageObject { index, image, .. } =
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject::deserialize(deserializer)?;
        Ok(Self { index, image })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectType {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectType,
            #[serde(rename = "image")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image: &'a Option<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,
        }
        let Self { index, image } = self;
        RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
            index,
            type_: &Default::default(),
            image,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    #[doc = "The index of the output in the outputs array."]
    pub index: u64,
    #[builder(default)]
    pub image: Option<RunStepDeltaStepDetailsToolCallsCodeOutputImageObjectImage>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectType,
            #[serde(rename = "logs")]
            #[allow(dead_code)]
            logs: Option<String>,
        }
        let RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject { index, logs, .. } =
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject::deserialize(deserializer)?;
        Ok(Self { index, logs })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsCodeOutputLogsObjectType,
            #[serde(rename = "logs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logs: &'a Option<String>,
        }
        let Self { index, logs } = self;
        RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
            index,
            type_: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[doc = "Text output from the Code Interpreter tool call as part of a run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    #[doc = "The index of the output in the outputs array."]
    pub index: u64,
    #[doc = "The text output from the Code Interpreter tool call."]
    #[builder(default)]
    pub logs: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsFileSearchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsFileSearchObjectType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsFileSearchObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsFileSearchObjectType,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: std::collections::HashMap<String, serde_json::Value>,
        }
        let RunStepDeltaStepDetailsToolCallsFileSearchObject {
            index,
            id,
            file_search,
            ..
        } = RunStepDeltaStepDetailsToolCallsFileSearchObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            id,
            file_search,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsFileSearchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsFileSearchObjectType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsFileSearchObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsFileSearchObjectType,
            #[serde(rename = "file_search")]
            file_search: &'a std::collections::HashMap<String, serde_json::Value>,
        }
        let Self {
            index,
            id,
            file_search,
        } = self;
        RunStepDeltaStepDetailsToolCallsFileSearchObject {
            index,
            id,
            type_: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsFileSearchObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: u64,
    #[doc = "The ID of the tool call object."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "For now, this is always going to be an empty object."]
    pub file_search: std::collections::HashMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
            ..
        } = RunStepDeltaStepDetailsToolCallsFunctionObjectFunction::deserialize(deserializer)?;
        Ok(Self {
            name,
            arguments,
            output,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsFunctionObjectFunction<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "arguments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            arguments: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let Self {
            name,
            arguments,
            output,
        } = self;
        RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
        }
        .serialize(serializer)
    }
}
#[doc = "The definition of the function that was called."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObjectFunction {
    #[doc = "The name of the function."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments passed to the function."]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet."]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsFunctionObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsFunctionObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsFunctionObject {
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsFunctionObjectType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: Option<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,
        }
        let RunStepDeltaStepDetailsToolCallsFunctionObject {
            index,
            id,
            function,
            ..
        } = RunStepDeltaStepDetailsToolCallsFunctionObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            id,
            function,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsFunctionObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsFunctionObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsFunctionObject<'a> {
            #[serde(rename = "index")]
            index: &'a u64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsFunctionObjectType,
            #[serde(rename = "function")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function: &'a Option<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,
        }
        let Self {
            index,
            id,
            function,
        } = self;
        RunStepDeltaStepDetailsToolCallsFunctionObject {
            index,
            id,
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: u64,
    #[doc = "The ID of the tool call object."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The definition of the function that was called."]
    #[builder(default)]
    pub function: Option<RunStepDeltaStepDetailsToolCallsFunctionObjectFunction>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `tool_calls`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsObjectType {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDeltaStepDetailsToolCallsObjectType,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Option<Vec<RunStepDeltaStepDetailsToolCall>>,
        }
        let RunStepDeltaStepDetailsToolCallsObject { tool_calls, .. } =
            RunStepDeltaStepDetailsToolCallsObject::deserialize(deserializer)?;
        Ok(Self { tool_calls })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `tool_calls`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDeltaStepDetailsToolCallsObjectType {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsObject<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDeltaStepDetailsToolCallsObjectType,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<Vec<RunStepDeltaStepDetailsToolCall>>,
        }
        let Self { tool_calls } = self;
        RunStepDeltaStepDetailsToolCallsObject {
            type_: &Default::default(),
            tool_calls,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the tool call."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsObject {
    #[doc = "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.\n"]
    #[builder(default)]
    pub tool_calls: Option<Vec<RunStepDeltaStepDetailsToolCall>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsMessageCreationObjectMessageCreation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsMessageCreationObjectMessageCreation {
            #[serde(rename = "message_id")]
            #[allow(dead_code)]
            message_id: String,
        }
        let RunStepDetailsMessageCreationObjectMessageCreation { message_id, .. } =
            RunStepDetailsMessageCreationObjectMessageCreation::deserialize(deserializer)?;
        Ok(Self { message_id })
    }
}
impl serde::Serialize for RunStepDetailsMessageCreationObjectMessageCreation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsMessageCreationObjectMessageCreation<'a> {
            #[serde(rename = "message_id")]
            message_id: &'a String,
        }
        let Self { message_id } = self;
        RunStepDetailsMessageCreationObjectMessageCreation { message_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsMessageCreationObjectMessageCreation {
    #[doc = "The ID of the message that was created by this run step."]
    pub message_id: String,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsMessageCreationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `message_creation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsMessageCreationObjectType {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsMessageCreationObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsMessageCreationObjectType,
            #[serde(rename = "message_creation")]
            #[allow(dead_code)]
            message_creation: RunStepDetailsMessageCreationObjectMessageCreation,
        }
        let RunStepDetailsMessageCreationObject {
            message_creation, ..
        } = RunStepDetailsMessageCreationObject::deserialize(deserializer)?;
        Ok(Self { message_creation })
    }
}
impl serde::Serialize for RunStepDetailsMessageCreationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `message_creation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsMessageCreationObjectType {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsMessageCreationObject<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsMessageCreationObjectType,
            #[serde(rename = "message_creation")]
            message_creation: &'a RunStepDetailsMessageCreationObjectMessageCreation,
        }
        let Self { message_creation } = self;
        RunStepDetailsMessageCreationObject {
            type_: &Default::default(),
            message_creation,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the message creation by the run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsMessageCreationObject {
    pub message_creation: RunStepDetailsMessageCreationObjectMessageCreation,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
            Logs(#[allow(dead_code)] RunStepDetailsToolCallsCodeOutputLogsObject),
            Image(#[allow(dead_code)] RunStepDetailsToolCallsCodeOutputImageObject),
        }
        Ok(
            match RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::deserialize(
                deserializer,
            )? {
                RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::Logs(_v) => Self::Logs(_v),
                RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::Image(_v) => {
                    Self::Image(_v)
                }
            },
        )
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs<'a> {
            Logs(#[allow(dead_code)] &'a RunStepDetailsToolCallsCodeOutputLogsObject),
            Image(#[allow(dead_code)] &'a RunStepDetailsToolCallsCodeOutputImageObject),
        }
        match self {
            Self::Logs(_v) => RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::Logs(_v)
                .serialize(serializer),
            Self::Image(_v) => RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs::Image(_v)
                .serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs {
    Logs(RunStepDetailsToolCallsCodeOutputLogsObject),
    Image(RunStepDetailsToolCallsCodeOutputImageObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsCodeObjectCodeInterpreter {
            #[serde(rename = "input")]
            #[allow(dead_code)]
            input: String,
            #[serde(rename = "outputs")]
            #[allow(dead_code)]
            outputs: Vec<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>,
        }
        let RunStepDetailsToolCallsCodeObjectCodeInterpreter { input, outputs, .. } =
            RunStepDetailsToolCallsCodeObjectCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { input, outputs })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsCodeObjectCodeInterpreter<'a> {
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "outputs")]
            outputs: &'a Vec<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>,
        }
        let Self { input, outputs } = self;
        RunStepDetailsToolCallsCodeObjectCodeInterpreter { input, outputs }.serialize(serializer)
    }
}
#[doc = "The Code Interpreter tool call definition."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeObjectCodeInterpreter {
    #[doc = "The input to the Code Interpreter tool call."]
    pub input: String,
    #[doc = "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type."]
    pub outputs: Vec<RunStepDetailsToolCallsCodeObjectCodeInterpreterOutputs>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeObjectType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsCodeObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsCodeObjectType,
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: RunStepDetailsToolCallsCodeObjectCodeInterpreter,
        }
        let RunStepDetailsToolCallsCodeObject {
            id,
            code_interpreter,
            ..
        } = RunStepDetailsToolCallsCodeObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            code_interpreter,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeObjectType {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsCodeObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsCodeObjectType,
            #[serde(rename = "code_interpreter")]
            code_interpreter: &'a RunStepDetailsToolCallsCodeObjectCodeInterpreter,
        }
        let Self {
            id,
            code_interpreter,
        } = self;
        RunStepDetailsToolCallsCodeObject {
            id,
            type_: &Default::default(),
            code_interpreter,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the Code Interpreter tool call the run step was involved in."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeObject {
    #[doc = "The ID of the tool call."]
    pub id: String,
    #[doc = "The Code Interpreter tool call definition."]
    pub code_interpreter: RunStepDetailsToolCallsCodeObjectCodeInterpreter,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeOutputImageObjectImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsCodeOutputImageObjectImage {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
        }
        let RunStepDetailsToolCallsCodeOutputImageObjectImage { file_id, .. } =
            RunStepDetailsToolCallsCodeOutputImageObjectImage::deserialize(deserializer)?;
        Ok(Self { file_id })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeOutputImageObjectImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsCodeOutputImageObjectImage<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
        }
        let Self { file_id } = self;
        RunStepDetailsToolCallsCodeOutputImageObjectImage { file_id }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeOutputImageObjectImage {
    #[doc = "The [file](https://platform.openai.com/docs/api-reference/files) ID of the image."]
    pub file_id: String,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeOutputImageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeOutputImageObjectType {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsCodeOutputImageObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsCodeOutputImageObjectType,
            #[serde(rename = "image")]
            #[allow(dead_code)]
            image: RunStepDetailsToolCallsCodeOutputImageObjectImage,
        }
        let RunStepDetailsToolCallsCodeOutputImageObject { image, .. } =
            RunStepDetailsToolCallsCodeOutputImageObject::deserialize(deserializer)?;
        Ok(Self { image })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeOutputImageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeOutputImageObjectType {
            #[default]
            #[serde(rename = "image")]
            Image,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsCodeOutputImageObject<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsCodeOutputImageObjectType,
            #[serde(rename = "image")]
            image: &'a RunStepDetailsToolCallsCodeOutputImageObjectImage,
        }
        let Self { image } = self;
        RunStepDetailsToolCallsCodeOutputImageObject {
            type_: &Default::default(),
            image,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeOutputImageObject {
    pub image: RunStepDetailsToolCallsCodeOutputImageObjectImage,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeOutputLogsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeOutputLogsObjectType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsCodeOutputLogsObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsCodeOutputLogsObjectType,
            #[serde(rename = "logs")]
            #[allow(dead_code)]
            logs: String,
        }
        let RunStepDetailsToolCallsCodeOutputLogsObject { logs, .. } =
            RunStepDetailsToolCallsCodeOutputLogsObject::deserialize(deserializer)?;
        Ok(Self { logs })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeOutputLogsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `logs`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsCodeOutputLogsObjectType {
            #[default]
            #[serde(rename = "logs")]
            Logs,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsCodeOutputLogsObject<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsCodeOutputLogsObjectType,
            #[serde(rename = "logs")]
            logs: &'a String,
        }
        let Self { logs } = self;
        RunStepDetailsToolCallsCodeOutputLogsObject {
            type_: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[doc = "Text output from the Code Interpreter tool call as part of a run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeOutputLogsObject {
    #[doc = "The text output from the Code Interpreter tool call."]
    pub logs: String,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchObjectFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFileSearchObjectFileSearch {
            #[serde(rename = "ranking_options")]
            #[allow(dead_code)]
            ranking_options: Option<RunStepDetailsToolCallsFileSearchRankingOptionsObject>,
            #[serde(rename = "results")]
            #[allow(dead_code)]
            results: Option<Vec<RunStepDetailsToolCallsFileSearchResultObject>>,
        }
        let RunStepDetailsToolCallsFileSearchObjectFileSearch {
            ranking_options,
            results,
            ..
        } = RunStepDetailsToolCallsFileSearchObjectFileSearch::deserialize(deserializer)?;
        Ok(Self {
            ranking_options,
            results,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchObjectFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFileSearchObjectFileSearch<'a> {
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<RunStepDetailsToolCallsFileSearchRankingOptionsObject>,
            #[serde(rename = "results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            results: &'a Option<Vec<RunStepDetailsToolCallsFileSearchResultObject>>,
        }
        let Self {
            ranking_options,
            results,
        } = self;
        RunStepDetailsToolCallsFileSearchObjectFileSearch {
            ranking_options,
            results,
        }
        .serialize(serializer)
    }
}
#[doc = "For now, this is always going to be an empty object."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchObjectFileSearch {
    #[builder(default)]
    pub ranking_options: Option<RunStepDetailsToolCallsFileSearchRankingOptionsObject>,
    #[doc = "The results of the file search."]
    #[builder(default)]
    pub results: Option<Vec<RunStepDetailsToolCallsFileSearchResultObject>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsFileSearchObjectType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFileSearchObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsFileSearchObjectType,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: RunStepDetailsToolCallsFileSearchObjectFileSearch,
        }
        let RunStepDetailsToolCallsFileSearchObject {
            id, file_search, ..
        } = RunStepDetailsToolCallsFileSearchObject::deserialize(deserializer)?;
        Ok(Self { id, file_search })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsFileSearchObjectType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFileSearchObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsFileSearchObjectType,
            #[serde(rename = "file_search")]
            file_search: &'a RunStepDetailsToolCallsFileSearchObjectFileSearch,
        }
        let Self { id, file_search } = self;
        RunStepDetailsToolCallsFileSearchObject {
            id,
            type_: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchObject {
    #[doc = "The ID of the tool call object."]
    pub id: String,
    #[doc = "For now, this is always going to be an empty object."]
    #[builder(default)]
    pub file_search: RunStepDetailsToolCallsFileSearchObjectFileSearch,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFileSearchRankingOptionsObject {
            #[serde(rename = "ranker")]
            #[allow(dead_code)]
            ranker: FileSearchRanker,
            #[serde(rename = "score_threshold")]
            #[allow(dead_code)]
            score_threshold: f64,
        }
        let RunStepDetailsToolCallsFileSearchRankingOptionsObject {
            ranker,
            score_threshold,
            ..
        } = RunStepDetailsToolCallsFileSearchRankingOptionsObject::deserialize(deserializer)?;
        Ok(Self {
            ranker,
            score_threshold,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFileSearchRankingOptionsObject<'a> {
            #[serde(rename = "ranker")]
            ranker: &'a FileSearchRanker,
            #[serde(rename = "score_threshold")]
            score_threshold: &'a f64,
        }
        let Self {
            ranker,
            score_threshold,
        } = self;
        RunStepDetailsToolCallsFileSearchRankingOptionsObject {
            ranker,
            score_threshold,
        }
        .serialize(serializer)
    }
}
#[doc = "The ranking options for the file search."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    pub ranker: FileSearchRanker,
    #[doc = "The score threshold for the file search. All values must be a floating point number between 0 and 1."]
    pub score_threshold: f64,
}
#[doc = "The type of the content."]
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum RunStepDetailsToolCallsFileSearchResultObjectContentType {
    #[default]
    #[serde(rename = "text")]
    Text,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchResultObjectContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFileSearchResultObjectContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RunStepDetailsToolCallsFileSearchResultObjectContentType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
        }
        let RunStepDetailsToolCallsFileSearchResultObjectContent { type_, text, .. } =
            RunStepDetailsToolCallsFileSearchResultObjectContent::deserialize(deserializer)?;
        Ok(Self { type_, text })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchResultObjectContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFileSearchResultObjectContent<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RunStepDetailsToolCallsFileSearchResultObjectContentType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
        }
        let Self { type_, text } = self;
        RunStepDetailsToolCallsFileSearchResultObjectContent { type_, text }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchResultObjectContent {
    #[doc = "The type of the content."]
    #[builder(default)]
    pub type_: Option<RunStepDetailsToolCallsFileSearchResultObjectContentType>,
    #[doc = "The text content of the file."]
    #[builder(default)]
    pub text: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchResultObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFileSearchResultObject {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "file_name")]
            #[allow(dead_code)]
            file_name: String,
            #[serde(rename = "score")]
            #[allow(dead_code)]
            score: f64,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Option<Vec<RunStepDetailsToolCallsFileSearchResultObjectContent>>,
        }
        let RunStepDetailsToolCallsFileSearchResultObject {
            file_id,
            file_name,
            score,
            content,
            ..
        } = RunStepDetailsToolCallsFileSearchResultObject::deserialize(deserializer)?;
        Ok(Self {
            file_id,
            file_name,
            score,
            content,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchResultObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFileSearchResultObject<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "file_name")]
            file_name: &'a String,
            #[serde(rename = "score")]
            score: &'a f64,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<RunStepDetailsToolCallsFileSearchResultObjectContent>>,
        }
        let Self {
            file_id,
            file_name,
            score,
            content,
        } = self;
        RunStepDetailsToolCallsFileSearchResultObject {
            file_id,
            file_name,
            score,
            content,
        }
        .serialize(serializer)
    }
}
#[doc = "A result instance of the file search."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchResultObject {
    #[doc = "The ID of the file that result was found in."]
    pub file_id: String,
    #[doc = "The name of the file that result was found in."]
    pub file_name: String,
    #[doc = "The score of the result. All values must be a floating point number between 0 and 1."]
    pub score: f64,
    #[doc = "The content of the result that was found. The content is only included if requested via the include query parameter."]
    #[builder(default)]
    pub content: Option<Vec<RunStepDetailsToolCallsFileSearchResultObjectContent>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFunctionObjectFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFunctionObjectFunction {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let RunStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
            ..
        } = RunStepDetailsToolCallsFunctionObjectFunction::deserialize(deserializer)?;
        Ok(Self {
            name,
            arguments,
            output,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFunctionObjectFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFunctionObjectFunction<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let Self {
            name,
            arguments,
            output,
        } = self;
        RunStepDetailsToolCallsFunctionObjectFunction {
            name,
            arguments,
            output,
        }
        .serialize(serializer)
    }
}
#[doc = "The definition of the function that was called."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFunctionObjectFunction {
    #[doc = "The name of the function."]
    pub name: String,
    #[doc = "The arguments passed to the function."]
    pub arguments: String,
    #[doc = "The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet."]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFunctionObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsFunctionObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFunctionObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsFunctionObjectType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: RunStepDetailsToolCallsFunctionObjectFunction,
        }
        let RunStepDetailsToolCallsFunctionObject { id, function, .. } =
            RunStepDetailsToolCallsFunctionObject::deserialize(deserializer)?;
        Ok(Self { id, function })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFunctionObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsFunctionObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFunctionObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsFunctionObjectType,
            #[serde(rename = "function")]
            function: &'a RunStepDetailsToolCallsFunctionObjectFunction,
        }
        let Self { id, function } = self;
        RunStepDetailsToolCallsFunctionObject {
            id,
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFunctionObject {
    #[doc = "The ID of the tool call object."]
    pub id: String,
    #[doc = "The definition of the function that was called."]
    pub function: RunStepDetailsToolCallsFunctionObjectFunction,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `tool_calls`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsObjectType {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepDetailsToolCallsObjectType,
            #[serde(rename = "tool_calls")]
            #[allow(dead_code)]
            tool_calls: Vec<RunStepDetailsToolCall>,
        }
        let RunStepDetailsToolCallsObject { tool_calls, .. } =
            RunStepDetailsToolCallsObject::deserialize(deserializer)?;
        Ok(Self { tool_calls })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `tool_calls`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepDetailsToolCallsObjectType {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsObject<'a> {
            #[serde(rename = "type")]
            type_: &'a RunStepDetailsToolCallsObjectType,
            #[serde(rename = "tool_calls")]
            tool_calls: &'a Vec<RunStepDetailsToolCall>,
        }
        let Self { tool_calls } = self;
        RunStepDetailsToolCallsObject {
            type_: &Default::default(),
            tool_calls,
        }
        .serialize(serializer)
    }
}
#[doc = "Details of the tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsObject {
    #[doc = "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.\n"]
    pub tool_calls: Vec<RunStepDetailsToolCall>,
}
impl<'de> serde::Deserialize<'de> for RunStepObjectType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectTypeMessageCreation {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectTypeToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepObjectType {
            MessageCreation(#[allow(dead_code)] RunStepObjectTypeMessageCreation),
            ToolCalls(#[allow(dead_code)] RunStepObjectTypeToolCalls),
        }
        Ok(match RunStepObjectType::deserialize(deserializer)? {
            RunStepObjectType::MessageCreation(_) => Self::MessageCreation,
            RunStepObjectType::ToolCalls(_) => Self::ToolCalls,
        })
    }
}
impl serde::Serialize for RunStepObjectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectTypeMessageCreation {
            #[default]
            #[serde(rename = "message_creation")]
            MessageCreation,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectTypeToolCalls {
            #[default]
            #[serde(rename = "tool_calls")]
            ToolCalls,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepObjectType<'a> {
            MessageCreation(#[allow(dead_code)] &'a RunStepObjectTypeMessageCreation),
            ToolCalls(#[allow(dead_code)] &'a RunStepObjectTypeToolCalls),
        }
        match self {
            Self::MessageCreation => {
                RunStepObjectType::MessageCreation(&Default::default()).serialize(serializer)
            }
            Self::ToolCalls => {
                RunStepObjectType::ToolCalls(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of run step, which can be either `message_creation` or `tool_calls`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepObjectType {
    #[doc = "message_creation"]
    MessageCreation,
    #[doc = "tool_calls"]
    ToolCalls,
}
impl<'de> serde::Deserialize<'de> for RunStepObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepObjectStatus {
            InProgress(#[allow(dead_code)] RunStepObjectStatusInProgress),
            Cancelled(#[allow(dead_code)] RunStepObjectStatusCancelled),
            Failed(#[allow(dead_code)] RunStepObjectStatusFailed),
            Completed(#[allow(dead_code)] RunStepObjectStatusCompleted),
            Expired(#[allow(dead_code)] RunStepObjectStatusExpired),
        }
        Ok(match RunStepObjectStatus::deserialize(deserializer)? {
            RunStepObjectStatus::InProgress(_) => Self::InProgress,
            RunStepObjectStatus::Cancelled(_) => Self::Cancelled,
            RunStepObjectStatus::Failed(_) => Self::Failed,
            RunStepObjectStatus::Completed(_) => Self::Completed,
            RunStepObjectStatus::Expired(_) => Self::Expired,
        })
    }
}
impl serde::Serialize for RunStepObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepObjectStatus<'a> {
            InProgress(#[allow(dead_code)] &'a RunStepObjectStatusInProgress),
            Cancelled(#[allow(dead_code)] &'a RunStepObjectStatusCancelled),
            Failed(#[allow(dead_code)] &'a RunStepObjectStatusFailed),
            Completed(#[allow(dead_code)] &'a RunStepObjectStatusCompleted),
            Expired(#[allow(dead_code)] &'a RunStepObjectStatusExpired),
        }
        match self {
            Self::InProgress => {
                RunStepObjectStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Cancelled => {
                RunStepObjectStatus::Cancelled(&Default::default()).serialize(serializer)
            }
            Self::Failed => RunStepObjectStatus::Failed(&Default::default()).serialize(serializer),
            Self::Completed => {
                RunStepObjectStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Expired => {
                RunStepObjectStatus::Expired(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepObjectStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
    #[doc = "completed"]
    Completed,
    #[doc = "expired"]
    Expired,
}
impl<'de> serde::Deserialize<'de> for RunStepObjectStepDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepObjectStepDetails {
            MessageCreation(#[allow(dead_code)] RunStepDetailsMessageCreationObject),
            ToolCalls(#[allow(dead_code)] RunStepDetailsToolCallsObject),
        }
        Ok(match RunStepObjectStepDetails::deserialize(deserializer)? {
            RunStepObjectStepDetails::MessageCreation(_v) => Self::MessageCreation(_v),
            RunStepObjectStepDetails::ToolCalls(_v) => Self::ToolCalls(_v),
        })
    }
}
impl serde::Serialize for RunStepObjectStepDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepObjectStepDetails<'a> {
            MessageCreation(#[allow(dead_code)] &'a RunStepDetailsMessageCreationObject),
            ToolCalls(#[allow(dead_code)] &'a RunStepDetailsToolCallsObject),
        }
        match self {
            Self::MessageCreation(_v) => {
                RunStepObjectStepDetails::MessageCreation(_v).serialize(serializer)
            }
            Self::ToolCalls(_v) => RunStepObjectStepDetails::ToolCalls(_v).serialize(serializer),
        }
    }
}
#[doc = "The details of the run step."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepObjectStepDetails {
    MessageCreation(RunStepDetailsMessageCreationObject),
    ToolCalls(RunStepDetailsToolCallsObject),
}
impl<'de> serde::Deserialize<'de> for RunStepObjectLastErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectLastErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepObjectLastErrorCode {
            ServerError(#[allow(dead_code)] RunStepObjectLastErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] RunStepObjectLastErrorCodeRateLimitExceeded),
        }
        Ok(
            match RunStepObjectLastErrorCode::deserialize(deserializer)? {
                RunStepObjectLastErrorCode::ServerError(_) => Self::ServerError,
                RunStepObjectLastErrorCode::RateLimitExceeded(_) => Self::RateLimitExceeded,
            },
        )
    }
}
impl serde::Serialize for RunStepObjectLastErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectLastErrorCodeRateLimitExceeded {
            #[default]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepObjectLastErrorCode<'a> {
            ServerError(#[allow(dead_code)] &'a RunStepObjectLastErrorCodeServerError),
            RateLimitExceeded(#[allow(dead_code)] &'a RunStepObjectLastErrorCodeRateLimitExceeded),
        }
        match self {
            Self::ServerError => {
                RunStepObjectLastErrorCode::ServerError(&Default::default()).serialize(serializer)
            }
            Self::RateLimitExceeded => {
                RunStepObjectLastErrorCode::RateLimitExceeded(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "One of `server_error` or `rate_limit_exceeded`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepObjectLastErrorCode {
    #[doc = "server_error"]
    ServerError,
    #[doc = "rate_limit_exceeded"]
    RateLimitExceeded,
}
impl<'de> serde::Deserialize<'de> for RunStepObjectLastError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepObjectLastError {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: RunStepObjectLastErrorCode,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let RunStepObjectLastError { code, message, .. } =
            RunStepObjectLastError::deserialize(deserializer)?;
        Ok(Self { code, message })
    }
}
impl serde::Serialize for RunStepObjectLastError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepObjectLastError<'a> {
            #[serde(rename = "code")]
            code: &'a RunStepObjectLastErrorCode,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let Self { code, message } = self;
        RunStepObjectLastError { code, message }.serialize(serializer)
    }
}
#[doc = "The last error associated with this run step. Will be `null` if there are no errors."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepObjectLastError {
    #[doc = "One of `server_error` or `rate_limit_exceeded`."]
    pub code: RunStepObjectLastErrorCode,
    #[doc = "A human-readable description of the error."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for RunStepObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread.run.step`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectObject {
            #[default]
            #[serde(rename = "thread.run.step")]
            ThreadRunStep,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: RunStepObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "thread_id")]
            #[allow(dead_code)]
            thread_id: String,
            #[serde(rename = "run_id")]
            #[allow(dead_code)]
            run_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunStepObjectType,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: RunStepObjectStatus,
            #[serde(rename = "step_details")]
            #[allow(dead_code)]
            step_details: RunStepObjectStepDetails,
            #[serde(rename = "last_error")]
            #[allow(dead_code)]
            last_error: Option<RunStepObjectLastError>,
            #[serde(rename = "expired_at")]
            #[allow(dead_code)]
            expired_at: Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[allow(dead_code)]
            cancelled_at: Option<u64>,
            #[serde(rename = "failed_at")]
            #[allow(dead_code)]
            failed_at: Option<u64>,
            #[serde(rename = "completed_at")]
            #[allow(dead_code)]
            completed_at: Option<u64>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "usage")]
            #[allow(dead_code)]
            usage: Option<RunStepCompletionUsage>,
        }
        let RunStepObject {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            type_,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
            ..
        } = RunStepObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            type_,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        })
    }
}
impl serde::Serialize for RunStepObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread.run.step`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepObjectObject {
            #[default]
            #[serde(rename = "thread.run.step")]
            ThreadRunStep,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a RunStepObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "run_id")]
            run_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunStepObjectType,
            #[serde(rename = "status")]
            status: &'a RunStepObjectStatus,
            #[serde(rename = "step_details")]
            step_details: &'a RunStepObjectStepDetails,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<RunStepObjectLastError>,
            #[serde(rename = "expired_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expired_at: &'a Option<u64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<u64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<u64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<u64>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<RunStepCompletionUsage>,
        }
        let Self {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            type_,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        } = self;
        RunStepObject {
            id,
            object: &Default::default(),
            created_at,
            assistant_id,
            thread_id,
            run_id,
            type_,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a step in execution of a run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepObject {
    #[doc = "The identifier of the run step, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the run step was created."]
    pub created_at: u64,
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step."]
    pub assistant_id: String,
    #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run."]
    pub thread_id: String,
    #[doc = "The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of."]
    pub run_id: String,
    #[doc = "The type of run step, which can be either `message_creation` or `tool_calls`."]
    pub type_: RunStepObjectType,
    #[doc = "The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`."]
    pub status: RunStepObjectStatus,
    #[doc = "The details of the run step."]
    pub step_details: RunStepObjectStepDetails,
    #[doc = "The last error associated with this run step. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<RunStepObjectLastError>,
    #[doc = "The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired."]
    #[builder(default)]
    pub expired_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step failed."]
    #[builder(default)]
    pub failed_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step completed."]
    #[builder(default)]
    pub completed_at: Option<u64>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[builder(default)]
    pub usage: Option<RunStepCompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCreatedEvent {
            #[default]
            #[serde(rename = "thread.run.step.created")]
            ThreadRunStepCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepStreamEventThreadRunStepCreated {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepCreatedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let RunStepStreamEventThreadRunStepCreated { data, .. } =
            RunStepStreamEventThreadRunStepCreated::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCreatedEvent {
            #[default]
            #[serde(rename = "thread.run.step.created")]
            ThreadRunStepCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepStreamEventThreadRunStepCreated<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepCreatedEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let Self { data } = self;
        RunStepStreamEventThreadRunStepCreated {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is created."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepCreated {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepInProgress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepInProgressEvent {
            #[default]
            #[serde(rename = "thread.run.step.in_progress")]
            ThreadRunStepInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepStreamEventThreadRunStepInProgress {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepInProgressEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let RunStepStreamEventThreadRunStepInProgress { data, .. } =
            RunStepStreamEventThreadRunStepInProgress::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepInProgress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepInProgressEvent {
            #[default]
            #[serde(rename = "thread.run.step.in_progress")]
            ThreadRunStepInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepStreamEventThreadRunStepInProgress<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepInProgressEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let Self { data } = self;
        RunStepStreamEventThreadRunStepInProgress {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) moves to an `in_progress` state."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepInProgress {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepDeltaEvent {
            #[default]
            #[serde(rename = "thread.run.step.delta")]
            ThreadRunStepDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepStreamEventThreadRunStepDelta {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepDeltaEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepDeltaObject,
        }
        let RunStepStreamEventThreadRunStepDelta { data, .. } =
            RunStepStreamEventThreadRunStepDelta::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepDeltaEvent {
            #[default]
            #[serde(rename = "thread.run.step.delta")]
            ThreadRunStepDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepStreamEventThreadRunStepDelta<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepDeltaEvent,
            #[serde(rename = "data")]
            data: &'a RunStepDeltaObject,
        }
        let Self { data } = self;
        RunStepStreamEventThreadRunStepDelta {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when parts of a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) are being streamed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepDelta {
    pub data: RunStepDeltaObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepCompleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCompletedEvent {
            #[default]
            #[serde(rename = "thread.run.step.completed")]
            ThreadRunStepCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepStreamEventThreadRunStepCompleted {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepCompletedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let RunStepStreamEventThreadRunStepCompleted { data, .. } =
            RunStepStreamEventThreadRunStepCompleted::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCompletedEvent {
            #[default]
            #[serde(rename = "thread.run.step.completed")]
            ThreadRunStepCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepStreamEventThreadRunStepCompleted<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepCompletedEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let Self { data } = self;
        RunStepStreamEventThreadRunStepCompleted {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepCompleted {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepFailedEvent {
            #[default]
            #[serde(rename = "thread.run.step.failed")]
            ThreadRunStepFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepStreamEventThreadRunStepFailed {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepFailedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let RunStepStreamEventThreadRunStepFailed { data, .. } =
            RunStepStreamEventThreadRunStepFailed::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepFailedEvent {
            #[default]
            #[serde(rename = "thread.run.step.failed")]
            ThreadRunStepFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepStreamEventThreadRunStepFailed<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepFailedEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let Self { data } = self;
        RunStepStreamEventThreadRunStepFailed {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) fails."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepFailed {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepCancelled {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCancelledEvent {
            #[default]
            #[serde(rename = "thread.run.step.cancelled")]
            ThreadRunStepCancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepStreamEventThreadRunStepCancelled {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepCancelledEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let RunStepStreamEventThreadRunStepCancelled { data, .. } =
            RunStepStreamEventThreadRunStepCancelled::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepCancelled {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepCancelledEvent {
            #[default]
            #[serde(rename = "thread.run.step.cancelled")]
            ThreadRunStepCancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepStreamEventThreadRunStepCancelled<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepCancelledEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let Self { data } = self;
        RunStepStreamEventThreadRunStepCancelled {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is cancelled."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepCancelled {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEventThreadRunStepExpired {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepExpiredEvent {
            #[default]
            #[serde(rename = "thread.run.step.expired")]
            ThreadRunStepExpired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepStreamEventThreadRunStepExpired {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStepStreamEventThreadRunStepExpiredEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunStepObject,
        }
        let RunStepStreamEventThreadRunStepExpired { data, .. } =
            RunStepStreamEventThreadRunStepExpired::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStepStreamEventThreadRunStepExpired {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStepStreamEventThreadRunStepExpiredEvent {
            #[default]
            #[serde(rename = "thread.run.step.expired")]
            ThreadRunStepExpired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepStreamEventThreadRunStepExpired<'a> {
            #[serde(rename = "event")]
            event: &'a RunStepStreamEventThreadRunStepExpiredEvent,
            #[serde(rename = "data")]
            data: &'a RunStepObject,
        }
        let Self { data } = self;
        RunStepStreamEventThreadRunStepExpired {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) expires."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepStreamEventThreadRunStepExpired {
    pub data: RunStepObject,
}
impl<'de> serde::Deserialize<'de> for RunStepStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepStreamEvent {
            ThreadRunStepCreated(#[allow(dead_code)] RunStepStreamEventThreadRunStepCreated),
            ThreadRunStepInProgress(#[allow(dead_code)] RunStepStreamEventThreadRunStepInProgress),
            ThreadRunStepDelta(#[allow(dead_code)] RunStepStreamEventThreadRunStepDelta),
            ThreadRunStepCompleted(#[allow(dead_code)] RunStepStreamEventThreadRunStepCompleted),
            ThreadRunStepFailed(#[allow(dead_code)] RunStepStreamEventThreadRunStepFailed),
            ThreadRunStepCancelled(#[allow(dead_code)] RunStepStreamEventThreadRunStepCancelled),
            ThreadRunStepExpired(#[allow(dead_code)] RunStepStreamEventThreadRunStepExpired),
        }
        Ok(match RunStepStreamEvent::deserialize(deserializer)? {
            RunStepStreamEvent::ThreadRunStepCreated(_v) => Self::ThreadRunStepCreated(_v),
            RunStepStreamEvent::ThreadRunStepInProgress(_v) => Self::ThreadRunStepInProgress(_v),
            RunStepStreamEvent::ThreadRunStepDelta(_v) => Self::ThreadRunStepDelta(_v),
            RunStepStreamEvent::ThreadRunStepCompleted(_v) => Self::ThreadRunStepCompleted(_v),
            RunStepStreamEvent::ThreadRunStepFailed(_v) => Self::ThreadRunStepFailed(_v),
            RunStepStreamEvent::ThreadRunStepCancelled(_v) => Self::ThreadRunStepCancelled(_v),
            RunStepStreamEvent::ThreadRunStepExpired(_v) => Self::ThreadRunStepExpired(_v),
        })
    }
}
impl serde::Serialize for RunStepStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepStreamEvent<'a> {
            ThreadRunStepCreated(#[allow(dead_code)] &'a RunStepStreamEventThreadRunStepCreated),
            ThreadRunStepInProgress(
                #[allow(dead_code)] &'a RunStepStreamEventThreadRunStepInProgress,
            ),
            ThreadRunStepDelta(#[allow(dead_code)] &'a RunStepStreamEventThreadRunStepDelta),
            ThreadRunStepCompleted(
                #[allow(dead_code)] &'a RunStepStreamEventThreadRunStepCompleted,
            ),
            ThreadRunStepFailed(#[allow(dead_code)] &'a RunStepStreamEventThreadRunStepFailed),
            ThreadRunStepCancelled(
                #[allow(dead_code)] &'a RunStepStreamEventThreadRunStepCancelled,
            ),
            ThreadRunStepExpired(#[allow(dead_code)] &'a RunStepStreamEventThreadRunStepExpired),
        }
        match self {
            Self::ThreadRunStepCreated(_v) => {
                RunStepStreamEvent::ThreadRunStepCreated(_v).serialize(serializer)
            }
            Self::ThreadRunStepInProgress(_v) => {
                RunStepStreamEvent::ThreadRunStepInProgress(_v).serialize(serializer)
            }
            Self::ThreadRunStepDelta(_v) => {
                RunStepStreamEvent::ThreadRunStepDelta(_v).serialize(serializer)
            }
            Self::ThreadRunStepCompleted(_v) => {
                RunStepStreamEvent::ThreadRunStepCompleted(_v).serialize(serializer)
            }
            Self::ThreadRunStepFailed(_v) => {
                RunStepStreamEvent::ThreadRunStepFailed(_v).serialize(serializer)
            }
            Self::ThreadRunStepCancelled(_v) => {
                RunStepStreamEvent::ThreadRunStepCancelled(_v).serialize(serializer)
            }
            Self::ThreadRunStepExpired(_v) => {
                RunStepStreamEvent::ThreadRunStepExpired(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepStreamEvent {
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is created."]
    ThreadRunStepCreated(RunStepStreamEventThreadRunStepCreated),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) moves to an `in_progress` state."]
    ThreadRunStepInProgress(RunStepStreamEventThreadRunStepInProgress),
    #[doc = "Occurs when parts of a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) are being streamed."]
    ThreadRunStepDelta(RunStepStreamEventThreadRunStepDelta),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is completed."]
    ThreadRunStepCompleted(RunStepStreamEventThreadRunStepCompleted),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) fails."]
    ThreadRunStepFailed(RunStepStreamEventThreadRunStepFailed),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is cancelled."]
    ThreadRunStepCancelled(RunStepStreamEventThreadRunStepCancelled),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) expires."]
    ThreadRunStepExpired(RunStepStreamEventThreadRunStepExpired),
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCreatedEvent {
            #[default]
            #[serde(rename = "thread.run.created")]
            ThreadRunCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunCreated {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunCreatedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunCreated { data, .. } =
            RunStreamEventThreadRunCreated::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCreatedEvent {
            #[default]
            #[serde(rename = "thread.run.created")]
            ThreadRunCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunCreated<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunCreatedEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunCreated {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a new [run](https://platform.openai.com/docs/api-reference/runs/object) is created."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunCreated {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunQueued {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunQueuedEvent {
            #[default]
            #[serde(rename = "thread.run.queued")]
            ThreadRunQueued,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunQueued {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunQueuedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunQueued { data, .. } =
            RunStreamEventThreadRunQueued::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunQueued {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunQueuedEvent {
            #[default]
            #[serde(rename = "thread.run.queued")]
            ThreadRunQueued,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunQueued<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunQueuedEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunQueued {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `queued` status."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunQueued {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunInProgress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunInProgressEvent {
            #[default]
            #[serde(rename = "thread.run.in_progress")]
            ThreadRunInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunInProgress {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunInProgressEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunInProgress { data, .. } =
            RunStreamEventThreadRunInProgress::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunInProgress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunInProgressEvent {
            #[default]
            #[serde(rename = "thread.run.in_progress")]
            ThreadRunInProgress,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunInProgress<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunInProgressEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunInProgress {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to an `in_progress` status."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunInProgress {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunRequiresAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunRequiresActionEvent {
            #[default]
            #[serde(rename = "thread.run.requires_action")]
            ThreadRunRequiresAction,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunRequiresAction {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunRequiresActionEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunRequiresAction { data, .. } =
            RunStreamEventThreadRunRequiresAction::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunRequiresAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunRequiresActionEvent {
            #[default]
            #[serde(rename = "thread.run.requires_action")]
            ThreadRunRequiresAction,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunRequiresAction<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunRequiresActionEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunRequiresAction {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `requires_action` status."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunRequiresAction {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunCompleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCompletedEvent {
            #[default]
            #[serde(rename = "thread.run.completed")]
            ThreadRunCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunCompleted {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunCompletedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunCompleted { data, .. } =
            RunStreamEventThreadRunCompleted::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCompletedEvent {
            #[default]
            #[serde(rename = "thread.run.completed")]
            ThreadRunCompleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunCompleted<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunCompletedEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunCompleted {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunCompleted {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunIncomplete {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunIncompleteEvent {
            #[default]
            #[serde(rename = "thread.run.incomplete")]
            ThreadRunIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunIncomplete {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunIncompleteEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunIncomplete { data, .. } =
            RunStreamEventThreadRunIncomplete::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunIncomplete {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunIncompleteEvent {
            #[default]
            #[serde(rename = "thread.run.incomplete")]
            ThreadRunIncomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunIncomplete<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunIncompleteEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunIncomplete {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) ends with status `incomplete`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunIncomplete {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunFailedEvent {
            #[default]
            #[serde(rename = "thread.run.failed")]
            ThreadRunFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunFailed {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunFailedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunFailed { data, .. } =
            RunStreamEventThreadRunFailed::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunFailedEvent {
            #[default]
            #[serde(rename = "thread.run.failed")]
            ThreadRunFailed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunFailed<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunFailedEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunFailed {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) fails."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunFailed {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunCancelling {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCancellingEvent {
            #[default]
            #[serde(rename = "thread.run.cancelling")]
            ThreadRunCancelling,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunCancelling {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunCancellingEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunCancelling { data, .. } =
            RunStreamEventThreadRunCancelling::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunCancelling {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCancellingEvent {
            #[default]
            #[serde(rename = "thread.run.cancelling")]
            ThreadRunCancelling,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunCancelling<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunCancellingEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunCancelling {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `cancelling` status."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunCancelling {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunCancelled {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCancelledEvent {
            #[default]
            #[serde(rename = "thread.run.cancelled")]
            ThreadRunCancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunCancelled {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunCancelledEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunCancelled { data, .. } =
            RunStreamEventThreadRunCancelled::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunCancelled {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunCancelledEvent {
            #[default]
            #[serde(rename = "thread.run.cancelled")]
            ThreadRunCancelled,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunCancelled<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunCancelledEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunCancelled {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is cancelled."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunCancelled {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEventThreadRunExpired {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunExpiredEvent {
            #[default]
            #[serde(rename = "thread.run.expired")]
            ThreadRunExpired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStreamEventThreadRunExpired {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: RunStreamEventThreadRunExpiredEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: RunObject,
        }
        let RunStreamEventThreadRunExpired { data, .. } =
            RunStreamEventThreadRunExpired::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for RunStreamEventThreadRunExpired {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStreamEventThreadRunExpiredEvent {
            #[default]
            #[serde(rename = "thread.run.expired")]
            ThreadRunExpired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStreamEventThreadRunExpired<'a> {
            #[serde(rename = "event")]
            event: &'a RunStreamEventThreadRunExpiredEvent,
            #[serde(rename = "data")]
            data: &'a RunObject,
        }
        let Self { data } = self;
        RunStreamEventThreadRunExpired {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) expires."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStreamEventThreadRunExpired {
    pub data: RunObject,
}
impl<'de> serde::Deserialize<'de> for RunStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStreamEvent {
            ThreadRunCreated(#[allow(dead_code)] RunStreamEventThreadRunCreated),
            ThreadRunQueued(#[allow(dead_code)] RunStreamEventThreadRunQueued),
            ThreadRunInProgress(#[allow(dead_code)] RunStreamEventThreadRunInProgress),
            ThreadRunRequiresAction(#[allow(dead_code)] RunStreamEventThreadRunRequiresAction),
            ThreadRunCompleted(#[allow(dead_code)] RunStreamEventThreadRunCompleted),
            ThreadRunIncomplete(#[allow(dead_code)] RunStreamEventThreadRunIncomplete),
            ThreadRunFailed(#[allow(dead_code)] RunStreamEventThreadRunFailed),
            ThreadRunCancelling(#[allow(dead_code)] RunStreamEventThreadRunCancelling),
            ThreadRunCancelled(#[allow(dead_code)] RunStreamEventThreadRunCancelled),
            ThreadRunExpired(#[allow(dead_code)] RunStreamEventThreadRunExpired),
        }
        Ok(match RunStreamEvent::deserialize(deserializer)? {
            RunStreamEvent::ThreadRunCreated(_v) => Self::ThreadRunCreated(_v),
            RunStreamEvent::ThreadRunQueued(_v) => Self::ThreadRunQueued(_v),
            RunStreamEvent::ThreadRunInProgress(_v) => Self::ThreadRunInProgress(_v),
            RunStreamEvent::ThreadRunRequiresAction(_v) => Self::ThreadRunRequiresAction(_v),
            RunStreamEvent::ThreadRunCompleted(_v) => Self::ThreadRunCompleted(_v),
            RunStreamEvent::ThreadRunIncomplete(_v) => Self::ThreadRunIncomplete(_v),
            RunStreamEvent::ThreadRunFailed(_v) => Self::ThreadRunFailed(_v),
            RunStreamEvent::ThreadRunCancelling(_v) => Self::ThreadRunCancelling(_v),
            RunStreamEvent::ThreadRunCancelled(_v) => Self::ThreadRunCancelled(_v),
            RunStreamEvent::ThreadRunExpired(_v) => Self::ThreadRunExpired(_v),
        })
    }
}
impl serde::Serialize for RunStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStreamEvent<'a> {
            ThreadRunCreated(#[allow(dead_code)] &'a RunStreamEventThreadRunCreated),
            ThreadRunQueued(#[allow(dead_code)] &'a RunStreamEventThreadRunQueued),
            ThreadRunInProgress(#[allow(dead_code)] &'a RunStreamEventThreadRunInProgress),
            ThreadRunRequiresAction(#[allow(dead_code)] &'a RunStreamEventThreadRunRequiresAction),
            ThreadRunCompleted(#[allow(dead_code)] &'a RunStreamEventThreadRunCompleted),
            ThreadRunIncomplete(#[allow(dead_code)] &'a RunStreamEventThreadRunIncomplete),
            ThreadRunFailed(#[allow(dead_code)] &'a RunStreamEventThreadRunFailed),
            ThreadRunCancelling(#[allow(dead_code)] &'a RunStreamEventThreadRunCancelling),
            ThreadRunCancelled(#[allow(dead_code)] &'a RunStreamEventThreadRunCancelled),
            ThreadRunExpired(#[allow(dead_code)] &'a RunStreamEventThreadRunExpired),
        }
        match self {
            Self::ThreadRunCreated(_v) => {
                RunStreamEvent::ThreadRunCreated(_v).serialize(serializer)
            }
            Self::ThreadRunQueued(_v) => RunStreamEvent::ThreadRunQueued(_v).serialize(serializer),
            Self::ThreadRunInProgress(_v) => {
                RunStreamEvent::ThreadRunInProgress(_v).serialize(serializer)
            }
            Self::ThreadRunRequiresAction(_v) => {
                RunStreamEvent::ThreadRunRequiresAction(_v).serialize(serializer)
            }
            Self::ThreadRunCompleted(_v) => {
                RunStreamEvent::ThreadRunCompleted(_v).serialize(serializer)
            }
            Self::ThreadRunIncomplete(_v) => {
                RunStreamEvent::ThreadRunIncomplete(_v).serialize(serializer)
            }
            Self::ThreadRunFailed(_v) => RunStreamEvent::ThreadRunFailed(_v).serialize(serializer),
            Self::ThreadRunCancelling(_v) => {
                RunStreamEvent::ThreadRunCancelling(_v).serialize(serializer)
            }
            Self::ThreadRunCancelled(_v) => {
                RunStreamEvent::ThreadRunCancelled(_v).serialize(serializer)
            }
            Self::ThreadRunExpired(_v) => {
                RunStreamEvent::ThreadRunExpired(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStreamEvent {
    #[doc = "Occurs when a new [run](https://platform.openai.com/docs/api-reference/runs/object) is created."]
    ThreadRunCreated(RunStreamEventThreadRunCreated),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `queued` status."]
    ThreadRunQueued(RunStreamEventThreadRunQueued),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to an `in_progress` status."]
    ThreadRunInProgress(RunStreamEventThreadRunInProgress),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `requires_action` status."]
    ThreadRunRequiresAction(RunStreamEventThreadRunRequiresAction),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is completed."]
    ThreadRunCompleted(RunStreamEventThreadRunCompleted),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) ends with status `incomplete`."]
    ThreadRunIncomplete(RunStreamEventThreadRunIncomplete),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) fails."]
    ThreadRunFailed(RunStreamEventThreadRunFailed),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `cancelling` status."]
    ThreadRunCancelling(RunStreamEventThreadRunCancelling),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is cancelled."]
    ThreadRunCancelled(RunStreamEventThreadRunCancelled),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) expires."]
    ThreadRunExpired(RunStreamEventThreadRunExpired),
}
impl<'de> serde::Deserialize<'de> for RunToolCallObjectFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunToolCallObjectFunction {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "arguments")]
            #[allow(dead_code)]
            arguments: String,
        }
        let RunToolCallObjectFunction {
            name, arguments, ..
        } = RunToolCallObjectFunction::deserialize(deserializer)?;
        Ok(Self { name, arguments })
    }
}
impl serde::Serialize for RunToolCallObjectFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunToolCallObjectFunction<'a> {
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let Self { name, arguments } = self;
        RunToolCallObjectFunction { name, arguments }.serialize(serializer)
    }
}
#[doc = "The function definition."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunToolCallObjectFunction {
    #[doc = "The name of the function."]
    pub name: String,
    #[doc = "The arguments that the model expects you to pass to the function."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for RunToolCallObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of tool call the output is required for. For now, this is always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunToolCallObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunToolCallObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RunToolCallObjectType,
            #[serde(rename = "function")]
            #[allow(dead_code)]
            function: RunToolCallObjectFunction,
        }
        let RunToolCallObject { id, function, .. } = RunToolCallObject::deserialize(deserializer)?;
        Ok(Self { id, function })
    }
}
impl serde::Serialize for RunToolCallObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of tool call the output is required for. For now, this is always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunToolCallObjectType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunToolCallObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a RunToolCallObjectType,
            #[serde(rename = "function")]
            function: &'a RunToolCallObjectFunction,
        }
        let Self { id, function } = self;
        RunToolCallObject {
            id,
            type_: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[doc = "Tool call objects"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunToolCallObject {
    #[doc = "The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint."]
    pub id: String,
    #[doc = "The function definition."]
    pub function: RunToolCallObjectFunction,
}
impl<'de> serde::Deserialize<'de> for Screenshot {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a screenshot action, this property is \nalways set to `screenshot`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ScreenshotType {
            #[default]
            #[serde(rename = "screenshot")]
            Screenshot,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Screenshot {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ScreenshotType,
        }
        let Screenshot { .. } = Screenshot::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for Screenshot {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a screenshot action, this property is \nalways set to `screenshot`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ScreenshotType {
            #[default]
            #[serde(rename = "screenshot")]
            Screenshot,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Screenshot<'a> {
            #[serde(rename = "type")]
            type_: &'a ScreenshotType,
        }
        let Self {} = self;
        Screenshot {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "A screenshot action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct Screenshot {}
impl<'de> serde::Deserialize<'de> for Scroll {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a scroll action, this property is \nalways set to `scroll`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ScrollType {
            #[default]
            #[serde(rename = "scroll")]
            Scroll,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Scroll {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ScrollType,
            #[serde(rename = "x")]
            #[allow(dead_code)]
            x: u64,
            #[serde(rename = "y")]
            #[allow(dead_code)]
            y: u64,
            #[serde(rename = "scroll_x")]
            #[allow(dead_code)]
            scroll_x: u64,
            #[serde(rename = "scroll_y")]
            #[allow(dead_code)]
            scroll_y: u64,
        }
        let Scroll {
            x,
            y,
            scroll_x,
            scroll_y,
            ..
        } = Scroll::deserialize(deserializer)?;
        Ok(Self {
            x,
            y,
            scroll_x,
            scroll_y,
        })
    }
}
impl serde::Serialize for Scroll {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a scroll action, this property is \nalways set to `scroll`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ScrollType {
            #[default]
            #[serde(rename = "scroll")]
            Scroll,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Scroll<'a> {
            #[serde(rename = "type")]
            type_: &'a ScrollType,
            #[serde(rename = "x")]
            x: &'a u64,
            #[serde(rename = "y")]
            y: &'a u64,
            #[serde(rename = "scroll_x")]
            scroll_x: &'a u64,
            #[serde(rename = "scroll_y")]
            scroll_y: &'a u64,
        }
        let Self {
            x,
            y,
            scroll_x,
            scroll_y,
        } = self;
        Scroll {
            type_: &Default::default(),
            x,
            y,
            scroll_x,
            scroll_y,
        }
        .serialize(serializer)
    }
}
#[doc = "A scroll action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct Scroll {
    #[doc = "The x-coordinate where the scroll occurred.\n"]
    pub x: u64,
    #[doc = "The y-coordinate where the scroll occurred.\n"]
    pub y: u64,
    #[doc = "The horizontal scroll distance.\n"]
    pub scroll_x: u64,
    #[doc = "The vertical scroll distance.\n"]
    pub scroll_y: u64,
}
impl<'de> serde::Deserialize<'de> for ServiceTier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierDefault {
            #[default]
            #[serde(rename = "default")]
            Default,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierFlex {
            #[default]
            #[serde(rename = "flex")]
            Flex,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ServiceTier {
            Auto(#[allow(dead_code)] ServiceTierAuto),
            Default(#[allow(dead_code)] ServiceTierDefault),
            Flex(#[allow(dead_code)] ServiceTierFlex),
        }
        Ok(match ServiceTier::deserialize(deserializer)? {
            ServiceTier::Auto(_) => Self::Auto,
            ServiceTier::Default(_) => Self::Default,
            ServiceTier::Flex(_) => Self::Flex,
        })
    }
}
impl serde::Serialize for ServiceTier {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierDefault {
            #[default]
            #[serde(rename = "default")]
            Default,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ServiceTierFlex {
            #[default]
            #[serde(rename = "flex")]
            Flex,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ServiceTier<'a> {
            Auto(#[allow(dead_code)] &'a ServiceTierAuto),
            Default(#[allow(dead_code)] &'a ServiceTierDefault),
            Flex(#[allow(dead_code)] &'a ServiceTierFlex),
        }
        match self {
            Self::Auto => ServiceTier::Auto(&Default::default()).serialize(serializer),
            Self::Default => ServiceTier::Default(&Default::default()).serialize(serializer),
            Self::Flex => ServiceTier::Flex(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "Specifies the latency tier to use for processing the request. This parameter is relevant for customers subscribed to the scale tier service:\n  - If set to 'auto', and the Project is Scale tier enabled, the system\n    will utilize scale tier credits until they are exhausted.\n  - If set to 'auto', and the Project is not Scale tier enabled, the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.\n  - If set to 'default', the request will be processed using the default service tier with a lower uptime SLA and no latency guarantee.\n  - If set to 'flex', the request will be processed with the Flex Processing service tier. [Learn more](https://platform.openai.com/docs/guides/flex-processing).\n  - When not set, the default behavior is 'auto'.\n\n  When this parameter is set, the response body will include the `service_tier` utilized.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ServiceTier {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "default"]
    Default,
    #[doc = "flex"]
    Flex,
}
impl<'de> serde::Deserialize<'de> for StaticChunkingStrategy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct StaticChunkingStrategy {
            #[serde(rename = "max_chunk_size_tokens")]
            #[allow(dead_code)]
            max_chunk_size_tokens: u64,
            #[serde(rename = "chunk_overlap_tokens")]
            #[allow(dead_code)]
            chunk_overlap_tokens: u64,
        }
        let StaticChunkingStrategy {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
            ..
        } = StaticChunkingStrategy::deserialize(deserializer)?;
        Ok(Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        })
    }
}
impl serde::Serialize for StaticChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct StaticChunkingStrategy<'a> {
            #[serde(rename = "max_chunk_size_tokens")]
            max_chunk_size_tokens: &'a u64,
            #[serde(rename = "chunk_overlap_tokens")]
            chunk_overlap_tokens: &'a u64,
        }
        let Self {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        } = self;
        StaticChunkingStrategy {
            max_chunk_size_tokens,
            chunk_overlap_tokens,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategy {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    pub max_chunk_size_tokens: u64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    pub chunk_overlap_tokens: u64,
}
impl<'de> serde::Deserialize<'de> for StaticChunkingStrategyRequestParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum StaticChunkingStrategyRequestParamType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct StaticChunkingStrategyRequestParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: StaticChunkingStrategyRequestParamType,
            #[serde(rename = "static")]
            #[allow(dead_code)]
            static_: StaticChunkingStrategy,
        }
        let StaticChunkingStrategyRequestParam { static_, .. } =
            StaticChunkingStrategyRequestParam::deserialize(deserializer)?;
        Ok(Self { static_ })
    }
}
impl serde::Serialize for StaticChunkingStrategyRequestParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum StaticChunkingStrategyRequestParamType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct StaticChunkingStrategyRequestParam<'a> {
            #[serde(rename = "type")]
            type_: &'a StaticChunkingStrategyRequestParamType,
            #[serde(rename = "static")]
            static_: &'a StaticChunkingStrategy,
        }
        let Self { static_ } = self;
        StaticChunkingStrategyRequestParam {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[doc = "Customize your own chunking strategy by setting chunk size and chunk overlap."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategyRequestParam {
    pub static_: StaticChunkingStrategy,
}
impl<'de> serde::Deserialize<'de> for StaticChunkingStrategyResponseParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum StaticChunkingStrategyResponseParamType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct StaticChunkingStrategyResponseParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: StaticChunkingStrategyResponseParamType,
            #[serde(rename = "static")]
            #[allow(dead_code)]
            static_: StaticChunkingStrategy,
        }
        let StaticChunkingStrategyResponseParam { static_, .. } =
            StaticChunkingStrategyResponseParam::deserialize(deserializer)?;
        Ok(Self { static_ })
    }
}
impl serde::Serialize for StaticChunkingStrategyResponseParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `static`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum StaticChunkingStrategyResponseParamType {
            #[default]
            #[serde(rename = "static")]
            Static,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct StaticChunkingStrategyResponseParam<'a> {
            #[serde(rename = "type")]
            type_: &'a StaticChunkingStrategyResponseParamType,
            #[serde(rename = "static")]
            static_: &'a StaticChunkingStrategy,
        }
        let Self { static_ } = self;
        StaticChunkingStrategyResponseParam {
            type_: &Default::default(),
            static_,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategyResponseParam {
    pub static_: StaticChunkingStrategy,
}
impl<'de> serde::Deserialize<'de> for StopConfiguration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum StopConfiguration {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<String>),
        }
        Ok(match StopConfiguration::deserialize(deserializer)? {
            StopConfiguration::String(_v) => Self::String(_v),
            StopConfiguration::Array(_v) => Self::Array(_v),
        })
    }
}
impl serde::Serialize for StopConfiguration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum StopConfiguration<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<String>),
        }
        match self {
            Self::String(_v) => StopConfiguration::String(_v).serialize(serializer),
            Self::Array(_v) => StopConfiguration::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "Not supported with latest reasoning models `o3` and `o4-mini`.\n\nUp to 4 sequences where the API will stop generating further tokens. The\nreturned text will not contain the stop sequence.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum StopConfiguration {
    String(String),
    Array(Vec<String>),
}
impl<'de> serde::Deserialize<'de> for SubmitToolOutputsRunRequestToolOutputs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct SubmitToolOutputsRunRequestToolOutputs {
            #[serde(rename = "tool_call_id")]
            #[allow(dead_code)]
            tool_call_id: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let SubmitToolOutputsRunRequestToolOutputs {
            tool_call_id,
            output,
            ..
        } = SubmitToolOutputsRunRequestToolOutputs::deserialize(deserializer)?;
        Ok(Self {
            tool_call_id,
            output,
        })
    }
}
impl serde::Serialize for SubmitToolOutputsRunRequestToolOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct SubmitToolOutputsRunRequestToolOutputs<'a> {
            #[serde(rename = "tool_call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_call_id: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let Self {
            tool_call_id,
            output,
        } = self;
        SubmitToolOutputsRunRequestToolOutputs {
            tool_call_id,
            output,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct SubmitToolOutputsRunRequestToolOutputs {
    #[doc = "The ID of the tool call in the `required_action` object within the run object the output is being submitted for."]
    #[builder(default)]
    pub tool_call_id: Option<String>,
    #[doc = "The output of the tool call to be submitted to continue the run."]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for SubmitToolOutputsRunRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct SubmitToolOutputsRunRequest {
            #[serde(rename = "tool_outputs")]
            #[allow(dead_code)]
            tool_outputs: Vec<SubmitToolOutputsRunRequestToolOutputs>,
            #[serde(rename = "stream")]
            #[allow(dead_code)]
            stream: Option<bool>,
        }
        let SubmitToolOutputsRunRequest {
            tool_outputs,
            stream,
            ..
        } = SubmitToolOutputsRunRequest::deserialize(deserializer)?;
        Ok(Self {
            tool_outputs,
            stream,
        })
    }
}
impl serde::Serialize for SubmitToolOutputsRunRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct SubmitToolOutputsRunRequest<'a> {
            #[serde(rename = "tool_outputs")]
            tool_outputs: &'a Vec<SubmitToolOutputsRunRequestToolOutputs>,
            #[serde(rename = "stream")]
            #[serde(skip_serializing_if = "Option::is_none")]
            stream: &'a Option<bool>,
        }
        let Self {
            tool_outputs,
            stream,
        } = self;
        SubmitToolOutputsRunRequest {
            tool_outputs,
            stream,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct SubmitToolOutputsRunRequest {
    #[doc = "A list of tools for which the outputs are being submitted."]
    pub tool_outputs: Vec<SubmitToolOutputsRunRequestToolOutputs>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[builder(default)]
    pub stream: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for TextResponseFormatConfiguration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum TextResponseFormatConfiguration {
            Text(#[allow(dead_code)] ResponseFormatText),
            JsonSchema(#[allow(dead_code)] TextResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] ResponseFormatJsonObject),
        }
        Ok(
            match TextResponseFormatConfiguration::deserialize(deserializer)? {
                TextResponseFormatConfiguration::Text(_v) => Self::Text(_v),
                TextResponseFormatConfiguration::JsonSchema(_v) => Self::JsonSchema(_v),
                TextResponseFormatConfiguration::JsonObject(_v) => Self::JsonObject(_v),
            },
        )
    }
}
impl serde::Serialize for TextResponseFormatConfiguration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum TextResponseFormatConfiguration<'a> {
            Text(#[allow(dead_code)] &'a ResponseFormatText),
            JsonSchema(#[allow(dead_code)] &'a TextResponseFormatJsonSchema),
            JsonObject(#[allow(dead_code)] &'a ResponseFormatJsonObject),
        }
        match self {
            Self::Text(_v) => TextResponseFormatConfiguration::Text(_v).serialize(serializer),
            Self::JsonSchema(_v) => {
                TextResponseFormatConfiguration::JsonSchema(_v).serialize(serializer)
            }
            Self::JsonObject(_v) => {
                TextResponseFormatConfiguration::JsonObject(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "An object specifying the format that the model must output.\n\nConfiguring `{ \"type\": \"json_schema\" }` enables Structured Outputs, \nwhich ensures the model will match your supplied JSON schema. Learn more in the \n[Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n\nThe default format is `{ \"type\": \"text\" }` with no additional options.\n\n**Not recommended for gpt-4o and newer models:**\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum TextResponseFormatConfiguration {
    Text(ResponseFormatText),
    JsonSchema(TextResponseFormatJsonSchema),
    JsonObject(ResponseFormatJsonObject),
}
impl<'de> serde::Deserialize<'de> for TextResponseFormatJsonSchema {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of response format being defined. Always `json_schema`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TextResponseFormatJsonSchemaType {
            #[default]
            #[serde(rename = "json_schema")]
            JsonSchema,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TextResponseFormatJsonSchema {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TextResponseFormatJsonSchemaType,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "schema")]
            #[allow(dead_code)]
            schema: ResponseFormatJsonSchemaSchema,
            #[serde(rename = "strict")]
            #[allow(dead_code)]
            strict: Option<bool>,
        }
        let TextResponseFormatJsonSchema {
            description,
            name,
            schema,
            strict,
            ..
        } = TextResponseFormatJsonSchema::deserialize(deserializer)?;
        Ok(Self {
            description,
            name,
            schema,
            strict,
        })
    }
}
impl serde::Serialize for TextResponseFormatJsonSchema {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of response format being defined. Always `json_schema`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TextResponseFormatJsonSchemaType {
            #[default]
            #[serde(rename = "json_schema")]
            JsonSchema,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TextResponseFormatJsonSchema<'a> {
            #[serde(rename = "type")]
            type_: &'a TextResponseFormatJsonSchemaType,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "schema")]
            schema: &'a ResponseFormatJsonSchemaSchema,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let Self {
            description,
            name,
            schema,
            strict,
        } = self;
        TextResponseFormatJsonSchema {
            type_: &Default::default(),
            description,
            name,
            schema,
            strict,
        }
        .serialize(serializer)
    }
}
#[doc = "JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TextResponseFormatJsonSchema {
    #[doc = "A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n"]
    pub name: String,
    pub schema: ResponseFormatJsonSchemaSchema,
    #[doc = "Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n"]
    #[builder(default)]
    pub strict: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for ThreadObjectToolResourcesCodeInterpreter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ThreadObjectToolResourcesCodeInterpreter {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let ThreadObjectToolResourcesCodeInterpreter { file_ids, .. } =
            ThreadObjectToolResourcesCodeInterpreter::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for ThreadObjectToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ThreadObjectToolResourcesCodeInterpreter<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        ThreadObjectToolResourcesCodeInterpreter { file_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ThreadObjectToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ThreadObjectToolResourcesFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ThreadObjectToolResourcesFileSearch {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let ThreadObjectToolResourcesFileSearch {
            vector_store_ids, ..
        } = ThreadObjectToolResourcesFileSearch::deserialize(deserializer)?;
        Ok(Self { vector_store_ids })
    }
}
impl serde::Serialize for ThreadObjectToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ThreadObjectToolResourcesFileSearch<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let Self { vector_store_ids } = self;
        ThreadObjectToolResourcesFileSearch { vector_store_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ThreadObjectToolResourcesFileSearch {
    #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for ThreadObjectToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ThreadObjectToolResources {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter: Option<ThreadObjectToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<ThreadObjectToolResourcesFileSearch>,
        }
        let ThreadObjectToolResources {
            code_interpreter,
            file_search,
            ..
        } = ThreadObjectToolResources::deserialize(deserializer)?;
        Ok(Self {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for ThreadObjectToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ThreadObjectToolResources<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<ThreadObjectToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<ThreadObjectToolResourcesFileSearch>,
        }
        let Self {
            code_interpreter,
            file_search,
        } = self;
        ThreadObjectToolResources {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ThreadObjectToolResources {
    #[builder(default)]
    pub code_interpreter: Option<ThreadObjectToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<ThreadObjectToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for ThreadObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `thread`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ThreadObjectObject {
            #[default]
            #[serde(rename = "thread")]
            Thread,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ThreadObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: ThreadObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<ThreadObjectToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let ThreadObject {
            id,
            created_at,
            tool_resources,
            metadata,
            ..
        } = ThreadObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            tool_resources,
            metadata,
        })
    }
}
impl serde::Serialize for ThreadObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `thread`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ThreadObjectObject {
            #[default]
            #[serde(rename = "thread")]
            Thread,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ThreadObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a ThreadObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<ThreadObjectToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            id,
            created_at,
            tool_resources,
            metadata,
        } = self;
        ThreadObject {
            id,
            object: &Default::default(),
            created_at,
            tool_resources,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ThreadObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the thread was created."]
    pub created_at: u64,
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<ThreadObjectToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for ThreadStreamEventThreadCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ThreadStreamEventThreadCreatedEvent {
            #[default]
            #[serde(rename = "thread.created")]
            ThreadCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ThreadStreamEventThreadCreated {
            #[serde(rename = "enabled")]
            #[allow(dead_code)]
            enabled: Option<bool>,
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: ThreadStreamEventThreadCreatedEvent,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: ThreadObject,
        }
        let ThreadStreamEventThreadCreated { enabled, data, .. } =
            ThreadStreamEventThreadCreated::deserialize(deserializer)?;
        Ok(Self { enabled, data })
    }
}
impl serde::Serialize for ThreadStreamEventThreadCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ThreadStreamEventThreadCreatedEvent {
            #[default]
            #[serde(rename = "thread.created")]
            ThreadCreated,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ThreadStreamEventThreadCreated<'a> {
            #[serde(rename = "enabled")]
            #[serde(skip_serializing_if = "Option::is_none")]
            enabled: &'a Option<bool>,
            #[serde(rename = "event")]
            event: &'a ThreadStreamEventThreadCreatedEvent,
            #[serde(rename = "data")]
            data: &'a ThreadObject,
        }
        let Self { enabled, data } = self;
        ThreadStreamEventThreadCreated {
            enabled,
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[doc = "Occurs when a new [thread](https://platform.openai.com/docs/api-reference/threads/object) is created."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ThreadStreamEventThreadCreated {
    #[doc = "Whether to enable input audio transcription."]
    #[builder(default)]
    pub enabled: Option<bool>,
    pub data: ThreadObject,
}
impl<'de> serde::Deserialize<'de> for ThreadStreamEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ThreadStreamEvent {
            ThreadCreated(#[allow(dead_code)] ThreadStreamEventThreadCreated),
        }
        Ok(match ThreadStreamEvent::deserialize(deserializer)? {
            ThreadStreamEvent::ThreadCreated(_v) => Self::ThreadCreated(_v),
        })
    }
}
impl serde::Serialize for ThreadStreamEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ThreadStreamEvent<'a> {
            ThreadCreated(#[allow(dead_code)] &'a ThreadStreamEventThreadCreated),
        }
        match self {
            Self::ThreadCreated(_v) => ThreadStreamEvent::ThreadCreated(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ThreadStreamEvent {
    #[doc = "Occurs when a new [thread](https://platform.openai.com/docs/api-reference/threads/object) is created."]
    ThreadCreated(ThreadStreamEventThreadCreated),
}
impl<'de> serde::Deserialize<'de> for ToggleCertificatesRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ToggleCertificatesRequest {
            #[serde(rename = "certificate_ids")]
            #[allow(dead_code)]
            certificate_ids: Vec<String>,
        }
        let ToggleCertificatesRequest {
            certificate_ids, ..
        } = ToggleCertificatesRequest::deserialize(deserializer)?;
        Ok(Self { certificate_ids })
    }
}
impl serde::Serialize for ToggleCertificatesRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ToggleCertificatesRequest<'a> {
            #[serde(rename = "certificate_ids")]
            certificate_ids: &'a Vec<String>,
        }
        let Self { certificate_ids } = self;
        ToggleCertificatesRequest { certificate_ids }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ToggleCertificatesRequest {
    pub certificate_ids: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for Tool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum Tool {
            FunctionTool(#[allow(dead_code)] FunctionTool),
            FileSearchTool(#[allow(dead_code)] FileSearchTool),
            WebSearchPreviewTool(#[allow(dead_code)] WebSearchPreviewTool),
            ComputerUsePreviewTool(#[allow(dead_code)] ComputerUsePreviewTool),
            McpTool(#[allow(dead_code)] McpTool),
            CodeInterpreterTool(#[allow(dead_code)] CodeInterpreterTool),
            ImageGenTool(#[allow(dead_code)] ImageGenTool),
            LocalShellTool(#[allow(dead_code)] LocalShellTool),
        }
        Ok(match Tool::deserialize(deserializer)? {
            Tool::FunctionTool(_v) => Self::FunctionTool(_v),
            Tool::FileSearchTool(_v) => Self::FileSearchTool(_v),
            Tool::WebSearchPreviewTool(_v) => Self::WebSearchPreviewTool(_v),
            Tool::ComputerUsePreviewTool(_v) => Self::ComputerUsePreviewTool(_v),
            Tool::McpTool(_v) => Self::McpTool(_v),
            Tool::CodeInterpreterTool(_v) => Self::CodeInterpreterTool(_v),
            Tool::ImageGenTool(_v) => Self::ImageGenTool(_v),
            Tool::LocalShellTool(_v) => Self::LocalShellTool(_v),
        })
    }
}
impl serde::Serialize for Tool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum Tool<'a> {
            FunctionTool(#[allow(dead_code)] &'a FunctionTool),
            FileSearchTool(#[allow(dead_code)] &'a FileSearchTool),
            WebSearchPreviewTool(#[allow(dead_code)] &'a WebSearchPreviewTool),
            ComputerUsePreviewTool(#[allow(dead_code)] &'a ComputerUsePreviewTool),
            McpTool(#[allow(dead_code)] &'a McpTool),
            CodeInterpreterTool(#[allow(dead_code)] &'a CodeInterpreterTool),
            ImageGenTool(#[allow(dead_code)] &'a ImageGenTool),
            LocalShellTool(#[allow(dead_code)] &'a LocalShellTool),
        }
        match self {
            Self::FunctionTool(_v) => Tool::FunctionTool(_v).serialize(serializer),
            Self::FileSearchTool(_v) => Tool::FileSearchTool(_v).serialize(serializer),
            Self::WebSearchPreviewTool(_v) => Tool::WebSearchPreviewTool(_v).serialize(serializer),
            Self::ComputerUsePreviewTool(_v) => {
                Tool::ComputerUsePreviewTool(_v).serialize(serializer)
            }
            Self::McpTool(_v) => Tool::McpTool(_v).serialize(serializer),
            Self::CodeInterpreterTool(_v) => Tool::CodeInterpreterTool(_v).serialize(serializer),
            Self::ImageGenTool(_v) => Tool::ImageGenTool(_v).serialize(serializer),
            Self::LocalShellTool(_v) => Tool::LocalShellTool(_v).serialize(serializer),
        }
    }
}
#[doc = "A tool that can be used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Tool {
    FunctionTool(FunctionTool),
    FileSearchTool(FileSearchTool),
    WebSearchPreviewTool(WebSearchPreviewTool),
    ComputerUsePreviewTool(ComputerUsePreviewTool),
    McpTool(McpTool),
    CodeInterpreterTool(CodeInterpreterTool),
    ImageGenTool(ImageGenTool),
    LocalShellTool(LocalShellTool),
}
impl<'de> serde::Deserialize<'de> for ToolChoiceFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "For function calling, the type is always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceFunctionType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ToolChoiceFunction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ToolChoiceFunctionType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
        }
        let ToolChoiceFunction { name, .. } = ToolChoiceFunction::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ToolChoiceFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "For function calling, the type is always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceFunctionType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ToolChoiceFunction<'a> {
            #[serde(rename = "type")]
            type_: &'a ToolChoiceFunctionType,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ToolChoiceFunction {
            type_: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Use this option to force the model to call a specific function.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ToolChoiceFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ToolChoiceOptions {
            None(#[allow(dead_code)] ToolChoiceOptionsNone),
            Auto(#[allow(dead_code)] ToolChoiceOptionsAuto),
            Required(#[allow(dead_code)] ToolChoiceOptionsRequired),
        }
        Ok(match ToolChoiceOptions::deserialize(deserializer)? {
            ToolChoiceOptions::None(_) => Self::None,
            ToolChoiceOptions::Auto(_) => Self::Auto,
            ToolChoiceOptions::Required(_) => Self::Required,
        })
    }
}
impl serde::Serialize for ToolChoiceOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsNone {
            #[default]
            #[serde(rename = "none")]
            None,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceOptionsRequired {
            #[default]
            #[serde(rename = "required")]
            Required,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ToolChoiceOptions<'a> {
            None(#[allow(dead_code)] &'a ToolChoiceOptionsNone),
            Auto(#[allow(dead_code)] &'a ToolChoiceOptionsAuto),
            Required(#[allow(dead_code)] &'a ToolChoiceOptionsRequired),
        }
        match self {
            Self::None => ToolChoiceOptions::None(&Default::default()).serialize(serializer),
            Self::Auto => ToolChoiceOptions::Auto(&Default::default()).serialize(serializer),
            Self::Required => {
                ToolChoiceOptions::Required(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "Controls which (if any) tool is called by the model.\n\n`none` means the model will not call any tool and instead generates a message.\n\n`auto` means the model can pick between generating a message or calling one or\nmore tools.\n\n`required` means the model must call one or more tools.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ToolChoiceOptions {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    #[doc = "required"]
    Required,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceTypesType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeFileSearch {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeWebSearchPreview {
            #[default]
            #[serde(rename = "web_search_preview")]
            WebSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeComputerUsePreview {
            #[default]
            #[serde(rename = "computer_use_preview")]
            ComputerUsePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeWebSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "web_search_preview_2025_03_11")]
            WebSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeImageGeneration {
            #[default]
            #[serde(rename = "image_generation")]
            ImageGeneration,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeCodeInterpreter {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeMcp {
            #[default]
            #[serde(rename = "mcp")]
            Mcp,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ToolChoiceTypesType {
            FileSearch(#[allow(dead_code)] ToolChoiceTypesTypeFileSearch),
            WebSearchPreview(#[allow(dead_code)] ToolChoiceTypesTypeWebSearchPreview),
            ComputerUsePreview(#[allow(dead_code)] ToolChoiceTypesTypeComputerUsePreview),
            WebSearchPreview2025_03_11(
                #[allow(dead_code)] ToolChoiceTypesTypeWebSearchPreview2025_03_11,
            ),
            ImageGeneration(#[allow(dead_code)] ToolChoiceTypesTypeImageGeneration),
            CodeInterpreter(#[allow(dead_code)] ToolChoiceTypesTypeCodeInterpreter),
            Mcp(#[allow(dead_code)] ToolChoiceTypesTypeMcp),
        }
        Ok(match ToolChoiceTypesType::deserialize(deserializer)? {
            ToolChoiceTypesType::FileSearch(_) => Self::FileSearch,
            ToolChoiceTypesType::WebSearchPreview(_) => Self::WebSearchPreview,
            ToolChoiceTypesType::ComputerUsePreview(_) => Self::ComputerUsePreview,
            ToolChoiceTypesType::WebSearchPreview2025_03_11(_) => Self::WebSearchPreview2025_03_11,
            ToolChoiceTypesType::ImageGeneration(_) => Self::ImageGeneration,
            ToolChoiceTypesType::CodeInterpreter(_) => Self::CodeInterpreter,
            ToolChoiceTypesType::Mcp(_) => Self::Mcp,
        })
    }
}
impl serde::Serialize for ToolChoiceTypesType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeFileSearch {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeWebSearchPreview {
            #[default]
            #[serde(rename = "web_search_preview")]
            WebSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeComputerUsePreview {
            #[default]
            #[serde(rename = "computer_use_preview")]
            ComputerUsePreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeWebSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "web_search_preview_2025_03_11")]
            WebSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeImageGeneration {
            #[default]
            #[serde(rename = "image_generation")]
            ImageGeneration,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeCodeInterpreter {
            #[default]
            #[serde(rename = "code_interpreter")]
            CodeInterpreter,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ToolChoiceTypesTypeMcp {
            #[default]
            #[serde(rename = "mcp")]
            Mcp,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ToolChoiceTypesType<'a> {
            FileSearch(#[allow(dead_code)] &'a ToolChoiceTypesTypeFileSearch),
            WebSearchPreview(#[allow(dead_code)] &'a ToolChoiceTypesTypeWebSearchPreview),
            ComputerUsePreview(#[allow(dead_code)] &'a ToolChoiceTypesTypeComputerUsePreview),
            WebSearchPreview2025_03_11(
                #[allow(dead_code)] &'a ToolChoiceTypesTypeWebSearchPreview2025_03_11,
            ),
            ImageGeneration(#[allow(dead_code)] &'a ToolChoiceTypesTypeImageGeneration),
            CodeInterpreter(#[allow(dead_code)] &'a ToolChoiceTypesTypeCodeInterpreter),
            Mcp(#[allow(dead_code)] &'a ToolChoiceTypesTypeMcp),
        }
        match self {
            Self::FileSearch => {
                ToolChoiceTypesType::FileSearch(&Default::default()).serialize(serializer)
            }
            Self::WebSearchPreview => {
                ToolChoiceTypesType::WebSearchPreview(&Default::default()).serialize(serializer)
            }
            Self::ComputerUsePreview => {
                ToolChoiceTypesType::ComputerUsePreview(&Default::default()).serialize(serializer)
            }
            Self::WebSearchPreview2025_03_11 => {
                ToolChoiceTypesType::WebSearchPreview2025_03_11(&Default::default())
                    .serialize(serializer)
            }
            Self::ImageGeneration => {
                ToolChoiceTypesType::ImageGeneration(&Default::default()).serialize(serializer)
            }
            Self::CodeInterpreter => {
                ToolChoiceTypesType::CodeInterpreter(&Default::default()).serialize(serializer)
            }
            Self::Mcp => ToolChoiceTypesType::Mcp(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The type of hosted tool the model should to use. Learn more about\n[built-in tools](https://platform.openai.com/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n- `code_interpreter`\n- `mcp`\n- `image_generation`\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ToolChoiceTypesType {
    #[doc = "file_search"]
    FileSearch,
    #[doc = "web_search_preview"]
    WebSearchPreview,
    #[doc = "computer_use_preview"]
    ComputerUsePreview,
    #[doc = "web_search_preview_2025_03_11"]
    WebSearchPreview2025_03_11,
    #[doc = "image_generation"]
    ImageGeneration,
    #[doc = "code_interpreter"]
    CodeInterpreter,
    #[doc = "mcp"]
    Mcp,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceTypes {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ToolChoiceTypes {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ToolChoiceTypesType,
        }
        let ToolChoiceTypes { type_, .. } = ToolChoiceTypes::deserialize(deserializer)?;
        Ok(Self { type_ })
    }
}
impl serde::Serialize for ToolChoiceTypes {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ToolChoiceTypes<'a> {
            #[serde(rename = "type")]
            type_: &'a ToolChoiceTypesType,
        }
        let Self { type_ } = self;
        ToolChoiceTypes { type_ }.serialize(serializer)
    }
}
#[doc = "Indicates that the model should use a built-in tool to generate a response.\n[Learn more about built-in tools](https://platform.openai.com/docs/guides/tools).\n"]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ToolChoiceTypes {
    #[doc = "The type of hosted tool the model should to use. Learn more about\n[built-in tools](https://platform.openai.com/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n- `code_interpreter`\n- `mcp`\n- `image_generation`\n"]
    pub type_: ToolChoiceTypesType,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDeltaEventLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptTextDeltaEventLogprob {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: Option<String>,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: Option<f64>,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<u64>>,
        }
        let TranscriptTextDeltaEventLogprob {
            token,
            logprob,
            bytes,
            ..
        } = TranscriptTextDeltaEventLogprob::deserialize(deserializer)?;
        Ok(Self {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for TranscriptTextDeltaEventLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptTextDeltaEventLogprob<'a> {
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token: &'a Option<String>,
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprob: &'a Option<f64>,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<u64>>,
        }
        let Self {
            token,
            logprob,
            bytes,
        } = self;
        TranscriptTextDeltaEventLogprob {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDeltaEventLogprob {
    #[doc = "The token that was used to generate the log probability.\n"]
    #[builder(default)]
    pub token: Option<String>,
    #[doc = "The log probability of the token.\n"]
    #[builder(default)]
    pub logprob: Option<f64>,
    #[doc = "The bytes that were used to generate the log probability.\n"]
    #[builder(default)]
    pub bytes: Option<Vec<u64>>,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `transcript.text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TranscriptTextDeltaEventType {
            #[default]
            #[serde(rename = "transcript.text.delta")]
            TranscriptTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptTextDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TranscriptTextDeltaEventType,
            #[serde(rename = "delta")]
            #[allow(dead_code)]
            delta: String,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<TranscriptTextDeltaEventLogprob>>,
        }
        let TranscriptTextDeltaEvent {
            delta, logprobs, ..
        } = TranscriptTextDeltaEvent::deserialize(deserializer)?;
        Ok(Self { delta, logprobs })
    }
}
impl serde::Serialize for TranscriptTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `transcript.text.delta`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TranscriptTextDeltaEventType {
            #[default]
            #[serde(rename = "transcript.text.delta")]
            TranscriptTextDelta,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptTextDeltaEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a TranscriptTextDeltaEventType,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<TranscriptTextDeltaEventLogprob>>,
        }
        let Self { delta, logprobs } = self;
        TranscriptTextDeltaEvent {
            type_: &Default::default(),
            delta,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when there is an additional text delta. This is also the first event emitted when the transcription starts. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDeltaEvent {
    #[doc = "The text delta that was additionally transcribed.\n"]
    pub delta: String,
    #[doc = "The log probabilities of the delta. Only included if you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.\n"]
    #[builder(default)]
    pub logprobs: Option<Vec<TranscriptTextDeltaEventLogprob>>,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDoneEventLogprob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptTextDoneEventLogprob {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: Option<String>,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: Option<f64>,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Option<Vec<u64>>,
        }
        let TranscriptTextDoneEventLogprob {
            token,
            logprob,
            bytes,
            ..
        } = TranscriptTextDoneEventLogprob::deserialize(deserializer)?;
        Ok(Self {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for TranscriptTextDoneEventLogprob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptTextDoneEventLogprob<'a> {
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            token: &'a Option<String>,
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprob: &'a Option<f64>,
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            bytes: &'a Option<Vec<u64>>,
        }
        let Self {
            token,
            logprob,
            bytes,
        } = self;
        TranscriptTextDoneEventLogprob {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDoneEventLogprob {
    #[doc = "The token that was used to generate the log probability.\n"]
    #[builder(default)]
    pub token: Option<String>,
    #[doc = "The log probability of the token.\n"]
    #[builder(default)]
    pub logprob: Option<f64>,
    #[doc = "The bytes that were used to generate the log probability.\n"]
    #[builder(default)]
    pub bytes: Option<Vec<u64>>,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the event. Always `transcript.text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TranscriptTextDoneEventType {
            #[default]
            #[serde(rename = "transcript.text.done")]
            TranscriptTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptTextDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TranscriptTextDoneEventType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<TranscriptTextDoneEventLogprob>>,
        }
        let TranscriptTextDoneEvent { text, logprobs, .. } =
            TranscriptTextDoneEvent::deserialize(deserializer)?;
        Ok(Self { text, logprobs })
    }
}
impl serde::Serialize for TranscriptTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the event. Always `transcript.text.done`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TranscriptTextDoneEventType {
            #[default]
            #[serde(rename = "transcript.text.done")]
            TranscriptTextDone,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptTextDoneEvent<'a> {
            #[serde(rename = "type")]
            type_: &'a TranscriptTextDoneEventType,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<TranscriptTextDoneEventLogprob>>,
        }
        let Self { text, logprobs } = self;
        TranscriptTextDoneEvent {
            type_: &Default::default(),
            text,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "Emitted when the transcription is complete. Contains the complete transcription text. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDoneEvent {
    #[doc = "The text that was transcribed.\n"]
    pub text: String,
    #[doc = "The log probabilities of the individual tokens in the transcription. Only included if you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.\n"]
    #[builder(default)]
    pub logprobs: Option<Vec<TranscriptTextDoneEventLogprob>>,
}
#[doc = "Controls how the audio is cut into chunks. When set to `\"auto\"`, the server first normalizes loudness and then uses voice activity detection (VAD) to choose boundaries. `server_vad` object can be provided to tweak VAD detection parameters manually. If unset, the audio is transcribed as a single block. "]
pub type TranscriptionChunkingStrategy = String;
#[derive(Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize)]
pub enum TranscriptionInclude {
    #[default]
    #[serde(rename = "logprobs")]
    Logprobs,
}
impl<'de> serde::Deserialize<'de> for TranscriptionSegment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptionSegment {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: u64,
            #[serde(rename = "seek")]
            #[allow(dead_code)]
            seek: u64,
            #[serde(rename = "start")]
            #[allow(dead_code)]
            start: f64,
            #[serde(rename = "end")]
            #[allow(dead_code)]
            end: f64,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "tokens")]
            #[allow(dead_code)]
            tokens: Vec<u64>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: f64,
            #[serde(rename = "avg_logprob")]
            #[allow(dead_code)]
            avg_logprob: f64,
            #[serde(rename = "compression_ratio")]
            #[allow(dead_code)]
            compression_ratio: f64,
            #[serde(rename = "no_speech_prob")]
            #[allow(dead_code)]
            no_speech_prob: f64,
        }
        let TranscriptionSegment {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
            ..
        } = TranscriptionSegment::deserialize(deserializer)?;
        Ok(Self {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
        })
    }
}
impl serde::Serialize for TranscriptionSegment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptionSegment<'a> {
            #[serde(rename = "id")]
            id: &'a u64,
            #[serde(rename = "seek")]
            seek: &'a u64,
            #[serde(rename = "start")]
            start: &'a f64,
            #[serde(rename = "end")]
            end: &'a f64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "tokens")]
            tokens: &'a Vec<u64>,
            #[serde(rename = "temperature")]
            temperature: &'a f64,
            #[serde(rename = "avg_logprob")]
            avg_logprob: &'a f64,
            #[serde(rename = "compression_ratio")]
            compression_ratio: &'a f64,
            #[serde(rename = "no_speech_prob")]
            no_speech_prob: &'a f64,
        }
        let Self {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
        } = self;
        TranscriptionSegment {
            id,
            seek,
            start,
            end,
            text,
            tokens,
            temperature,
            avg_logprob,
            compression_ratio,
            no_speech_prob,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptionSegment {
    #[doc = "Unique identifier of the segment."]
    pub id: u64,
    #[doc = "Seek offset of the segment."]
    pub seek: u64,
    #[doc = "Start time of the segment in seconds."]
    pub start: f64,
    #[doc = "End time of the segment in seconds."]
    pub end: f64,
    #[doc = "Text content of the segment."]
    pub text: String,
    #[doc = "Array of token IDs for the text content."]
    pub tokens: Vec<u64>,
    #[doc = "Temperature parameter used for generating the segment."]
    pub temperature: f64,
    #[doc = "Average logprob of the segment. If the value is lower than -1, consider the logprobs failed."]
    pub avg_logprob: f64,
    #[doc = "Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed."]
    pub compression_ratio: f64,
    #[doc = "Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent."]
    pub no_speech_prob: f64,
}
impl<'de> serde::Deserialize<'de> for TranscriptionWord {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptionWord {
            #[serde(rename = "word")]
            #[allow(dead_code)]
            word: String,
            #[serde(rename = "start")]
            #[allow(dead_code)]
            start: f64,
            #[serde(rename = "end")]
            #[allow(dead_code)]
            end: f64,
        }
        let TranscriptionWord {
            word, start, end, ..
        } = TranscriptionWord::deserialize(deserializer)?;
        Ok(Self { word, start, end })
    }
}
impl serde::Serialize for TranscriptionWord {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptionWord<'a> {
            #[serde(rename = "word")]
            word: &'a String,
            #[serde(rename = "start")]
            start: &'a f64,
            #[serde(rename = "end")]
            end: &'a f64,
        }
        let Self { word, start, end } = self;
        TranscriptionWord { word, start, end }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptionWord {
    #[doc = "The text content of the word."]
    pub word: String,
    #[doc = "Start time of the word in seconds."]
    pub start: f64,
    #[doc = "End time of the word in seconds."]
    pub end: f64,
}
impl<'de> serde::Deserialize<'de> for TruncationObjectType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TruncationObjectTypeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TruncationObjectTypeLastMessages {
            #[default]
            #[serde(rename = "last_messages")]
            LastMessages,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum TruncationObjectType {
            Auto(#[allow(dead_code)] TruncationObjectTypeAuto),
            LastMessages(#[allow(dead_code)] TruncationObjectTypeLastMessages),
        }
        Ok(match TruncationObjectType::deserialize(deserializer)? {
            TruncationObjectType::Auto(_) => Self::Auto,
            TruncationObjectType::LastMessages(_) => Self::LastMessages,
        })
    }
}
impl serde::Serialize for TruncationObjectType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TruncationObjectTypeAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TruncationObjectTypeLastMessages {
            #[default]
            #[serde(rename = "last_messages")]
            LastMessages,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum TruncationObjectType<'a> {
            Auto(#[allow(dead_code)] &'a TruncationObjectTypeAuto),
            LastMessages(#[allow(dead_code)] &'a TruncationObjectTypeLastMessages),
        }
        match self {
            Self::Auto => TruncationObjectType::Auto(&Default::default()).serialize(serializer),
            Self::LastMessages => {
                TruncationObjectType::LastMessages(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum TruncationObjectType {
    #[doc = "auto"]
    Auto,
    #[doc = "last_messages"]
    LastMessages,
}
impl<'de> serde::Deserialize<'de> for TruncationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TruncationObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TruncationObjectType,
            #[serde(rename = "last_messages")]
            #[allow(dead_code)]
            last_messages: Option<u64>,
        }
        let TruncationObject {
            type_,
            last_messages,
            ..
        } = TruncationObject::deserialize(deserializer)?;
        Ok(Self {
            type_,
            last_messages,
        })
    }
}
impl serde::Serialize for TruncationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TruncationObject<'a> {
            #[serde(rename = "type")]
            type_: &'a TruncationObjectType,
            #[serde(rename = "last_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_messages: &'a Option<u64>,
        }
        let Self {
            type_,
            last_messages,
        } = self;
        TruncationObject {
            type_,
            last_messages,
        }
        .serialize(serializer)
    }
}
#[doc = "Controls for how a thread will be truncated prior to the run. Use this to control the intial context window of the run."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct TruncationObject {
    #[doc = "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."]
    pub type_: TruncationObjectType,
    #[doc = "The number of most recent messages from the thread when constructing the context for the run."]
    #[builder(default)]
    pub last_messages: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for Type {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a type action, this property is \nalways set to `type`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TypeType {
            #[default]
            #[serde(rename = "type")]
            Type,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Type {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: TypeType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let Type { text, .. } = Type::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for Type {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a type action, this property is \nalways set to `type`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum TypeType {
            #[default]
            #[serde(rename = "type")]
            Type,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Type<'a> {
            #[serde(rename = "type")]
            type_: &'a TypeType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        Type {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "An action to type in text.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Type {
    #[doc = "The text to type.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for UpdateVectorStoreFileAttributesRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UpdateVectorStoreFileAttributesRequest {
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
        }
        let UpdateVectorStoreFileAttributesRequest { attributes, .. } =
            UpdateVectorStoreFileAttributesRequest::deserialize(deserializer)?;
        Ok(Self { attributes })
    }
}
impl serde::Serialize for UpdateVectorStoreFileAttributesRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UpdateVectorStoreFileAttributesRequest<'a> {
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
        }
        let Self { attributes } = self;
        UpdateVectorStoreFileAttributesRequest { attributes }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UpdateVectorStoreFileAttributesRequest {
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
}
impl<'de> serde::Deserialize<'de> for UpdateVectorStoreRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UpdateVectorStoreRequest {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "expires_after")]
            #[allow(dead_code)]
            expires_after: Option<VectorStoreExpirationAfter>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let UpdateVectorStoreRequest {
            name,
            expires_after,
            metadata,
            ..
        } = UpdateVectorStoreRequest::deserialize(deserializer)?;
        Ok(Self {
            name,
            expires_after,
            metadata,
        })
    }
}
impl serde::Serialize for UpdateVectorStoreRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UpdateVectorStoreRequest<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<VectorStoreExpirationAfter>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            name,
            expires_after,
            metadata,
        } = self;
        UpdateVectorStoreRequest {
            name,
            expires_after,
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct UpdateVectorStoreRequest {
    #[doc = "The name of the vector store."]
    #[builder(default)]
    pub name: Option<String>,
    #[builder(default)]
    pub expires_after: Option<VectorStoreExpirationAfter>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for UploadStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusPending {
            #[default]
            #[serde(rename = "pending")]
            Pending,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum UploadStatus {
            Pending(#[allow(dead_code)] UploadStatusPending),
            Completed(#[allow(dead_code)] UploadStatusCompleted),
            Cancelled(#[allow(dead_code)] UploadStatusCancelled),
            Expired(#[allow(dead_code)] UploadStatusExpired),
        }
        Ok(match UploadStatus::deserialize(deserializer)? {
            UploadStatus::Pending(_) => Self::Pending,
            UploadStatus::Completed(_) => Self::Completed,
            UploadStatus::Cancelled(_) => Self::Cancelled,
            UploadStatus::Expired(_) => Self::Expired,
        })
    }
}
impl serde::Serialize for UploadStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusPending {
            #[default]
            #[serde(rename = "pending")]
            Pending,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum UploadStatus<'a> {
            Pending(#[allow(dead_code)] &'a UploadStatusPending),
            Completed(#[allow(dead_code)] &'a UploadStatusCompleted),
            Cancelled(#[allow(dead_code)] &'a UploadStatusCancelled),
            Expired(#[allow(dead_code)] &'a UploadStatusExpired),
        }
        match self {
            Self::Pending => UploadStatus::Pending(&Default::default()).serialize(serializer),
            Self::Completed => UploadStatus::Completed(&Default::default()).serialize(serializer),
            Self::Cancelled => UploadStatus::Cancelled(&Default::default()).serialize(serializer),
            Self::Expired => UploadStatus::Expired(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the Upload."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum UploadStatus {
    #[doc = "pending"]
    Pending,
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "expired"]
    Expired,
}
impl<'de> serde::Deserialize<'de> for Upload {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always \"upload\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadObject {
            #[default]
            #[serde(rename = "upload")]
            Upload,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Upload {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: String,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: u64,
            #[serde(rename = "purpose")]
            #[allow(dead_code)]
            purpose: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: UploadStatus,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: u64,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UploadObject,
            #[serde(rename = "file")]
            #[allow(dead_code)]
            file: Option<OpenAiFile>,
        }
        let Upload {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            file,
            ..
        } = Upload::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            file,
        })
    }
}
impl serde::Serialize for Upload {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always \"upload\"."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadObject {
            #[default]
            #[serde(rename = "upload")]
            Upload,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Upload<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "bytes")]
            bytes: &'a u64,
            #[serde(rename = "purpose")]
            purpose: &'a String,
            #[serde(rename = "status")]
            status: &'a UploadStatus,
            #[serde(rename = "expires_at")]
            expires_at: &'a u64,
            #[serde(rename = "object")]
            object: &'a UploadObject,
            #[serde(rename = "file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file: &'a Option<OpenAiFile>,
        }
        let Self {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            file,
        } = self;
        Upload {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            object: &Default::default(),
            file,
        }
        .serialize(serializer)
    }
}
#[doc = "The Upload object can accept byte chunks in the form of Parts.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Upload {
    #[doc = "The Upload unique identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the Upload was created."]
    pub created_at: u64,
    #[doc = "The name of the file to be uploaded."]
    pub filename: String,
    #[doc = "The intended number of bytes to be uploaded."]
    pub bytes: u64,
    #[doc = "The intended purpose of the file. [Please refer here](https://platform.openai.com/docs/api-reference/files/object#files/object-purpose) for acceptable values."]
    pub purpose: String,
    #[doc = "The status of the Upload."]
    pub status: UploadStatus,
    #[doc = "The Unix timestamp (in seconds) for when the Upload will expire."]
    pub expires_at: u64,
    #[doc = "The ready File object after the Upload is completed."]
    #[builder(default)]
    pub file: Option<OpenAiFile>,
}
impl<'de> serde::Deserialize<'de> for UploadCertificateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UploadCertificateRequest {
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: Option<String>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: String,
        }
        let UploadCertificateRequest { name, content, .. } =
            UploadCertificateRequest::deserialize(deserializer)?;
        Ok(Self { name, content })
    }
}
impl serde::Serialize for UploadCertificateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UploadCertificateRequest<'a> {
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "content")]
            content: &'a String,
        }
        let Self { name, content } = self;
        UploadCertificateRequest { name, content }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UploadCertificateRequest {
    #[doc = "An optional name for the certificate"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The certificate content in PEM format"]
    pub content: String,
}
impl<'de> serde::Deserialize<'de> for UploadPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `upload.part`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadPartObject {
            #[default]
            #[serde(rename = "upload.part")]
            UploadPart,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UploadPart {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "upload_id")]
            #[allow(dead_code)]
            upload_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UploadPartObject,
        }
        let UploadPart {
            id,
            created_at,
            upload_id,
            ..
        } = UploadPart::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            upload_id,
        })
    }
}
impl serde::Serialize for UploadPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `upload.part`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UploadPartObject {
            #[default]
            #[serde(rename = "upload.part")]
            UploadPart,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UploadPart<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "upload_id")]
            upload_id: &'a String,
            #[serde(rename = "object")]
            object: &'a UploadPartObject,
        }
        let Self {
            id,
            created_at,
            upload_id,
        } = self;
        UploadPart {
            id,
            created_at,
            upload_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "The upload Part represents a chunk of bytes we can add to an Upload object.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UploadPart {
    #[doc = "The upload Part unique identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the Part was created."]
    pub created_at: u64,
    #[doc = "The ID of the Upload object that this Part was added to."]
    pub upload_id: String,
}
impl<'de> serde::Deserialize<'de> for UsageAudioSpeechesResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageAudioSpeechesResultObject {
            #[default]
            #[serde(rename = "organization.usage.audio_speeches.result")]
            OrganizationUsageAudioSpeechesResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageAudioSpeechesResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageAudioSpeechesResultObject,
            #[serde(rename = "characters")]
            #[allow(dead_code)]
            characters: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let UsageAudioSpeechesResult {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageAudioSpeechesResult::deserialize(deserializer)?;
        Ok(Self {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageAudioSpeechesResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageAudioSpeechesResultObject {
            #[default]
            #[serde(rename = "organization.usage.audio_speeches.result")]
            OrganizationUsageAudioSpeechesResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageAudioSpeechesResult<'a> {
            #[serde(rename = "object")]
            object: &'a UsageAudioSpeechesResultObject,
            #[serde(rename = "characters")]
            characters: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageAudioSpeechesResult {
            object: &Default::default(),
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated audio speeches usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageAudioSpeechesResult {
    #[doc = "The number of characters processed."]
    pub characters: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageAudioTranscriptionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageAudioTranscriptionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.audio_transcriptions.result")]
            OrganizationUsageAudioTranscriptionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageAudioTranscriptionsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageAudioTranscriptionsResultObject,
            #[serde(rename = "seconds")]
            #[allow(dead_code)]
            seconds: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let UsageAudioTranscriptionsResult {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageAudioTranscriptionsResult::deserialize(deserializer)?;
        Ok(Self {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageAudioTranscriptionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageAudioTranscriptionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.audio_transcriptions.result")]
            OrganizationUsageAudioTranscriptionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageAudioTranscriptionsResult<'a> {
            #[serde(rename = "object")]
            object: &'a UsageAudioTranscriptionsResultObject,
            #[serde(rename = "seconds")]
            seconds: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageAudioTranscriptionsResult {
            object: &Default::default(),
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated audio transcriptions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageAudioTranscriptionsResult {
    #[doc = "The number of seconds processed."]
    pub seconds: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageCodeInterpreterSessionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageCodeInterpreterSessionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.code_interpreter_sessions.result")]
            OrganizationUsageCodeInterpreterSessionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageCodeInterpreterSessionsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageCodeInterpreterSessionsResultObject,
            #[serde(rename = "num_sessions")]
            #[allow(dead_code)]
            num_sessions: Option<u64>,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
        }
        let UsageCodeInterpreterSessionsResult {
            num_sessions,
            project_id,
            ..
        } = UsageCodeInterpreterSessionsResult::deserialize(deserializer)?;
        Ok(Self {
            num_sessions,
            project_id,
        })
    }
}
impl serde::Serialize for UsageCodeInterpreterSessionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageCodeInterpreterSessionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.code_interpreter_sessions.result")]
            OrganizationUsageCodeInterpreterSessionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageCodeInterpreterSessionsResult<'a> {
            #[serde(rename = "object")]
            object: &'a UsageCodeInterpreterSessionsResultObject,
            #[serde(rename = "num_sessions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            num_sessions: &'a Option<u64>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
        }
        let Self {
            num_sessions,
            project_id,
        } = self;
        UsageCodeInterpreterSessionsResult {
            object: &Default::default(),
            num_sessions,
            project_id,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated code interpreter sessions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct UsageCodeInterpreterSessionsResult {
    #[doc = "The number of code interpreter sessions."]
    #[builder(default)]
    pub num_sessions: Option<u64>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageCompletionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageCompletionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.completions.result")]
            OrganizationUsageCompletionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageCompletionsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageCompletionsResultObject,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "input_cached_tokens")]
            #[allow(dead_code)]
            input_cached_tokens: Option<u64>,
            #[serde(rename = "output_tokens")]
            #[allow(dead_code)]
            output_tokens: u64,
            #[serde(rename = "input_audio_tokens")]
            #[allow(dead_code)]
            input_audio_tokens: Option<u64>,
            #[serde(rename = "output_audio_tokens")]
            #[allow(dead_code)]
            output_audio_tokens: Option<u64>,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "batch")]
            #[allow(dead_code)]
            batch: Option<bool>,
        }
        let UsageCompletionsResult {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
            ..
        } = UsageCompletionsResult::deserialize(deserializer)?;
        Ok(Self {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        })
    }
}
impl serde::Serialize for UsageCompletionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageCompletionsResultObject {
            #[default]
            #[serde(rename = "organization.usage.completions.result")]
            OrganizationUsageCompletionsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageCompletionsResult<'a> {
            #[serde(rename = "object")]
            object: &'a UsageCompletionsResultObject,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "input_cached_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_cached_tokens: &'a Option<u64>,
            #[serde(rename = "output_tokens")]
            output_tokens: &'a u64,
            #[serde(rename = "input_audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_tokens: &'a Option<u64>,
            #[serde(rename = "output_audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_tokens: &'a Option<u64>,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "batch")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch: &'a Option<bool>,
        }
        let Self {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        } = self;
        UsageCompletionsResult {
            object: &Default::default(),
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated completions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageCompletionsResult {
    #[doc = "The aggregated number of text input tokens used, including cached tokens. For customers subscribe to scale tier, this includes scale tier tokens."]
    pub input_tokens: u64,
    #[doc = "The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens."]
    #[builder(default)]
    pub input_cached_tokens: Option<u64>,
    #[doc = "The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens."]
    pub output_tokens: u64,
    #[doc = "The aggregated number of audio input tokens used, including cached tokens."]
    #[builder(default)]
    pub input_audio_tokens: Option<u64>,
    #[doc = "The aggregated number of audio output tokens used."]
    #[builder(default)]
    pub output_audio_tokens: Option<u64>,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "When `group_by=batch`, this field tells whether the grouped usage result is batch or not."]
    #[builder(default)]
    pub batch: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for UsageEmbeddingsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageEmbeddingsResultObject {
            #[default]
            #[serde(rename = "organization.usage.embeddings.result")]
            OrganizationUsageEmbeddingsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageEmbeddingsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageEmbeddingsResultObject,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let UsageEmbeddingsResult {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageEmbeddingsResult::deserialize(deserializer)?;
        Ok(Self {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageEmbeddingsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageEmbeddingsResultObject {
            #[default]
            #[serde(rename = "organization.usage.embeddings.result")]
            OrganizationUsageEmbeddingsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageEmbeddingsResult<'a> {
            #[serde(rename = "object")]
            object: &'a UsageEmbeddingsResultObject,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageEmbeddingsResult {
            object: &Default::default(),
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated embeddings usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageEmbeddingsResult {
    #[doc = "The aggregated number of input tokens used."]
    pub input_tokens: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageImagesResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageImagesResultObject {
            #[default]
            #[serde(rename = "organization.usage.images.result")]
            OrganizationUsageImagesResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageImagesResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageImagesResultObject,
            #[serde(rename = "images")]
            #[allow(dead_code)]
            images: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "source")]
            #[allow(dead_code)]
            source: Option<String>,
            #[serde(rename = "size")]
            #[allow(dead_code)]
            size: Option<String>,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let UsageImagesResult {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageImagesResult::deserialize(deserializer)?;
        Ok(Self {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageImagesResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageImagesResultObject {
            #[default]
            #[serde(rename = "organization.usage.images.result")]
            OrganizationUsageImagesResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageImagesResult<'a> {
            #[serde(rename = "object")]
            object: &'a UsageImagesResultObject,
            #[serde(rename = "images")]
            images: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "source")]
            #[serde(skip_serializing_if = "Option::is_none")]
            source: &'a Option<String>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<String>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageImagesResult {
            object: &Default::default(),
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated images usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageImagesResult {
    #[doc = "The number of images processed."]
    pub images: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=source`, this field provides the source of the grouped usage result, possible values are `image.generation`, `image.edit`, `image.variation`."]
    #[builder(default)]
    pub source: Option<String>,
    #[doc = "When `group_by=size`, this field provides the image size of the grouped usage result."]
    #[builder(default)]
    pub size: Option<String>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageModerationsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageModerationsResultObject {
            #[default]
            #[serde(rename = "organization.usage.moderations.result")]
            OrganizationUsageModerationsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageModerationsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageModerationsResultObject,
            #[serde(rename = "input_tokens")]
            #[allow(dead_code)]
            input_tokens: u64,
            #[serde(rename = "num_model_requests")]
            #[allow(dead_code)]
            num_model_requests: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            #[allow(dead_code)]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            #[allow(dead_code)]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
        }
        let UsageModerationsResult {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageModerationsResult::deserialize(deserializer)?;
        Ok(Self {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageModerationsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageModerationsResultObject {
            #[default]
            #[serde(rename = "organization.usage.moderations.result")]
            OrganizationUsageModerationsResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageModerationsResult<'a> {
            #[serde(rename = "object")]
            object: &'a UsageModerationsResultObject,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a u64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageModerationsResult {
            object: &Default::default(),
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated moderations usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageModerationsResult {
    #[doc = "The aggregated number of input tokens used."]
    pub input_tokens: u64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageResponseObject {
            #[default]
            #[serde(rename = "page")]
            Page,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<UsageTimeBucket>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "next_page")]
            #[allow(dead_code)]
            next_page: String,
        }
        let UsageResponse {
            data,
            has_more,
            next_page,
            ..
        } = UsageResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for UsageResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageResponseObject {
            #[default]
            #[serde(rename = "page")]
            Page,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageResponse<'a> {
            #[serde(rename = "object")]
            object: &'a UsageResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<UsageTimeBucket>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            next_page: &'a String,
        }
        let Self {
            data,
            has_more,
            next_page,
        } = self;
        UsageResponse {
            object: &Default::default(),
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageResponse {
    pub data: Vec<UsageTimeBucket>,
    pub has_more: bool,
    pub next_page: String,
}
impl<'de> serde::Deserialize<'de> for UsageTimeBucketResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum UsageTimeBucketResult {
            OrganizationUsageCompletionsResult(#[allow(dead_code)] UsageCompletionsResult),
            OrganizationUsageEmbeddingsResult(#[allow(dead_code)] UsageEmbeddingsResult),
            OrganizationUsageModerationsResult(#[allow(dead_code)] UsageModerationsResult),
            OrganizationUsageImagesResult(#[allow(dead_code)] UsageImagesResult),
            OrganizationUsageAudioSpeechesResult(#[allow(dead_code)] UsageAudioSpeechesResult),
            OrganizationUsageAudioTranscriptionsResult(
                #[allow(dead_code)] UsageAudioTranscriptionsResult,
            ),
            OrganizationUsageVectorStoresResult(#[allow(dead_code)] UsageVectorStoresResult),
            OrganizationUsageCodeInterpreterSessionsResult(
                #[allow(dead_code)] UsageCodeInterpreterSessionsResult,
            ),
            OrganizationCostsResult(#[allow(dead_code)] CostsResult),
        }
        Ok(match UsageTimeBucketResult::deserialize(deserializer)? {
            UsageTimeBucketResult::OrganizationUsageCompletionsResult(_v) => {
                Self::OrganizationUsageCompletionsResult(_v)
            }
            UsageTimeBucketResult::OrganizationUsageEmbeddingsResult(_v) => {
                Self::OrganizationUsageEmbeddingsResult(_v)
            }
            UsageTimeBucketResult::OrganizationUsageModerationsResult(_v) => {
                Self::OrganizationUsageModerationsResult(_v)
            }
            UsageTimeBucketResult::OrganizationUsageImagesResult(_v) => {
                Self::OrganizationUsageImagesResult(_v)
            }
            UsageTimeBucketResult::OrganizationUsageAudioSpeechesResult(_v) => {
                Self::OrganizationUsageAudioSpeechesResult(_v)
            }
            UsageTimeBucketResult::OrganizationUsageAudioTranscriptionsResult(_v) => {
                Self::OrganizationUsageAudioTranscriptionsResult(_v)
            }
            UsageTimeBucketResult::OrganizationUsageVectorStoresResult(_v) => {
                Self::OrganizationUsageVectorStoresResult(_v)
            }
            UsageTimeBucketResult::OrganizationUsageCodeInterpreterSessionsResult(_v) => {
                Self::OrganizationUsageCodeInterpreterSessionsResult(_v)
            }
            UsageTimeBucketResult::OrganizationCostsResult(_v) => Self::OrganizationCostsResult(_v),
        })
    }
}
impl serde::Serialize for UsageTimeBucketResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum UsageTimeBucketResult<'a> {
            OrganizationUsageCompletionsResult(#[allow(dead_code)] &'a UsageCompletionsResult),
            OrganizationUsageEmbeddingsResult(#[allow(dead_code)] &'a UsageEmbeddingsResult),
            OrganizationUsageModerationsResult(#[allow(dead_code)] &'a UsageModerationsResult),
            OrganizationUsageImagesResult(#[allow(dead_code)] &'a UsageImagesResult),
            OrganizationUsageAudioSpeechesResult(#[allow(dead_code)] &'a UsageAudioSpeechesResult),
            OrganizationUsageAudioTranscriptionsResult(
                #[allow(dead_code)] &'a UsageAudioTranscriptionsResult,
            ),
            OrganizationUsageVectorStoresResult(#[allow(dead_code)] &'a UsageVectorStoresResult),
            OrganizationUsageCodeInterpreterSessionsResult(
                #[allow(dead_code)] &'a UsageCodeInterpreterSessionsResult,
            ),
            OrganizationCostsResult(#[allow(dead_code)] &'a CostsResult),
        }
        match self {
            Self::OrganizationUsageCompletionsResult(_v) => {
                UsageTimeBucketResult::OrganizationUsageCompletionsResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageEmbeddingsResult(_v) => {
                UsageTimeBucketResult::OrganizationUsageEmbeddingsResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageModerationsResult(_v) => {
                UsageTimeBucketResult::OrganizationUsageModerationsResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageImagesResult(_v) => {
                UsageTimeBucketResult::OrganizationUsageImagesResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageAudioSpeechesResult(_v) => {
                UsageTimeBucketResult::OrganizationUsageAudioSpeechesResult(_v)
                    .serialize(serializer)
            }
            Self::OrganizationUsageAudioTranscriptionsResult(_v) => {
                UsageTimeBucketResult::OrganizationUsageAudioTranscriptionsResult(_v)
                    .serialize(serializer)
            }
            Self::OrganizationUsageVectorStoresResult(_v) => {
                UsageTimeBucketResult::OrganizationUsageVectorStoresResult(_v).serialize(serializer)
            }
            Self::OrganizationUsageCodeInterpreterSessionsResult(_v) => {
                UsageTimeBucketResult::OrganizationUsageCodeInterpreterSessionsResult(_v)
                    .serialize(serializer)
            }
            Self::OrganizationCostsResult(_v) => {
                UsageTimeBucketResult::OrganizationCostsResult(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum UsageTimeBucketResult {
    OrganizationUsageCompletionsResult(UsageCompletionsResult),
    OrganizationUsageEmbeddingsResult(UsageEmbeddingsResult),
    OrganizationUsageModerationsResult(UsageModerationsResult),
    OrganizationUsageImagesResult(UsageImagesResult),
    OrganizationUsageAudioSpeechesResult(UsageAudioSpeechesResult),
    OrganizationUsageAudioTranscriptionsResult(UsageAudioTranscriptionsResult),
    OrganizationUsageVectorStoresResult(UsageVectorStoresResult),
    OrganizationUsageCodeInterpreterSessionsResult(UsageCodeInterpreterSessionsResult),
    OrganizationCostsResult(CostsResult),
}
impl<'de> serde::Deserialize<'de> for UsageTimeBucket {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageTimeBucketObject {
            #[default]
            #[serde(rename = "bucket")]
            Bucket,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageTimeBucket {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageTimeBucketObject,
            #[serde(rename = "start_time")]
            #[allow(dead_code)]
            start_time: u64,
            #[serde(rename = "end_time")]
            #[allow(dead_code)]
            end_time: u64,
            #[serde(rename = "result")]
            #[allow(dead_code)]
            result: Vec<UsageTimeBucketResult>,
        }
        let UsageTimeBucket {
            start_time,
            end_time,
            result,
            ..
        } = UsageTimeBucket::deserialize(deserializer)?;
        Ok(Self {
            start_time,
            end_time,
            result,
        })
    }
}
impl serde::Serialize for UsageTimeBucket {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageTimeBucketObject {
            #[default]
            #[serde(rename = "bucket")]
            Bucket,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageTimeBucket<'a> {
            #[serde(rename = "object")]
            object: &'a UsageTimeBucketObject,
            #[serde(rename = "start_time")]
            start_time: &'a u64,
            #[serde(rename = "end_time")]
            end_time: &'a u64,
            #[serde(rename = "result")]
            result: &'a Vec<UsageTimeBucketResult>,
        }
        let Self {
            start_time,
            end_time,
            result,
        } = self;
        UsageTimeBucket {
            object: &Default::default(),
            start_time,
            end_time,
            result,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageTimeBucket {
    pub start_time: u64,
    pub end_time: u64,
    pub result: Vec<UsageTimeBucketResult>,
}
impl<'de> serde::Deserialize<'de> for UsageVectorStoresResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageVectorStoresResultObject {
            #[default]
            #[serde(rename = "organization.usage.vector_stores.result")]
            OrganizationUsageVectorStoresResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageVectorStoresResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UsageVectorStoresResultObject,
            #[serde(rename = "usage_bytes")]
            #[allow(dead_code)]
            usage_bytes: u64,
            #[serde(rename = "project_id")]
            #[allow(dead_code)]
            project_id: Option<String>,
        }
        let UsageVectorStoresResult {
            usage_bytes,
            project_id,
            ..
        } = UsageVectorStoresResult::deserialize(deserializer)?;
        Ok(Self {
            usage_bytes,
            project_id,
        })
    }
}
impl serde::Serialize for UsageVectorStoresResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UsageVectorStoresResultObject {
            #[default]
            #[serde(rename = "organization.usage.vector_stores.result")]
            OrganizationUsageVectorStoresResult,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageVectorStoresResult<'a> {
            #[serde(rename = "object")]
            object: &'a UsageVectorStoresResultObject,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a u64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
        }
        let Self {
            usage_bytes,
            project_id,
        } = self;
        UsageVectorStoresResult {
            object: &Default::default(),
            usage_bytes,
            project_id,
        }
        .serialize(serializer)
    }
}
#[doc = "The aggregated vector stores usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageVectorStoresResult {
    #[doc = "The vector stores usage in bytes."]
    pub usage_bytes: u64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UserRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum UserRole {
            Owner(#[allow(dead_code)] UserRoleOwner),
            Reader(#[allow(dead_code)] UserRoleReader),
        }
        Ok(match UserRole::deserialize(deserializer)? {
            UserRole::Owner(_) => Self::Owner,
            UserRole::Reader(_) => Self::Reader,
        })
    }
}
impl serde::Serialize for UserRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum UserRole<'a> {
            Owner(#[allow(dead_code)] &'a UserRoleOwner),
            Reader(#[allow(dead_code)] &'a UserRoleReader),
        }
        match self {
            Self::Owner => UserRole::Owner(&Default::default()).serialize(serializer),
            Self::Reader => UserRole::Reader(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "`owner` or `reader`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum UserRole {
    #[doc = "owner"]
    Owner,
    #[doc = "reader"]
    Reader,
}
impl<'de> serde::Deserialize<'de> for User {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `organization.user`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserObject {
            #[default]
            #[serde(rename = "organization.user")]
            OrganizationUser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct User {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UserObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "email")]
            #[allow(dead_code)]
            email: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: UserRole,
            #[serde(rename = "added_at")]
            #[allow(dead_code)]
            added_at: u64,
        }
        let User {
            id,
            name,
            email,
            role,
            added_at,
            ..
        } = User::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            email,
            role,
            added_at,
        })
    }
}
impl serde::Serialize for User {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `organization.user`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserObject {
            #[default]
            #[serde(rename = "organization.user")]
            OrganizationUser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct User<'a> {
            #[serde(rename = "object")]
            object: &'a UserObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a UserRole,
            #[serde(rename = "added_at")]
            added_at: &'a u64,
        }
        let Self {
            id,
            name,
            email,
            role,
            added_at,
        } = self;
        User {
            object: &Default::default(),
            id,
            name,
            email,
            role,
            added_at,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an individual `user` within an organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct User {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the user"]
    pub name: String,
    #[doc = "The email address of the user"]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    pub role: UserRole,
    #[doc = "The Unix timestamp (in seconds) of when the user was added."]
    pub added_at: u64,
}
impl<'de> serde::Deserialize<'de> for UserDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.user.deleted")]
            OrganizationUserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UserDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UserDeleteResponseObject,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "deleted")]
            #[allow(dead_code)]
            deleted: bool,
        }
        let UserDeleteResponse { id, deleted, .. } = UserDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for UserDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserDeleteResponseObject {
            #[default]
            #[serde(rename = "organization.user.deleted")]
            OrganizationUserDeleted,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UserDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a UserDeleteResponseObject,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        UserDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UserDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for UserListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UserListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: UserListResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<User>,
            #[serde(rename = "first_id")]
            #[allow(dead_code)]
            first_id: String,
            #[serde(rename = "last_id")]
            #[allow(dead_code)]
            last_id: String,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
        }
        let UserListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = UserListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for UserListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserListResponseObject {
            #[default]
            #[serde(rename = "list")]
            List,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UserListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a UserListResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<User>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        UserListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UserListResponse {
    pub data: Vec<User>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for UserRoleUpdateRequestRole {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleUpdateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleUpdateRequestRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum UserRoleUpdateRequestRole {
            Owner(#[allow(dead_code)] UserRoleUpdateRequestRoleOwner),
            Reader(#[allow(dead_code)] UserRoleUpdateRequestRoleReader),
        }
        Ok(
            match UserRoleUpdateRequestRole::deserialize(deserializer)? {
                UserRoleUpdateRequestRole::Owner(_) => Self::Owner,
                UserRoleUpdateRequestRole::Reader(_) => Self::Reader,
            },
        )
    }
}
impl serde::Serialize for UserRoleUpdateRequestRole {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleUpdateRequestRoleOwner {
            #[default]
            #[serde(rename = "owner")]
            Owner,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UserRoleUpdateRequestRoleReader {
            #[default]
            #[serde(rename = "reader")]
            Reader,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum UserRoleUpdateRequestRole<'a> {
            Owner(#[allow(dead_code)] &'a UserRoleUpdateRequestRoleOwner),
            Reader(#[allow(dead_code)] &'a UserRoleUpdateRequestRoleReader),
        }
        match self {
            Self::Owner => {
                UserRoleUpdateRequestRole::Owner(&Default::default()).serialize(serializer)
            }
            Self::Reader => {
                UserRoleUpdateRequestRole::Reader(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "`owner` or `reader`"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum UserRoleUpdateRequestRole {
    #[doc = "owner"]
    Owner,
    #[doc = "reader"]
    Reader,
}
impl<'de> serde::Deserialize<'de> for UserRoleUpdateRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UserRoleUpdateRequest {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: UserRoleUpdateRequestRole,
        }
        let UserRoleUpdateRequest { role, .. } = UserRoleUpdateRequest::deserialize(deserializer)?;
        Ok(Self { role })
    }
}
impl serde::Serialize for UserRoleUpdateRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UserRoleUpdateRequest<'a> {
            #[serde(rename = "role")]
            role: &'a UserRoleUpdateRequestRole,
        }
        let Self { role } = self;
        UserRoleUpdateRequest { role }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct UserRoleUpdateRequest {
    #[doc = "`owner` or `reader`"]
    pub role: UserRoleUpdateRequestRole,
}
impl<'de> serde::Deserialize<'de> for VadConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Must be set to `server_vad` to enable manual chunking using server side VAD."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VadConfigType {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VadConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: VadConfigType,
            #[serde(rename = "prefix_padding_ms")]
            #[allow(dead_code)]
            prefix_padding_ms: Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[allow(dead_code)]
            silence_duration_ms: Option<u64>,
            #[serde(rename = "threshold")]
            #[allow(dead_code)]
            threshold: Option<f64>,
        }
        let VadConfig {
            prefix_padding_ms,
            silence_duration_ms,
            threshold,
            ..
        } = VadConfig::deserialize(deserializer)?;
        Ok(Self {
            prefix_padding_ms,
            silence_duration_ms,
            threshold,
        })
    }
}
impl serde::Serialize for VadConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Must be set to `server_vad` to enable manual chunking using server side VAD."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VadConfigType {
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VadConfig<'a> {
            #[serde(rename = "type")]
            type_: &'a VadConfigType,
            #[serde(rename = "prefix_padding_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prefix_padding_ms: &'a Option<u64>,
            #[serde(rename = "silence_duration_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            silence_duration_ms: &'a Option<u64>,
            #[serde(rename = "threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            threshold: &'a Option<f64>,
        }
        let Self {
            prefix_padding_ms,
            silence_duration_ms,
            threshold,
        } = self;
        VadConfig {
            type_: &Default::default(),
            prefix_padding_ms,
            silence_duration_ms,
            threshold,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct VadConfig {
    #[doc = "Amount of audio to include before the VAD detected speech (in \nmilliseconds).\n"]
    #[builder(default)]
    pub prefix_padding_ms: Option<u64>,
    #[doc = "Duration of silence to detect speech stop (in milliseconds).\nWith shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[builder(default)]
    pub silence_duration_ms: Option<u64>,
    #[doc = "Sensitivity threshold (0.0 to 1.0) for voice activity detection. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[builder(default)]
    pub threshold: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for ValidateGraderRequestGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ValidateGraderRequestGrader {
            StringCheck(#[allow(dead_code)] GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] GraderTextSimilarity),
            Python(#[allow(dead_code)] GraderPython),
            ScoreModel(#[allow(dead_code)] GraderScoreModel),
            Multi(#[allow(dead_code)] GraderMulti),
        }
        Ok(
            match ValidateGraderRequestGrader::deserialize(deserializer)? {
                ValidateGraderRequestGrader::StringCheck(_v) => Self::StringCheck(_v),
                ValidateGraderRequestGrader::TextSimilarity(_v) => Self::TextSimilarity(_v),
                ValidateGraderRequestGrader::Python(_v) => Self::Python(_v),
                ValidateGraderRequestGrader::ScoreModel(_v) => Self::ScoreModel(_v),
                ValidateGraderRequestGrader::Multi(_v) => Self::Multi(_v),
            },
        )
    }
}
impl serde::Serialize for ValidateGraderRequestGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ValidateGraderRequestGrader<'a> {
            StringCheck(#[allow(dead_code)] &'a GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] &'a GraderTextSimilarity),
            Python(#[allow(dead_code)] &'a GraderPython),
            ScoreModel(#[allow(dead_code)] &'a GraderScoreModel),
            Multi(#[allow(dead_code)] &'a GraderMulti),
        }
        match self {
            Self::StringCheck(_v) => {
                ValidateGraderRequestGrader::StringCheck(_v).serialize(serializer)
            }
            Self::TextSimilarity(_v) => {
                ValidateGraderRequestGrader::TextSimilarity(_v).serialize(serializer)
            }
            Self::Python(_v) => ValidateGraderRequestGrader::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => {
                ValidateGraderRequestGrader::ScoreModel(_v).serialize(serializer)
            }
            Self::Multi(_v) => ValidateGraderRequestGrader::Multi(_v).serialize(serializer),
        }
    }
}
#[doc = "The grader used for the fine-tuning job."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ValidateGraderRequestGrader {
    StringCheck(GraderStringCheck),
    TextSimilarity(GraderTextSimilarity),
    Python(GraderPython),
    ScoreModel(GraderScoreModel),
    Multi(GraderMulti),
}
impl<'de> serde::Deserialize<'de> for ValidateGraderRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ValidateGraderRequest {
            #[serde(rename = "grader")]
            #[allow(dead_code)]
            grader: ValidateGraderRequestGrader,
        }
        let ValidateGraderRequest { grader, .. } =
            ValidateGraderRequest::deserialize(deserializer)?;
        Ok(Self { grader })
    }
}
impl serde::Serialize for ValidateGraderRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ValidateGraderRequest<'a> {
            #[serde(rename = "grader")]
            grader: &'a ValidateGraderRequestGrader,
        }
        let Self { grader } = self;
        ValidateGraderRequest { grader }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ValidateGraderRequest {
    #[doc = "The grader used for the fine-tuning job."]
    pub grader: ValidateGraderRequestGrader,
}
impl<'de> serde::Deserialize<'de> for ValidateGraderResponseGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ValidateGraderResponseGrader {
            StringCheck(#[allow(dead_code)] GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] GraderTextSimilarity),
            Python(#[allow(dead_code)] GraderPython),
            ScoreModel(#[allow(dead_code)] GraderScoreModel),
            Multi(#[allow(dead_code)] GraderMulti),
        }
        Ok(
            match ValidateGraderResponseGrader::deserialize(deserializer)? {
                ValidateGraderResponseGrader::StringCheck(_v) => Self::StringCheck(_v),
                ValidateGraderResponseGrader::TextSimilarity(_v) => Self::TextSimilarity(_v),
                ValidateGraderResponseGrader::Python(_v) => Self::Python(_v),
                ValidateGraderResponseGrader::ScoreModel(_v) => Self::ScoreModel(_v),
                ValidateGraderResponseGrader::Multi(_v) => Self::Multi(_v),
            },
        )
    }
}
impl serde::Serialize for ValidateGraderResponseGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ValidateGraderResponseGrader<'a> {
            StringCheck(#[allow(dead_code)] &'a GraderStringCheck),
            TextSimilarity(#[allow(dead_code)] &'a GraderTextSimilarity),
            Python(#[allow(dead_code)] &'a GraderPython),
            ScoreModel(#[allow(dead_code)] &'a GraderScoreModel),
            Multi(#[allow(dead_code)] &'a GraderMulti),
        }
        match self {
            Self::StringCheck(_v) => {
                ValidateGraderResponseGrader::StringCheck(_v).serialize(serializer)
            }
            Self::TextSimilarity(_v) => {
                ValidateGraderResponseGrader::TextSimilarity(_v).serialize(serializer)
            }
            Self::Python(_v) => ValidateGraderResponseGrader::Python(_v).serialize(serializer),
            Self::ScoreModel(_v) => {
                ValidateGraderResponseGrader::ScoreModel(_v).serialize(serializer)
            }
            Self::Multi(_v) => ValidateGraderResponseGrader::Multi(_v).serialize(serializer),
        }
    }
}
#[doc = "The grader used for the fine-tuning job."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ValidateGraderResponseGrader {
    StringCheck(GraderStringCheck),
    TextSimilarity(GraderTextSimilarity),
    Python(GraderPython),
    ScoreModel(GraderScoreModel),
    Multi(GraderMulti),
}
impl<'de> serde::Deserialize<'de> for ValidateGraderResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ValidateGraderResponse {
            #[serde(rename = "grader")]
            #[allow(dead_code)]
            grader: Option<ValidateGraderResponseGrader>,
        }
        let ValidateGraderResponse { grader, .. } =
            ValidateGraderResponse::deserialize(deserializer)?;
        Ok(Self { grader })
    }
}
impl serde::Serialize for ValidateGraderResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ValidateGraderResponse<'a> {
            #[serde(rename = "grader")]
            #[serde(skip_serializing_if = "Option::is_none")]
            grader: &'a Option<ValidateGraderResponseGrader>,
        }
        let Self { grader } = self;
        ValidateGraderResponse { grader }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ValidateGraderResponse {
    #[doc = "The grader used for the fine-tuning job."]
    #[builder(default)]
    pub grader: Option<ValidateGraderResponseGrader>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreExpirationAfter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreExpirationAfterAnchor {
            #[default]
            #[serde(rename = "last_active_at")]
            LastActiveAt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreExpirationAfter {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: VectorStoreExpirationAfterAnchor,
            #[serde(rename = "days")]
            #[allow(dead_code)]
            days: u64,
        }
        let VectorStoreExpirationAfter { days, .. } =
            VectorStoreExpirationAfter::deserialize(deserializer)?;
        Ok(Self { days })
    }
}
impl serde::Serialize for VectorStoreExpirationAfter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreExpirationAfterAnchor {
            #[default]
            #[serde(rename = "last_active_at")]
            LastActiveAt,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreExpirationAfter<'a> {
            #[serde(rename = "anchor")]
            anchor: &'a VectorStoreExpirationAfterAnchor,
            #[serde(rename = "days")]
            days: &'a u64,
        }
        let Self { days } = self;
        VectorStoreExpirationAfter {
            anchor: &Default::default(),
            days,
        }
        .serialize(serializer)
    }
}
#[doc = "The expiration policy for a vector store."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct VectorStoreExpirationAfter {
    #[doc = "The number of days after the anchor time that the vector store will expire."]
    pub days: u64,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileAttribute {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VectorStoreFileAttribute {
            String(#[allow(dead_code)] String),
            Number(#[allow(dead_code)] f64),
            Bool(#[allow(dead_code)] bool),
        }
        Ok(match VectorStoreFileAttribute::deserialize(deserializer)? {
            VectorStoreFileAttribute::String(_v) => Self::String(_v),
            VectorStoreFileAttribute::Number(_v) => Self::Number(_v),
            VectorStoreFileAttribute::Bool(_v) => Self::Bool(_v),
        })
    }
}
impl serde::Serialize for VectorStoreFileAttribute {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VectorStoreFileAttribute<'a> {
            String(#[allow(dead_code)] &'a String),
            Number(#[allow(dead_code)] &'a f64),
            Bool(#[allow(dead_code)] &'a bool),
        }
        match self {
            Self::String(_v) => VectorStoreFileAttribute::String(_v).serialize(serializer),
            Self::Number(_v) => VectorStoreFileAttribute::Number(_v).serialize(serializer),
            Self::Bool(_v) => VectorStoreFileAttribute::Bool(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileAttribute {
    String(String),
    Number(f64),
    Bool(bool),
}
#[doc = "Set of 16 key-value pairs that can be attached to an object. This can be \nuseful for storing additional information about the object in a structured \nformat, and querying for objects via API or the dashboard. Keys are strings \nwith a maximum length of 64 characters. Values are strings with a maximum \nlength of 512 characters, booleans, or numbers.\n"]
pub type VectorStoreFileAttributes = std::collections::HashMap<String, VectorStoreFileAttribute>;
impl<'de> serde::Deserialize<'de> for VectorStoreFileBatchObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VectorStoreFileBatchObjectStatus {
            InProgress(#[allow(dead_code)] VectorStoreFileBatchObjectStatusInProgress),
            Completed(#[allow(dead_code)] VectorStoreFileBatchObjectStatusCompleted),
            Cancelled(#[allow(dead_code)] VectorStoreFileBatchObjectStatusCancelled),
            Failed(#[allow(dead_code)] VectorStoreFileBatchObjectStatusFailed),
        }
        Ok(
            match VectorStoreFileBatchObjectStatus::deserialize(deserializer)? {
                VectorStoreFileBatchObjectStatus::InProgress(_) => Self::InProgress,
                VectorStoreFileBatchObjectStatus::Completed(_) => Self::Completed,
                VectorStoreFileBatchObjectStatus::Cancelled(_) => Self::Cancelled,
                VectorStoreFileBatchObjectStatus::Failed(_) => Self::Failed,
            },
        )
    }
}
impl serde::Serialize for VectorStoreFileBatchObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VectorStoreFileBatchObjectStatus<'a> {
            InProgress(#[allow(dead_code)] &'a VectorStoreFileBatchObjectStatusInProgress),
            Completed(#[allow(dead_code)] &'a VectorStoreFileBatchObjectStatusCompleted),
            Cancelled(#[allow(dead_code)] &'a VectorStoreFileBatchObjectStatusCancelled),
            Failed(#[allow(dead_code)] &'a VectorStoreFileBatchObjectStatusFailed),
        }
        match self {
            Self::InProgress => VectorStoreFileBatchObjectStatus::InProgress(&Default::default())
                .serialize(serializer),
            Self::Completed => VectorStoreFileBatchObjectStatus::Completed(&Default::default())
                .serialize(serializer),
            Self::Cancelled => VectorStoreFileBatchObjectStatus::Cancelled(&Default::default())
                .serialize(serializer),
            Self::Failed => {
                VectorStoreFileBatchObjectStatus::Failed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileBatchObjectStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileBatchObjectFileCounts {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileBatchObjectFileCounts {
            #[serde(rename = "in_progress")]
            #[allow(dead_code)]
            in_progress: u64,
            #[serde(rename = "completed")]
            #[allow(dead_code)]
            completed: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
            #[serde(rename = "cancelled")]
            #[allow(dead_code)]
            cancelled: u64,
            #[serde(rename = "total")]
            #[allow(dead_code)]
            total: u64,
        }
        let VectorStoreFileBatchObjectFileCounts {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
            ..
        } = VectorStoreFileBatchObjectFileCounts::deserialize(deserializer)?;
        Ok(Self {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        })
    }
}
impl serde::Serialize for VectorStoreFileBatchObjectFileCounts {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileBatchObjectFileCounts<'a> {
            #[serde(rename = "in_progress")]
            in_progress: &'a u64,
            #[serde(rename = "completed")]
            completed: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
            #[serde(rename = "cancelled")]
            cancelled: &'a u64,
            #[serde(rename = "total")]
            total: &'a u64,
        }
        let Self {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        } = self;
        VectorStoreFileBatchObjectFileCounts {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileBatchObjectFileCounts {
    #[doc = "The number of files that are currently being processed."]
    pub in_progress: u64,
    #[doc = "The number of files that have been processed."]
    pub completed: u64,
    #[doc = "The number of files that have failed to process."]
    pub failed: u64,
    #[doc = "The number of files that where cancelled."]
    pub cancelled: u64,
    #[doc = "The total number of files."]
    pub total: u64,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileBatchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store.file_batch`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectObject {
            #[default]
            #[serde(rename = "vector_store.files_batch")]
            VectorStoreFilesBatch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileBatchObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreFileBatchObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "vector_store_id")]
            #[allow(dead_code)]
            vector_store_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: VectorStoreFileBatchObjectStatus,
            #[serde(rename = "file_counts")]
            #[allow(dead_code)]
            file_counts: VectorStoreFileBatchObjectFileCounts,
        }
        let VectorStoreFileBatchObject {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
            ..
        } = VectorStoreFileBatchObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
        })
    }
}
impl serde::Serialize for VectorStoreFileBatchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store.file_batch`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileBatchObjectObject {
            #[default]
            #[serde(rename = "vector_store.files_batch")]
            VectorStoreFilesBatch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileBatchObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a VectorStoreFileBatchObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "vector_store_id")]
            vector_store_id: &'a String,
            #[serde(rename = "status")]
            status: &'a VectorStoreFileBatchObjectStatus,
            #[serde(rename = "file_counts")]
            file_counts: &'a VectorStoreFileBatchObjectFileCounts,
        }
        let Self {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
        } = self;
        VectorStoreFileBatchObject {
            id,
            object: &Default::default(),
            created_at,
            vector_store_id,
            status,
            file_counts,
        }
        .serialize(serializer)
    }
}
#[doc = "A batch of files attached to a vector store."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileBatchObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the vector store files batch was created."]
    pub created_at: u64,
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to."]
    pub vector_store_id: String,
    #[doc = "The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`."]
    pub status: VectorStoreFileBatchObjectStatus,
    pub file_counts: VectorStoreFileBatchObjectFileCounts,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileContentResponseDatum {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileContentResponseDatum {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<String>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
        }
        let VectorStoreFileContentResponseDatum { type_, text, .. } =
            VectorStoreFileContentResponseDatum::deserialize(deserializer)?;
        Ok(Self { type_, text })
    }
}
impl serde::Serialize for VectorStoreFileContentResponseDatum {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileContentResponseDatum<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<String>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
        }
        let Self { type_, text } = self;
        VectorStoreFileContentResponseDatum { type_, text }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileContentResponseDatum {
    #[doc = "The content type (currently only `\"text\"`)"]
    #[builder(default)]
    pub type_: Option<String>,
    #[doc = "The text content"]
    #[builder(default)]
    pub text: Option<String>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileContentResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store.file_content.page`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileContentResponseObject {
            #[default]
            #[serde(rename = "vector_store.file_content.page")]
            VectorStoreFileContentPage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileContentResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreFileContentResponseObject,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<VectorStoreFileContentResponseDatum>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "next_page")]
            #[allow(dead_code)]
            next_page: Option<String>,
        }
        let VectorStoreFileContentResponse {
            data,
            has_more,
            next_page,
            ..
        } = VectorStoreFileContentResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for VectorStoreFileContentResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store.file_content.page`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileContentResponseObject {
            #[default]
            #[serde(rename = "vector_store.file_content.page")]
            VectorStoreFileContentPage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileContentResponse<'a> {
            #[serde(rename = "object")]
            object: &'a VectorStoreFileContentResponseObject,
            #[serde(rename = "data")]
            data: &'a Vec<VectorStoreFileContentResponseDatum>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            #[serde(skip_serializing_if = "Option::is_none")]
            next_page: &'a Option<String>,
        }
        let Self {
            data,
            has_more,
            next_page,
        } = self;
        VectorStoreFileContentResponse {
            object: &Default::default(),
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents the parsed content of a vector store file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileContentResponse {
    #[doc = "Parsed content of the file."]
    pub data: Vec<VectorStoreFileContentResponseDatum>,
    #[doc = "Indicates if there are more content pages to fetch."]
    pub has_more: bool,
    #[doc = "The token for the next page, if any."]
    #[builder(default)]
    pub next_page: Option<String>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VectorStoreFileObjectStatus {
            InProgress(#[allow(dead_code)] VectorStoreFileObjectStatusInProgress),
            Completed(#[allow(dead_code)] VectorStoreFileObjectStatusCompleted),
            Cancelled(#[allow(dead_code)] VectorStoreFileObjectStatusCancelled),
            Failed(#[allow(dead_code)] VectorStoreFileObjectStatusFailed),
        }
        Ok(
            match VectorStoreFileObjectStatus::deserialize(deserializer)? {
                VectorStoreFileObjectStatus::InProgress(_) => Self::InProgress,
                VectorStoreFileObjectStatus::Completed(_) => Self::Completed,
                VectorStoreFileObjectStatus::Cancelled(_) => Self::Cancelled,
                VectorStoreFileObjectStatus::Failed(_) => Self::Failed,
            },
        )
    }
}
impl serde::Serialize for VectorStoreFileObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VectorStoreFileObjectStatus<'a> {
            InProgress(#[allow(dead_code)] &'a VectorStoreFileObjectStatusInProgress),
            Completed(#[allow(dead_code)] &'a VectorStoreFileObjectStatusCompleted),
            Cancelled(#[allow(dead_code)] &'a VectorStoreFileObjectStatusCancelled),
            Failed(#[allow(dead_code)] &'a VectorStoreFileObjectStatusFailed),
        }
        match self {
            Self::InProgress => {
                VectorStoreFileObjectStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                VectorStoreFileObjectStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Cancelled => {
                VectorStoreFileObjectStatus::Cancelled(&Default::default()).serialize(serializer)
            }
            Self::Failed => {
                VectorStoreFileObjectStatus::Failed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileObjectStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObjectLastErrorCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeUnsupportedFile {
            #[default]
            #[serde(rename = "unsupported_file")]
            UnsupportedFile,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeInvalidFile {
            #[default]
            #[serde(rename = "invalid_file")]
            InvalidFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VectorStoreFileObjectLastErrorCode {
            ServerError(#[allow(dead_code)] VectorStoreFileObjectLastErrorCodeServerError),
            UnsupportedFile(#[allow(dead_code)] VectorStoreFileObjectLastErrorCodeUnsupportedFile),
            InvalidFile(#[allow(dead_code)] VectorStoreFileObjectLastErrorCodeInvalidFile),
        }
        Ok(
            match VectorStoreFileObjectLastErrorCode::deserialize(deserializer)? {
                VectorStoreFileObjectLastErrorCode::ServerError(_) => Self::ServerError,
                VectorStoreFileObjectLastErrorCode::UnsupportedFile(_) => Self::UnsupportedFile,
                VectorStoreFileObjectLastErrorCode::InvalidFile(_) => Self::InvalidFile,
            },
        )
    }
}
impl serde::Serialize for VectorStoreFileObjectLastErrorCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeServerError {
            #[default]
            #[serde(rename = "server_error")]
            ServerError,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeUnsupportedFile {
            #[default]
            #[serde(rename = "unsupported_file")]
            UnsupportedFile,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectLastErrorCodeInvalidFile {
            #[default]
            #[serde(rename = "invalid_file")]
            InvalidFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VectorStoreFileObjectLastErrorCode<'a> {
            ServerError(#[allow(dead_code)] &'a VectorStoreFileObjectLastErrorCodeServerError),
            UnsupportedFile(
                #[allow(dead_code)] &'a VectorStoreFileObjectLastErrorCodeUnsupportedFile,
            ),
            InvalidFile(#[allow(dead_code)] &'a VectorStoreFileObjectLastErrorCodeInvalidFile),
        }
        match self {
            Self::ServerError => {
                VectorStoreFileObjectLastErrorCode::ServerError(&Default::default())
                    .serialize(serializer)
            }
            Self::UnsupportedFile => {
                VectorStoreFileObjectLastErrorCode::UnsupportedFile(&Default::default())
                    .serialize(serializer)
            }
            Self::InvalidFile => {
                VectorStoreFileObjectLastErrorCode::InvalidFile(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "One of `server_error` or `rate_limit_exceeded`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreFileObjectLastErrorCode {
    #[doc = "server_error"]
    ServerError,
    #[doc = "unsupported_file"]
    UnsupportedFile,
    #[doc = "invalid_file"]
    InvalidFile,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObjectLastError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileObjectLastError {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: VectorStoreFileObjectLastErrorCode,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: String,
        }
        let VectorStoreFileObjectLastError { code, message, .. } =
            VectorStoreFileObjectLastError::deserialize(deserializer)?;
        Ok(Self { code, message })
    }
}
impl serde::Serialize for VectorStoreFileObjectLastError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileObjectLastError<'a> {
            #[serde(rename = "code")]
            code: &'a VectorStoreFileObjectLastErrorCode,
            #[serde(rename = "message")]
            message: &'a String,
        }
        let Self { code, message } = self;
        VectorStoreFileObjectLastError { code, message }.serialize(serializer)
    }
}
#[doc = "The last error associated with this vector store file. Will be `null` if there are no errors."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileObjectLastError {
    #[doc = "One of `server_error` or `rate_limit_exceeded`."]
    pub code: VectorStoreFileObjectLastErrorCode,
    #[doc = "A human-readable description of the error."]
    pub message: String,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store.file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectObject {
            #[default]
            #[serde(rename = "vector_store.file")]
            VectorStoreFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreFileObjectObject,
            #[serde(rename = "usage_bytes")]
            #[allow(dead_code)]
            usage_bytes: u64,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "vector_store_id")]
            #[allow(dead_code)]
            vector_store_id: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: VectorStoreFileObjectStatus,
            #[serde(rename = "last_error")]
            #[allow(dead_code)]
            last_error: Option<VectorStoreFileObjectLastError>,
            #[serde(rename = "chunking_strategy")]
            #[allow(dead_code)]
            chunking_strategy: Option<ChunkingStrategyResponse>,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
        }
        let VectorStoreFileObject {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
            ..
        } = VectorStoreFileObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        })
    }
}
impl serde::Serialize for VectorStoreFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store.file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreFileObjectObject {
            #[default]
            #[serde(rename = "vector_store.file")]
            VectorStoreFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a VectorStoreFileObjectObject,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a u64,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "vector_store_id")]
            vector_store_id: &'a String,
            #[serde(rename = "status")]
            status: &'a VectorStoreFileObjectStatus,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<VectorStoreFileObjectLastError>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<ChunkingStrategyResponse>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
        }
        let Self {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        } = self;
        VectorStoreFileObject {
            id,
            object: &Default::default(),
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        }
        .serialize(serializer)
    }
}
#[doc = "A list of files attached to a vector store."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The total vector store usage in bytes. Note that this may be different from the original file size."]
    pub usage_bytes: u64,
    #[doc = "The Unix timestamp (in seconds) for when the vector store file was created."]
    pub created_at: u64,
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to."]
    pub vector_store_id: String,
    #[doc = "The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use."]
    pub status: VectorStoreFileObjectStatus,
    #[doc = "The last error associated with this vector store file. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<VectorStoreFileObjectLastError>,
    #[builder(default)]
    pub chunking_strategy: Option<ChunkingStrategyResponse>,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreObjectFileCounts {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreObjectFileCounts {
            #[serde(rename = "in_progress")]
            #[allow(dead_code)]
            in_progress: u64,
            #[serde(rename = "completed")]
            #[allow(dead_code)]
            completed: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
            #[serde(rename = "cancelled")]
            #[allow(dead_code)]
            cancelled: u64,
            #[serde(rename = "total")]
            #[allow(dead_code)]
            total: u64,
        }
        let VectorStoreObjectFileCounts {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
            ..
        } = VectorStoreObjectFileCounts::deserialize(deserializer)?;
        Ok(Self {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        })
    }
}
impl serde::Serialize for VectorStoreObjectFileCounts {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreObjectFileCounts<'a> {
            #[serde(rename = "in_progress")]
            in_progress: &'a u64,
            #[serde(rename = "completed")]
            completed: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
            #[serde(rename = "cancelled")]
            cancelled: &'a u64,
            #[serde(rename = "total")]
            total: &'a u64,
        }
        let Self {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        } = self;
        VectorStoreObjectFileCounts {
            in_progress,
            completed,
            failed,
            cancelled,
            total,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct VectorStoreObjectFileCounts {
    #[doc = "The number of files that are currently being processed."]
    pub in_progress: u64,
    #[doc = "The number of files that have been successfully processed."]
    pub completed: u64,
    #[doc = "The number of files that have failed to process."]
    pub failed: u64,
    #[doc = "The number of files that were cancelled."]
    pub cancelled: u64,
    #[doc = "The total number of files."]
    pub total: u64,
}
impl<'de> serde::Deserialize<'de> for VectorStoreObjectStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VectorStoreObjectStatus {
            Expired(#[allow(dead_code)] VectorStoreObjectStatusExpired),
            InProgress(#[allow(dead_code)] VectorStoreObjectStatusInProgress),
            Completed(#[allow(dead_code)] VectorStoreObjectStatusCompleted),
        }
        Ok(match VectorStoreObjectStatus::deserialize(deserializer)? {
            VectorStoreObjectStatus::Expired(_) => Self::Expired,
            VectorStoreObjectStatus::InProgress(_) => Self::InProgress,
            VectorStoreObjectStatus::Completed(_) => Self::Completed,
        })
    }
}
impl serde::Serialize for VectorStoreObjectStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VectorStoreObjectStatus<'a> {
            Expired(#[allow(dead_code)] &'a VectorStoreObjectStatusExpired),
            InProgress(#[allow(dead_code)] &'a VectorStoreObjectStatusInProgress),
            Completed(#[allow(dead_code)] &'a VectorStoreObjectStatusCompleted),
        }
        match self {
            Self::Expired => {
                VectorStoreObjectStatus::Expired(&Default::default()).serialize(serializer)
            }
            Self::InProgress => {
                VectorStoreObjectStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                VectorStoreObjectStatus::Completed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreObjectStatus {
    #[doc = "expired"]
    Expired,
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
}
impl<'de> serde::Deserialize<'de> for VectorStoreObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectObject {
            #[default]
            #[serde(rename = "vector_store")]
            VectorStore,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreObject {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreObjectObject,
            #[serde(rename = "created_at")]
            #[allow(dead_code)]
            created_at: u64,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "usage_bytes")]
            #[allow(dead_code)]
            usage_bytes: u64,
            #[serde(rename = "file_counts")]
            #[allow(dead_code)]
            file_counts: VectorStoreObjectFileCounts,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: VectorStoreObjectStatus,
            #[serde(rename = "expires_after")]
            #[allow(dead_code)]
            expires_after: Option<VectorStoreExpirationAfter>,
            #[serde(rename = "expires_at")]
            #[allow(dead_code)]
            expires_at: Option<u64>,
            #[serde(rename = "last_active_at")]
            #[allow(dead_code)]
            last_active_at: Option<u64>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
        }
        let VectorStoreObject {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
            ..
        } = VectorStoreObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        })
    }
}
impl serde::Serialize for VectorStoreObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreObjectObject {
            #[default]
            #[serde(rename = "vector_store")]
            VectorStore,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a VectorStoreObjectObject,
            #[serde(rename = "created_at")]
            created_at: &'a u64,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a u64,
            #[serde(rename = "file_counts")]
            file_counts: &'a VectorStoreObjectFileCounts,
            #[serde(rename = "status")]
            status: &'a VectorStoreObjectStatus,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<VectorStoreExpirationAfter>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<u64>,
            #[serde(rename = "last_active_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_active_at: &'a Option<u64>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
        }
        let Self {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        } = self;
        VectorStoreObject {
            id,
            object: &Default::default(),
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "A vector store is a collection of processed files can be used by the `file_search` tool."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the vector store was created."]
    pub created_at: u64,
    #[doc = "The name of the vector store."]
    pub name: String,
    #[doc = "The total number of bytes used by the files in the vector store."]
    pub usage_bytes: u64,
    pub file_counts: VectorStoreObjectFileCounts,
    #[doc = "The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use."]
    pub status: VectorStoreObjectStatus,
    #[builder(default)]
    pub expires_after: Option<VectorStoreExpirationAfter>,
    #[doc = "The Unix timestamp (in seconds) for when the vector store will expire."]
    #[builder(default)]
    pub expires_at: Option<u64>,
    #[doc = "The Unix timestamp (in seconds) for when the vector store was last active."]
    #[builder(default)]
    pub last_active_at: Option<u64>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequestQuery {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VectorStoreSearchRequestQuery {
            String(#[allow(dead_code)] String),
            Array(#[allow(dead_code)] Vec<String>),
        }
        Ok(
            match VectorStoreSearchRequestQuery::deserialize(deserializer)? {
                VectorStoreSearchRequestQuery::String(_v) => Self::String(_v),
                VectorStoreSearchRequestQuery::Array(_v) => Self::Array(_v),
            },
        )
    }
}
impl serde::Serialize for VectorStoreSearchRequestQuery {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VectorStoreSearchRequestQuery<'a> {
            String(#[allow(dead_code)] &'a String),
            Array(#[allow(dead_code)] &'a Vec<String>),
        }
        match self {
            Self::String(_v) => VectorStoreSearchRequestQuery::String(_v).serialize(serializer),
            Self::Array(_v) => VectorStoreSearchRequestQuery::Array(_v).serialize(serializer),
        }
    }
}
#[doc = "A query string for a search"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreSearchRequestQuery {
    String(String),
    Array(Vec<String>),
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequestFilters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VectorStoreSearchRequestFilters {
            ComparisonFilter(#[allow(dead_code)] ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] CompoundFilter),
        }
        Ok(
            match VectorStoreSearchRequestFilters::deserialize(deserializer)? {
                VectorStoreSearchRequestFilters::ComparisonFilter(_v) => Self::ComparisonFilter(_v),
                VectorStoreSearchRequestFilters::CompoundFilter(_v) => Self::CompoundFilter(_v),
            },
        )
    }
}
impl serde::Serialize for VectorStoreSearchRequestFilters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VectorStoreSearchRequestFilters<'a> {
            ComparisonFilter(#[allow(dead_code)] &'a ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] &'a CompoundFilter),
        }
        match self {
            Self::ComparisonFilter(_v) => {
                VectorStoreSearchRequestFilters::ComparisonFilter(_v).serialize(serializer)
            }
            Self::CompoundFilter(_v) => {
                VectorStoreSearchRequestFilters::CompoundFilter(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "A filter to apply based on file attributes."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreSearchRequestFilters {
    ComparisonFilter(ComparisonFilter),
    CompoundFilter(CompoundFilter),
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequestRankingOptionsRanker {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchRequestRankingOptionsRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchRequestRankingOptionsRankerDefault2024_11_15 {
            #[default]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VectorStoreSearchRequestRankingOptionsRanker {
            Auto(#[allow(dead_code)] VectorStoreSearchRequestRankingOptionsRankerAuto),
            Default2024_11_15(
                #[allow(dead_code)] VectorStoreSearchRequestRankingOptionsRankerDefault2024_11_15,
            ),
        }
        Ok(
            match VectorStoreSearchRequestRankingOptionsRanker::deserialize(deserializer)? {
                VectorStoreSearchRequestRankingOptionsRanker::Auto(_) => Self::Auto,
                VectorStoreSearchRequestRankingOptionsRanker::Default2024_11_15(_) => {
                    Self::Default2024_11_15
                }
            },
        )
    }
}
impl serde::Serialize for VectorStoreSearchRequestRankingOptionsRanker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchRequestRankingOptionsRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchRequestRankingOptionsRankerDefault2024_11_15 {
            #[default]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VectorStoreSearchRequestRankingOptionsRanker<'a> {
            Auto(#[allow(dead_code)] &'a VectorStoreSearchRequestRankingOptionsRankerAuto),
            Default2024_11_15(
                #[allow(dead_code)]
                &'a VectorStoreSearchRequestRankingOptionsRankerDefault2024_11_15,
            ),
        }
        match self {
            Self::Auto => VectorStoreSearchRequestRankingOptionsRanker::Auto(&Default::default())
                .serialize(serializer),
            Self::Default2024_11_15 => {
                VectorStoreSearchRequestRankingOptionsRanker::Default2024_11_15(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum VectorStoreSearchRequestRankingOptionsRanker {
    #[doc = "auto"]
    #[default]
    Auto,
    #[doc = "default-2024-11-15"]
    Default2024_11_15,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequestRankingOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreSearchRequestRankingOptions {
            #[serde(rename = "ranker")]
            #[allow(dead_code)]
            ranker: Option<VectorStoreSearchRequestRankingOptionsRanker>,
            #[serde(rename = "score_threshold")]
            #[allow(dead_code)]
            score_threshold: Option<f64>,
        }
        let VectorStoreSearchRequestRankingOptions {
            ranker,
            score_threshold,
            ..
        } = VectorStoreSearchRequestRankingOptions::deserialize(deserializer)?;
        Ok(Self {
            ranker,
            score_threshold,
        })
    }
}
impl serde::Serialize for VectorStoreSearchRequestRankingOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreSearchRequestRankingOptions<'a> {
            #[serde(rename = "ranker")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranker: &'a Option<VectorStoreSearchRequestRankingOptionsRanker>,
            #[serde(rename = "score_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            score_threshold: &'a Option<f64>,
        }
        let Self {
            ranker,
            score_threshold,
        } = self;
        VectorStoreSearchRequestRankingOptions {
            ranker,
            score_threshold,
        }
        .serialize(serializer)
    }
}
#[doc = "Ranking options for search."]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchRequestRankingOptions {
    #[builder(default)]
    pub ranker: Option<VectorStoreSearchRequestRankingOptionsRanker>,
    #[builder(default)]
    pub score_threshold: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreSearchRequest {
            #[serde(rename = "query")]
            #[allow(dead_code)]
            query: VectorStoreSearchRequestQuery,
            #[serde(rename = "rewrite_query")]
            #[allow(dead_code)]
            rewrite_query: Option<bool>,
            #[serde(rename = "max_num_results")]
            #[allow(dead_code)]
            max_num_results: Option<u64>,
            #[serde(rename = "filters")]
            #[allow(dead_code)]
            filters: Option<VectorStoreSearchRequestFilters>,
            #[serde(rename = "ranking_options")]
            #[allow(dead_code)]
            ranking_options: Option<VectorStoreSearchRequestRankingOptions>,
        }
        let VectorStoreSearchRequest {
            query,
            rewrite_query,
            max_num_results,
            filters,
            ranking_options,
            ..
        } = VectorStoreSearchRequest::deserialize(deserializer)?;
        Ok(Self {
            query,
            rewrite_query,
            max_num_results,
            filters,
            ranking_options,
        })
    }
}
impl serde::Serialize for VectorStoreSearchRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreSearchRequest<'a> {
            #[serde(rename = "query")]
            query: &'a VectorStoreSearchRequestQuery,
            #[serde(rename = "rewrite_query")]
            #[serde(skip_serializing_if = "Option::is_none")]
            rewrite_query: &'a Option<bool>,
            #[serde(rename = "max_num_results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_num_results: &'a Option<u64>,
            #[serde(rename = "filters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filters: &'a Option<VectorStoreSearchRequestFilters>,
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<VectorStoreSearchRequestRankingOptions>,
        }
        let Self {
            query,
            rewrite_query,
            max_num_results,
            filters,
            ranking_options,
        } = self;
        VectorStoreSearchRequest {
            query,
            rewrite_query,
            max_num_results,
            filters,
            ranking_options,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchRequest {
    #[doc = "A query string for a search"]
    pub query: VectorStoreSearchRequestQuery,
    #[doc = "Whether to rewrite the natural language query for vector search."]
    #[builder(default)]
    pub rewrite_query: Option<bool>,
    #[doc = "The maximum number of results to return. This number should be between 1 and 50 inclusive."]
    #[builder(default)]
    pub max_num_results: Option<u64>,
    #[doc = "A filter to apply based on file attributes."]
    #[builder(default)]
    pub filters: Option<VectorStoreSearchRequestFilters>,
    #[doc = "Ranking options for search."]
    #[builder(default)]
    pub ranking_options: Option<VectorStoreSearchRequestRankingOptions>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchResultContentObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of content."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchResultContentObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreSearchResultContentObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: VectorStoreSearchResultContentObjectType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let VectorStoreSearchResultContentObject { text, .. } =
            VectorStoreSearchResultContentObject::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for VectorStoreSearchResultContentObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of content."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchResultContentObjectType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreSearchResultContentObject<'a> {
            #[serde(rename = "type")]
            type_: &'a VectorStoreSearchResultContentObjectType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        VectorStoreSearchResultContentObject {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultContentObject {
    #[doc = "The text content returned from search."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchResultItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreSearchResultItem {
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: String,
            #[serde(rename = "score")]
            #[allow(dead_code)]
            score: f64,
            #[serde(rename = "attributes")]
            #[allow(dead_code)]
            attributes: Option<VectorStoreFileAttributes>,
            #[serde(rename = "content")]
            #[allow(dead_code)]
            content: Vec<VectorStoreSearchResultContentObject>,
        }
        let VectorStoreSearchResultItem {
            file_id,
            filename,
            score,
            attributes,
            content,
            ..
        } = VectorStoreSearchResultItem::deserialize(deserializer)?;
        Ok(Self {
            file_id,
            filename,
            score,
            attributes,
            content,
        })
    }
}
impl serde::Serialize for VectorStoreSearchResultItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreSearchResultItem<'a> {
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "score")]
            score: &'a f64,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<VectorStoreFileAttributes>,
            #[serde(rename = "content")]
            content: &'a Vec<VectorStoreSearchResultContentObject>,
        }
        let Self {
            file_id,
            filename,
            score,
            attributes,
            content,
        } = self;
        VectorStoreSearchResultItem {
            file_id,
            filename,
            score,
            attributes,
            content,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultItem {
    #[doc = "The ID of the vector store file."]
    pub file_id: String,
    #[doc = "The name of the vector store file."]
    pub filename: String,
    #[doc = "The similarity score for the result."]
    pub score: f64,
    #[builder(default)]
    pub attributes: Option<VectorStoreFileAttributes>,
    #[doc = "Content chunks from the file."]
    pub content: Vec<VectorStoreSearchResultContentObject>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchResultsPage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The object type, which is always `vector_store.search_results.page`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchResultsPageObject {
            #[default]
            #[serde(rename = "vector_store.search_results.page")]
            VectorStoreSearchResultsPage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreSearchResultsPage {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: VectorStoreSearchResultsPageObject,
            #[serde(rename = "search_query")]
            #[allow(dead_code)]
            search_query: Vec<String>,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: Vec<VectorStoreSearchResultItem>,
            #[serde(rename = "has_more")]
            #[allow(dead_code)]
            has_more: bool,
            #[serde(rename = "next_page")]
            #[allow(dead_code)]
            next_page: Option<String>,
        }
        let VectorStoreSearchResultsPage {
            search_query,
            data,
            has_more,
            next_page,
            ..
        } = VectorStoreSearchResultsPage::deserialize(deserializer)?;
        Ok(Self {
            search_query,
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for VectorStoreSearchResultsPage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The object type, which is always `vector_store.search_results.page`"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VectorStoreSearchResultsPageObject {
            #[default]
            #[serde(rename = "vector_store.search_results.page")]
            VectorStoreSearchResultsPage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreSearchResultsPage<'a> {
            #[serde(rename = "object")]
            object: &'a VectorStoreSearchResultsPageObject,
            #[serde(rename = "search_query")]
            search_query: &'a Vec<String>,
            #[serde(rename = "data")]
            data: &'a Vec<VectorStoreSearchResultItem>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            #[serde(skip_serializing_if = "Option::is_none")]
            next_page: &'a Option<String>,
        }
        let Self {
            search_query,
            data,
            has_more,
            next_page,
        } = self;
        VectorStoreSearchResultsPage {
            object: &Default::default(),
            search_query,
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultsPage {
    pub search_query: Vec<String>,
    #[doc = "The list of search result items."]
    pub data: Vec<VectorStoreSearchResultItem>,
    #[doc = "Indicates if there are more results to fetch."]
    pub has_more: bool,
    #[doc = "The token for the next page, if any."]
    #[builder(default)]
    pub next_page: Option<String>,
}
impl<'de> serde::Deserialize<'de> for VoiceIdsShared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedAlloy {
            #[default]
            #[serde(rename = "alloy")]
            Alloy,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedAsh {
            #[default]
            #[serde(rename = "ash")]
            Ash,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedBallad {
            #[default]
            #[serde(rename = "ballad")]
            Ballad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedCoral {
            #[default]
            #[serde(rename = "coral")]
            Coral,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedEcho {
            #[default]
            #[serde(rename = "echo")]
            Echo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedFable {
            #[default]
            #[serde(rename = "fable")]
            Fable,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedOnyx {
            #[default]
            #[serde(rename = "onyx")]
            Onyx,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedNova {
            #[default]
            #[serde(rename = "nova")]
            Nova,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedSage {
            #[default]
            #[serde(rename = "sage")]
            Sage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedShimmer {
            #[default]
            #[serde(rename = "shimmer")]
            Shimmer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedVerse {
            #[default]
            #[serde(rename = "verse")]
            Verse,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VoiceIdsShared {
            Alloy(#[allow(dead_code)] VoiceIdsSharedAlloy),
            Ash(#[allow(dead_code)] VoiceIdsSharedAsh),
            Ballad(#[allow(dead_code)] VoiceIdsSharedBallad),
            Coral(#[allow(dead_code)] VoiceIdsSharedCoral),
            Echo(#[allow(dead_code)] VoiceIdsSharedEcho),
            Fable(#[allow(dead_code)] VoiceIdsSharedFable),
            Onyx(#[allow(dead_code)] VoiceIdsSharedOnyx),
            Nova(#[allow(dead_code)] VoiceIdsSharedNova),
            Sage(#[allow(dead_code)] VoiceIdsSharedSage),
            Shimmer(#[allow(dead_code)] VoiceIdsSharedShimmer),
            Verse(#[allow(dead_code)] VoiceIdsSharedVerse),
            Other(#[allow(dead_code)] String),
        }
        Ok(match VoiceIdsShared::deserialize(deserializer)? {
            VoiceIdsShared::Other(_v) => Self::Other(_v),
            VoiceIdsShared::Alloy(_) => Self::Alloy,
            VoiceIdsShared::Ash(_) => Self::Ash,
            VoiceIdsShared::Ballad(_) => Self::Ballad,
            VoiceIdsShared::Coral(_) => Self::Coral,
            VoiceIdsShared::Echo(_) => Self::Echo,
            VoiceIdsShared::Fable(_) => Self::Fable,
            VoiceIdsShared::Onyx(_) => Self::Onyx,
            VoiceIdsShared::Nova(_) => Self::Nova,
            VoiceIdsShared::Sage(_) => Self::Sage,
            VoiceIdsShared::Shimmer(_) => Self::Shimmer,
            VoiceIdsShared::Verse(_) => Self::Verse,
        })
    }
}
impl serde::Serialize for VoiceIdsShared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedAlloy {
            #[default]
            #[serde(rename = "alloy")]
            Alloy,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedAsh {
            #[default]
            #[serde(rename = "ash")]
            Ash,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedBallad {
            #[default]
            #[serde(rename = "ballad")]
            Ballad,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedCoral {
            #[default]
            #[serde(rename = "coral")]
            Coral,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedEcho {
            #[default]
            #[serde(rename = "echo")]
            Echo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedFable {
            #[default]
            #[serde(rename = "fable")]
            Fable,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedOnyx {
            #[default]
            #[serde(rename = "onyx")]
            Onyx,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedNova {
            #[default]
            #[serde(rename = "nova")]
            Nova,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedSage {
            #[default]
            #[serde(rename = "sage")]
            Sage,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedShimmer {
            #[default]
            #[serde(rename = "shimmer")]
            Shimmer,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum VoiceIdsSharedVerse {
            #[default]
            #[serde(rename = "verse")]
            Verse,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VoiceIdsShared<'a> {
            Other(#[allow(dead_code)] &'a String),
            Alloy(#[allow(dead_code)] &'a VoiceIdsSharedAlloy),
            Ash(#[allow(dead_code)] &'a VoiceIdsSharedAsh),
            Ballad(#[allow(dead_code)] &'a VoiceIdsSharedBallad),
            Coral(#[allow(dead_code)] &'a VoiceIdsSharedCoral),
            Echo(#[allow(dead_code)] &'a VoiceIdsSharedEcho),
            Fable(#[allow(dead_code)] &'a VoiceIdsSharedFable),
            Onyx(#[allow(dead_code)] &'a VoiceIdsSharedOnyx),
            Nova(#[allow(dead_code)] &'a VoiceIdsSharedNova),
            Sage(#[allow(dead_code)] &'a VoiceIdsSharedSage),
            Shimmer(#[allow(dead_code)] &'a VoiceIdsSharedShimmer),
            Verse(#[allow(dead_code)] &'a VoiceIdsSharedVerse),
        }
        match self {
            Self::Other(_v) => VoiceIdsShared::Other(_v).serialize(serializer),
            Self::Alloy => VoiceIdsShared::Alloy(&Default::default()).serialize(serializer),
            Self::Ash => VoiceIdsShared::Ash(&Default::default()).serialize(serializer),
            Self::Ballad => VoiceIdsShared::Ballad(&Default::default()).serialize(serializer),
            Self::Coral => VoiceIdsShared::Coral(&Default::default()).serialize(serializer),
            Self::Echo => VoiceIdsShared::Echo(&Default::default()).serialize(serializer),
            Self::Fable => VoiceIdsShared::Fable(&Default::default()).serialize(serializer),
            Self::Onyx => VoiceIdsShared::Onyx(&Default::default()).serialize(serializer),
            Self::Nova => VoiceIdsShared::Nova(&Default::default()).serialize(serializer),
            Self::Sage => VoiceIdsShared::Sage(&Default::default()).serialize(serializer),
            Self::Shimmer => VoiceIdsShared::Shimmer(&Default::default()).serialize(serializer),
            Self::Verse => VoiceIdsShared::Verse(&Default::default()).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VoiceIdsShared {
    Other(String),
    #[doc = "alloy"]
    Alloy,
    #[doc = "ash"]
    Ash,
    #[doc = "ballad"]
    Ballad,
    #[doc = "coral"]
    Coral,
    #[doc = "echo"]
    Echo,
    #[doc = "fable"]
    Fable,
    #[doc = "onyx"]
    Onyx,
    #[doc = "nova"]
    Nova,
    #[doc = "sage"]
    Sage,
    #[doc = "shimmer"]
    Shimmer,
    #[doc = "verse"]
    Verse,
}
impl<'de> serde::Deserialize<'de> for Wait {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Specifies the event type. For a wait action, this property is \nalways set to `wait`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WaitType {
            #[default]
            #[serde(rename = "wait")]
            Wait,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Wait {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: WaitType,
        }
        let Wait { .. } = Wait::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for Wait {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Specifies the event type. For a wait action, this property is \nalways set to `wait`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WaitType {
            #[default]
            #[serde(rename = "wait")]
            Wait,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Wait<'a> {
            #[serde(rename = "type")]
            type_: &'a WaitType,
        }
        let Self {} = self;
        Wait {
            type_: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[doc = "A wait action.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct Wait {}
impl<'de> serde::Deserialize<'de> for WebSearchContextSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum WebSearchContextSize {
            Low(#[allow(dead_code)] WebSearchContextSizeLow),
            Medium(#[allow(dead_code)] WebSearchContextSizeMedium),
            High(#[allow(dead_code)] WebSearchContextSizeHigh),
        }
        Ok(match WebSearchContextSize::deserialize(deserializer)? {
            WebSearchContextSize::Low(_) => Self::Low,
            WebSearchContextSize::Medium(_) => Self::Medium,
            WebSearchContextSize::High(_) => Self::High,
        })
    }
}
impl serde::Serialize for WebSearchContextSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchContextSizeHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum WebSearchContextSize<'a> {
            Low(#[allow(dead_code)] &'a WebSearchContextSizeLow),
            Medium(#[allow(dead_code)] &'a WebSearchContextSizeMedium),
            High(#[allow(dead_code)] &'a WebSearchContextSizeHigh),
        }
        match self {
            Self::Low => WebSearchContextSize::Low(&Default::default()).serialize(serializer),
            Self::Medium => WebSearchContextSize::Medium(&Default::default()).serialize(serializer),
            Self::High => WebSearchContextSize::High(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "High level guidance for the amount of context window space to use for the \nsearch. One of `low`, `medium`, or `high`. `medium` is the default.\n"]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum WebSearchContextSize {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    #[default]
    Medium,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for WebSearchLocation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebSearchLocation {
            #[serde(rename = "country")]
            #[allow(dead_code)]
            country: Option<String>,
            #[serde(rename = "region")]
            #[allow(dead_code)]
            region: Option<String>,
            #[serde(rename = "city")]
            #[allow(dead_code)]
            city: Option<String>,
            #[serde(rename = "timezone")]
            #[allow(dead_code)]
            timezone: Option<String>,
        }
        let WebSearchLocation {
            country,
            region,
            city,
            timezone,
            ..
        } = WebSearchLocation::deserialize(deserializer)?;
        Ok(Self {
            country,
            region,
            city,
            timezone,
        })
    }
}
impl serde::Serialize for WebSearchLocation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebSearchLocation<'a> {
            #[serde(rename = "country")]
            #[serde(skip_serializing_if = "Option::is_none")]
            country: &'a Option<String>,
            #[serde(rename = "region")]
            #[serde(skip_serializing_if = "Option::is_none")]
            region: &'a Option<String>,
            #[serde(rename = "city")]
            #[serde(skip_serializing_if = "Option::is_none")]
            city: &'a Option<String>,
            #[serde(rename = "timezone")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timezone: &'a Option<String>,
        }
        let Self {
            country,
            region,
            city,
            timezone,
        } = self;
        WebSearchLocation {
            country,
            region,
            city,
            timezone,
        }
        .serialize(serializer)
    }
}
#[doc = "Approximate location parameters for the search."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct WebSearchLocation {
    #[doc = "The two-letter \n[ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user,\ne.g. `US`.\n"]
    #[builder(default)]
    pub country: Option<String>,
    #[doc = "Free text input for the region of the user, e.g. `California`.\n"]
    #[builder(default)]
    pub region: Option<String>,
    #[doc = "Free text input for the city of the user, e.g. `San Francisco`.\n"]
    #[builder(default)]
    pub city: Option<String>,
    #[doc = "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) \nof the user, e.g. `America/Los_Angeles`.\n"]
    #[builder(default)]
    pub timezone: Option<String>,
}
impl<'de> serde::Deserialize<'de> for WebSearchToolCallStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusSearching {
            #[default]
            #[serde(rename = "searching")]
            Searching,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum WebSearchToolCallStatus {
            InProgress(#[allow(dead_code)] WebSearchToolCallStatusInProgress),
            Searching(#[allow(dead_code)] WebSearchToolCallStatusSearching),
            Completed(#[allow(dead_code)] WebSearchToolCallStatusCompleted),
            Failed(#[allow(dead_code)] WebSearchToolCallStatusFailed),
        }
        Ok(match WebSearchToolCallStatus::deserialize(deserializer)? {
            WebSearchToolCallStatus::InProgress(_) => Self::InProgress,
            WebSearchToolCallStatus::Searching(_) => Self::Searching,
            WebSearchToolCallStatus::Completed(_) => Self::Completed,
            WebSearchToolCallStatus::Failed(_) => Self::Failed,
        })
    }
}
impl serde::Serialize for WebSearchToolCallStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusSearching {
            #[default]
            #[serde(rename = "searching")]
            Searching,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum WebSearchToolCallStatus<'a> {
            InProgress(#[allow(dead_code)] &'a WebSearchToolCallStatusInProgress),
            Searching(#[allow(dead_code)] &'a WebSearchToolCallStatusSearching),
            Completed(#[allow(dead_code)] &'a WebSearchToolCallStatusCompleted),
            Failed(#[allow(dead_code)] &'a WebSearchToolCallStatusFailed),
        }
        match self {
            Self::InProgress => {
                WebSearchToolCallStatus::InProgress(&Default::default()).serialize(serializer)
            }
            Self::Searching => {
                WebSearchToolCallStatus::Searching(&Default::default()).serialize(serializer)
            }
            Self::Completed => {
                WebSearchToolCallStatus::Completed(&Default::default()).serialize(serializer)
            }
            Self::Failed => {
                WebSearchToolCallStatus::Failed(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The status of the web search tool call.\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum WebSearchToolCallStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "searching"]
    Searching,
    #[doc = "completed"]
    Completed,
    #[doc = "failed"]
    Failed,
}
impl<'de> serde::Deserialize<'de> for WebSearchToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the web search tool call. Always `web_search_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallType {
            #[default]
            #[serde(rename = "web_search_call")]
            WebSearchCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebSearchToolCall {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: WebSearchToolCallType,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: WebSearchToolCallStatus,
        }
        let WebSearchToolCall { id, status, .. } = WebSearchToolCall::deserialize(deserializer)?;
        Ok(Self { id, status })
    }
}
impl serde::Serialize for WebSearchToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the web search tool call. Always `web_search_call`.\n"]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchToolCallType {
            #[default]
            #[serde(rename = "web_search_call")]
            WebSearchCall,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebSearchToolCall<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            type_: &'a WebSearchToolCallType,
            #[serde(rename = "status")]
            status: &'a WebSearchToolCallStatus,
        }
        let Self { id, status } = self;
        WebSearchToolCall {
            id,
            type_: &Default::default(),
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The results of a web search tool call. See the \n[web search guide](https://platform.openai.com/docs/guides/tools-web-search) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebSearchToolCall {
    #[doc = "The unique ID of the web search tool call.\n"]
    pub id: String,
    #[doc = "The status of the web search tool call.\n"]
    pub status: WebSearchToolCallStatus,
}
impl<'de> serde::Deserialize<'de> for InputTextContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the input item. Always `input_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputTextContentType {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputTextContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: InputTextContentType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let InputTextContent { text, .. } = InputTextContent::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for InputTextContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the input item. Always `input_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputTextContentType {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputTextContent<'a> {
            #[serde(rename = "type")]
            type_: &'a InputTextContentType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        InputTextContent {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "A text input to the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputTextContent {
    #[doc = "The text input to the model."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for InputImageContentDetail {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum InputImageContentDetail {
            Low(#[allow(dead_code)] InputImageContentDetailLow),
            High(#[allow(dead_code)] InputImageContentDetailHigh),
            Auto(#[allow(dead_code)] InputImageContentDetailAuto),
        }
        Ok(match InputImageContentDetail::deserialize(deserializer)? {
            InputImageContentDetail::Low(_) => Self::Low,
            InputImageContentDetail::High(_) => Self::High,
            InputImageContentDetail::Auto(_) => Self::Auto,
        })
    }
}
impl serde::Serialize for InputImageContentDetail {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentDetailAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum InputImageContentDetail<'a> {
            Low(#[allow(dead_code)] &'a InputImageContentDetailLow),
            High(#[allow(dead_code)] &'a InputImageContentDetailHigh),
            Auto(#[allow(dead_code)] &'a InputImageContentDetailAuto),
        }
        match self {
            Self::Low => InputImageContentDetail::Low(&Default::default()).serialize(serializer),
            Self::High => InputImageContentDetail::High(&Default::default()).serialize(serializer),
            Self::Auto => InputImageContentDetail::Auto(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum InputImageContentDetail {
    #[doc = "low"]
    Low,
    #[doc = "high"]
    High,
    #[doc = "auto"]
    Auto,
}
impl<'de> serde::Deserialize<'de> for InputImageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the input item. Always `input_image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentType {
            #[default]
            #[serde(rename = "input_image")]
            InputImage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputImageContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: InputImageContentType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: Option<String>,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "detail")]
            #[allow(dead_code)]
            detail: InputImageContentDetail,
        }
        let InputImageContent {
            image_url,
            file_id,
            detail,
            ..
        } = InputImageContent::deserialize(deserializer)?;
        Ok(Self {
            image_url,
            file_id,
            detail,
        })
    }
}
impl serde::Serialize for InputImageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the input item. Always `input_image`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputImageContentType {
            #[default]
            #[serde(rename = "input_image")]
            InputImage,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputImageContent<'a> {
            #[serde(rename = "type")]
            type_: &'a InputImageContentType,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "detail")]
            detail: &'a InputImageContentDetail,
        }
        let Self {
            image_url,
            file_id,
            detail,
        } = self;
        InputImageContent {
            type_: &Default::default(),
            image_url,
            file_id,
            detail,
        }
        .serialize(serializer)
    }
}
#[doc = "An image input to the model. Learn about [image inputs](https://platform.openai.com/docs/guides/vision)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputImageContent {
    #[doc = "The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL."]
    #[builder(default)]
    pub image_url: Option<String>,
    #[doc = "The ID of the file to be sent to the model."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`."]
    pub detail: InputImageContentDetail,
}
impl<'de> serde::Deserialize<'de> for InputFileContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the input item. Always `input_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputFileContentType {
            #[default]
            #[serde(rename = "input_file")]
            InputFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputFileContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: InputFileContentType,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: Option<String>,
            #[serde(rename = "filename")]
            #[allow(dead_code)]
            filename: Option<String>,
            #[serde(rename = "file_data")]
            #[allow(dead_code)]
            file_data: Option<String>,
        }
        let InputFileContent {
            file_id,
            filename,
            file_data,
            ..
        } = InputFileContent::deserialize(deserializer)?;
        Ok(Self {
            file_id,
            filename,
            file_data,
        })
    }
}
impl serde::Serialize for InputFileContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the input item. Always `input_file`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum InputFileContentType {
            #[default]
            #[serde(rename = "input_file")]
            InputFile,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputFileContent<'a> {
            #[serde(rename = "type")]
            type_: &'a InputFileContentType,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "filename")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filename: &'a Option<String>,
            #[serde(rename = "file_data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_data: &'a Option<String>,
        }
        let Self {
            file_id,
            filename,
            file_data,
        } = self;
        InputFileContent {
            type_: &Default::default(),
            file_id,
            filename,
            file_data,
        }
        .serialize(serializer)
    }
}
#[doc = "A file input to the model."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct InputFileContent {
    #[doc = "The ID of the file to be sent to the model."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The name of the file to be sent to the model."]
    #[builder(default)]
    pub filename: Option<String>,
    #[doc = "The content of the file to be sent to the model.\n"]
    #[builder(default)]
    pub file_data: Option<String>,
}
impl<'de> serde::Deserialize<'de> for FunctionTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the function tool. Always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FunctionToolType,
            #[serde(rename = "name")]
            #[allow(dead_code)]
            name: String,
            #[serde(rename = "description")]
            #[allow(dead_code)]
            description: Option<String>,
            #[serde(rename = "parameters")]
            #[allow(dead_code)]
            parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "strict")]
            #[allow(dead_code)]
            strict: Option<bool>,
        }
        let FunctionTool {
            name,
            description,
            parameters,
            strict,
            ..
        } = FunctionTool::deserialize(deserializer)?;
        Ok(Self {
            name,
            description,
            parameters,
            strict,
        })
    }
}
impl serde::Serialize for FunctionTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the function tool. Always `function`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionToolType {
            #[default]
            #[serde(rename = "function")]
            Function,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionTool<'a> {
            #[serde(rename = "type")]
            type_: &'a FunctionToolType,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<std::collections::HashMap<String, serde_json::Value>>,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let Self {
            name,
            description,
            parameters,
            strict,
        } = self;
        FunctionTool {
            type_: &Default::default(),
            name,
            description,
            parameters,
            strict,
        }
        .serialize(serializer)
    }
}
#[doc = "Defines a function in your own code the model can choose to call. Learn more about [function calling](https://platform.openai.com/docs/guides/function-calling)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionTool {
    #[doc = "The name of the function to call."]
    pub name: String,
    #[doc = "A description of the function. Used by the model to determine whether or not to call the function."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "A JSON schema object describing the parameters of the function."]
    #[builder(default)]
    pub parameters: Option<std::collections::HashMap<String, serde_json::Value>>,
    #[doc = "Whether to enforce strict parameter validation. Default `true`."]
    #[builder(default)]
    pub strict: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for RankingOptionsRanker {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RankingOptionsRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RankingOptionsRankerDefault2024_11_15 {
            #[default]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RankingOptionsRanker {
            Auto(#[allow(dead_code)] RankingOptionsRankerAuto),
            Default2024_11_15(#[allow(dead_code)] RankingOptionsRankerDefault2024_11_15),
        }
        Ok(match RankingOptionsRanker::deserialize(deserializer)? {
            RankingOptionsRanker::Auto(_) => Self::Auto,
            RankingOptionsRanker::Default2024_11_15(_) => Self::Default2024_11_15,
        })
    }
}
impl serde::Serialize for RankingOptionsRanker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RankingOptionsRankerAuto {
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RankingOptionsRankerDefault2024_11_15 {
            #[default]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RankingOptionsRanker<'a> {
            Auto(#[allow(dead_code)] &'a RankingOptionsRankerAuto),
            Default2024_11_15(#[allow(dead_code)] &'a RankingOptionsRankerDefault2024_11_15),
        }
        match self {
            Self::Auto => RankingOptionsRanker::Auto(&Default::default()).serialize(serializer),
            Self::Default2024_11_15 => {
                RankingOptionsRanker::Default2024_11_15(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The ranker to use for the file search."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RankingOptionsRanker {
    #[doc = "auto"]
    Auto,
    #[doc = "default-2024-11-15"]
    Default2024_11_15,
}
impl<'de> serde::Deserialize<'de> for RankingOptions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RankingOptions {
            #[serde(rename = "ranker")]
            #[allow(dead_code)]
            ranker: Option<RankingOptionsRanker>,
            #[serde(rename = "score_threshold")]
            #[allow(dead_code)]
            score_threshold: Option<f64>,
        }
        let RankingOptions {
            ranker,
            score_threshold,
            ..
        } = RankingOptions::deserialize(deserializer)?;
        Ok(Self {
            ranker,
            score_threshold,
        })
    }
}
impl serde::Serialize for RankingOptions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RankingOptions<'a> {
            #[serde(rename = "ranker")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranker: &'a Option<RankingOptionsRanker>,
            #[serde(rename = "score_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            score_threshold: &'a Option<f64>,
        }
        let Self {
            ranker,
            score_threshold,
        } = self;
        RankingOptions {
            ranker,
            score_threshold,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Copy, Default, typed_builder :: TypedBuilder)]
pub struct RankingOptions {
    #[doc = "The ranker to use for the file search."]
    #[builder(default)]
    pub ranker: Option<RankingOptionsRanker>,
    #[doc = "The score threshold for the file search, a number between 0 and 1. Numbers closer to 1 will attempt to return only the most relevant results, but may return fewer results."]
    #[builder(default)]
    pub score_threshold: Option<f64>,
}
impl<'de> serde::Deserialize<'de> for Filters {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum Filters {
            ComparisonFilter(#[allow(dead_code)] ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] CompoundFilter),
        }
        Ok(match Filters::deserialize(deserializer)? {
            Filters::ComparisonFilter(_v) => Self::ComparisonFilter(_v),
            Filters::CompoundFilter(_v) => Self::CompoundFilter(_v),
        })
    }
}
impl serde::Serialize for Filters {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum Filters<'a> {
            ComparisonFilter(#[allow(dead_code)] &'a ComparisonFilter),
            CompoundFilter(#[allow(dead_code)] &'a CompoundFilter),
        }
        match self {
            Self::ComparisonFilter(_v) => Filters::ComparisonFilter(_v).serialize(serializer),
            Self::CompoundFilter(_v) => Filters::CompoundFilter(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Filters {
    ComparisonFilter(ComparisonFilter),
    CompoundFilter(CompoundFilter),
}
impl<'de> serde::Deserialize<'de> for FileSearchTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the file search tool. Always `file_search`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileSearchTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FileSearchToolType,
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Vec<String>,
            #[serde(rename = "max_num_results")]
            #[allow(dead_code)]
            max_num_results: Option<u64>,
            #[serde(rename = "ranking_options")]
            #[allow(dead_code)]
            ranking_options: Option<RankingOptions>,
            #[serde(rename = "filters")]
            #[allow(dead_code)]
            filters: Option<Filters>,
        }
        let FileSearchTool {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
            ..
        } = FileSearchTool::deserialize(deserializer)?;
        Ok(Self {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        })
    }
}
impl serde::Serialize for FileSearchTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the file search tool. Always `file_search`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileSearchToolType {
            #[default]
            #[serde(rename = "file_search")]
            FileSearch,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileSearchTool<'a> {
            #[serde(rename = "type")]
            type_: &'a FileSearchToolType,
            #[serde(rename = "vector_store_ids")]
            vector_store_ids: &'a Vec<String>,
            #[serde(rename = "max_num_results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_num_results: &'a Option<u64>,
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<RankingOptions>,
            #[serde(rename = "filters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filters: &'a Option<Filters>,
        }
        let Self {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        } = self;
        FileSearchTool {
            type_: &Default::default(),
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool that searches for relevant content from uploaded files. Learn more about the [file search tool](https://platform.openai.com/docs/guides/tools-file-search)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileSearchTool {
    #[doc = "The IDs of the vector stores to search."]
    pub vector_store_ids: Vec<String>,
    #[doc = "The maximum number of results to return. This number should be between 1 and 50 inclusive."]
    #[builder(default)]
    pub max_num_results: Option<u64>,
    #[doc = "Ranking options for search."]
    #[builder(default)]
    pub ranking_options: Option<RankingOptions>,
    #[doc = "A filter to apply."]
    #[builder(default)]
    pub filters: Option<Filters>,
}
impl<'de> serde::Deserialize<'de> for ApproximateLocation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of location approximation. Always `approximate`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ApproximateLocationType {
            #[default]
            #[serde(rename = "approximate")]
            Approximate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ApproximateLocation {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ApproximateLocationType,
            #[serde(rename = "country")]
            #[allow(dead_code)]
            country: Option<String>,
            #[serde(rename = "region")]
            #[allow(dead_code)]
            region: Option<String>,
            #[serde(rename = "city")]
            #[allow(dead_code)]
            city: Option<String>,
            #[serde(rename = "timezone")]
            #[allow(dead_code)]
            timezone: Option<String>,
        }
        let ApproximateLocation {
            country,
            region,
            city,
            timezone,
            ..
        } = ApproximateLocation::deserialize(deserializer)?;
        Ok(Self {
            country,
            region,
            city,
            timezone,
        })
    }
}
impl serde::Serialize for ApproximateLocation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of location approximation. Always `approximate`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ApproximateLocationType {
            #[default]
            #[serde(rename = "approximate")]
            Approximate,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ApproximateLocation<'a> {
            #[serde(rename = "type")]
            type_: &'a ApproximateLocationType,
            #[serde(rename = "country")]
            #[serde(skip_serializing_if = "Option::is_none")]
            country: &'a Option<String>,
            #[serde(rename = "region")]
            #[serde(skip_serializing_if = "Option::is_none")]
            region: &'a Option<String>,
            #[serde(rename = "city")]
            #[serde(skip_serializing_if = "Option::is_none")]
            city: &'a Option<String>,
            #[serde(rename = "timezone")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timezone: &'a Option<String>,
        }
        let Self {
            country,
            region,
            city,
            timezone,
        } = self;
        ApproximateLocation {
            type_: &Default::default(),
            country,
            region,
            city,
            timezone,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct ApproximateLocation {
    #[doc = "The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`."]
    #[builder(default)]
    pub country: Option<String>,
    #[doc = "Free text input for the region of the user, e.g. `California`."]
    #[builder(default)]
    pub region: Option<String>,
    #[doc = "Free text input for the city of the user, e.g. `San Francisco`."]
    #[builder(default)]
    pub city: Option<String>,
    #[doc = "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`."]
    #[builder(default)]
    pub timezone: Option<String>,
}
impl<'de> serde::Deserialize<'de> for WebSearchPreviewToolType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolTypeWebSearchPreview {
            #[default]
            #[serde(rename = "web_search_preview")]
            WebSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolTypeWebSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "web_search_preview_2025_03_11")]
            WebSearchPreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum WebSearchPreviewToolType {
            WebSearchPreview(#[allow(dead_code)] WebSearchPreviewToolTypeWebSearchPreview),
            WebSearchPreview2025_03_11(
                #[allow(dead_code)] WebSearchPreviewToolTypeWebSearchPreview2025_03_11,
            ),
        }
        Ok(match WebSearchPreviewToolType::deserialize(deserializer)? {
            WebSearchPreviewToolType::WebSearchPreview(_) => Self::WebSearchPreview,
            WebSearchPreviewToolType::WebSearchPreview2025_03_11(_) => {
                Self::WebSearchPreview2025_03_11
            }
        })
    }
}
impl serde::Serialize for WebSearchPreviewToolType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolTypeWebSearchPreview {
            #[default]
            #[serde(rename = "web_search_preview")]
            WebSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolTypeWebSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "web_search_preview_2025_03_11")]
            WebSearchPreview2025_03_11,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum WebSearchPreviewToolType<'a> {
            WebSearchPreview(#[allow(dead_code)] &'a WebSearchPreviewToolTypeWebSearchPreview),
            WebSearchPreview2025_03_11(
                #[allow(dead_code)] &'a WebSearchPreviewToolTypeWebSearchPreview2025_03_11,
            ),
        }
        match self {
            Self::WebSearchPreview => {
                WebSearchPreviewToolType::WebSearchPreview(&Default::default())
                    .serialize(serializer)
            }
            Self::WebSearchPreview2025_03_11 => {
                WebSearchPreviewToolType::WebSearchPreview2025_03_11(&Default::default())
                    .serialize(serializer)
            }
        }
    }
}
#[doc = "The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum WebSearchPreviewToolType {
    #[doc = "web_search_preview"]
    #[default]
    WebSearchPreview,
    #[doc = "web_search_preview_2025_03_11"]
    WebSearchPreview2025_03_11,
}
impl<'de> serde::Deserialize<'de> for WebSearchPreviewToolSearchContextSize {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum WebSearchPreviewToolSearchContextSize {
            Low(#[allow(dead_code)] WebSearchPreviewToolSearchContextSizeLow),
            Medium(#[allow(dead_code)] WebSearchPreviewToolSearchContextSizeMedium),
            High(#[allow(dead_code)] WebSearchPreviewToolSearchContextSizeHigh),
        }
        Ok(
            match WebSearchPreviewToolSearchContextSize::deserialize(deserializer)? {
                WebSearchPreviewToolSearchContextSize::Low(_) => Self::Low,
                WebSearchPreviewToolSearchContextSize::Medium(_) => Self::Medium,
                WebSearchPreviewToolSearchContextSize::High(_) => Self::High,
            },
        )
    }
}
impl serde::Serialize for WebSearchPreviewToolSearchContextSize {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeLow {
            #[default]
            #[serde(rename = "low")]
            Low,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeMedium {
            #[default]
            #[serde(rename = "medium")]
            Medium,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum WebSearchPreviewToolSearchContextSizeHigh {
            #[default]
            #[serde(rename = "high")]
            High,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum WebSearchPreviewToolSearchContextSize<'a> {
            Low(#[allow(dead_code)] &'a WebSearchPreviewToolSearchContextSizeLow),
            Medium(#[allow(dead_code)] &'a WebSearchPreviewToolSearchContextSizeMedium),
            High(#[allow(dead_code)] &'a WebSearchPreviewToolSearchContextSizeHigh),
        }
        match self {
            Self::Low => WebSearchPreviewToolSearchContextSize::Low(&Default::default())
                .serialize(serializer),
            Self::Medium => WebSearchPreviewToolSearchContextSize::Medium(&Default::default())
                .serialize(serializer),
            Self::High => WebSearchPreviewToolSearchContextSize::High(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum WebSearchPreviewToolSearchContextSize {
    #[doc = "low"]
    Low,
    #[doc = "medium"]
    Medium,
    #[doc = "high"]
    High,
}
impl<'de> serde::Deserialize<'de> for WebSearchPreviewTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebSearchPreviewTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: WebSearchPreviewToolType,
            #[serde(rename = "user_location")]
            #[allow(dead_code)]
            user_location: Option<ApproximateLocation>,
            #[serde(rename = "search_context_size")]
            #[allow(dead_code)]
            search_context_size: Option<WebSearchPreviewToolSearchContextSize>,
        }
        let WebSearchPreviewTool {
            type_,
            user_location,
            search_context_size,
            ..
        } = WebSearchPreviewTool::deserialize(deserializer)?;
        Ok(Self {
            type_,
            user_location,
            search_context_size,
        })
    }
}
impl serde::Serialize for WebSearchPreviewTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebSearchPreviewTool<'a> {
            #[serde(rename = "type")]
            type_: &'a WebSearchPreviewToolType,
            #[serde(rename = "user_location")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_location: &'a Option<ApproximateLocation>,
            #[serde(rename = "search_context_size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            search_context_size: &'a Option<WebSearchPreviewToolSearchContextSize>,
        }
        let Self {
            type_,
            user_location,
            search_context_size,
        } = self;
        WebSearchPreviewTool {
            type_,
            user_location,
            search_context_size,
        }
        .serialize(serializer)
    }
}
#[doc = "This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search)."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct WebSearchPreviewTool {
    #[doc = "The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`."]
    #[builder(default)]
    pub type_: WebSearchPreviewToolType,
    #[doc = "The user's location."]
    #[builder(default)]
    pub user_location: Option<ApproximateLocation>,
    #[doc = "High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default."]
    #[builder(default)]
    pub search_context_size: Option<WebSearchPreviewToolSearchContextSize>,
}
impl<'de> serde::Deserialize<'de> for ComputerUsePreviewToolEnvironment {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentWindows {
            #[default]
            #[serde(rename = "windows")]
            Windows,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentMac {
            #[default]
            #[serde(rename = "mac")]
            Mac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentLinux {
            #[default]
            #[serde(rename = "linux")]
            Linux,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentUbuntu {
            #[default]
            #[serde(rename = "ubuntu")]
            Ubuntu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentBrowser {
            #[default]
            #[serde(rename = "browser")]
            Browser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ComputerUsePreviewToolEnvironment {
            Windows(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentWindows),
            Mac(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentMac),
            Linux(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentLinux),
            Ubuntu(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentUbuntu),
            Browser(#[allow(dead_code)] ComputerUsePreviewToolEnvironmentBrowser),
        }
        Ok(
            match ComputerUsePreviewToolEnvironment::deserialize(deserializer)? {
                ComputerUsePreviewToolEnvironment::Windows(_) => Self::Windows,
                ComputerUsePreviewToolEnvironment::Mac(_) => Self::Mac,
                ComputerUsePreviewToolEnvironment::Linux(_) => Self::Linux,
                ComputerUsePreviewToolEnvironment::Ubuntu(_) => Self::Ubuntu,
                ComputerUsePreviewToolEnvironment::Browser(_) => Self::Browser,
            },
        )
    }
}
impl serde::Serialize for ComputerUsePreviewToolEnvironment {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentWindows {
            #[default]
            #[serde(rename = "windows")]
            Windows,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentMac {
            #[default]
            #[serde(rename = "mac")]
            Mac,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentLinux {
            #[default]
            #[serde(rename = "linux")]
            Linux,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentUbuntu {
            #[default]
            #[serde(rename = "ubuntu")]
            Ubuntu,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolEnvironmentBrowser {
            #[default]
            #[serde(rename = "browser")]
            Browser,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ComputerUsePreviewToolEnvironment<'a> {
            Windows(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentWindows),
            Mac(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentMac),
            Linux(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentLinux),
            Ubuntu(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentUbuntu),
            Browser(#[allow(dead_code)] &'a ComputerUsePreviewToolEnvironmentBrowser),
        }
        match self {
            Self::Windows => ComputerUsePreviewToolEnvironment::Windows(&Default::default())
                .serialize(serializer),
            Self::Mac => {
                ComputerUsePreviewToolEnvironment::Mac(&Default::default()).serialize(serializer)
            }
            Self::Linux => {
                ComputerUsePreviewToolEnvironment::Linux(&Default::default()).serialize(serializer)
            }
            Self::Ubuntu => {
                ComputerUsePreviewToolEnvironment::Ubuntu(&Default::default()).serialize(serializer)
            }
            Self::Browser => ComputerUsePreviewToolEnvironment::Browser(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The type of computer environment to control."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerUsePreviewToolEnvironment {
    #[doc = "windows"]
    Windows,
    #[doc = "mac"]
    Mac,
    #[doc = "linux"]
    Linux,
    #[doc = "ubuntu"]
    Ubuntu,
    #[doc = "browser"]
    Browser,
}
impl<'de> serde::Deserialize<'de> for ComputerUsePreviewTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the computer use tool. Always `computer_use_preview`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolType {
            #[default]
            #[serde(rename = "computer_use_preview")]
            ComputerUsePreview,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerUsePreviewTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerUsePreviewToolType,
            #[serde(rename = "environment")]
            #[allow(dead_code)]
            environment: ComputerUsePreviewToolEnvironment,
            #[serde(rename = "display_width")]
            #[allow(dead_code)]
            display_width: u64,
            #[serde(rename = "display_height")]
            #[allow(dead_code)]
            display_height: u64,
        }
        let ComputerUsePreviewTool {
            environment,
            display_width,
            display_height,
            ..
        } = ComputerUsePreviewTool::deserialize(deserializer)?;
        Ok(Self {
            environment,
            display_width,
            display_height,
        })
    }
}
impl serde::Serialize for ComputerUsePreviewTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the computer use tool. Always `computer_use_preview`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerUsePreviewToolType {
            #[default]
            #[serde(rename = "computer_use_preview")]
            ComputerUsePreview,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerUsePreviewTool<'a> {
            #[serde(rename = "type")]
            type_: &'a ComputerUsePreviewToolType,
            #[serde(rename = "environment")]
            environment: &'a ComputerUsePreviewToolEnvironment,
            #[serde(rename = "display_width")]
            display_width: &'a u64,
            #[serde(rename = "display_height")]
            display_height: &'a u64,
        }
        let Self {
            environment,
            display_width,
            display_height,
        } = self;
        ComputerUsePreviewTool {
            type_: &Default::default(),
            environment,
            display_width,
            display_height,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use)."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct ComputerUsePreviewTool {
    #[doc = "The type of computer environment to control."]
    pub environment: ComputerUsePreviewToolEnvironment,
    #[doc = "The width of the computer display."]
    pub display_width: u64,
    #[doc = "The height of the computer display."]
    pub display_height: u64,
}
impl<'de> serde::Deserialize<'de> for FileCitationBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the file citation. Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileCitationBodyType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileCitationBody {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FileCitationBodyType,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "index")]
            #[allow(dead_code)]
            index: u64,
        }
        let FileCitationBody { file_id, index, .. } = FileCitationBody::deserialize(deserializer)?;
        Ok(Self { file_id, index })
    }
}
impl serde::Serialize for FileCitationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the file citation. Always `file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FileCitationBodyType {
            #[default]
            #[serde(rename = "file_citation")]
            FileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileCitationBody<'a> {
            #[serde(rename = "type")]
            type_: &'a FileCitationBodyType,
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "index")]
            index: &'a u64,
        }
        let Self { file_id, index } = self;
        FileCitationBody {
            type_: &Default::default(),
            file_id,
            index,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation to a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileCitationBody {
    #[doc = "The ID of the file."]
    pub file_id: String,
    #[doc = "The index of the file in the list of files."]
    pub index: u64,
}
impl<'de> serde::Deserialize<'de> for UrlCitationBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the URL citation. Always `url_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UrlCitationBodyType {
            #[default]
            #[serde(rename = "url_citation")]
            UrlCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UrlCitationBody {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: UrlCitationBodyType,
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
            #[serde(rename = "title")]
            #[allow(dead_code)]
            title: String,
        }
        let UrlCitationBody {
            url,
            start_index,
            end_index,
            title,
            ..
        } = UrlCitationBody::deserialize(deserializer)?;
        Ok(Self {
            url,
            start_index,
            end_index,
            title,
        })
    }
}
impl serde::Serialize for UrlCitationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the URL citation. Always `url_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum UrlCitationBodyType {
            #[default]
            #[serde(rename = "url_citation")]
            UrlCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UrlCitationBody<'a> {
            #[serde(rename = "type")]
            type_: &'a UrlCitationBodyType,
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "end_index")]
            end_index: &'a u64,
            #[serde(rename = "title")]
            title: &'a String,
        }
        let Self {
            url,
            start_index,
            end_index,
            title,
        } = self;
        UrlCitationBody {
            type_: &Default::default(),
            url,
            start_index,
            end_index,
            title,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation for a web resource used to generate a model response."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UrlCitationBody {
    #[doc = "The URL of the web resource."]
    pub url: String,
    #[doc = "The index of the first character of the URL citation in the message."]
    pub start_index: u64,
    #[doc = "The index of the last character of the URL citation in the message."]
    pub end_index: u64,
    #[doc = "The title of the web resource."]
    pub title: String,
}
impl<'de> serde::Deserialize<'de> for ContainerFileCitationBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the container file citation. Always `container_file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ContainerFileCitationBodyType {
            #[default]
            #[serde(rename = "container_file_citation")]
            ContainerFileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerFileCitationBody {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ContainerFileCitationBodyType,
            #[serde(rename = "container_id")]
            #[allow(dead_code)]
            container_id: String,
            #[serde(rename = "file_id")]
            #[allow(dead_code)]
            file_id: String,
            #[serde(rename = "start_index")]
            #[allow(dead_code)]
            start_index: u64,
            #[serde(rename = "end_index")]
            #[allow(dead_code)]
            end_index: u64,
        }
        let ContainerFileCitationBody {
            container_id,
            file_id,
            start_index,
            end_index,
            ..
        } = ContainerFileCitationBody::deserialize(deserializer)?;
        Ok(Self {
            container_id,
            file_id,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for ContainerFileCitationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the container file citation. Always `container_file_citation`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ContainerFileCitationBodyType {
            #[default]
            #[serde(rename = "container_file_citation")]
            ContainerFileCitation,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerFileCitationBody<'a> {
            #[serde(rename = "type")]
            type_: &'a ContainerFileCitationBodyType,
            #[serde(rename = "container_id")]
            container_id: &'a String,
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "start_index")]
            start_index: &'a u64,
            #[serde(rename = "end_index")]
            end_index: &'a u64,
        }
        let Self {
            container_id,
            file_id,
            start_index,
            end_index,
        } = self;
        ContainerFileCitationBody {
            type_: &Default::default(),
            container_id,
            file_id,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[doc = "A citation for a container file used to generate a model response."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ContainerFileCitationBody {
    #[doc = "The ID of the container file."]
    pub container_id: String,
    #[doc = "The ID of the file."]
    pub file_id: String,
    #[doc = "The index of the first character of the container file citation in the message."]
    pub start_index: u64,
    #[doc = "The index of the last character of the container file citation in the message."]
    pub end_index: u64,
}
impl<'de> serde::Deserialize<'de> for Annotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum Annotation {
            FileCitation(#[allow(dead_code)] FileCitationBody),
            UrlCitation(#[allow(dead_code)] UrlCitationBody),
            ContainerFileCitation(#[allow(dead_code)] ContainerFileCitationBody),
            FilePath(#[allow(dead_code)] FilePath),
        }
        Ok(match Annotation::deserialize(deserializer)? {
            Annotation::FileCitation(_v) => Self::FileCitation(_v),
            Annotation::UrlCitation(_v) => Self::UrlCitation(_v),
            Annotation::ContainerFileCitation(_v) => Self::ContainerFileCitation(_v),
            Annotation::FilePath(_v) => Self::FilePath(_v),
        })
    }
}
impl serde::Serialize for Annotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum Annotation<'a> {
            FileCitation(#[allow(dead_code)] &'a FileCitationBody),
            UrlCitation(#[allow(dead_code)] &'a UrlCitationBody),
            ContainerFileCitation(#[allow(dead_code)] &'a ContainerFileCitationBody),
            FilePath(#[allow(dead_code)] &'a FilePath),
        }
        match self {
            Self::FileCitation(_v) => Annotation::FileCitation(_v).serialize(serializer),
            Self::UrlCitation(_v) => Annotation::UrlCitation(_v).serialize(serializer),
            Self::ContainerFileCitation(_v) => {
                Annotation::ContainerFileCitation(_v).serialize(serializer)
            }
            Self::FilePath(_v) => Annotation::FilePath(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum Annotation {
    FileCitation(FileCitationBody),
    UrlCitation(UrlCitationBody),
    ContainerFileCitation(ContainerFileCitationBody),
    FilePath(FilePath),
}
impl<'de> serde::Deserialize<'de> for TopLogProb {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TopLogProb {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: String,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: f64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Vec<u64>,
        }
        let TopLogProb {
            token,
            logprob,
            bytes,
            ..
        } = TopLogProb::deserialize(deserializer)?;
        Ok(Self {
            token,
            logprob,
            bytes,
        })
    }
}
impl serde::Serialize for TopLogProb {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TopLogProb<'a> {
            #[serde(rename = "token")]
            token: &'a String,
            #[serde(rename = "logprob")]
            logprob: &'a f64,
            #[serde(rename = "bytes")]
            bytes: &'a Vec<u64>,
        }
        let Self {
            token,
            logprob,
            bytes,
        } = self;
        TopLogProb {
            token,
            logprob,
            bytes,
        }
        .serialize(serializer)
    }
}
#[doc = "The top log probability of a token."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TopLogProb {
    pub token: String,
    pub logprob: f64,
    pub bytes: Vec<u64>,
}
impl<'de> serde::Deserialize<'de> for LogProb {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LogProb {
            #[serde(rename = "token")]
            #[allow(dead_code)]
            token: String,
            #[serde(rename = "logprob")]
            #[allow(dead_code)]
            logprob: f64,
            #[serde(rename = "bytes")]
            #[allow(dead_code)]
            bytes: Vec<u64>,
            #[serde(rename = "top_logprobs")]
            #[allow(dead_code)]
            top_logprobs: Vec<TopLogProb>,
        }
        let LogProb {
            token,
            logprob,
            bytes,
            top_logprobs,
            ..
        } = LogProb::deserialize(deserializer)?;
        Ok(Self {
            token,
            logprob,
            bytes,
            top_logprobs,
        })
    }
}
impl serde::Serialize for LogProb {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LogProb<'a> {
            #[serde(rename = "token")]
            token: &'a String,
            #[serde(rename = "logprob")]
            logprob: &'a f64,
            #[serde(rename = "bytes")]
            bytes: &'a Vec<u64>,
            #[serde(rename = "top_logprobs")]
            top_logprobs: &'a Vec<TopLogProb>,
        }
        let Self {
            token,
            logprob,
            bytes,
            top_logprobs,
        } = self;
        LogProb {
            token,
            logprob,
            bytes,
            top_logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "The log probability of a token."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LogProb {
    pub token: String,
    pub logprob: f64,
    pub bytes: Vec<u64>,
    pub top_logprobs: Vec<TopLogProb>,
}
impl<'de> serde::Deserialize<'de> for OutputTextContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the output text. Always `output_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputTextContentType {
            #[default]
            #[serde(rename = "output_text")]
            OutputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OutputTextContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: OutputTextContentType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
            #[serde(rename = "annotations")]
            #[allow(dead_code)]
            annotations: Vec<Annotation>,
            #[serde(rename = "logprobs")]
            #[allow(dead_code)]
            logprobs: Option<Vec<LogProb>>,
        }
        let OutputTextContent {
            text,
            annotations,
            logprobs,
            ..
        } = OutputTextContent::deserialize(deserializer)?;
        Ok(Self {
            text,
            annotations,
            logprobs,
        })
    }
}
impl serde::Serialize for OutputTextContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the output text. Always `output_text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum OutputTextContentType {
            #[default]
            #[serde(rename = "output_text")]
            OutputText,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OutputTextContent<'a> {
            #[serde(rename = "type")]
            type_: &'a OutputTextContentType,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "annotations")]
            annotations: &'a Vec<Annotation>,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<LogProb>>,
        }
        let Self {
            text,
            annotations,
            logprobs,
        } = self;
        OutputTextContent {
            type_: &Default::default(),
            text,
            annotations,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[doc = "A text output from the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputTextContent {
    #[doc = "The text output from the model."]
    pub text: String,
    #[doc = "The annotations of the text output."]
    pub annotations: Vec<Annotation>,
    #[builder(default)]
    pub logprobs: Option<Vec<LogProb>>,
}
impl<'de> serde::Deserialize<'de> for RefusalContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the refusal. Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RefusalContentType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RefusalContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: RefusalContentType,
            #[serde(rename = "refusal")]
            #[allow(dead_code)]
            refusal: String,
        }
        let RefusalContent { refusal, .. } = RefusalContent::deserialize(deserializer)?;
        Ok(Self { refusal })
    }
}
impl serde::Serialize for RefusalContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the refusal. Always `refusal`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RefusalContentType {
            #[default]
            #[serde(rename = "refusal")]
            Refusal,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RefusalContent<'a> {
            #[serde(rename = "type")]
            type_: &'a RefusalContentType,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let Self { refusal } = self;
        RefusalContent {
            type_: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "A refusal from the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RefusalContent {
    #[doc = "The refusal explanationfrom the model."]
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for ComputerCallSafetyCheckParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerCallSafetyCheckParam {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: Option<String>,
        }
        let ComputerCallSafetyCheckParam {
            id, code, message, ..
        } = ComputerCallSafetyCheckParam::deserialize(deserializer)?;
        Ok(Self { id, code, message })
    }
}
impl serde::Serialize for ComputerCallSafetyCheckParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerCallSafetyCheckParam<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message: &'a Option<String>,
        }
        let Self { id, code, message } = self;
        ComputerCallSafetyCheckParam { id, code, message }.serialize(serializer)
    }
}
#[doc = "A pending safety check for the computer call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerCallSafetyCheckParam {
    #[doc = "The ID of the pending safety check."]
    pub id: String,
    #[doc = "The type of the pending safety check."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "Details about the pending safety check."]
    #[builder(default)]
    pub message: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ComputerCallOutputItemParamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ComputerCallOutputItemParamStatus {
            InProgress(#[allow(dead_code)] ComputerCallOutputItemParamStatusInProgress),
            Completed(#[allow(dead_code)] ComputerCallOutputItemParamStatusCompleted),
            Incomplete(#[allow(dead_code)] ComputerCallOutputItemParamStatusIncomplete),
        }
        Ok(
            match ComputerCallOutputItemParamStatus::deserialize(deserializer)? {
                ComputerCallOutputItemParamStatus::InProgress(_) => Self::InProgress,
                ComputerCallOutputItemParamStatus::Completed(_) => Self::Completed,
                ComputerCallOutputItemParamStatus::Incomplete(_) => Self::Incomplete,
            },
        )
    }
}
impl serde::Serialize for ComputerCallOutputItemParamStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ComputerCallOutputItemParamStatus<'a> {
            InProgress(#[allow(dead_code)] &'a ComputerCallOutputItemParamStatusInProgress),
            Completed(#[allow(dead_code)] &'a ComputerCallOutputItemParamStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a ComputerCallOutputItemParamStatusIncomplete),
        }
        match self {
            Self::InProgress => ComputerCallOutputItemParamStatus::InProgress(&Default::default())
                .serialize(serializer),
            Self::Completed => ComputerCallOutputItemParamStatus::Completed(&Default::default())
                .serialize(serializer),
            Self::Incomplete => ComputerCallOutputItemParamStatus::Incomplete(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The status of the message input. One of `in_progress`, `completed`, or `incomplete`. Populated when input items are returned via API."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerCallOutputItemParamStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for ComputerCallOutputItemParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the computer tool call output. Always `computer_call_output`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamType {
            #[default]
            #[serde(rename = "computer_call_output")]
            ComputerCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerCallOutputItemParam {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ComputerCallOutputItemParamType,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: ComputerScreenshotImage,
            #[serde(rename = "acknowledged_safety_checks")]
            #[allow(dead_code)]
            acknowledged_safety_checks: Option<Vec<ComputerCallSafetyCheckParam>>,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<ComputerCallOutputItemParamStatus>,
        }
        let ComputerCallOutputItemParam {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
            ..
        } = ComputerCallOutputItemParam::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
        })
    }
}
impl serde::Serialize for ComputerCallOutputItemParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the computer tool call output. Always `computer_call_output`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ComputerCallOutputItemParamType {
            #[default]
            #[serde(rename = "computer_call_output")]
            ComputerCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerCallOutputItemParam<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a ComputerCallOutputItemParamType,
            #[serde(rename = "output")]
            output: &'a ComputerScreenshotImage,
            #[serde(rename = "acknowledged_safety_checks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            acknowledged_safety_checks: &'a Option<Vec<ComputerCallSafetyCheckParam>>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<ComputerCallOutputItemParamStatus>,
        }
        let Self {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
        } = self;
        ComputerCallOutputItemParam {
            id,
            call_id,
            type_: &Default::default(),
            output,
            acknowledged_safety_checks,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a computer tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerCallOutputItemParam {
    #[doc = "The ID of the computer tool call output."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The ID of the computer tool call that produced the output."]
    pub call_id: String,
    #[builder(default)]
    pub output: ComputerScreenshotImage,
    #[doc = "The safety checks reported by the API that have been acknowledged by the developer."]
    #[builder(default)]
    pub acknowledged_safety_checks: Option<Vec<ComputerCallSafetyCheckParam>>,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or `incomplete`. Populated when input items are returned via API."]
    #[builder(default)]
    pub status: Option<ComputerCallOutputItemParamStatus>,
}
impl<'de> serde::Deserialize<'de> for FunctionCallOutputItemParamStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FunctionCallOutputItemParamStatus {
            InProgress(#[allow(dead_code)] FunctionCallOutputItemParamStatusInProgress),
            Completed(#[allow(dead_code)] FunctionCallOutputItemParamStatusCompleted),
            Incomplete(#[allow(dead_code)] FunctionCallOutputItemParamStatusIncomplete),
        }
        Ok(
            match FunctionCallOutputItemParamStatus::deserialize(deserializer)? {
                FunctionCallOutputItemParamStatus::InProgress(_) => Self::InProgress,
                FunctionCallOutputItemParamStatus::Completed(_) => Self::Completed,
                FunctionCallOutputItemParamStatus::Incomplete(_) => Self::Incomplete,
            },
        )
    }
}
impl serde::Serialize for FunctionCallOutputItemParamStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FunctionCallOutputItemParamStatus<'a> {
            InProgress(#[allow(dead_code)] &'a FunctionCallOutputItemParamStatusInProgress),
            Completed(#[allow(dead_code)] &'a FunctionCallOutputItemParamStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a FunctionCallOutputItemParamStatusIncomplete),
        }
        match self {
            Self::InProgress => FunctionCallOutputItemParamStatus::InProgress(&Default::default())
                .serialize(serializer),
            Self::Completed => FunctionCallOutputItemParamStatus::Completed(&Default::default())
                .serialize(serializer),
            Self::Incomplete => FunctionCallOutputItemParamStatus::Incomplete(&Default::default())
                .serialize(serializer),
        }
    }
}
#[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`. Populated when items are returned via API."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FunctionCallOutputItemParamStatus {
    #[doc = "in_progress"]
    InProgress,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
}
impl<'de> serde::Deserialize<'de> for FunctionCallOutputItemParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "The type of the function tool call output. Always `function_call_output`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamType {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionCallOutputItemParam {
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "call_id")]
            #[allow(dead_code)]
            call_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: FunctionCallOutputItemParamType,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: String,
            #[serde(rename = "status")]
            #[allow(dead_code)]
            status: Option<FunctionCallOutputItemParamStatus>,
        }
        let FunctionCallOutputItemParam {
            id,
            call_id,
            output,
            status,
            ..
        } = FunctionCallOutputItemParam::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            output,
            status,
        })
    }
}
impl serde::Serialize for FunctionCallOutputItemParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "The type of the function tool call output. Always `function_call_output`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FunctionCallOutputItemParamType {
            #[default]
            #[serde(rename = "function_call_output")]
            FunctionCallOutput,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionCallOutputItemParam<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "type")]
            type_: &'a FunctionCallOutputItemParamType,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<FunctionCallOutputItemParamStatus>,
        }
        let Self {
            id,
            call_id,
            output,
            status,
        } = self;
        FunctionCallOutputItemParam {
            id,
            call_id,
            type_: &Default::default(),
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "The output of a function tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionCallOutputItemParam {
    #[doc = "The unique ID of the function tool call output. Populated when this item is returned via API."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model."]
    pub call_id: String,
    #[doc = "A JSON string of the output of the function tool call."]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`. Populated when items are returned via API."]
    #[builder(default)]
    pub status: Option<FunctionCallOutputItemParamStatus>,
}
impl<'de> serde::Deserialize<'de> for ItemReferenceParamType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ItemReferenceParamTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ItemReferenceParamType {
            ItemReference(#[allow(dead_code)] ItemReferenceParamTypeItemReference),
        }
        Ok(match ItemReferenceParamType::deserialize(deserializer)? {
            ItemReferenceParamType::ItemReference(_) => Self::ItemReference,
        })
    }
}
impl serde::Serialize for ItemReferenceParamType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ItemReferenceParamTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ItemReferenceParamType<'a> {
            ItemReference(#[allow(dead_code)] &'a ItemReferenceParamTypeItemReference),
        }
        match self {
            Self::ItemReference => {
                ItemReferenceParamType::ItemReference(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The type of item to reference. Always `item_reference`."]
#[derive(Clone, Debug, PartialEq, Copy, Default)]
#[allow(clippy::large_enum_variant)]
pub enum ItemReferenceParamType {
    #[doc = "item_reference"]
    #[default]
    ItemReference,
}
impl<'de> serde::Deserialize<'de> for ItemReferenceParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ItemReferenceParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<ItemReferenceParamType>,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: String,
        }
        let ItemReferenceParam { type_, id, .. } = ItemReferenceParam::deserialize(deserializer)?;
        Ok(Self { type_, id })
    }
}
impl serde::Serialize for ItemReferenceParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ItemReferenceParam<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<ItemReferenceParamType>,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self { type_, id } = self;
        ItemReferenceParam { type_, id }.serialize(serializer)
    }
}
#[doc = "An internal identifier for an item to reference."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ItemReferenceParam {
    #[doc = "The type of item to reference. Always `item_reference`."]
    #[builder(default)]
    pub type_: Option<ItemReferenceParamType>,
    #[doc = "The ID of the item to reference."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemContentType {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeInputText {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeInputAudio {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RealtimeConversationItemContentType {
            InputText(#[allow(dead_code)] RealtimeConversationItemContentTypeInputText),
            InputAudio(#[allow(dead_code)] RealtimeConversationItemContentTypeInputAudio),
            ItemReference(#[allow(dead_code)] RealtimeConversationItemContentTypeItemReference),
            Text(#[allow(dead_code)] RealtimeConversationItemContentTypeText),
        }
        Ok(
            match RealtimeConversationItemContentType::deserialize(deserializer)? {
                RealtimeConversationItemContentType::InputText(_) => Self::InputText,
                RealtimeConversationItemContentType::InputAudio(_) => Self::InputAudio,
                RealtimeConversationItemContentType::ItemReference(_) => Self::ItemReference,
                RealtimeConversationItemContentType::Text(_) => Self::Text,
            },
        )
    }
}
impl serde::Serialize for RealtimeConversationItemContentType {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeInputText {
            #[default]
            #[serde(rename = "input_text")]
            InputText,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeInputAudio {
            #[default]
            #[serde(rename = "input_audio")]
            InputAudio,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeItemReference {
            #[default]
            #[serde(rename = "item_reference")]
            ItemReference,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RealtimeConversationItemContentTypeText {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RealtimeConversationItemContentType<'a> {
            InputText(#[allow(dead_code)] &'a RealtimeConversationItemContentTypeInputText),
            InputAudio(#[allow(dead_code)] &'a RealtimeConversationItemContentTypeInputAudio),
            ItemReference(#[allow(dead_code)] &'a RealtimeConversationItemContentTypeItemReference),
            Text(#[allow(dead_code)] &'a RealtimeConversationItemContentTypeText),
        }
        match self {
            Self::InputText => RealtimeConversationItemContentType::InputText(&Default::default())
                .serialize(serializer),
            Self::InputAudio => {
                RealtimeConversationItemContentType::InputAudio(&Default::default())
                    .serialize(serializer)
            }
            Self::ItemReference => {
                RealtimeConversationItemContentType::ItemReference(&Default::default())
                    .serialize(serializer)
            }
            Self::Text => {
                RealtimeConversationItemContentType::Text(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`).\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeConversationItemContentType {
    #[doc = "input_text"]
    InputText,
    #[doc = "input_audio"]
    InputAudio,
    #[doc = "item_reference"]
    ItemReference,
    #[doc = "text"]
    Text,
}
impl<'de> serde::Deserialize<'de> for RealtimeConversationItemContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeConversationItemContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: Option<RealtimeConversationItemContentType>,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: Option<String>,
            #[serde(rename = "id")]
            #[allow(dead_code)]
            id: Option<String>,
            #[serde(rename = "audio")]
            #[allow(dead_code)]
            audio: Option<String>,
            #[serde(rename = "transcript")]
            #[allow(dead_code)]
            transcript: Option<String>,
        }
        let RealtimeConversationItemContent {
            type_,
            text,
            id,
            audio,
            transcript,
            ..
        } = RealtimeConversationItemContent::deserialize(deserializer)?;
        Ok(Self {
            type_,
            text,
            id,
            audio,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeConversationItemContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeConversationItemContent<'a> {
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            type_: &'a Option<RealtimeConversationItemContentType>,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<String>,
            #[serde(rename = "transcript")]
            #[serde(skip_serializing_if = "Option::is_none")]
            transcript: &'a Option<String>,
        }
        let Self {
            type_,
            text,
            id,
            audio,
            transcript,
        } = self;
        RealtimeConversationItemContent {
            type_,
            text,
            id,
            audio,
            transcript,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItemContent {
    #[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`).\n"]
    #[builder(default)]
    pub type_: Option<RealtimeConversationItemContentType>,
    #[doc = "The text content, used for `input_text` and `text` content types.\n"]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "ID of a previous conversation item to reference (for `item_reference`\ncontent types in `response.create` events). These can reference both\nclient and server created items.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "Base64-encoded audio bytes, used for `input_audio` content type.\n"]
    #[builder(default)]
    pub audio: Option<String>,
    #[doc = "The transcript of the audio, used for `input_audio` content type.\n"]
    #[builder(default)]
    pub transcript: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeConnectParams {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeConnectParams {
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: String,
        }
        let RealtimeConnectParams { model, .. } = RealtimeConnectParams::deserialize(deserializer)?;
        Ok(Self { model })
    }
}
impl serde::Serialize for RealtimeConnectParams {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeConnectParams<'a> {
            #[serde(rename = "model")]
            model: &'a String,
        }
        let Self { model } = self;
        RealtimeConnectParams { model }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeConnectParams {
    pub model: String,
}
impl<'de> serde::Deserialize<'de> for ModerationImageUrlInputImageUrl {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModerationImageUrlInputImageUrl {
            #[serde(rename = "url")]
            #[allow(dead_code)]
            url: String,
        }
        let ModerationImageUrlInputImageUrl { url, .. } =
            ModerationImageUrlInputImageUrl::deserialize(deserializer)?;
        Ok(Self { url })
    }
}
impl serde::Serialize for ModerationImageUrlInputImageUrl {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModerationImageUrlInputImageUrl<'a> {
            #[serde(rename = "url")]
            url: &'a String,
        }
        let Self { url } = self;
        ModerationImageUrlInputImageUrl { url }.serialize(serializer)
    }
}
#[doc = "Contains either an image URL or a data URL for a base64 encoded image."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ModerationImageUrlInputImageUrl {
    #[doc = "Either a URL of the image or the base64 encoded image data."]
    pub url: String,
}
impl<'de> serde::Deserialize<'de> for ModerationImageUrlInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `image_url`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModerationImageUrlInputType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModerationImageUrlInput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ModerationImageUrlInputType,
            #[serde(rename = "image_url")]
            #[allow(dead_code)]
            image_url: ModerationImageUrlInputImageUrl,
        }
        let ModerationImageUrlInput { image_url, .. } =
            ModerationImageUrlInput::deserialize(deserializer)?;
        Ok(Self { image_url })
    }
}
impl serde::Serialize for ModerationImageUrlInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `image_url`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModerationImageUrlInputType {
            #[default]
            #[serde(rename = "image_url")]
            ImageUrl,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModerationImageUrlInput<'a> {
            #[serde(rename = "type")]
            type_: &'a ModerationImageUrlInputType,
            #[serde(rename = "image_url")]
            image_url: &'a ModerationImageUrlInputImageUrl,
        }
        let Self { image_url } = self;
        ModerationImageUrlInput {
            type_: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[doc = "An object describing an image to classify."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ModerationImageUrlInput {
    #[doc = "Contains either an image URL or a data URL for a base64 encoded image."]
    pub image_url: ModerationImageUrlInputImageUrl,
}
impl<'de> serde::Deserialize<'de> for ModerationTextInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModerationTextInputType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModerationTextInput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            type_: ModerationTextInputType,
            #[serde(rename = "text")]
            #[allow(dead_code)]
            text: String,
        }
        let ModerationTextInput { text, .. } = ModerationTextInput::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for ModerationTextInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[doc = "Always `text`."]
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ModerationTextInputType {
            #[default]
            #[serde(rename = "text")]
            Text,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModerationTextInput<'a> {
            #[serde(rename = "type")]
            type_: &'a ModerationTextInputType,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        ModerationTextInput {
            type_: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "An object describing text to classify."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ModerationTextInput {
    #[doc = "A string of text to classify."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ChunkingStrategyResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChunkingStrategyResponse {
            Static(#[allow(dead_code)] StaticChunkingStrategyResponseParam),
            Other(#[allow(dead_code)] OtherChunkingStrategyResponseParam),
        }
        Ok(match ChunkingStrategyResponse::deserialize(deserializer)? {
            ChunkingStrategyResponse::Static(_v) => Self::Static(_v),
            ChunkingStrategyResponse::Other(_v) => Self::Other(_v),
        })
    }
}
impl serde::Serialize for ChunkingStrategyResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChunkingStrategyResponse<'a> {
            Static(#[allow(dead_code)] &'a StaticChunkingStrategyResponseParam),
            Other(#[allow(dead_code)] &'a OtherChunkingStrategyResponseParam),
        }
        match self {
            Self::Static(_v) => ChunkingStrategyResponse::Static(_v).serialize(serializer),
            Self::Other(_v) => ChunkingStrategyResponse::Other(_v).serialize(serializer),
        }
    }
}
#[doc = "The strategy used to chunk the file."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChunkingStrategyResponse {
    Static(StaticChunkingStrategyResponseParam),
    Other(OtherChunkingStrategyResponseParam),
}
impl<'de> serde::Deserialize<'de> for FilePurpose {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeUserData {
            #[default]
            #[serde(rename = "user_data")]
            UserData,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeEvals {
            #[default]
            #[serde(rename = "evals")]
            Evals,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum FilePurpose {
            Assistants(#[allow(dead_code)] FilePurposeAssistants),
            Batch(#[allow(dead_code)] FilePurposeBatch),
            FineTune(#[allow(dead_code)] FilePurposeFineTune),
            Vision(#[allow(dead_code)] FilePurposeVision),
            UserData(#[allow(dead_code)] FilePurposeUserData),
            Evals(#[allow(dead_code)] FilePurposeEvals),
        }
        Ok(match FilePurpose::deserialize(deserializer)? {
            FilePurpose::Assistants(_) => Self::Assistants,
            FilePurpose::Batch(_) => Self::Batch,
            FilePurpose::FineTune(_) => Self::FineTune,
            FilePurpose::Vision(_) => Self::Vision,
            FilePurpose::UserData(_) => Self::UserData,
            FilePurpose::Evals(_) => Self::Evals,
        })
    }
}
impl serde::Serialize for FilePurpose {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeAssistants {
            #[default]
            #[serde(rename = "assistants")]
            Assistants,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeBatch {
            #[default]
            #[serde(rename = "batch")]
            Batch,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeFineTune {
            #[default]
            #[serde(rename = "fine-tune")]
            FineTune,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeVision {
            #[default]
            #[serde(rename = "vision")]
            Vision,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeUserData {
            #[default]
            #[serde(rename = "user_data")]
            UserData,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum FilePurposeEvals {
            #[default]
            #[serde(rename = "evals")]
            Evals,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum FilePurpose<'a> {
            Assistants(#[allow(dead_code)] &'a FilePurposeAssistants),
            Batch(#[allow(dead_code)] &'a FilePurposeBatch),
            FineTune(#[allow(dead_code)] &'a FilePurposeFineTune),
            Vision(#[allow(dead_code)] &'a FilePurposeVision),
            UserData(#[allow(dead_code)] &'a FilePurposeUserData),
            Evals(#[allow(dead_code)] &'a FilePurposeEvals),
        }
        match self {
            Self::Assistants => FilePurpose::Assistants(&Default::default()).serialize(serializer),
            Self::Batch => FilePurpose::Batch(&Default::default()).serialize(serializer),
            Self::FineTune => FilePurpose::FineTune(&Default::default()).serialize(serializer),
            Self::Vision => FilePurpose::Vision(&Default::default()).serialize(serializer),
            Self::UserData => FilePurpose::UserData(&Default::default()).serialize(serializer),
            Self::Evals => FilePurpose::Evals(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The intended purpose of the uploaded file. One of: - `assistants`: Used in the Assistants API - `batch`: Used in the Batch API - `fine-tune`: Used for fine-tuning - `vision`: Images used for vision fine-tuning - `user_data`: Flexible file type for any purpose - `evals`: Used for eval data sets\n"]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum FilePurpose {
    #[doc = "assistants"]
    Assistants,
    #[doc = "batch"]
    Batch,
    #[doc = "fine-tune"]
    FineTune,
    #[doc = "vision"]
    Vision,
    #[doc = "user_data"]
    UserData,
    #[doc = "evals"]
    Evals,
}
impl<'de> serde::Deserialize<'de> for BatchError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct BatchError {
            #[serde(rename = "code")]
            #[allow(dead_code)]
            code: Option<String>,
            #[serde(rename = "message")]
            #[allow(dead_code)]
            message: Option<String>,
            #[serde(rename = "param")]
            #[allow(dead_code)]
            param: Option<String>,
            #[serde(rename = "line")]
            #[allow(dead_code)]
            line: Option<u64>,
        }
        let BatchError {
            code,
            message,
            param,
            line,
            ..
        } = BatchError::deserialize(deserializer)?;
        Ok(Self {
            code,
            message,
            param,
            line,
        })
    }
}
impl serde::Serialize for BatchError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct BatchError<'a> {
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            #[serde(skip_serializing_if = "Option::is_none")]
            message: &'a Option<String>,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
            #[serde(rename = "line")]
            #[serde(skip_serializing_if = "Option::is_none")]
            line: &'a Option<u64>,
        }
        let Self {
            code,
            message,
            param,
            line,
        } = self;
        BatchError {
            code,
            message,
            param,
            line,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct BatchError {
    #[doc = "An error code identifying the error type."]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable message providing more details about the error."]
    #[builder(default)]
    pub message: Option<String>,
    #[doc = "The name of the parameter that caused the error, if applicable."]
    #[builder(default)]
    pub param: Option<String>,
    #[doc = "The line number of the input file where the error occurred, if applicable."]
    #[builder(default)]
    pub line: Option<u64>,
}
impl<'de> serde::Deserialize<'de> for BatchRequestCounts {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct BatchRequestCounts {
            #[serde(rename = "total")]
            #[allow(dead_code)]
            total: u64,
            #[serde(rename = "completed")]
            #[allow(dead_code)]
            completed: u64,
            #[serde(rename = "failed")]
            #[allow(dead_code)]
            failed: u64,
        }
        let BatchRequestCounts {
            total,
            completed,
            failed,
            ..
        } = BatchRequestCounts::deserialize(deserializer)?;
        Ok(Self {
            total,
            completed,
            failed,
        })
    }
}
impl serde::Serialize for BatchRequestCounts {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct BatchRequestCounts<'a> {
            #[serde(rename = "total")]
            total: &'a u64,
            #[serde(rename = "completed")]
            completed: &'a u64,
            #[serde(rename = "failed")]
            failed: &'a u64,
        }
        let Self {
            total,
            completed,
            failed,
        } = self;
        BatchRequestCounts {
            total,
            completed,
            failed,
        }
        .serialize(serializer)
    }
}
#[doc = "The request counts for different statuses within the batch."]
#[derive(Clone, Debug, PartialEq, Copy, typed_builder :: TypedBuilder)]
pub struct BatchRequestCounts {
    #[doc = "Total number of requests in the batch."]
    pub total: u64,
    #[doc = "Number of requests that have been completed successfully."]
    pub completed: u64,
    #[doc = "Number of requests that have failed."]
    pub failed: u64,
}
impl<'de> serde::Deserialize<'de> for AssistantTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AssistantTool {
            CodeInterpreter(#[allow(dead_code)] AssistantToolsCode),
            FileSearch(#[allow(dead_code)] AssistantToolsFileSearch),
            Function(#[allow(dead_code)] AssistantToolsFunction),
        }
        Ok(match AssistantTool::deserialize(deserializer)? {
            AssistantTool::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            AssistantTool::FileSearch(_v) => Self::FileSearch(_v),
            AssistantTool::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for AssistantTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AssistantTool<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a AssistantToolsCode),
            FileSearch(#[allow(dead_code)] &'a AssistantToolsFileSearch),
            Function(#[allow(dead_code)] &'a AssistantToolsFunction),
        }
        match self {
            Self::CodeInterpreter(_v) => AssistantTool::CodeInterpreter(_v).serialize(serializer),
            Self::FileSearch(_v) => AssistantTool::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => AssistantTool::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantTool {
    CodeInterpreter(AssistantToolsCode),
    FileSearch(AssistantToolsFileSearch),
    Function(AssistantToolsFunction),
}
impl<'de> serde::Deserialize<'de> for TextAnnotationDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum TextAnnotationDelta {
            FileCitation(#[allow(dead_code)] MessageDeltaContentTextAnnotationsFileCitationObject),
            FilePath(#[allow(dead_code)] MessageDeltaContentTextAnnotationsFilePathObject),
        }
        Ok(match TextAnnotationDelta::deserialize(deserializer)? {
            TextAnnotationDelta::FileCitation(_v) => Self::FileCitation(_v),
            TextAnnotationDelta::FilePath(_v) => Self::FilePath(_v),
        })
    }
}
impl serde::Serialize for TextAnnotationDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum TextAnnotationDelta<'a> {
            FileCitation(
                #[allow(dead_code)] &'a MessageDeltaContentTextAnnotationsFileCitationObject,
            ),
            FilePath(#[allow(dead_code)] &'a MessageDeltaContentTextAnnotationsFilePathObject),
        }
        match self {
            Self::FileCitation(_v) => TextAnnotationDelta::FileCitation(_v).serialize(serializer),
            Self::FilePath(_v) => TextAnnotationDelta::FilePath(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum TextAnnotationDelta {
    FileCitation(MessageDeltaContentTextAnnotationsFileCitationObject),
    FilePath(MessageDeltaContentTextAnnotationsFilePathObject),
}
impl<'de> serde::Deserialize<'de> for TextAnnotation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum TextAnnotation {
            FileCitation(#[allow(dead_code)] MessageContentTextAnnotationsFileCitationObject),
            FilePath(#[allow(dead_code)] MessageContentTextAnnotationsFilePathObject),
        }
        Ok(match TextAnnotation::deserialize(deserializer)? {
            TextAnnotation::FileCitation(_v) => Self::FileCitation(_v),
            TextAnnotation::FilePath(_v) => Self::FilePath(_v),
        })
    }
}
impl serde::Serialize for TextAnnotation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum TextAnnotation<'a> {
            FileCitation(#[allow(dead_code)] &'a MessageContentTextAnnotationsFileCitationObject),
            FilePath(#[allow(dead_code)] &'a MessageContentTextAnnotationsFilePathObject),
        }
        match self {
            Self::FileCitation(_v) => TextAnnotation::FileCitation(_v).serialize(serializer),
            Self::FilePath(_v) => TextAnnotation::FilePath(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum TextAnnotation {
    FileCitation(MessageContentTextAnnotationsFileCitationObject),
    FilePath(MessageContentTextAnnotationsFilePathObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepDetailsToolCall {
            CodeInterpreter(#[allow(dead_code)] RunStepDetailsToolCallsCodeObject),
            FileSearch(#[allow(dead_code)] RunStepDetailsToolCallsFileSearchObject),
            Function(#[allow(dead_code)] RunStepDetailsToolCallsFunctionObject),
        }
        Ok(match RunStepDetailsToolCall::deserialize(deserializer)? {
            RunStepDetailsToolCall::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
            RunStepDetailsToolCall::FileSearch(_v) => Self::FileSearch(_v),
            RunStepDetailsToolCall::Function(_v) => Self::Function(_v),
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepDetailsToolCall<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a RunStepDetailsToolCallsCodeObject),
            FileSearch(#[allow(dead_code)] &'a RunStepDetailsToolCallsFileSearchObject),
            Function(#[allow(dead_code)] &'a RunStepDetailsToolCallsFunctionObject),
        }
        match self {
            Self::CodeInterpreter(_v) => {
                RunStepDetailsToolCall::CodeInterpreter(_v).serialize(serializer)
            }
            Self::FileSearch(_v) => RunStepDetailsToolCall::FileSearch(_v).serialize(serializer),
            Self::Function(_v) => RunStepDetailsToolCall::Function(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDetailsToolCall {
    CodeInterpreter(RunStepDetailsToolCallsCodeObject),
    FileSearch(RunStepDetailsToolCallsFileSearchObject),
    Function(RunStepDetailsToolCallsFunctionObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepDeltaStepDetailsToolCall {
            CodeInterpreter(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsCodeObject),
            FileSearch(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsFileSearchObject),
            Function(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsFunctionObject),
        }
        Ok(
            match RunStepDeltaStepDetailsToolCall::deserialize(deserializer)? {
                RunStepDeltaStepDetailsToolCall::CodeInterpreter(_v) => Self::CodeInterpreter(_v),
                RunStepDeltaStepDetailsToolCall::FileSearch(_v) => Self::FileSearch(_v),
                RunStepDeltaStepDetailsToolCall::Function(_v) => Self::Function(_v),
            },
        )
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepDeltaStepDetailsToolCall<'a> {
            CodeInterpreter(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsCodeObject),
            FileSearch(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsFileSearchObject),
            Function(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsFunctionObject),
        }
        match self {
            Self::CodeInterpreter(_v) => {
                RunStepDeltaStepDetailsToolCall::CodeInterpreter(_v).serialize(serializer)
            }
            Self::FileSearch(_v) => {
                RunStepDeltaStepDetailsToolCall::FileSearch(_v).serialize(serializer)
            }
            Self::Function(_v) => {
                RunStepDeltaStepDetailsToolCall::Function(_v).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDeltaStepDetailsToolCall {
    CodeInterpreter(RunStepDeltaStepDetailsToolCallsCodeObject),
    FileSearch(RunStepDeltaStepDetailsToolCallsFileSearchObject),
    Function(RunStepDeltaStepDetailsToolCallsFunctionObject),
}
impl<'de> serde::Deserialize<'de> for MessageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageContent {
            ImageFile(#[allow(dead_code)] MessageContentImageFileObject),
            ImageUrl(#[allow(dead_code)] MessageContentImageUrlObject),
            Text(#[allow(dead_code)] MessageContentTextObject),
            Refusal(#[allow(dead_code)] MessageContentRefusalObject),
        }
        Ok(match MessageContent::deserialize(deserializer)? {
            MessageContent::ImageFile(_v) => Self::ImageFile(_v),
            MessageContent::ImageUrl(_v) => Self::ImageUrl(_v),
            MessageContent::Text(_v) => Self::Text(_v),
            MessageContent::Refusal(_v) => Self::Refusal(_v),
        })
    }
}
impl serde::Serialize for MessageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageContent<'a> {
            ImageFile(#[allow(dead_code)] &'a MessageContentImageFileObject),
            ImageUrl(#[allow(dead_code)] &'a MessageContentImageUrlObject),
            Text(#[allow(dead_code)] &'a MessageContentTextObject),
            Refusal(#[allow(dead_code)] &'a MessageContentRefusalObject),
        }
        match self {
            Self::ImageFile(_v) => MessageContent::ImageFile(_v).serialize(serializer),
            Self::ImageUrl(_v) => MessageContent::ImageUrl(_v).serialize(serializer),
            Self::Text(_v) => MessageContent::Text(_v).serialize(serializer),
            Self::Refusal(_v) => MessageContent::Refusal(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContent {
    ImageFile(MessageContentImageFileObject),
    ImageUrl(MessageContentImageUrlObject),
    Text(MessageContentTextObject),
    Refusal(MessageContentRefusalObject),
}
impl<'de> serde::Deserialize<'de> for MessageContentDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum MessageContentDelta {
            ImageFile(#[allow(dead_code)] MessageDeltaContentImageFileObject),
            Text(#[allow(dead_code)] MessageDeltaContentTextObject),
            Refusal(#[allow(dead_code)] MessageDeltaContentRefusalObject),
            ImageUrl(#[allow(dead_code)] MessageDeltaContentImageUrlObject),
        }
        Ok(match MessageContentDelta::deserialize(deserializer)? {
            MessageContentDelta::ImageFile(_v) => Self::ImageFile(_v),
            MessageContentDelta::Text(_v) => Self::Text(_v),
            MessageContentDelta::Refusal(_v) => Self::Refusal(_v),
            MessageContentDelta::ImageUrl(_v) => Self::ImageUrl(_v),
        })
    }
}
impl serde::Serialize for MessageContentDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum MessageContentDelta<'a> {
            ImageFile(#[allow(dead_code)] &'a MessageDeltaContentImageFileObject),
            Text(#[allow(dead_code)] &'a MessageDeltaContentTextObject),
            Refusal(#[allow(dead_code)] &'a MessageDeltaContentRefusalObject),
            ImageUrl(#[allow(dead_code)] &'a MessageDeltaContentImageUrlObject),
        }
        match self {
            Self::ImageFile(_v) => MessageContentDelta::ImageFile(_v).serialize(serializer),
            Self::Text(_v) => MessageContentDelta::Text(_v).serialize(serializer),
            Self::Refusal(_v) => MessageContentDelta::Refusal(_v).serialize(serializer),
            Self::ImageUrl(_v) => MessageContentDelta::ImageUrl(_v).serialize(serializer),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContentDelta {
    ImageFile(MessageDeltaContentImageFileObject),
    Text(MessageDeltaContentTextObject),
    Refusal(MessageDeltaContentRefusalObject),
    ImageUrl(MessageDeltaContentImageUrlObject),
}
impl<'de> serde::Deserialize<'de> for ChatModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1 {
            #[default]
            #[serde(rename = "gpt-4.1")]
            Gpt4_1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1Mini {
            #[default]
            #[serde(rename = "gpt-4.1-mini")]
            Gpt4_1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1Nano {
            #[default]
            #[serde(rename = "gpt-4.1-nano")]
            Gpt4_1Nano,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1_2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-2025-04-14")]
            Gpt4_1_2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1Mini2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-mini-2025-04-14")]
            Gpt4_1Mini2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1Nano2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-nano-2025-04-14")]
            Gpt4_1Nano2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO4Mini {
            #[default]
            #[serde(rename = "o4-mini")]
            O4Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO4Mini2025_04_16 {
            #[default]
            #[serde(rename = "o4-mini-2025-04-16")]
            O4Mini2025_04_16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO3 {
            #[default]
            #[serde(rename = "o3")]
            O3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO3_2025_04_16 {
            #[default]
            #[serde(rename = "o3-2025-04-16")]
            O3_2025_04_16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO3Mini {
            #[default]
            #[serde(rename = "o3-mini")]
            O3Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO3Mini2025_01_31 {
            #[default]
            #[serde(rename = "o3-mini-2025-01-31")]
            O3Mini2025_01_31,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1 {
            #[default]
            #[serde(rename = "o1")]
            O1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1_2024_12_17 {
            #[default]
            #[serde(rename = "o1-2024-12-17")]
            O1_2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1Preview {
            #[default]
            #[serde(rename = "o1-preview")]
            O1Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1Preview2024_09_12 {
            #[default]
            #[serde(rename = "o1-preview-2024-09-12")]
            O1Preview2024_09_12,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1Mini {
            #[default]
            #[serde(rename = "o1-mini")]
            O1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1Mini2024_09_12 {
            #[default]
            #[serde(rename = "o1-mini-2024-09-12")]
            O1Mini2024_09_12,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4o {
            #[default]
            #[serde(rename = "gpt-4o")]
            Gpt4o,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4o2024_11_20 {
            #[default]
            #[serde(rename = "gpt-4o-2024-11-20")]
            Gpt4o2024_11_20,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4o2024_08_06 {
            #[default]
            #[serde(rename = "gpt-4o-2024-08-06")]
            Gpt4o2024_08_06,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4o2024_05_13 {
            #[default]
            #[serde(rename = "gpt-4o-2024-05-13")]
            Gpt4o2024_05_13,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oAudioPreview {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview")]
            Gpt4oAudioPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oAudioPreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2024-10-01")]
            Gpt4oAudioPreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oAudioPreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2024-12-17")]
            Gpt4oAudioPreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oAudioPreview2025_06_03 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2025-06-03")]
            Gpt4oAudioPreview2025_06_03,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMiniAudioPreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-audio-preview")]
            Gpt4oMiniAudioPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMiniAudioPreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-audio-preview-2024-12-17")]
            Gpt4oMiniAudioPreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oSearchPreview {
            #[default]
            #[serde(rename = "gpt-4o-search-preview")]
            Gpt4oSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMiniSearchPreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-search-preview")]
            Gpt4oMiniSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "gpt-4o-search-preview-2025-03-11")]
            Gpt4oSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMiniSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "gpt-4o-mini-search-preview-2025-03-11")]
            Gpt4oMiniSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelChatgpt4oLatest {
            #[default]
            #[serde(rename = "chatgpt-4o-latest")]
            Chatgpt4oLatest,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelCodexMiniLatest {
            #[default]
            #[serde(rename = "codex-mini-latest")]
            CodexMiniLatest,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMini {
            #[default]
            #[serde(rename = "gpt-4o-mini")]
            Gpt4oMini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMini2024_07_18 {
            #[default]
            #[serde(rename = "gpt-4o-mini-2024-07-18")]
            Gpt4oMini2024_07_18,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4Turbo {
            #[default]
            #[serde(rename = "gpt-4-turbo")]
            Gpt4Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4Turbo2024_04_09 {
            #[default]
            #[serde(rename = "gpt-4-turbo-2024-04-09")]
            Gpt4Turbo2024_04_09,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_0125Preview {
            #[default]
            #[serde(rename = "gpt-4-0125-preview")]
            Gpt4_0125Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4TurboPreview {
            #[default]
            #[serde(rename = "gpt-4-turbo-preview")]
            Gpt4TurboPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1106Preview {
            #[default]
            #[serde(rename = "gpt-4-1106-preview")]
            Gpt4_1106Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4VisionPreview {
            #[default]
            #[serde(rename = "gpt-4-vision-preview")]
            Gpt4VisionPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4 {
            #[default]
            #[serde(rename = "gpt-4")]
            Gpt4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_0314 {
            #[default]
            #[serde(rename = "gpt-4-0314")]
            Gpt4_0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_0613 {
            #[default]
            #[serde(rename = "gpt-4-0613")]
            Gpt4_0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_32k {
            #[default]
            #[serde(rename = "gpt-4-32k")]
            Gpt4_32k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_32k0314 {
            #[default]
            #[serde(rename = "gpt-4-32k-0314")]
            Gpt4_32k0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_32k0613 {
            #[default]
            #[serde(rename = "gpt-4-32k-0613")]
            Gpt4_32k0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo {
            #[default]
            #[serde(rename = "gpt-3.5-turbo")]
            Gpt3_5Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo16k {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k")]
            Gpt3_5Turbo16k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo0301 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0301")]
            Gpt3_5Turbo0301,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0613")]
            Gpt3_5Turbo0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo1106 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-1106")]
            Gpt3_5Turbo1106,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo0125 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0125")]
            Gpt3_5Turbo0125,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo16k0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k-0613")]
            Gpt3_5Turbo16k0613,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatModel {
            Gpt4_1(#[allow(dead_code)] ChatModelGpt4_1),
            Gpt4_1Mini(#[allow(dead_code)] ChatModelGpt4_1Mini),
            Gpt4_1Nano(#[allow(dead_code)] ChatModelGpt4_1Nano),
            Gpt4_1_2025_04_14(#[allow(dead_code)] ChatModelGpt4_1_2025_04_14),
            Gpt4_1Mini2025_04_14(#[allow(dead_code)] ChatModelGpt4_1Mini2025_04_14),
            Gpt4_1Nano2025_04_14(#[allow(dead_code)] ChatModelGpt4_1Nano2025_04_14),
            O4Mini(#[allow(dead_code)] ChatModelO4Mini),
            O4Mini2025_04_16(#[allow(dead_code)] ChatModelO4Mini2025_04_16),
            O3(#[allow(dead_code)] ChatModelO3),
            O3_2025_04_16(#[allow(dead_code)] ChatModelO3_2025_04_16),
            O3Mini(#[allow(dead_code)] ChatModelO3Mini),
            O3Mini2025_01_31(#[allow(dead_code)] ChatModelO3Mini2025_01_31),
            O1(#[allow(dead_code)] ChatModelO1),
            O1_2024_12_17(#[allow(dead_code)] ChatModelO1_2024_12_17),
            O1Preview(#[allow(dead_code)] ChatModelO1Preview),
            O1Preview2024_09_12(#[allow(dead_code)] ChatModelO1Preview2024_09_12),
            O1Mini(#[allow(dead_code)] ChatModelO1Mini),
            O1Mini2024_09_12(#[allow(dead_code)] ChatModelO1Mini2024_09_12),
            Gpt4o(#[allow(dead_code)] ChatModelGpt4o),
            Gpt4o2024_11_20(#[allow(dead_code)] ChatModelGpt4o2024_11_20),
            Gpt4o2024_08_06(#[allow(dead_code)] ChatModelGpt4o2024_08_06),
            Gpt4o2024_05_13(#[allow(dead_code)] ChatModelGpt4o2024_05_13),
            Gpt4oAudioPreview(#[allow(dead_code)] ChatModelGpt4oAudioPreview),
            Gpt4oAudioPreview2024_10_01(#[allow(dead_code)] ChatModelGpt4oAudioPreview2024_10_01),
            Gpt4oAudioPreview2024_12_17(#[allow(dead_code)] ChatModelGpt4oAudioPreview2024_12_17),
            Gpt4oAudioPreview2025_06_03(#[allow(dead_code)] ChatModelGpt4oAudioPreview2025_06_03),
            Gpt4oMiniAudioPreview(#[allow(dead_code)] ChatModelGpt4oMiniAudioPreview),
            Gpt4oMiniAudioPreview2024_12_17(
                #[allow(dead_code)] ChatModelGpt4oMiniAudioPreview2024_12_17,
            ),
            Gpt4oSearchPreview(#[allow(dead_code)] ChatModelGpt4oSearchPreview),
            Gpt4oMiniSearchPreview(#[allow(dead_code)] ChatModelGpt4oMiniSearchPreview),
            Gpt4oSearchPreview2025_03_11(#[allow(dead_code)] ChatModelGpt4oSearchPreview2025_03_11),
            Gpt4oMiniSearchPreview2025_03_11(
                #[allow(dead_code)] ChatModelGpt4oMiniSearchPreview2025_03_11,
            ),
            Chatgpt4oLatest(#[allow(dead_code)] ChatModelChatgpt4oLatest),
            CodexMiniLatest(#[allow(dead_code)] ChatModelCodexMiniLatest),
            Gpt4oMini(#[allow(dead_code)] ChatModelGpt4oMini),
            Gpt4oMini2024_07_18(#[allow(dead_code)] ChatModelGpt4oMini2024_07_18),
            Gpt4Turbo(#[allow(dead_code)] ChatModelGpt4Turbo),
            Gpt4Turbo2024_04_09(#[allow(dead_code)] ChatModelGpt4Turbo2024_04_09),
            Gpt4_0125Preview(#[allow(dead_code)] ChatModelGpt4_0125Preview),
            Gpt4TurboPreview(#[allow(dead_code)] ChatModelGpt4TurboPreview),
            Gpt4_1106Preview(#[allow(dead_code)] ChatModelGpt4_1106Preview),
            Gpt4VisionPreview(#[allow(dead_code)] ChatModelGpt4VisionPreview),
            Gpt4(#[allow(dead_code)] ChatModelGpt4),
            Gpt4_0314(#[allow(dead_code)] ChatModelGpt4_0314),
            Gpt4_0613(#[allow(dead_code)] ChatModelGpt4_0613),
            Gpt4_32k(#[allow(dead_code)] ChatModelGpt4_32k),
            Gpt4_32k0314(#[allow(dead_code)] ChatModelGpt4_32k0314),
            Gpt4_32k0613(#[allow(dead_code)] ChatModelGpt4_32k0613),
            Gpt3_5Turbo(#[allow(dead_code)] ChatModelGpt3_5Turbo),
            Gpt3_5Turbo16k(#[allow(dead_code)] ChatModelGpt3_5Turbo16k),
            Gpt3_5Turbo0301(#[allow(dead_code)] ChatModelGpt3_5Turbo0301),
            Gpt3_5Turbo0613(#[allow(dead_code)] ChatModelGpt3_5Turbo0613),
            Gpt3_5Turbo1106(#[allow(dead_code)] ChatModelGpt3_5Turbo1106),
            Gpt3_5Turbo0125(#[allow(dead_code)] ChatModelGpt3_5Turbo0125),
            Gpt3_5Turbo16k0613(#[allow(dead_code)] ChatModelGpt3_5Turbo16k0613),
        }
        Ok(match ChatModel::deserialize(deserializer)? {
            ChatModel::Gpt4_1(_) => Self::Gpt4_1,
            ChatModel::Gpt4_1Mini(_) => Self::Gpt4_1Mini,
            ChatModel::Gpt4_1Nano(_) => Self::Gpt4_1Nano,
            ChatModel::Gpt4_1_2025_04_14(_) => Self::Gpt4_1_2025_04_14,
            ChatModel::Gpt4_1Mini2025_04_14(_) => Self::Gpt4_1Mini2025_04_14,
            ChatModel::Gpt4_1Nano2025_04_14(_) => Self::Gpt4_1Nano2025_04_14,
            ChatModel::O4Mini(_) => Self::O4Mini,
            ChatModel::O4Mini2025_04_16(_) => Self::O4Mini2025_04_16,
            ChatModel::O3(_) => Self::O3,
            ChatModel::O3_2025_04_16(_) => Self::O3_2025_04_16,
            ChatModel::O3Mini(_) => Self::O3Mini,
            ChatModel::O3Mini2025_01_31(_) => Self::O3Mini2025_01_31,
            ChatModel::O1(_) => Self::O1,
            ChatModel::O1_2024_12_17(_) => Self::O1_2024_12_17,
            ChatModel::O1Preview(_) => Self::O1Preview,
            ChatModel::O1Preview2024_09_12(_) => Self::O1Preview2024_09_12,
            ChatModel::O1Mini(_) => Self::O1Mini,
            ChatModel::O1Mini2024_09_12(_) => Self::O1Mini2024_09_12,
            ChatModel::Gpt4o(_) => Self::Gpt4o,
            ChatModel::Gpt4o2024_11_20(_) => Self::Gpt4o2024_11_20,
            ChatModel::Gpt4o2024_08_06(_) => Self::Gpt4o2024_08_06,
            ChatModel::Gpt4o2024_05_13(_) => Self::Gpt4o2024_05_13,
            ChatModel::Gpt4oAudioPreview(_) => Self::Gpt4oAudioPreview,
            ChatModel::Gpt4oAudioPreview2024_10_01(_) => Self::Gpt4oAudioPreview2024_10_01,
            ChatModel::Gpt4oAudioPreview2024_12_17(_) => Self::Gpt4oAudioPreview2024_12_17,
            ChatModel::Gpt4oAudioPreview2025_06_03(_) => Self::Gpt4oAudioPreview2025_06_03,
            ChatModel::Gpt4oMiniAudioPreview(_) => Self::Gpt4oMiniAudioPreview,
            ChatModel::Gpt4oMiniAudioPreview2024_12_17(_) => Self::Gpt4oMiniAudioPreview2024_12_17,
            ChatModel::Gpt4oSearchPreview(_) => Self::Gpt4oSearchPreview,
            ChatModel::Gpt4oMiniSearchPreview(_) => Self::Gpt4oMiniSearchPreview,
            ChatModel::Gpt4oSearchPreview2025_03_11(_) => Self::Gpt4oSearchPreview2025_03_11,
            ChatModel::Gpt4oMiniSearchPreview2025_03_11(_) => {
                Self::Gpt4oMiniSearchPreview2025_03_11
            }
            ChatModel::Chatgpt4oLatest(_) => Self::Chatgpt4oLatest,
            ChatModel::CodexMiniLatest(_) => Self::CodexMiniLatest,
            ChatModel::Gpt4oMini(_) => Self::Gpt4oMini,
            ChatModel::Gpt4oMini2024_07_18(_) => Self::Gpt4oMini2024_07_18,
            ChatModel::Gpt4Turbo(_) => Self::Gpt4Turbo,
            ChatModel::Gpt4Turbo2024_04_09(_) => Self::Gpt4Turbo2024_04_09,
            ChatModel::Gpt4_0125Preview(_) => Self::Gpt4_0125Preview,
            ChatModel::Gpt4TurboPreview(_) => Self::Gpt4TurboPreview,
            ChatModel::Gpt4_1106Preview(_) => Self::Gpt4_1106Preview,
            ChatModel::Gpt4VisionPreview(_) => Self::Gpt4VisionPreview,
            ChatModel::Gpt4(_) => Self::Gpt4,
            ChatModel::Gpt4_0314(_) => Self::Gpt4_0314,
            ChatModel::Gpt4_0613(_) => Self::Gpt4_0613,
            ChatModel::Gpt4_32k(_) => Self::Gpt4_32k,
            ChatModel::Gpt4_32k0314(_) => Self::Gpt4_32k0314,
            ChatModel::Gpt4_32k0613(_) => Self::Gpt4_32k0613,
            ChatModel::Gpt3_5Turbo(_) => Self::Gpt3_5Turbo,
            ChatModel::Gpt3_5Turbo16k(_) => Self::Gpt3_5Turbo16k,
            ChatModel::Gpt3_5Turbo0301(_) => Self::Gpt3_5Turbo0301,
            ChatModel::Gpt3_5Turbo0613(_) => Self::Gpt3_5Turbo0613,
            ChatModel::Gpt3_5Turbo1106(_) => Self::Gpt3_5Turbo1106,
            ChatModel::Gpt3_5Turbo0125(_) => Self::Gpt3_5Turbo0125,
            ChatModel::Gpt3_5Turbo16k0613(_) => Self::Gpt3_5Turbo16k0613,
        })
    }
}
impl serde::Serialize for ChatModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1 {
            #[default]
            #[serde(rename = "gpt-4.1")]
            Gpt4_1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1Mini {
            #[default]
            #[serde(rename = "gpt-4.1-mini")]
            Gpt4_1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1Nano {
            #[default]
            #[serde(rename = "gpt-4.1-nano")]
            Gpt4_1Nano,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1_2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-2025-04-14")]
            Gpt4_1_2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1Mini2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-mini-2025-04-14")]
            Gpt4_1Mini2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1Nano2025_04_14 {
            #[default]
            #[serde(rename = "gpt-4.1-nano-2025-04-14")]
            Gpt4_1Nano2025_04_14,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO4Mini {
            #[default]
            #[serde(rename = "o4-mini")]
            O4Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO4Mini2025_04_16 {
            #[default]
            #[serde(rename = "o4-mini-2025-04-16")]
            O4Mini2025_04_16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO3 {
            #[default]
            #[serde(rename = "o3")]
            O3,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO3_2025_04_16 {
            #[default]
            #[serde(rename = "o3-2025-04-16")]
            O3_2025_04_16,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO3Mini {
            #[default]
            #[serde(rename = "o3-mini")]
            O3Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO3Mini2025_01_31 {
            #[default]
            #[serde(rename = "o3-mini-2025-01-31")]
            O3Mini2025_01_31,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1 {
            #[default]
            #[serde(rename = "o1")]
            O1,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1_2024_12_17 {
            #[default]
            #[serde(rename = "o1-2024-12-17")]
            O1_2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1Preview {
            #[default]
            #[serde(rename = "o1-preview")]
            O1Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1Preview2024_09_12 {
            #[default]
            #[serde(rename = "o1-preview-2024-09-12")]
            O1Preview2024_09_12,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1Mini {
            #[default]
            #[serde(rename = "o1-mini")]
            O1Mini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelO1Mini2024_09_12 {
            #[default]
            #[serde(rename = "o1-mini-2024-09-12")]
            O1Mini2024_09_12,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4o {
            #[default]
            #[serde(rename = "gpt-4o")]
            Gpt4o,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4o2024_11_20 {
            #[default]
            #[serde(rename = "gpt-4o-2024-11-20")]
            Gpt4o2024_11_20,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4o2024_08_06 {
            #[default]
            #[serde(rename = "gpt-4o-2024-08-06")]
            Gpt4o2024_08_06,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4o2024_05_13 {
            #[default]
            #[serde(rename = "gpt-4o-2024-05-13")]
            Gpt4o2024_05_13,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oAudioPreview {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview")]
            Gpt4oAudioPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oAudioPreview2024_10_01 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2024-10-01")]
            Gpt4oAudioPreview2024_10_01,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oAudioPreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2024-12-17")]
            Gpt4oAudioPreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oAudioPreview2025_06_03 {
            #[default]
            #[serde(rename = "gpt-4o-audio-preview-2025-06-03")]
            Gpt4oAudioPreview2025_06_03,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMiniAudioPreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-audio-preview")]
            Gpt4oMiniAudioPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMiniAudioPreview2024_12_17 {
            #[default]
            #[serde(rename = "gpt-4o-mini-audio-preview-2024-12-17")]
            Gpt4oMiniAudioPreview2024_12_17,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oSearchPreview {
            #[default]
            #[serde(rename = "gpt-4o-search-preview")]
            Gpt4oSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMiniSearchPreview {
            #[default]
            #[serde(rename = "gpt-4o-mini-search-preview")]
            Gpt4oMiniSearchPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "gpt-4o-search-preview-2025-03-11")]
            Gpt4oSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMiniSearchPreview2025_03_11 {
            #[default]
            #[serde(rename = "gpt-4o-mini-search-preview-2025-03-11")]
            Gpt4oMiniSearchPreview2025_03_11,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelChatgpt4oLatest {
            #[default]
            #[serde(rename = "chatgpt-4o-latest")]
            Chatgpt4oLatest,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelCodexMiniLatest {
            #[default]
            #[serde(rename = "codex-mini-latest")]
            CodexMiniLatest,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMini {
            #[default]
            #[serde(rename = "gpt-4o-mini")]
            Gpt4oMini,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4oMini2024_07_18 {
            #[default]
            #[serde(rename = "gpt-4o-mini-2024-07-18")]
            Gpt4oMini2024_07_18,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4Turbo {
            #[default]
            #[serde(rename = "gpt-4-turbo")]
            Gpt4Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4Turbo2024_04_09 {
            #[default]
            #[serde(rename = "gpt-4-turbo-2024-04-09")]
            Gpt4Turbo2024_04_09,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_0125Preview {
            #[default]
            #[serde(rename = "gpt-4-0125-preview")]
            Gpt4_0125Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4TurboPreview {
            #[default]
            #[serde(rename = "gpt-4-turbo-preview")]
            Gpt4TurboPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_1106Preview {
            #[default]
            #[serde(rename = "gpt-4-1106-preview")]
            Gpt4_1106Preview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4VisionPreview {
            #[default]
            #[serde(rename = "gpt-4-vision-preview")]
            Gpt4VisionPreview,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4 {
            #[default]
            #[serde(rename = "gpt-4")]
            Gpt4,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_0314 {
            #[default]
            #[serde(rename = "gpt-4-0314")]
            Gpt4_0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_0613 {
            #[default]
            #[serde(rename = "gpt-4-0613")]
            Gpt4_0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_32k {
            #[default]
            #[serde(rename = "gpt-4-32k")]
            Gpt4_32k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_32k0314 {
            #[default]
            #[serde(rename = "gpt-4-32k-0314")]
            Gpt4_32k0314,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt4_32k0613 {
            #[default]
            #[serde(rename = "gpt-4-32k-0613")]
            Gpt4_32k0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo {
            #[default]
            #[serde(rename = "gpt-3.5-turbo")]
            Gpt3_5Turbo,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo16k {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k")]
            Gpt3_5Turbo16k,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo0301 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0301")]
            Gpt3_5Turbo0301,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0613")]
            Gpt3_5Turbo0613,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo1106 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-1106")]
            Gpt3_5Turbo1106,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo0125 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-0125")]
            Gpt3_5Turbo0125,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum ChatModelGpt3_5Turbo16k0613 {
            #[default]
            #[serde(rename = "gpt-3.5-turbo-16k-0613")]
            Gpt3_5Turbo16k0613,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatModel<'a> {
            Gpt4_1(#[allow(dead_code)] &'a ChatModelGpt4_1),
            Gpt4_1Mini(#[allow(dead_code)] &'a ChatModelGpt4_1Mini),
            Gpt4_1Nano(#[allow(dead_code)] &'a ChatModelGpt4_1Nano),
            Gpt4_1_2025_04_14(#[allow(dead_code)] &'a ChatModelGpt4_1_2025_04_14),
            Gpt4_1Mini2025_04_14(#[allow(dead_code)] &'a ChatModelGpt4_1Mini2025_04_14),
            Gpt4_1Nano2025_04_14(#[allow(dead_code)] &'a ChatModelGpt4_1Nano2025_04_14),
            O4Mini(#[allow(dead_code)] &'a ChatModelO4Mini),
            O4Mini2025_04_16(#[allow(dead_code)] &'a ChatModelO4Mini2025_04_16),
            O3(#[allow(dead_code)] &'a ChatModelO3),
            O3_2025_04_16(#[allow(dead_code)] &'a ChatModelO3_2025_04_16),
            O3Mini(#[allow(dead_code)] &'a ChatModelO3Mini),
            O3Mini2025_01_31(#[allow(dead_code)] &'a ChatModelO3Mini2025_01_31),
            O1(#[allow(dead_code)] &'a ChatModelO1),
            O1_2024_12_17(#[allow(dead_code)] &'a ChatModelO1_2024_12_17),
            O1Preview(#[allow(dead_code)] &'a ChatModelO1Preview),
            O1Preview2024_09_12(#[allow(dead_code)] &'a ChatModelO1Preview2024_09_12),
            O1Mini(#[allow(dead_code)] &'a ChatModelO1Mini),
            O1Mini2024_09_12(#[allow(dead_code)] &'a ChatModelO1Mini2024_09_12),
            Gpt4o(#[allow(dead_code)] &'a ChatModelGpt4o),
            Gpt4o2024_11_20(#[allow(dead_code)] &'a ChatModelGpt4o2024_11_20),
            Gpt4o2024_08_06(#[allow(dead_code)] &'a ChatModelGpt4o2024_08_06),
            Gpt4o2024_05_13(#[allow(dead_code)] &'a ChatModelGpt4o2024_05_13),
            Gpt4oAudioPreview(#[allow(dead_code)] &'a ChatModelGpt4oAudioPreview),
            Gpt4oAudioPreview2024_10_01(
                #[allow(dead_code)] &'a ChatModelGpt4oAudioPreview2024_10_01,
            ),
            Gpt4oAudioPreview2024_12_17(
                #[allow(dead_code)] &'a ChatModelGpt4oAudioPreview2024_12_17,
            ),
            Gpt4oAudioPreview2025_06_03(
                #[allow(dead_code)] &'a ChatModelGpt4oAudioPreview2025_06_03,
            ),
            Gpt4oMiniAudioPreview(#[allow(dead_code)] &'a ChatModelGpt4oMiniAudioPreview),
            Gpt4oMiniAudioPreview2024_12_17(
                #[allow(dead_code)] &'a ChatModelGpt4oMiniAudioPreview2024_12_17,
            ),
            Gpt4oSearchPreview(#[allow(dead_code)] &'a ChatModelGpt4oSearchPreview),
            Gpt4oMiniSearchPreview(#[allow(dead_code)] &'a ChatModelGpt4oMiniSearchPreview),
            Gpt4oSearchPreview2025_03_11(
                #[allow(dead_code)] &'a ChatModelGpt4oSearchPreview2025_03_11,
            ),
            Gpt4oMiniSearchPreview2025_03_11(
                #[allow(dead_code)] &'a ChatModelGpt4oMiniSearchPreview2025_03_11,
            ),
            Chatgpt4oLatest(#[allow(dead_code)] &'a ChatModelChatgpt4oLatest),
            CodexMiniLatest(#[allow(dead_code)] &'a ChatModelCodexMiniLatest),
            Gpt4oMini(#[allow(dead_code)] &'a ChatModelGpt4oMini),
            Gpt4oMini2024_07_18(#[allow(dead_code)] &'a ChatModelGpt4oMini2024_07_18),
            Gpt4Turbo(#[allow(dead_code)] &'a ChatModelGpt4Turbo),
            Gpt4Turbo2024_04_09(#[allow(dead_code)] &'a ChatModelGpt4Turbo2024_04_09),
            Gpt4_0125Preview(#[allow(dead_code)] &'a ChatModelGpt4_0125Preview),
            Gpt4TurboPreview(#[allow(dead_code)] &'a ChatModelGpt4TurboPreview),
            Gpt4_1106Preview(#[allow(dead_code)] &'a ChatModelGpt4_1106Preview),
            Gpt4VisionPreview(#[allow(dead_code)] &'a ChatModelGpt4VisionPreview),
            Gpt4(#[allow(dead_code)] &'a ChatModelGpt4),
            Gpt4_0314(#[allow(dead_code)] &'a ChatModelGpt4_0314),
            Gpt4_0613(#[allow(dead_code)] &'a ChatModelGpt4_0613),
            Gpt4_32k(#[allow(dead_code)] &'a ChatModelGpt4_32k),
            Gpt4_32k0314(#[allow(dead_code)] &'a ChatModelGpt4_32k0314),
            Gpt4_32k0613(#[allow(dead_code)] &'a ChatModelGpt4_32k0613),
            Gpt3_5Turbo(#[allow(dead_code)] &'a ChatModelGpt3_5Turbo),
            Gpt3_5Turbo16k(#[allow(dead_code)] &'a ChatModelGpt3_5Turbo16k),
            Gpt3_5Turbo0301(#[allow(dead_code)] &'a ChatModelGpt3_5Turbo0301),
            Gpt3_5Turbo0613(#[allow(dead_code)] &'a ChatModelGpt3_5Turbo0613),
            Gpt3_5Turbo1106(#[allow(dead_code)] &'a ChatModelGpt3_5Turbo1106),
            Gpt3_5Turbo0125(#[allow(dead_code)] &'a ChatModelGpt3_5Turbo0125),
            Gpt3_5Turbo16k0613(#[allow(dead_code)] &'a ChatModelGpt3_5Turbo16k0613),
        }
        match self {
            Self::Gpt4_1 => ChatModel::Gpt4_1(&Default::default()).serialize(serializer),
            Self::Gpt4_1Mini => ChatModel::Gpt4_1Mini(&Default::default()).serialize(serializer),
            Self::Gpt4_1Nano => ChatModel::Gpt4_1Nano(&Default::default()).serialize(serializer),
            Self::Gpt4_1_2025_04_14 => {
                ChatModel::Gpt4_1_2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1Mini2025_04_14 => {
                ChatModel::Gpt4_1Mini2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1Nano2025_04_14 => {
                ChatModel::Gpt4_1Nano2025_04_14(&Default::default()).serialize(serializer)
            }
            Self::O4Mini => ChatModel::O4Mini(&Default::default()).serialize(serializer),
            Self::O4Mini2025_04_16 => {
                ChatModel::O4Mini2025_04_16(&Default::default()).serialize(serializer)
            }
            Self::O3 => ChatModel::O3(&Default::default()).serialize(serializer),
            Self::O3_2025_04_16 => {
                ChatModel::O3_2025_04_16(&Default::default()).serialize(serializer)
            }
            Self::O3Mini => ChatModel::O3Mini(&Default::default()).serialize(serializer),
            Self::O3Mini2025_01_31 => {
                ChatModel::O3Mini2025_01_31(&Default::default()).serialize(serializer)
            }
            Self::O1 => ChatModel::O1(&Default::default()).serialize(serializer),
            Self::O1_2024_12_17 => {
                ChatModel::O1_2024_12_17(&Default::default()).serialize(serializer)
            }
            Self::O1Preview => ChatModel::O1Preview(&Default::default()).serialize(serializer),
            Self::O1Preview2024_09_12 => {
                ChatModel::O1Preview2024_09_12(&Default::default()).serialize(serializer)
            }
            Self::O1Mini => ChatModel::O1Mini(&Default::default()).serialize(serializer),
            Self::O1Mini2024_09_12 => {
                ChatModel::O1Mini2024_09_12(&Default::default()).serialize(serializer)
            }
            Self::Gpt4o => ChatModel::Gpt4o(&Default::default()).serialize(serializer),
            Self::Gpt4o2024_11_20 => {
                ChatModel::Gpt4o2024_11_20(&Default::default()).serialize(serializer)
            }
            Self::Gpt4o2024_08_06 => {
                ChatModel::Gpt4o2024_08_06(&Default::default()).serialize(serializer)
            }
            Self::Gpt4o2024_05_13 => {
                ChatModel::Gpt4o2024_05_13(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oAudioPreview => {
                ChatModel::Gpt4oAudioPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oAudioPreview2024_10_01 => {
                ChatModel::Gpt4oAudioPreview2024_10_01(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oAudioPreview2024_12_17 => {
                ChatModel::Gpt4oAudioPreview2024_12_17(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oAudioPreview2025_06_03 => {
                ChatModel::Gpt4oAudioPreview2025_06_03(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniAudioPreview => {
                ChatModel::Gpt4oMiniAudioPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniAudioPreview2024_12_17 => {
                ChatModel::Gpt4oMiniAudioPreview2024_12_17(&Default::default())
                    .serialize(serializer)
            }
            Self::Gpt4oSearchPreview => {
                ChatModel::Gpt4oSearchPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniSearchPreview => {
                ChatModel::Gpt4oMiniSearchPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oSearchPreview2025_03_11 => {
                ChatModel::Gpt4oSearchPreview2025_03_11(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMiniSearchPreview2025_03_11 => {
                ChatModel::Gpt4oMiniSearchPreview2025_03_11(&Default::default())
                    .serialize(serializer)
            }
            Self::Chatgpt4oLatest => {
                ChatModel::Chatgpt4oLatest(&Default::default()).serialize(serializer)
            }
            Self::CodexMiniLatest => {
                ChatModel::CodexMiniLatest(&Default::default()).serialize(serializer)
            }
            Self::Gpt4oMini => ChatModel::Gpt4oMini(&Default::default()).serialize(serializer),
            Self::Gpt4oMini2024_07_18 => {
                ChatModel::Gpt4oMini2024_07_18(&Default::default()).serialize(serializer)
            }
            Self::Gpt4Turbo => ChatModel::Gpt4Turbo(&Default::default()).serialize(serializer),
            Self::Gpt4Turbo2024_04_09 => {
                ChatModel::Gpt4Turbo2024_04_09(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_0125Preview => {
                ChatModel::Gpt4_0125Preview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4TurboPreview => {
                ChatModel::Gpt4TurboPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_1106Preview => {
                ChatModel::Gpt4_1106Preview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4VisionPreview => {
                ChatModel::Gpt4VisionPreview(&Default::default()).serialize(serializer)
            }
            Self::Gpt4 => ChatModel::Gpt4(&Default::default()).serialize(serializer),
            Self::Gpt4_0314 => ChatModel::Gpt4_0314(&Default::default()).serialize(serializer),
            Self::Gpt4_0613 => ChatModel::Gpt4_0613(&Default::default()).serialize(serializer),
            Self::Gpt4_32k => ChatModel::Gpt4_32k(&Default::default()).serialize(serializer),
            Self::Gpt4_32k0314 => {
                ChatModel::Gpt4_32k0314(&Default::default()).serialize(serializer)
            }
            Self::Gpt4_32k0613 => {
                ChatModel::Gpt4_32k0613(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo => ChatModel::Gpt3_5Turbo(&Default::default()).serialize(serializer),
            Self::Gpt3_5Turbo16k => {
                ChatModel::Gpt3_5Turbo16k(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo0301 => {
                ChatModel::Gpt3_5Turbo0301(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo0613 => {
                ChatModel::Gpt3_5Turbo0613(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo1106 => {
                ChatModel::Gpt3_5Turbo1106(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo0125 => {
                ChatModel::Gpt3_5Turbo0125(&Default::default()).serialize(serializer)
            }
            Self::Gpt3_5Turbo16k0613 => {
                ChatModel::Gpt3_5Turbo16k0613(&Default::default()).serialize(serializer)
            }
        }
    }
}
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum ChatModel {
    #[doc = "gpt-4.1"]
    Gpt4_1,
    #[doc = "gpt-4.1-mini"]
    Gpt4_1Mini,
    #[doc = "gpt-4.1-nano"]
    Gpt4_1Nano,
    #[doc = "gpt-4.1-2025-04-14"]
    Gpt4_1_2025_04_14,
    #[doc = "gpt-4.1-mini-2025-04-14"]
    Gpt4_1Mini2025_04_14,
    #[doc = "gpt-4.1-nano-2025-04-14"]
    Gpt4_1Nano2025_04_14,
    #[doc = "o4-mini"]
    O4Mini,
    #[doc = "o4-mini-2025-04-16"]
    O4Mini2025_04_16,
    #[doc = "o3"]
    O3,
    #[doc = "o3-2025-04-16"]
    O3_2025_04_16,
    #[doc = "o3-mini"]
    O3Mini,
    #[doc = "o3-mini-2025-01-31"]
    O3Mini2025_01_31,
    #[doc = "o1"]
    O1,
    #[doc = "o1-2024-12-17"]
    O1_2024_12_17,
    #[doc = "o1-preview"]
    O1Preview,
    #[doc = "o1-preview-2024-09-12"]
    O1Preview2024_09_12,
    #[doc = "o1-mini"]
    O1Mini,
    #[doc = "o1-mini-2024-09-12"]
    O1Mini2024_09_12,
    #[doc = "gpt-4o"]
    Gpt4o,
    #[doc = "gpt-4o-2024-11-20"]
    Gpt4o2024_11_20,
    #[doc = "gpt-4o-2024-08-06"]
    Gpt4o2024_08_06,
    #[doc = "gpt-4o-2024-05-13"]
    Gpt4o2024_05_13,
    #[doc = "gpt-4o-audio-preview"]
    Gpt4oAudioPreview,
    #[doc = "gpt-4o-audio-preview-2024-10-01"]
    Gpt4oAudioPreview2024_10_01,
    #[doc = "gpt-4o-audio-preview-2024-12-17"]
    Gpt4oAudioPreview2024_12_17,
    #[doc = "gpt-4o-audio-preview-2025-06-03"]
    Gpt4oAudioPreview2025_06_03,
    #[doc = "gpt-4o-mini-audio-preview"]
    Gpt4oMiniAudioPreview,
    #[doc = "gpt-4o-mini-audio-preview-2024-12-17"]
    Gpt4oMiniAudioPreview2024_12_17,
    #[doc = "gpt-4o-search-preview"]
    Gpt4oSearchPreview,
    #[doc = "gpt-4o-mini-search-preview"]
    Gpt4oMiniSearchPreview,
    #[doc = "gpt-4o-search-preview-2025-03-11"]
    Gpt4oSearchPreview2025_03_11,
    #[doc = "gpt-4o-mini-search-preview-2025-03-11"]
    Gpt4oMiniSearchPreview2025_03_11,
    #[doc = "chatgpt-4o-latest"]
    Chatgpt4oLatest,
    #[doc = "codex-mini-latest"]
    CodexMiniLatest,
    #[doc = "gpt-4o-mini"]
    Gpt4oMini,
    #[doc = "gpt-4o-mini-2024-07-18"]
    Gpt4oMini2024_07_18,
    #[doc = "gpt-4-turbo"]
    Gpt4Turbo,
    #[doc = "gpt-4-turbo-2024-04-09"]
    Gpt4Turbo2024_04_09,
    #[doc = "gpt-4-0125-preview"]
    Gpt4_0125Preview,
    #[doc = "gpt-4-turbo-preview"]
    Gpt4TurboPreview,
    #[doc = "gpt-4-1106-preview"]
    Gpt4_1106Preview,
    #[doc = "gpt-4-vision-preview"]
    Gpt4VisionPreview,
    #[doc = "gpt-4"]
    Gpt4,
    #[doc = "gpt-4-0314"]
    Gpt4_0314,
    #[doc = "gpt-4-0613"]
    Gpt4_0613,
    #[doc = "gpt-4-32k"]
    Gpt4_32k,
    #[doc = "gpt-4-32k-0314"]
    Gpt4_32k0314,
    #[doc = "gpt-4-32k-0613"]
    Gpt4_32k0613,
    #[doc = "gpt-3.5-turbo"]
    Gpt3_5Turbo,
    #[doc = "gpt-3.5-turbo-16k"]
    Gpt3_5Turbo16k,
    #[doc = "gpt-3.5-turbo-0301"]
    Gpt3_5Turbo0301,
    #[doc = "gpt-3.5-turbo-0613"]
    Gpt3_5Turbo0613,
    #[doc = "gpt-3.5-turbo-1106"]
    Gpt3_5Turbo1106,
    #[doc = "gpt-3.5-turbo-0125"]
    Gpt3_5Turbo0125,
    #[doc = "gpt-3.5-turbo-16k-0613"]
    Gpt3_5Turbo16k0613,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter {
            #[serde(rename = "file_ids")]
            #[allow(dead_code)]
            file_ids: Option<Vec<String>>,
        }
        let CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter { file_ids, .. } =
            CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter::deserialize(
                deserializer,
            )?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter<'a> {
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter { file_ids }
            .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter {
    #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de>
    for CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch {
            #[serde(rename = "vector_store_ids")]
            #[allow(dead_code)]
            vector_store_ids: Option<Vec<String>>,
        }
        let CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch {
            vector_store_ids, ..
        } = CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch::deserialize(
            deserializer,
        )?;
        Ok(Self { vector_store_ids })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch<'a> {
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            vector_store_ids: &'a Option<Vec<String>>,
        }
        let Self { vector_store_ids } = self;
        CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch { vector_store_ids }
            .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch {
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
    #[builder(default)]
    pub vector_store_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestWithoutStreamToolResources {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadAndRunRequestWithoutStreamToolResources {
            #[serde(rename = "code_interpreter")]
            #[allow(dead_code)]
            code_interpreter:
                Option<CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[allow(dead_code)]
            file_search: Option<CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch>,
        }
        let CreateThreadAndRunRequestWithoutStreamToolResources {
            code_interpreter,
            file_search,
            ..
        } = CreateThreadAndRunRequestWithoutStreamToolResources::deserialize(deserializer)?;
        Ok(Self {
            code_interpreter,
            file_search,
        })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestWithoutStreamToolResources {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadAndRunRequestWithoutStreamToolResources<'a> {
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter:
                &'a Option<CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter>,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch>,
        }
        let Self {
            code_interpreter,
            file_search,
        } = self;
        CreateThreadAndRunRequestWithoutStreamToolResources {
            code_interpreter,
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestWithoutStreamToolResources {
    #[builder(default)]
    pub code_interpreter:
        Option<CreateThreadAndRunRequestWithoutStreamToolResourcesCodeInterpreter>,
    #[builder(default)]
    pub file_search: Option<CreateThreadAndRunRequestWithoutStreamToolResourcesFileSearch>,
}
impl<'de> serde::Deserialize<'de> for CreateThreadAndRunRequestWithoutStream {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateThreadAndRunRequestWithoutStream {
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "thread")]
            #[allow(dead_code)]
            thread: Option<CreateThreadRequest>,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<AssistantTool>>,
            #[serde(rename = "tool_resources")]
            #[allow(dead_code)]
            tool_resources: Option<CreateThreadAndRunRequestWithoutStreamToolResources>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "max_prompt_tokens")]
            #[allow(dead_code)]
            max_prompt_tokens: Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[allow(dead_code)]
            truncation_strategy: Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let CreateThreadAndRunRequestWithoutStream {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = CreateThreadAndRunRequestWithoutStream::deserialize(deserializer)?;
        Ok(Self {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for CreateThreadAndRunRequestWithoutStream {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateThreadAndRunRequestWithoutStream<'a> {
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "thread")]
            #[serde(skip_serializing_if = "Option::is_none")]
            thread: &'a Option<CreateThreadRequest>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<AssistantTool>>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<CreateThreadAndRunRequestWithoutStreamToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let Self {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        CreateThreadAndRunRequestWithoutStream {
            assistant_id,
            thread,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestWithoutStream {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    pub assistant_id: String,
    #[builder(default)]
    pub thread: Option<CreateThreadRequest>,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub tools: Option<Vec<AssistantTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<CreateThreadAndRunRequestWithoutStreamToolResources>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<u64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[builder(default)]
    pub truncation_strategy: Option<TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<AssistantsApiToolChoiceOption>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for CreateRunRequestWithoutStream {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateRunRequestWithoutStream {
            #[serde(rename = "assistant_id")]
            #[allow(dead_code)]
            assistant_id: String,
            #[serde(rename = "model")]
            #[allow(dead_code)]
            model: Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[allow(dead_code)]
            reasoning_effort: Option<ReasoningEffort>,
            #[serde(rename = "instructions")]
            #[allow(dead_code)]
            instructions: Option<String>,
            #[serde(rename = "additional_instructions")]
            #[allow(dead_code)]
            additional_instructions: Option<String>,
            #[serde(rename = "additional_messages")]
            #[allow(dead_code)]
            additional_messages: Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tools")]
            #[allow(dead_code)]
            tools: Option<Vec<AssistantTool>>,
            #[serde(rename = "metadata")]
            #[allow(dead_code)]
            metadata: Option<Metadata>,
            #[serde(rename = "temperature")]
            #[allow(dead_code)]
            temperature: Option<f64>,
            #[serde(rename = "top_p")]
            #[allow(dead_code)]
            top_p: Option<f64>,
            #[serde(rename = "max_prompt_tokens")]
            #[allow(dead_code)]
            max_prompt_tokens: Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[allow(dead_code)]
            max_completion_tokens: Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[allow(dead_code)]
            truncation_strategy: Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[allow(dead_code)]
            tool_choice: Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[allow(dead_code)]
            parallel_tool_calls: Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[allow(dead_code)]
            response_format: Option<AssistantsApiResponseFormatOption>,
        }
        let CreateRunRequestWithoutStream {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = CreateRunRequestWithoutStream::deserialize(deserializer)?;
        Ok(Self {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for CreateRunRequestWithoutStream {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateRunRequestWithoutStream<'a> {
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<ReasoningEffort>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "additional_instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            additional_instructions: &'a Option<String>,
            #[serde(rename = "additional_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            additional_messages: &'a Option<Vec<CreateMessageRequest>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<AssistantTool>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<f64>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<f64>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<u64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<u64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parallel_tool_calls: &'a Option<ParallelToolCalls>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<AssistantsApiResponseFormatOption>,
        }
        let Self {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        CreateRunRequestWithoutStream {
            assistant_id,
            model,
            reasoning_effort,
            instructions,
            additional_instructions,
            additional_messages,
            tools,
            metadata,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateRunRequestWithoutStream {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    pub assistant_id: String,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[builder(default)]
    pub model: Option<String>,
    #[builder(default)]
    pub reasoning_effort: Option<ReasoningEffort>,
    #[doc = "Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions."]
    #[builder(default)]
    pub additional_instructions: Option<String>,
    #[doc = "Adds additional messages to the thread before creating the run."]
    #[builder(default)]
    pub additional_messages: Option<Vec<CreateMessageRequest>>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[builder(default)]
    pub tools: Option<Vec<AssistantTool>>,
    #[builder(default)]
    pub metadata: Option<Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<f64>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<f64>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<u64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<u64>,
    #[builder(default)]
    pub truncation_strategy: Option<TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<AssistantsApiToolChoiceOption>,
    #[builder(default)]
    pub parallel_tool_calls: Option<ParallelToolCalls>,
    #[builder(default)]
    pub response_format: Option<AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for SubmitToolOutputsRunRequestWithoutStreamToolOutputs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct SubmitToolOutputsRunRequestWithoutStreamToolOutputs {
            #[serde(rename = "tool_call_id")]
            #[allow(dead_code)]
            tool_call_id: Option<String>,
            #[serde(rename = "output")]
            #[allow(dead_code)]
            output: Option<String>,
        }
        let SubmitToolOutputsRunRequestWithoutStreamToolOutputs {
            tool_call_id,
            output,
            ..
        } = SubmitToolOutputsRunRequestWithoutStreamToolOutputs::deserialize(deserializer)?;
        Ok(Self {
            tool_call_id,
            output,
        })
    }
}
impl serde::Serialize for SubmitToolOutputsRunRequestWithoutStreamToolOutputs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct SubmitToolOutputsRunRequestWithoutStreamToolOutputs<'a> {
            #[serde(rename = "tool_call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_call_id: &'a Option<String>,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
        }
        let Self {
            tool_call_id,
            output,
        } = self;
        SubmitToolOutputsRunRequestWithoutStreamToolOutputs {
            tool_call_id,
            output,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct SubmitToolOutputsRunRequestWithoutStreamToolOutputs {
    #[doc = "The ID of the tool call in the `required_action` object within the run object the output is being submitted for."]
    #[builder(default)]
    pub tool_call_id: Option<String>,
    #[doc = "The output of the tool call to be submitted to continue the run."]
    #[builder(default)]
    pub output: Option<String>,
}
impl<'de> serde::Deserialize<'de> for SubmitToolOutputsRunRequestWithoutStream {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct SubmitToolOutputsRunRequestWithoutStream {
            #[serde(rename = "tool_outputs")]
            #[allow(dead_code)]
            tool_outputs: Vec<SubmitToolOutputsRunRequestWithoutStreamToolOutputs>,
        }
        let SubmitToolOutputsRunRequestWithoutStream { tool_outputs, .. } =
            SubmitToolOutputsRunRequestWithoutStream::deserialize(deserializer)?;
        Ok(Self { tool_outputs })
    }
}
impl serde::Serialize for SubmitToolOutputsRunRequestWithoutStream {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct SubmitToolOutputsRunRequestWithoutStream<'a> {
            #[serde(rename = "tool_outputs")]
            tool_outputs: &'a Vec<SubmitToolOutputsRunRequestWithoutStreamToolOutputs>,
        }
        let Self { tool_outputs } = self;
        SubmitToolOutputsRunRequestWithoutStream { tool_outputs }.serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct SubmitToolOutputsRunRequestWithoutStream {
    #[doc = "A list of tools for which the outputs are being submitted."]
    pub tool_outputs: Vec<SubmitToolOutputsRunRequestWithoutStreamToolOutputs>,
}
impl<'de> serde::Deserialize<'de> for RunStatus {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusRequiresAction {
            #[default]
            #[serde(rename = "requires_action")]
            RequiresAction,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusCancelling {
            #[default]
            #[serde(rename = "cancelling")]
            Cancelling,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStatus {
            Queued(#[allow(dead_code)] RunStatusQueued),
            InProgress(#[allow(dead_code)] RunStatusInProgress),
            RequiresAction(#[allow(dead_code)] RunStatusRequiresAction),
            Cancelling(#[allow(dead_code)] RunStatusCancelling),
            Cancelled(#[allow(dead_code)] RunStatusCancelled),
            Failed(#[allow(dead_code)] RunStatusFailed),
            Completed(#[allow(dead_code)] RunStatusCompleted),
            Incomplete(#[allow(dead_code)] RunStatusIncomplete),
            Expired(#[allow(dead_code)] RunStatusExpired),
        }
        Ok(match RunStatus::deserialize(deserializer)? {
            RunStatus::Queued(_) => Self::Queued,
            RunStatus::InProgress(_) => Self::InProgress,
            RunStatus::RequiresAction(_) => Self::RequiresAction,
            RunStatus::Cancelling(_) => Self::Cancelling,
            RunStatus::Cancelled(_) => Self::Cancelled,
            RunStatus::Failed(_) => Self::Failed,
            RunStatus::Completed(_) => Self::Completed,
            RunStatus::Incomplete(_) => Self::Incomplete,
            RunStatus::Expired(_) => Self::Expired,
        })
    }
}
impl serde::Serialize for RunStatus {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusQueued {
            #[default]
            #[serde(rename = "queued")]
            Queued,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusInProgress {
            #[default]
            #[serde(rename = "in_progress")]
            InProgress,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusRequiresAction {
            #[default]
            #[serde(rename = "requires_action")]
            RequiresAction,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusCancelling {
            #[default]
            #[serde(rename = "cancelling")]
            Cancelling,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusCancelled {
            #[default]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusFailed {
            #[default]
            #[serde(rename = "failed")]
            Failed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusCompleted {
            #[default]
            #[serde(rename = "completed")]
            Completed,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusIncomplete {
            #[default]
            #[serde(rename = "incomplete")]
            Incomplete,
        }
        #[derive(
            Clone, Debug, PartialEq, Copy, Default, serde :: Deserialize, serde :: Serialize,
        )]
        enum RunStatusExpired {
            #[default]
            #[serde(rename = "expired")]
            Expired,
        }
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStatus<'a> {
            Queued(#[allow(dead_code)] &'a RunStatusQueued),
            InProgress(#[allow(dead_code)] &'a RunStatusInProgress),
            RequiresAction(#[allow(dead_code)] &'a RunStatusRequiresAction),
            Cancelling(#[allow(dead_code)] &'a RunStatusCancelling),
            Cancelled(#[allow(dead_code)] &'a RunStatusCancelled),
            Failed(#[allow(dead_code)] &'a RunStatusFailed),
            Completed(#[allow(dead_code)] &'a RunStatusCompleted),
            Incomplete(#[allow(dead_code)] &'a RunStatusIncomplete),
            Expired(#[allow(dead_code)] &'a RunStatusExpired),
        }
        match self {
            Self::Queued => RunStatus::Queued(&Default::default()).serialize(serializer),
            Self::InProgress => RunStatus::InProgress(&Default::default()).serialize(serializer),
            Self::RequiresAction => {
                RunStatus::RequiresAction(&Default::default()).serialize(serializer)
            }
            Self::Cancelling => RunStatus::Cancelling(&Default::default()).serialize(serializer),
            Self::Cancelled => RunStatus::Cancelled(&Default::default()).serialize(serializer),
            Self::Failed => RunStatus::Failed(&Default::default()).serialize(serializer),
            Self::Completed => RunStatus::Completed(&Default::default()).serialize(serializer),
            Self::Incomplete => RunStatus::Incomplete(&Default::default()).serialize(serializer),
            Self::Expired => RunStatus::Expired(&Default::default()).serialize(serializer),
        }
    }
}
#[doc = "The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`."]
#[derive(Clone, Debug, PartialEq, Copy)]
#[allow(clippy::large_enum_variant)]
pub enum RunStatus {
    #[doc = "queued"]
    Queued,
    #[doc = "in_progress"]
    InProgress,
    #[doc = "requires_action"]
    RequiresAction,
    #[doc = "cancelling"]
    Cancelling,
    #[doc = "cancelled"]
    Cancelled,
    #[doc = "failed"]
    Failed,
    #[doc = "completed"]
    Completed,
    #[doc = "incomplete"]
    Incomplete,
    #[doc = "expired"]
    Expired,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaObjectDeltaStepDetails {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum RunStepDeltaObjectDeltaStepDetails {
            MessageCreation(#[allow(dead_code)] RunStepDeltaStepDetailsMessageCreationObject),
            ToolCalls(#[allow(dead_code)] RunStepDeltaStepDetailsToolCallsObject),
        }
        Ok(
            match RunStepDeltaObjectDeltaStepDetails::deserialize(deserializer)? {
                RunStepDeltaObjectDeltaStepDetails::MessageCreation(_v) => {
                    Self::MessageCreation(_v)
                }
                RunStepDeltaObjectDeltaStepDetails::ToolCalls(_v) => Self::ToolCalls(_v),
            },
        )
    }
}
impl serde::Serialize for RunStepDeltaObjectDeltaStepDetails {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum RunStepDeltaObjectDeltaStepDetails<'a> {
            MessageCreation(#[allow(dead_code)] &'a RunStepDeltaStepDetailsMessageCreationObject),
            ToolCalls(#[allow(dead_code)] &'a RunStepDeltaStepDetailsToolCallsObject),
        }
        match self {
            Self::MessageCreation(_v) => {
                RunStepDeltaObjectDeltaStepDetails::MessageCreation(_v).serialize(serializer)
            }
            Self::ToolCalls(_v) => {
                RunStepDeltaObjectDeltaStepDetails::ToolCalls(_v).serialize(serializer)
            }
        }
    }
}
#[doc = "The details of the run step."]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDeltaObjectDeltaStepDetails {
    MessageCreation(RunStepDeltaStepDetailsMessageCreationObject),
    ToolCalls(RunStepDeltaStepDetailsToolCallsObject),
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaObjectDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaObjectDelta {
            #[serde(rename = "step_details")]
            #[allow(dead_code)]
            step_details: Option<RunStepDeltaObjectDeltaStepDetails>,
        }
        let RunStepDeltaObjectDelta { step_details, .. } =
            RunStepDeltaObjectDelta::deserialize(deserializer)?;
        Ok(Self { step_details })
    }
}
impl serde::Serialize for RunStepDeltaObjectDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaObjectDelta<'a> {
            #[serde(rename = "step_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            step_details: &'a Option<RunStepDeltaObjectDeltaStepDetails>,
        }
        let Self { step_details } = self;
        RunStepDeltaObjectDelta { step_details }.serialize(serializer)
    }
}
#[doc = "The delta containing the fields that have changed on the run step."]
#[derive(Clone, Debug, PartialEq, Default, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaObjectDelta {
    #[doc = "The details of the run step."]
    #[builder(default)]
    pub step_details: Option<RunStepDeltaObjectDeltaStepDetails>,
}
#[cfg(test)]
mod tests;
