#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct AddUploadPartRequest {
    #[doc = "The chunk of bytes for this Part.\n"]
    #[serde_as(as = "serde_with::base64::Base64")]
    #[serde(rename = "data")]
    pub data: Vec<u8>,
}
#[allow(clippy::module_inception)]
pub mod admin_api_key {
    #[doc = "The object type, which is always `organization.admin_api_key`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.admin_api_key");
    #[allow(clippy::module_inception)]
    pub mod owner {
        #[doc = "Always `user`"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub struct Type;
        impl_serde!(Type, "user");
        #[doc = "The object type, which is always organization.user"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub struct Object;
        impl_serde!(Object, "organization.user");
        #[doc = "Always `owner`"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub struct Role;
        impl_serde!(Role, "owner");
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Owner {
        #[doc = "Always `user`"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<crate::__types::admin_api_key::owner::Type>,
        #[doc = "The object type, which is always organization.user"]
        #[serde(rename = "object")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub object: Option<crate::__types::admin_api_key::owner::Object>,
        #[doc = "The identifier, which can be referenced in API endpoints"]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The name of the user"]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
        #[doc = "The Unix timestamp (in seconds) of when the user was created"]
        #[serde(rename = "created_at")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub created_at: Option<i64>,
        #[doc = "Always `owner`"]
        #[serde(rename = "role")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub role: Option<crate::__types::admin_api_key::owner::Role>,
    }
}
#[doc = "Represents an individual Admin API key in an org."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AdminApiKey {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the API key"]
    pub name: String,
    #[doc = "The redacted value of the API key"]
    pub redacted_value: String,
    #[doc = "The value of the API key. Only shown on create."]
    #[builder(default)]
    pub value: Option<String>,
    #[doc = "The Unix timestamp (in seconds) of when the API key was created"]
    pub created_at: i64,
    #[doc = "The Unix timestamp (in seconds) of when the API key was last used"]
    #[builder(default)]
    pub last_used_at: Option<i64>,
    #[builder(default)]
    pub owner: crate::__types::admin_api_key::Owner,
}
impl<'de> serde::Deserialize<'de> for AdminApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AdminApiKey {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::admin_api_key::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "redacted_value")]
            redacted_value: String,
            #[serde(rename = "value")]
            value: Option<String>,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "last_used_at")]
            last_used_at: Option<i64>,
            #[serde(rename = "owner")]
            owner: crate::__types::admin_api_key::Owner,
        }
        let AdminApiKey {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
            ..
        } = AdminApiKey::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        })
    }
}
impl serde::Serialize for AdminApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AdminApiKey<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::admin_api_key::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "redacted_value")]
            redacted_value: &'a String,
            #[serde(rename = "value")]
            #[serde(skip_serializing_if = "Option::is_none")]
            value: &'a Option<String>,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "last_used_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_used_at: &'a Option<i64>,
            #[serde(rename = "owner")]
            owner: &'a crate::__types::admin_api_key::Owner,
        }
        let Self {
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        } = self;
        AdminApiKey {
            object: &Default::default(),
            id,
            name,
            redacted_value,
            value,
            created_at,
            last_used_at,
            owner,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ApiKeyList {
    #[serde(rename = "object")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<String>,
    #[serde(rename = "data")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub data: Option<Vec<crate::__types::AdminApiKey>>,
    #[serde(rename = "has_more")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub has_more: Option<bool>,
    #[serde(rename = "first_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub first_id: Option<String>,
    #[serde(rename = "last_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub last_id: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod assistant_object {
    #[doc = "The object type, which is always `assistant`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "assistant");
    #[allow(clippy::module_inception)]
    pub mod tool_resources {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct CodeInterpreter {
            #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter`` tool. There can be a maximum of 20 files associated with the tool.\n"]
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_ids: Option<Vec<String>>,
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct FileSearch {
            #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub vector_store_ids: Option<Vec<String>>,
        }
    }
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ToolResources {
        #[serde(rename = "code_interpreter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code_interpreter:
            Option<crate::__types::assistant_object::tool_resources::CodeInterpreter>,
        #[serde(rename = "file_search")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_search: Option<crate::__types::assistant_object::tool_resources::FileSearch>,
    }
}
#[doc = "Represents an `assistant` that can call the model and use tools."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the assistant was created."]
    pub created_at: i64,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    pub model: String,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    pub tools: Vec<crate::__types::AssistantTool>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<crate::__types::assistant_object::ToolResources>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[builder(default)]
    pub response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for AssistantObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::assistant_object::Object,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "name")]
            name: Option<String>,
            #[serde(rename = "description")]
            description: Option<String>,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "instructions")]
            instructions: Option<String>,
            #[serde(rename = "tools")]
            tools: Vec<crate::__types::AssistantTool>,
            #[serde(rename = "tool_resources")]
            tool_resources: Option<crate::__types::assistant_object::ToolResources>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
            #[serde(rename = "temperature")]
            temperature: Option<serde_json::Number>,
            #[serde(rename = "top_p")]
            top_p: Option<serde_json::Number>,
            #[serde(rename = "response_format")]
            response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
        }
        let AssistantObject {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
            ..
        } = AssistantObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        })
    }
}
impl serde::Serialize for AssistantObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::assistant_object::Object,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<String>,
            #[serde(rename = "tools")]
            tools: &'a Vec<crate::__types::AssistantTool>,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<crate::__types::assistant_object::ToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<serde_json::Number>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<serde_json::Number>,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<crate::__types::AssistantsApiResponseFormatOption>,
        }
        let Self {
            id,
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        } = self;
        AssistantObject {
            id,
            object: &Default::default(),
            created_at,
            name,
            description,
            model,
            instructions,
            tools,
            tool_resources,
            metadata,
            temperature,
            top_p,
            response_format,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents an event emitted when streaming a Run.\n\nEach event in a server-sent events stream has an `event` and `data` property:\n\n```text\nevent: thread.created\ndata: {\"id\": \"thread_123\", \"object\": \"thread\", ...}\n```\n\nWe emit events whenever a new object is created, transitions to a new state, or is being\nstreamed in parts (deltas). For example, we emit `thread.run.created` when a new run\nis created, `thread.run.completed` when a run completes, and so on. When an Assistant chooses\nto create a message during a run, we emit a `thread.message.created event`, a\n`thread.message.in_progress` event, many `thread.message.delta` events, and finally a\n`thread.message.completed` event.\n\nWe may add additional events over time, so we recommend handling unknown events gracefully\nin your code. See the [Assistants API quickstart](https://platform.openai.com/docs/assistants/overview) to learn how to\nintegrate the Assistants API with streaming.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantStreamEvent {
    ThreadStreamEvent(crate::__types::ThreadStreamEvent),
    RunStreamEvent(crate::__types::RunStreamEvent),
    RunStepStreamEvent(crate::__types::RunStepStreamEvent),
    MessageStreamEvent(crate::__types::MessageStreamEvent),
    ErrorEvent(crate::__types::ErrorEvent),
}
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum AssistantSupportedModels {
    #[doc = "`gpt-5`"]
    #[serde(rename = "gpt-5")]
    Gpt5,
    #[doc = "`gpt-5-mini`"]
    #[serde(rename = "gpt-5-mini")]
    Gpt5Mini,
    #[doc = "`gpt-5-nano`"]
    #[serde(rename = "gpt-5-nano")]
    Gpt5Nano,
    #[doc = "`gpt-5-2025-08-07`"]
    #[serde(rename = "gpt-5-2025-08-07")]
    Gpt5_2025_08_07,
    #[doc = "`gpt-5-mini-2025-08-07`"]
    #[serde(rename = "gpt-5-mini-2025-08-07")]
    Gpt5Mini2025_08_07,
    #[doc = "`gpt-5-nano-2025-08-07`"]
    #[serde(rename = "gpt-5-nano-2025-08-07")]
    Gpt5Nano2025_08_07,
    #[doc = "`gpt-4.1`"]
    #[serde(rename = "gpt-4.1")]
    Gpt4_1,
    #[doc = "`gpt-4.1-mini`"]
    #[serde(rename = "gpt-4.1-mini")]
    Gpt4_1Mini,
    #[doc = "`gpt-4.1-nano`"]
    #[serde(rename = "gpt-4.1-nano")]
    Gpt4_1Nano,
    #[doc = "`gpt-4.1-2025-04-14`"]
    #[serde(rename = "gpt-4.1-2025-04-14")]
    Gpt4_1_2025_04_14,
    #[doc = "`gpt-4.1-mini-2025-04-14`"]
    #[serde(rename = "gpt-4.1-mini-2025-04-14")]
    Gpt4_1Mini2025_04_14,
    #[doc = "`gpt-4.1-nano-2025-04-14`"]
    #[serde(rename = "gpt-4.1-nano-2025-04-14")]
    Gpt4_1Nano2025_04_14,
    #[doc = "`o3-mini`"]
    #[serde(rename = "o3-mini")]
    O3Mini,
    #[doc = "`o3-mini-2025-01-31`"]
    #[serde(rename = "o3-mini-2025-01-31")]
    O3Mini2025_01_31,
    #[doc = "`o1`"]
    #[serde(rename = "o1")]
    O1,
    #[doc = "`o1-2024-12-17`"]
    #[serde(rename = "o1-2024-12-17")]
    O1_2024_12_17,
    #[doc = "`gpt-4o`"]
    #[serde(rename = "gpt-4o")]
    Gpt4o,
    #[doc = "`gpt-4o-2024-11-20`"]
    #[serde(rename = "gpt-4o-2024-11-20")]
    Gpt4o2024_11_20,
    #[doc = "`gpt-4o-2024-08-06`"]
    #[serde(rename = "gpt-4o-2024-08-06")]
    Gpt4o2024_08_06,
    #[doc = "`gpt-4o-2024-05-13`"]
    #[serde(rename = "gpt-4o-2024-05-13")]
    Gpt4o2024_05_13,
    #[doc = "`gpt-4o-mini`"]
    #[serde(rename = "gpt-4o-mini")]
    Gpt4oMini,
    #[doc = "`gpt-4o-mini-2024-07-18`"]
    #[serde(rename = "gpt-4o-mini-2024-07-18")]
    Gpt4oMini2024_07_18,
    #[doc = "`gpt-4.5-preview`"]
    #[serde(rename = "gpt-4.5-preview")]
    Gpt4_5Preview,
    #[doc = "`gpt-4.5-preview-2025-02-27`"]
    #[serde(rename = "gpt-4.5-preview-2025-02-27")]
    Gpt4_5Preview2025_02_27,
    #[doc = "`gpt-4-turbo`"]
    #[serde(rename = "gpt-4-turbo")]
    Gpt4Turbo,
    #[doc = "`gpt-4-turbo-2024-04-09`"]
    #[serde(rename = "gpt-4-turbo-2024-04-09")]
    Gpt4Turbo2024_04_09,
    #[doc = "`gpt-4-0125-preview`"]
    #[serde(rename = "gpt-4-0125-preview")]
    Gpt4_0125Preview,
    #[doc = "`gpt-4-turbo-preview`"]
    #[serde(rename = "gpt-4-turbo-preview")]
    Gpt4TurboPreview,
    #[doc = "`gpt-4-1106-preview`"]
    #[serde(rename = "gpt-4-1106-preview")]
    Gpt4_1106Preview,
    #[doc = "`gpt-4-vision-preview`"]
    #[serde(rename = "gpt-4-vision-preview")]
    Gpt4VisionPreview,
    #[doc = "`gpt-4`"]
    #[serde(rename = "gpt-4")]
    Gpt4,
    #[doc = "`gpt-4-0314`"]
    #[serde(rename = "gpt-4-0314")]
    Gpt4_0314,
    #[doc = "`gpt-4-0613`"]
    #[serde(rename = "gpt-4-0613")]
    Gpt4_0613,
    #[doc = "`gpt-4-32k`"]
    #[serde(rename = "gpt-4-32k")]
    Gpt4_32k,
    #[doc = "`gpt-4-32k-0314`"]
    #[serde(rename = "gpt-4-32k-0314")]
    Gpt4_32k0314,
    #[doc = "`gpt-4-32k-0613`"]
    #[serde(rename = "gpt-4-32k-0613")]
    Gpt4_32k0613,
    #[doc = "`gpt-3.5-turbo`"]
    #[serde(rename = "gpt-3.5-turbo")]
    Gpt3_5Turbo,
    #[doc = "`gpt-3.5-turbo-16k`"]
    #[serde(rename = "gpt-3.5-turbo-16k")]
    Gpt3_5Turbo16k,
    #[doc = "`gpt-3.5-turbo-0613`"]
    #[serde(rename = "gpt-3.5-turbo-0613")]
    Gpt3_5Turbo0613,
    #[doc = "`gpt-3.5-turbo-1106`"]
    #[serde(rename = "gpt-3.5-turbo-1106")]
    Gpt3_5Turbo1106,
    #[doc = "`gpt-3.5-turbo-0125`"]
    #[serde(rename = "gpt-3.5-turbo-0125")]
    Gpt3_5Turbo0125,
    #[doc = "`gpt-3.5-turbo-16k-0613`"]
    #[serde(rename = "gpt-3.5-turbo-16k-0613")]
    Gpt3_5Turbo16k0613,
}
#[allow(clippy::module_inception)]
pub(crate) mod assistant_tools_code {
    #[doc = "The type of tool being defined: `code_interpreter`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "code_interpreter");
}
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantToolsCode {}
impl<'de> serde::Deserialize<'de> for AssistantToolsCode {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsCode {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::assistant_tools_code::Type,
        }
        let AssistantToolsCode { .. } = AssistantToolsCode::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for AssistantToolsCode {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsCode<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::assistant_tools_code::Type,
        }
        let Self {} = self;
        AssistantToolsCode {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod assistant_tools_file_search {
    #[doc = "The type of tool being defined: `file_search`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_search");
    #[doc = "Overrides for the file search tool."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FileSearch {
        #[doc = "The maximum number of results the file search tool should output. The default is 20 for `gpt-4*` models and 5 for `gpt-3.5-turbo`. This number should be between 1 and 50 inclusive.\n\nNote that the file search tool may output fewer than `max_num_results` results. See the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
        #[serde(rename = "max_num_results")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub max_num_results: Option<i64>,
        #[serde(rename = "ranking_options")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub ranking_options: Option<crate::__types::FileSearchRankingOptions>,
    }
}
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFileSearch {
    #[doc = "Overrides for the file search tool."]
    #[builder(default)]
    pub file_search: Option<crate::__types::assistant_tools_file_search::FileSearch>,
}
impl<'de> serde::Deserialize<'de> for AssistantToolsFileSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsFileSearch {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::assistant_tools_file_search::Type,
            #[serde(rename = "file_search")]
            file_search: Option<crate::__types::assistant_tools_file_search::FileSearch>,
        }
        let AssistantToolsFileSearch { file_search, .. } =
            AssistantToolsFileSearch::deserialize(deserializer)?;
        Ok(Self { file_search })
    }
}
impl serde::Serialize for AssistantToolsFileSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsFileSearch<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::assistant_tools_file_search::Type,
            #[serde(rename = "file_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_search: &'a Option<crate::__types::assistant_tools_file_search::FileSearch>,
        }
        let Self { file_search } = self;
        AssistantToolsFileSearch {
            r#type: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod assistant_tools_file_search_type_only {
    #[doc = "The type of tool being defined: `file_search`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_search");
}
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFileSearchTypeOnly {}
impl<'de> serde::Deserialize<'de> for AssistantToolsFileSearchTypeOnly {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsFileSearchTypeOnly {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::assistant_tools_file_search_type_only::Type,
        }
        let AssistantToolsFileSearchTypeOnly { .. } =
            AssistantToolsFileSearchTypeOnly::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for AssistantToolsFileSearchTypeOnly {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsFileSearchTypeOnly<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::assistant_tools_file_search_type_only::Type,
        }
        let Self {} = self;
        AssistantToolsFileSearchTypeOnly {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod assistant_tools_function {
    #[doc = "The type of tool being defined: `function`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct AssistantToolsFunction {
    pub function: crate::__types::FunctionObject,
}
impl<'de> serde::Deserialize<'de> for AssistantToolsFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AssistantToolsFunction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::assistant_tools_function::Type,
            #[serde(rename = "function")]
            function: crate::__types::FunctionObject,
        }
        let AssistantToolsFunction { function, .. } =
            AssistantToolsFunction::deserialize(deserializer)?;
        Ok(Self { function })
    }
}
impl serde::Serialize for AssistantToolsFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AssistantToolsFunction<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::assistant_tools_function::Type,
            #[serde(rename = "function")]
            function: &'a crate::__types::FunctionObject,
        }
        let Self { function } = self;
        AssistantToolsFunction {
            r#type: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod assistants_api_response_format_option {
    #[doc = "`auto` is the default value\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Auto;
    impl_serde!(Auto, "auto");
}
#[doc = "Specifies the format that the model must output. Compatible with [GPT-4o](https://platform.openai.com/docs/models#gpt-4o), [GPT-4 Turbo](https://platform.openai.com/docs/models#gpt-4-turbo-and-gpt-4), and all GPT-3.5 Turbo models since `gpt-3.5-turbo-1106`.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema. Learn more in the [Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables JSON mode, which ensures the message the model generates is valid JSON.\n\n**Important:** when using JSON mode, you **must** also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly \"stuck\" request. Also note that the message content may be partially cut off if `finish_reason=\"length\"`, which indicates the generation exceeded `max_tokens` or the conversation exceeded the max context length.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantsApiResponseFormatOption {
    #[doc = "auto"]
    Auto,
    Text(crate::__types::ResponseFormatText),
    JsonObject(crate::__types::ResponseFormatJsonObject),
    JsonSchema(crate::__types::ResponseFormatJsonSchema),
}
impl<'de> serde::Deserialize<'de> for AssistantsApiResponseFormatOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AssistantsApiResponseFormatOption {
            Auto(crate::__types::assistants_api_response_format_option::Auto),
            Text(crate::__types::ResponseFormatText),
            JsonObject(crate::__types::ResponseFormatJsonObject),
            JsonSchema(crate::__types::ResponseFormatJsonSchema),
        }
        Ok(
            match AssistantsApiResponseFormatOption::deserialize(deserializer)? {
                AssistantsApiResponseFormatOption::Auto(_) => Self::Auto,
                AssistantsApiResponseFormatOption::Text(v) => Self::Text(v),
                AssistantsApiResponseFormatOption::JsonObject(v) => Self::JsonObject(v),
                AssistantsApiResponseFormatOption::JsonSchema(v) => Self::JsonSchema(v),
            },
        )
    }
}
impl serde::Serialize for AssistantsApiResponseFormatOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AssistantsApiResponseFormatOption<'a> {
            Auto(crate::__types::assistants_api_response_format_option::Auto),
            Text(&'a crate::__types::ResponseFormatText),
            JsonObject(&'a crate::__types::ResponseFormatJsonObject),
            JsonSchema(&'a crate::__types::ResponseFormatJsonSchema),
        }
        match self {
            Self::Auto => AssistantsApiResponseFormatOption::Auto(Default::default()),
            Self::Text(v) => AssistantsApiResponseFormatOption::Text(v),
            Self::JsonObject(v) => AssistantsApiResponseFormatOption::JsonObject(v),
            Self::JsonSchema(v) => AssistantsApiResponseFormatOption::JsonSchema(v),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod assistants_api_tool_choice_option {
    #[doc = "none"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct None;
    impl_serde!(None, "none");
    #[doc = "auto"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Auto;
    impl_serde!(Auto, "auto");
    #[doc = "required"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Required;
    impl_serde!(Required, "required");
}
#[doc = "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tools and instead generates a message.\n`auto` is the default value and means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools before responding to the user.\nSpecifying a particular tool like `{\"type\": \"file_search\"}` or `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantsApiToolChoiceOption {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    #[doc = "required"]
    Required,
    AssistantsNamedToolChoice(crate::__types::AssistantsNamedToolChoice),
}
impl<'de> serde::Deserialize<'de> for AssistantsApiToolChoiceOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum AssistantsApiToolChoiceOption {
            None(crate::__types::assistants_api_tool_choice_option::None),
            Auto(crate::__types::assistants_api_tool_choice_option::Auto),
            Required(crate::__types::assistants_api_tool_choice_option::Required),
            AssistantsNamedToolChoice(crate::__types::AssistantsNamedToolChoice),
        }
        Ok(
            match AssistantsApiToolChoiceOption::deserialize(deserializer)? {
                AssistantsApiToolChoiceOption::None(_) => Self::None,
                AssistantsApiToolChoiceOption::Auto(_) => Self::Auto,
                AssistantsApiToolChoiceOption::Required(_) => Self::Required,
                AssistantsApiToolChoiceOption::AssistantsNamedToolChoice(v) => {
                    Self::AssistantsNamedToolChoice(v)
                }
            },
        )
    }
}
impl serde::Serialize for AssistantsApiToolChoiceOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum AssistantsApiToolChoiceOption<'a> {
            None(crate::__types::assistants_api_tool_choice_option::None),
            Auto(crate::__types::assistants_api_tool_choice_option::Auto),
            Required(crate::__types::assistants_api_tool_choice_option::Required),
            AssistantsNamedToolChoice(&'a crate::__types::AssistantsNamedToolChoice),
        }
        match self {
            Self::None => AssistantsApiToolChoiceOption::None(Default::default()),
            Self::Auto => AssistantsApiToolChoiceOption::Auto(Default::default()),
            Self::Required => AssistantsApiToolChoiceOption::Required(Default::default()),
            Self::AssistantsNamedToolChoice(v) => {
                AssistantsApiToolChoiceOption::AssistantsNamedToolChoice(v)
            }
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod assistants_named_tool_choice {
    #[doc = "The type of the tool. If type is `function`, the function name must be set"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`function`"]
        #[serde(rename = "function")]
        Function,
        #[doc = "`code_interpreter`"]
        #[serde(rename = "code_interpreter")]
        CodeInterpreter,
        #[doc = "`file_search`"]
        #[serde(rename = "file_search")]
        FileSearch,
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Function {
        #[doc = "The name of the function to call."]
        #[serde(rename = "name")]
        pub name: String,
    }
}
#[doc = "Specifies a tool the model should use. Use to force the model to call a specific tool."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct AssistantsNamedToolChoice {
    #[doc = "The type of the tool. If type is `function`, the function name must be set"]
    #[serde(rename = "type")]
    pub r#type: crate::__types::assistants_named_tool_choice::Type,
    #[serde(rename = "function")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub function: Option<crate::__types::assistants_named_tool_choice::Function>,
}
#[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`. For `gpt-4o-transcribe` and `gpt-4o-mini-transcribe`, the only supported format is `json`.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum AudioResponseFormat {
    #[doc = "`json`"]
    #[default]
    #[serde(rename = "json")]
    Json,
    #[doc = "`text`"]
    #[serde(rename = "text")]
    Text,
    #[doc = "`srt`"]
    #[serde(rename = "srt")]
    Srt,
    #[doc = "`verbose_json`"]
    #[serde(rename = "verbose_json")]
    VerboseJson,
    #[doc = "`vtt`"]
    #[serde(rename = "vtt")]
    Vtt,
}
#[allow(clippy::module_inception)]
pub mod audit_log {
    #[doc = "The project that the action was scoped to. Absent for actions not scoped to projects. Note that any admin actions taken via Admin API keys are associated with the default project."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Project {
        #[doc = "The project ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The project title."]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod api_key_created {
        #[doc = "The payload used to create the API key."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Data {
            #[doc = "A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`"]
            #[serde(rename = "scopes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub scopes: Option<Vec<String>>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ApiKeyCreated {
        #[doc = "The tracking ID of the API key."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to create the API key."]
        #[serde(rename = "data")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub data: Option<crate::__types::audit_log::api_key_created::Data>,
    }
    #[allow(clippy::module_inception)]
    pub mod api_key_updated {
        #[doc = "The payload used to update the API key."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct ChangesRequested {
            #[doc = "A list of scopes allowed for the API key, e.g. `[\"api.model.request\"]`"]
            #[serde(rename = "scopes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub scopes: Option<Vec<String>>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ApiKeyUpdated {
        #[doc = "The tracking ID of the API key."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to update the API key."]
        #[serde(rename = "changes_requested")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub changes_requested: Option<crate::__types::audit_log::api_key_updated::ChangesRequested>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ApiKeyDeleted {
        #[doc = "The tracking ID of the API key."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod checkpoint_permission_created {
        #[doc = "The payload used to create the checkpoint permission."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Data {
            #[doc = "The ID of the project that the checkpoint permission was created for."]
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub project_id: Option<String>,
            #[doc = "The ID of the fine-tuned model checkpoint."]
            #[serde(rename = "fine_tuned_model_checkpoint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub fine_tuned_model_checkpoint: Option<String>,
        }
    }
    #[doc = "The project and fine-tuned model checkpoint that the checkpoint permission was created for."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CheckpointPermissionCreated {
        #[doc = "The ID of the checkpoint permission."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to create the checkpoint permission."]
        #[serde(rename = "data")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub data: Option<crate::__types::audit_log::checkpoint_permission_created::Data>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CheckpointPermissionDeleted {
        #[doc = "The ID of the checkpoint permission."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod invite_sent {
        #[doc = "The payload used to create the invite."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Data {
            #[doc = "The email invited to the organization."]
            #[serde(rename = "email")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub email: Option<String>,
            #[doc = "The role the email was invited to be. Is either `owner` or `member`."]
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub role: Option<String>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InviteSent {
        #[doc = "The ID of the invite."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to create the invite."]
        #[serde(rename = "data")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub data: Option<crate::__types::audit_log::invite_sent::Data>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InviteAccepted {
        #[doc = "The ID of the invite."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InviteDeleted {
        #[doc = "The ID of the invite."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct LoginFailed {
        #[doc = "The error code of the failure."]
        #[serde(rename = "error_code")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub error_code: Option<String>,
        #[doc = "The error message of the failure."]
        #[serde(rename = "error_message")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub error_message: Option<String>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct LogoutFailed {
        #[doc = "The error code of the failure."]
        #[serde(rename = "error_code")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub error_code: Option<String>,
        #[doc = "The error message of the failure."]
        #[serde(rename = "error_message")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub error_message: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod organization_updated {
        #[doc = "The payload used to update the organization settings."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct ChangesRequested {
            #[doc = "The organization title."]
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub title: Option<String>,
            #[doc = "The organization description."]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub description: Option<String>,
            #[doc = "The organization name."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub name: Option<String>,
            #[doc = "Visibility of the threads page which shows messages created with the Assistants API and Playground. One of `ANY_ROLE`, `OWNERS`, or `NONE`."]
            #[serde(rename = "threads_ui_visibility")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub threads_ui_visibility: Option<String>,
            #[doc = "Visibility of the usage dashboard which shows activity and costs for your organization. One of `ANY_ROLE` or `OWNERS`."]
            #[serde(rename = "usage_dashboard_visibility")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub usage_dashboard_visibility: Option<String>,
            #[doc = "How your organization logs data from supported API calls. One of `disabled`, `enabled_per_call`, `enabled_for_all_projects`, or `enabled_for_selected_projects`"]
            #[serde(rename = "api_call_logging")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub api_call_logging: Option<String>,
            #[doc = "The list of project ids if api_call_logging is set to `enabled_for_selected_projects`"]
            #[serde(rename = "api_call_logging_project_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub api_call_logging_project_ids: Option<String>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct OrganizationUpdated {
        #[doc = "The organization ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to update the organization settings."]
        #[serde(rename = "changes_requested")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub changes_requested:
            Option<crate::__types::audit_log::organization_updated::ChangesRequested>,
    }
    #[allow(clippy::module_inception)]
    pub mod project_created {
        #[doc = "The payload used to create the project."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Data {
            #[doc = "The project name."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub name: Option<String>,
            #[doc = "The title of the project as seen on the dashboard."]
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub title: Option<String>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ProjectCreated {
        #[doc = "The project ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to create the project."]
        #[serde(rename = "data")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub data: Option<crate::__types::audit_log::project_created::Data>,
    }
    #[allow(clippy::module_inception)]
    pub mod project_updated {
        #[doc = "The payload used to update the project."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct ChangesRequested {
            #[doc = "The title of the project as seen on the dashboard."]
            #[serde(rename = "title")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub title: Option<String>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ProjectUpdated {
        #[doc = "The project ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to update the project."]
        #[serde(rename = "changes_requested")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub changes_requested: Option<crate::__types::audit_log::project_updated::ChangesRequested>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ProjectArchived {
        #[doc = "The project ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod rate_limit_updated {
        #[doc = "The payload used to update the rate limits."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct ChangesRequested {
            #[doc = "The maximum requests per minute."]
            #[serde(rename = "max_requests_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub max_requests_per_1_minute: Option<i64>,
            #[doc = "The maximum tokens per minute."]
            #[serde(rename = "max_tokens_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub max_tokens_per_1_minute: Option<i64>,
            #[doc = "The maximum images per minute. Only relevant for certain models."]
            #[serde(rename = "max_images_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub max_images_per_1_minute: Option<i64>,
            #[doc = "The maximum audio megabytes per minute. Only relevant for certain models."]
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub max_audio_megabytes_per_1_minute: Option<i64>,
            #[doc = "The maximum requests per day. Only relevant for certain models."]
            #[serde(rename = "max_requests_per_1_day")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub max_requests_per_1_day: Option<i64>,
            #[doc = "The maximum batch input tokens per day. Only relevant for certain models."]
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub batch_1_day_max_input_tokens: Option<i64>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct RateLimitUpdated {
        #[doc = "The rate limit ID"]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to update the rate limits."]
        #[serde(rename = "changes_requested")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub changes_requested:
            Option<crate::__types::audit_log::rate_limit_updated::ChangesRequested>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct RateLimitDeleted {
        #[doc = "The rate limit ID"]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod service_account_created {
        #[doc = "The payload used to create the service account."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Data {
            #[doc = "The role of the service account. Is either `owner` or `member`."]
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub role: Option<String>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ServiceAccountCreated {
        #[doc = "The service account ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to create the service account."]
        #[serde(rename = "data")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub data: Option<crate::__types::audit_log::service_account_created::Data>,
    }
    #[allow(clippy::module_inception)]
    pub mod service_account_updated {
        #[doc = "The payload used to updated the service account."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct ChangesRequested {
            #[doc = "The role of the service account. Is either `owner` or `member`."]
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub role: Option<String>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ServiceAccountUpdated {
        #[doc = "The service account ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to updated the service account."]
        #[serde(rename = "changes_requested")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub changes_requested:
            Option<crate::__types::audit_log::service_account_updated::ChangesRequested>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ServiceAccountDeleted {
        #[doc = "The service account ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod user_added {
        #[doc = "The payload used to add the user to the project."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Data {
            #[doc = "The role of the user. Is either `owner` or `member`."]
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub role: Option<String>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct UserAdded {
        #[doc = "The user ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to add the user to the project."]
        #[serde(rename = "data")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub data: Option<crate::__types::audit_log::user_added::Data>,
    }
    #[allow(clippy::module_inception)]
    pub mod user_updated {
        #[doc = "The payload used to update the user."]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct ChangesRequested {
            #[doc = "The role of the user. Is either `owner` or `member`."]
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub role: Option<String>,
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct UserUpdated {
        #[doc = "The project ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The payload used to update the user."]
        #[serde(rename = "changes_requested")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub changes_requested: Option<crate::__types::audit_log::user_updated::ChangesRequested>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct UserDeleted {
        #[doc = "The user ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CertificateCreated {
        #[doc = "The certificate ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The name of the certificate."]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CertificateUpdated {
        #[doc = "The certificate ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The name of the certificate."]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CertificateDeleted {
        #[doc = "The certificate ID."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The name of the certificate."]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
        #[doc = "The certificate content in PEM format."]
        #[serde(rename = "certificate")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub certificate: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod certificates_activated {
        #[allow(clippy::module_inception)]
        pub mod certificates {
            #[derive(Clone, Debug, Default, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Item {
                #[doc = "The certificate ID."]
                #[serde(rename = "id")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub id: Option<String>,
                #[doc = "The name of the certificate."]
                #[serde(rename = "name")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub name: Option<String>,
            }
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CertificatesActivated {
        #[serde(rename = "certificates")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub certificates:
            Option<Vec<crate::__types::audit_log::certificates_activated::certificates::Item>>,
    }
    #[allow(clippy::module_inception)]
    pub mod certificates_deactivated {
        #[allow(clippy::module_inception)]
        pub mod certificates {
            #[derive(Clone, Debug, Default, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Item {
                #[doc = "The certificate ID."]
                #[serde(rename = "id")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub id: Option<String>,
                #[doc = "The name of the certificate."]
                #[serde(rename = "name")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub name: Option<String>,
            }
        }
    }
    #[doc = "The details for events with this `type`."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CertificatesDeactivated {
        #[serde(rename = "certificates")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub certificates:
            Option<Vec<crate::__types::audit_log::certificates_deactivated::certificates::Item>>,
    }
}
#[doc = "A log of a user action or configuration change within this organization."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct AuditLog {
    #[doc = "The ID of this log."]
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "type")]
    pub r#type: crate::__types::AuditLogEventType,
    #[doc = "The Unix timestamp (in seconds) of the event."]
    #[serde(rename = "effective_at")]
    pub effective_at: i64,
    #[doc = "The project that the action was scoped to. Absent for actions not scoped to projects. Note that any admin actions taken via Admin API keys are associated with the default project."]
    #[serde(rename = "project")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project: Option<crate::__types::audit_log::Project>,
    #[serde(rename = "actor")]
    #[builder(default)]
    pub actor: crate::__types::AuditLogActor,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "api_key.created")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub api_key_created: Option<crate::__types::audit_log::ApiKeyCreated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "api_key.updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub api_key_updated: Option<crate::__types::audit_log::ApiKeyUpdated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "api_key.deleted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub api_key_deleted: Option<crate::__types::audit_log::ApiKeyDeleted>,
    #[doc = "The project and fine-tuned model checkpoint that the checkpoint permission was created for."]
    #[serde(rename = "checkpoint_permission.created")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub checkpoint_permission_created:
        Option<crate::__types::audit_log::CheckpointPermissionCreated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "checkpoint_permission.deleted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub checkpoint_permission_deleted:
        Option<crate::__types::audit_log::CheckpointPermissionDeleted>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "invite.sent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub invite_sent: Option<crate::__types::audit_log::InviteSent>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "invite.accepted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub invite_accepted: Option<crate::__types::audit_log::InviteAccepted>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "invite.deleted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub invite_deleted: Option<crate::__types::audit_log::InviteDeleted>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "login.failed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub login_failed: Option<crate::__types::audit_log::LoginFailed>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "logout.failed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logout_failed: Option<crate::__types::audit_log::LogoutFailed>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "organization.updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub organization_updated: Option<crate::__types::audit_log::OrganizationUpdated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "project.created")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project_created: Option<crate::__types::audit_log::ProjectCreated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "project.updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project_updated: Option<crate::__types::audit_log::ProjectUpdated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "project.archived")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub project_archived: Option<crate::__types::audit_log::ProjectArchived>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "rate_limit.updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rate_limit_updated: Option<crate::__types::audit_log::RateLimitUpdated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "rate_limit.deleted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rate_limit_deleted: Option<crate::__types::audit_log::RateLimitDeleted>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "service_account.created")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service_account_created: Option<crate::__types::audit_log::ServiceAccountCreated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "service_account.updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service_account_updated: Option<crate::__types::audit_log::ServiceAccountUpdated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "service_account.deleted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service_account_deleted: Option<crate::__types::audit_log::ServiceAccountDeleted>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "user.added")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user_added: Option<crate::__types::audit_log::UserAdded>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "user.updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user_updated: Option<crate::__types::audit_log::UserUpdated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "user.deleted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user_deleted: Option<crate::__types::audit_log::UserDeleted>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "certificate.created")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub certificate_created: Option<crate::__types::audit_log::CertificateCreated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "certificate.updated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub certificate_updated: Option<crate::__types::audit_log::CertificateUpdated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "certificate.deleted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub certificate_deleted: Option<crate::__types::audit_log::CertificateDeleted>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "certificates.activated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub certificates_activated: Option<crate::__types::audit_log::CertificatesActivated>,
    #[doc = "The details for events with this `type`."]
    #[serde(rename = "certificates.deactivated")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub certificates_deactivated: Option<crate::__types::audit_log::CertificatesDeactivated>,
}
#[allow(clippy::module_inception)]
pub mod audit_log_actor {
    #[doc = "The type of actor. Is either `session` or `api_key`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`session`"]
        #[serde(rename = "session")]
        Session,
        #[doc = "`api_key`"]
        #[serde(rename = "api_key")]
        ApiKey,
    }
}
#[doc = "The actor who performed the audit logged action."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct AuditLogActor {
    #[doc = "The type of actor. Is either `session` or `api_key`."]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::audit_log_actor::Type>,
    #[serde(rename = "session")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub session: Option<crate::__types::AuditLogActorSession>,
    #[serde(rename = "api_key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub api_key: Option<crate::__types::AuditLogActorApiKey>,
}
#[allow(clippy::module_inception)]
pub mod audit_log_actor_api_key {
    #[doc = "The type of API key. Can be either `user` or `service_account`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`service_account`"]
        #[serde(rename = "service_account")]
        ServiceAccount,
    }
}
#[doc = "The API Key used to perform the audit logged action."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct AuditLogActorApiKey {
    #[doc = "The tracking id of the API key."]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of API key. Can be either `user` or `service_account`."]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::audit_log_actor_api_key::Type>,
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<crate::__types::AuditLogActorUser>,
    #[serde(rename = "service_account")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service_account: Option<crate::__types::AuditLogActorServiceAccount>,
}
#[doc = "The service account that performed the audit logged action."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct AuditLogActorServiceAccount {
    #[doc = "The service account id."]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
}
#[doc = "The session in which the audit logged action was performed."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct AuditLogActorSession {
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<crate::__types::AuditLogActorUser>,
    #[doc = "The IP address from which the action was performed."]
    #[serde(rename = "ip_address")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ip_address: Option<String>,
}
#[doc = "The user who performed the audit logged action."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct AuditLogActorUser {
    #[doc = "The user id."]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The user email."]
    #[serde(rename = "email")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub email: Option<String>,
}
#[doc = "The event type."]
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum AuditLogEventType {
    #[doc = "`api_key.created`"]
    #[serde(rename = "api_key.created")]
    ApiKeyCreated,
    #[doc = "`api_key.updated`"]
    #[serde(rename = "api_key.updated")]
    ApiKeyUpdated,
    #[doc = "`api_key.deleted`"]
    #[serde(rename = "api_key.deleted")]
    ApiKeyDeleted,
    #[doc = "`checkpoint_permission.created`"]
    #[serde(rename = "checkpoint_permission.created")]
    CheckpointPermissionCreated,
    #[doc = "`checkpoint_permission.deleted`"]
    #[serde(rename = "checkpoint_permission.deleted")]
    CheckpointPermissionDeleted,
    #[doc = "`invite.sent`"]
    #[serde(rename = "invite.sent")]
    InviteSent,
    #[doc = "`invite.accepted`"]
    #[serde(rename = "invite.accepted")]
    InviteAccepted,
    #[doc = "`invite.deleted`"]
    #[serde(rename = "invite.deleted")]
    InviteDeleted,
    #[doc = "`login.succeeded`"]
    #[serde(rename = "login.succeeded")]
    LoginSucceeded,
    #[doc = "`login.failed`"]
    #[serde(rename = "login.failed")]
    LoginFailed,
    #[doc = "`logout.succeeded`"]
    #[serde(rename = "logout.succeeded")]
    LogoutSucceeded,
    #[doc = "`logout.failed`"]
    #[serde(rename = "logout.failed")]
    LogoutFailed,
    #[doc = "`organization.updated`"]
    #[serde(rename = "organization.updated")]
    OrganizationUpdated,
    #[doc = "`project.created`"]
    #[serde(rename = "project.created")]
    ProjectCreated,
    #[doc = "`project.updated`"]
    #[serde(rename = "project.updated")]
    ProjectUpdated,
    #[doc = "`project.archived`"]
    #[serde(rename = "project.archived")]
    ProjectArchived,
    #[doc = "`service_account.created`"]
    #[serde(rename = "service_account.created")]
    ServiceAccountCreated,
    #[doc = "`service_account.updated`"]
    #[serde(rename = "service_account.updated")]
    ServiceAccountUpdated,
    #[doc = "`service_account.deleted`"]
    #[serde(rename = "service_account.deleted")]
    ServiceAccountDeleted,
    #[doc = "`rate_limit.updated`"]
    #[serde(rename = "rate_limit.updated")]
    RateLimitUpdated,
    #[doc = "`rate_limit.deleted`"]
    #[serde(rename = "rate_limit.deleted")]
    RateLimitDeleted,
    #[doc = "`user.added`"]
    #[serde(rename = "user.added")]
    UserAdded,
    #[doc = "`user.updated`"]
    #[serde(rename = "user.updated")]
    UserUpdated,
    #[doc = "`user.deleted`"]
    #[serde(rename = "user.deleted")]
    UserDeleted,
}
#[allow(clippy::module_inception)]
pub(crate) mod auto_chunking_strategy_request_param {
    #[doc = "Always `auto`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "auto");
}
#[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct AutoChunkingStrategyRequestParam {}
impl<'de> serde::Deserialize<'de> for AutoChunkingStrategyRequestParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct AutoChunkingStrategyRequestParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::auto_chunking_strategy_request_param::Type,
        }
        let AutoChunkingStrategyRequestParam { .. } =
            AutoChunkingStrategyRequestParam::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for AutoChunkingStrategyRequestParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct AutoChunkingStrategyRequestParam<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::auto_chunking_strategy_request_param::Type,
        }
        let Self {} = self;
        AutoChunkingStrategyRequestParam {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod batch {
    #[doc = "The object type, which is always `batch`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "batch");
    #[allow(clippy::module_inception)]
    pub mod errors {
        #[doc = "The object type, which is always `list`."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub struct Object;
        impl_serde!(Object, "list");
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Errors {
        #[doc = "The object type, which is always `list`."]
        #[serde(rename = "object")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub object: Option<crate::__types::batch::errors::Object>,
        #[serde(rename = "data")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub data: Option<Vec<crate::__types::BatchError>>,
    }
    #[doc = "The current status of the batch."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`validating`"]
        #[serde(rename = "validating")]
        Validating,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`finalizing`"]
        #[serde(rename = "finalizing")]
        Finalizing,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`expired`"]
        #[serde(rename = "expired")]
        Expired,
        #[doc = "`cancelling`"]
        #[serde(rename = "cancelling")]
        Cancelling,
        #[doc = "`cancelled`"]
        #[serde(rename = "cancelled")]
        Cancelled,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Batch {
    pub id: String,
    #[doc = "The OpenAI API endpoint used by the batch."]
    pub endpoint: String,
    #[builder(default)]
    pub errors: Option<crate::__types::batch::Errors>,
    #[doc = "The ID of the input file for the batch."]
    pub input_file_id: String,
    #[doc = "The time frame within which the batch should be processed."]
    pub completion_window: String,
    #[doc = "The current status of the batch."]
    pub status: crate::__types::batch::Status,
    #[doc = "The ID of the file containing the outputs of successfully executed requests."]
    #[builder(default)]
    pub output_file_id: Option<String>,
    #[doc = "The ID of the file containing the outputs of requests with errors."]
    #[builder(default)]
    pub error_file_id: Option<String>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was created."]
    pub created_at: i64,
    #[doc = "The Unix timestamp (in seconds) for when the batch started processing."]
    #[builder(default)]
    pub in_progress_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch will expire."]
    #[builder(default)]
    pub expires_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch started finalizing."]
    #[builder(default)]
    pub finalizing_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was completed."]
    #[builder(default)]
    pub completed_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch failed."]
    #[builder(default)]
    pub failed_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch expired."]
    #[builder(default)]
    pub expired_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch started cancelling."]
    #[builder(default)]
    pub cancelling_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the batch was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<i64>,
    #[builder(default)]
    pub request_counts: Option<crate::__types::BatchRequestCounts>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
impl<'de> serde::Deserialize<'de> for Batch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Batch {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::batch::Object,
            #[serde(rename = "endpoint")]
            endpoint: String,
            #[serde(rename = "errors")]
            errors: Option<crate::__types::batch::Errors>,
            #[serde(rename = "input_file_id")]
            input_file_id: String,
            #[serde(rename = "completion_window")]
            completion_window: String,
            #[serde(rename = "status")]
            status: crate::__types::batch::Status,
            #[serde(rename = "output_file_id")]
            output_file_id: Option<String>,
            #[serde(rename = "error_file_id")]
            error_file_id: Option<String>,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "in_progress_at")]
            in_progress_at: Option<i64>,
            #[serde(rename = "expires_at")]
            expires_at: Option<i64>,
            #[serde(rename = "finalizing_at")]
            finalizing_at: Option<i64>,
            #[serde(rename = "completed_at")]
            completed_at: Option<i64>,
            #[serde(rename = "failed_at")]
            failed_at: Option<i64>,
            #[serde(rename = "expired_at")]
            expired_at: Option<i64>,
            #[serde(rename = "cancelling_at")]
            cancelling_at: Option<i64>,
            #[serde(rename = "cancelled_at")]
            cancelled_at: Option<i64>,
            #[serde(rename = "request_counts")]
            request_counts: Option<crate::__types::BatchRequestCounts>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
        }
        let Batch {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
            ..
        } = Batch::deserialize(deserializer)?;
        Ok(Self {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        })
    }
}
impl serde::Serialize for Batch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Batch<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::batch::Object,
            #[serde(rename = "endpoint")]
            endpoint: &'a String,
            #[serde(rename = "errors")]
            #[serde(skip_serializing_if = "Option::is_none")]
            errors: &'a Option<crate::__types::batch::Errors>,
            #[serde(rename = "input_file_id")]
            input_file_id: &'a String,
            #[serde(rename = "completion_window")]
            completion_window: &'a String,
            #[serde(rename = "status")]
            status: &'a crate::__types::batch::Status,
            #[serde(rename = "output_file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_file_id: &'a Option<String>,
            #[serde(rename = "error_file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error_file_id: &'a Option<String>,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "in_progress_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            in_progress_at: &'a Option<i64>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<i64>,
            #[serde(rename = "finalizing_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            finalizing_at: &'a Option<i64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<i64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<i64>,
            #[serde(rename = "expired_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expired_at: &'a Option<i64>,
            #[serde(rename = "cancelling_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelling_at: &'a Option<i64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<i64>,
            #[serde(rename = "request_counts")]
            #[serde(skip_serializing_if = "Option::is_none")]
            request_counts: &'a Option<crate::__types::BatchRequestCounts>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
        }
        let Self {
            id,
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        } = self;
        Batch {
            id,
            object: &Default::default(),
            endpoint,
            errors,
            input_file_id,
            completion_window,
            status,
            output_file_id,
            error_file_id,
            created_at,
            in_progress_at,
            expires_at,
            finalizing_at,
            completed_at,
            failed_at,
            expired_at,
            cancelling_at,
            cancelled_at,
            request_counts,
            metadata,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod batch_file_expiration_after {
    #[doc = "Anchor timestamp after which the expiration policy applies. Supported anchors: `created_at`. Note that the anchor is the file creation time, not the time the batch is created."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Anchor;
    impl_serde!(Anchor, "created_at");
}
#[doc = "The expiration policy for the output and/or error file that are generated for a batch."]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct BatchFileExpirationAfter {
    #[doc = "The number of seconds after the anchor time that the file will expire. Must be between 3600 (1 hour) and 2592000 (30 days)."]
    pub seconds: i64,
}
impl<'de> serde::Deserialize<'de> for BatchFileExpirationAfter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct BatchFileExpirationAfter {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: crate::__types::batch_file_expiration_after::Anchor,
            #[serde(rename = "seconds")]
            seconds: i64,
        }
        let BatchFileExpirationAfter { seconds, .. } =
            BatchFileExpirationAfter::deserialize(deserializer)?;
        Ok(Self { seconds })
    }
}
impl serde::Serialize for BatchFileExpirationAfter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct BatchFileExpirationAfter<'a> {
            #[serde(rename = "anchor")]
            anchor: &'a crate::__types::batch_file_expiration_after::Anchor,
            #[serde(rename = "seconds")]
            seconds: &'a i64,
        }
        let Self { seconds } = self;
        BatchFileExpirationAfter {
            anchor: &Default::default(),
            seconds,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod batch_request_input {
    #[doc = "The HTTP method to be used for the request. Currently only `POST` is supported."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Method;
    impl_serde!(Method, "POST");
}
#[doc = "The per-line object of the batch input file"]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct BatchRequestInput {
    #[doc = "A developer-provided per-request id that will be used to match outputs to inputs. Must be unique for each request in a batch."]
    #[serde(rename = "custom_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub custom_id: Option<String>,
    #[doc = "The HTTP method to be used for the request. Currently only `POST` is supported."]
    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub method: Option<crate::__types::batch_request_input::Method>,
    #[doc = "The OpenAI API relative URL to be used for the request. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported."]
    #[serde(rename = "url")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub url: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod batch_request_output {
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Response {
        #[doc = "The HTTP status code of the response"]
        #[serde(rename = "status_code")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub status_code: Option<i64>,
        #[doc = "An unique identifier for the OpenAI API request. Please include this request ID when contacting support."]
        #[serde(rename = "request_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub request_id: Option<String>,
        #[doc = "The JSON body of the response"]
        #[serde(rename = "body")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub body: Option<indexmap::IndexMap<String, serde_json::Value>>,
    }
    #[doc = "For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Error {
        #[doc = "A machine-readable error code."]
        #[serde(rename = "code")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code: Option<String>,
        #[doc = "A human-readable error message."]
        #[serde(rename = "message")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub message: Option<String>,
    }
}
#[doc = "The per-line object of the batch output and error files"]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct BatchRequestOutput {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "A developer-provided per-request id that will be used to match outputs to inputs."]
    #[serde(rename = "custom_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub custom_id: Option<String>,
    #[serde(rename = "response")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response: Option<crate::__types::batch_request_output::Response>,
    #[doc = "For requests that failed with a non-HTTP error, this will contain more information on the cause of the failure."]
    #[serde(rename = "error")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub error: Option<crate::__types::batch_request_output::Error>,
}
#[allow(clippy::module_inception)]
pub mod certificate {
    #[doc = "The object type.\n\n- If creating, updating, or getting a specific certificate, the object type is `certificate`.\n- If listing, activating, or deactivating certificates for the organization, the object type is `organization.certificate`.\n- If listing, activating, or deactivating certificates for a project, the object type is `organization.project.certificate`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Object {
        #[doc = "`certificate`"]
        #[serde(rename = "certificate")]
        Certificate,
        #[doc = "`organization.certificate`"]
        #[serde(rename = "organization.certificate")]
        OrganizationCertificate,
        #[doc = "`organization.project.certificate`"]
        #[serde(rename = "organization.project.certificate")]
        OrganizationProjectCertificate,
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CertificateDetails {
        #[doc = "The Unix timestamp (in seconds) of when the certificate becomes valid."]
        #[serde(rename = "valid_at")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub valid_at: Option<i64>,
        #[doc = "The Unix timestamp (in seconds) of when the certificate expires."]
        #[serde(rename = "expires_at")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub expires_at: Option<i64>,
        #[doc = "The content of the certificate in PEM format."]
        #[serde(rename = "content")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub content: Option<String>,
    }
}
#[doc = "Represents an individual `certificate` uploaded to the organization."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct Certificate {
    #[doc = "The object type.\n\n- If creating, updating, or getting a specific certificate, the object type is `certificate`.\n- If listing, activating, or deactivating certificates for the organization, the object type is `organization.certificate`.\n- If listing, activating, or deactivating certificates for a project, the object type is `organization.project.certificate`.\n"]
    #[serde(rename = "object")]
    pub object: crate::__types::certificate::Object,
    #[doc = "The identifier, which can be referenced in API endpoints"]
    #[serde(rename = "id")]
    pub id: String,
    #[doc = "The name of the certificate."]
    #[serde(rename = "name")]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the certificate was uploaded."]
    #[serde(rename = "created_at")]
    pub created_at: i64,
    #[serde(rename = "certificate_details")]
    #[builder(default)]
    pub certificate_details: crate::__types::certificate::CertificateDetails,
    #[doc = "Whether the certificate is currently active at the specified scope. Not returned when getting details for a specific certificate."]
    #[serde(rename = "active")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub active: Option<bool>,
}
#[allow(clippy::module_inception)]
pub mod chat_completion_allowed_tools {
    #[doc = "Constrains the tools available to the model to a pre-defined set.\n\n`auto` allows the model to pick from among the allowed tools and generate a\nmessage.\n\n`required` requires the model to call one or more of the allowed tools.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Mode {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`required`"]
        #[serde(rename = "required")]
        Required,
    }
}
#[doc = "Constrains the tools available to the model to a pre-defined set.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ChatCompletionAllowedTools {
    #[doc = "Constrains the tools available to the model to a pre-defined set.\n\n`auto` allows the model to pick from among the allowed tools and generate a\nmessage.\n\n`required` requires the model to call one or more of the allowed tools.\n"]
    #[serde(rename = "mode")]
    pub mode: crate::__types::chat_completion_allowed_tools::Mode,
    #[doc = "A list of tool definitions that the model should be allowed to call.\n\nFor the Chat Completions API, the list of tool definitions might look like:\n```json\n[\n  { \"type\": \"function\", \"function\": { \"name\": \"get_weather\" } },\n  { \"type\": \"function\", \"function\": { \"name\": \"get_time\" } }\n]\n```text\n"]
    #[serde(rename = "tools")]
    pub tools: Vec<indexmap::IndexMap<String, serde_json::Value>>,
}
#[allow(clippy::module_inception)]
pub(crate) mod chat_completion_allowed_tools_choice {
    #[doc = "Allowed tool configuration type. Always `allowed_tools`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "allowed_tools");
}
#[doc = "Constrains the tools available to the model to a pre-defined set.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionAllowedToolsChoice {
    pub allowed_tools: crate::__types::ChatCompletionAllowedTools,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionAllowedToolsChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionAllowedToolsChoice {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_allowed_tools_choice::Type,
            #[serde(rename = "allowed_tools")]
            allowed_tools: crate::__types::ChatCompletionAllowedTools,
        }
        let ChatCompletionAllowedToolsChoice { allowed_tools, .. } =
            ChatCompletionAllowedToolsChoice::deserialize(deserializer)?;
        Ok(Self { allowed_tools })
    }
}
impl serde::Serialize for ChatCompletionAllowedToolsChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionAllowedToolsChoice<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_allowed_tools_choice::Type,
            #[serde(rename = "allowed_tools")]
            allowed_tools: &'a crate::__types::ChatCompletionAllowedTools,
        }
        let Self { allowed_tools } = self;
        ChatCompletionAllowedToolsChoice {
            r#type: &Default::default(),
            allowed_tools,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod chat_completion_deleted {
    #[doc = "The type of object being deleted."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "chat.completion.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionDeleted {
    #[doc = "The ID of the chat completion that was deleted."]
    pub id: String,
    #[doc = "Whether the chat completion was deleted."]
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionDeleted {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::chat_completion_deleted::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
        }
        let ChatCompletionDeleted { id, deleted, .. } =
            ChatCompletionDeleted::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for ChatCompletionDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionDeleted<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::chat_completion_deleted::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        ChatCompletionDeleted {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[doc = "Specifying a particular function via `{\"name\": \"my_function\"}` forces the model to call that function.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ChatCompletionFunctionCallOption {
    #[doc = "The name of the function to call."]
    #[serde(rename = "name")]
    pub name: String,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ChatCompletionFunctions {
    #[doc = "A description of what the function does, used by the model to choose when and how to call the function."]
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."]
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parameters: Option<crate::__types::FunctionParameters>,
}
#[allow(clippy::module_inception)]
pub(crate) mod chat_completion_list {
    #[doc = "The type of this object. It is always set to \"list\".\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[doc = "An object representing a list of Chat Completions.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionList {
    #[doc = "An array of chat completion objects.\n"]
    pub data: Vec<crate::__types::CreateChatCompletionResponse>,
    #[doc = "The identifier of the first chat completion in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last chat completion in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more Chat Completions available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::chat_completion_list::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::CreateChatCompletionResponse>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ChatCompletionList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ChatCompletionList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ChatCompletionList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionList<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::chat_completion_list::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::CreateChatCompletionResponse>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ChatCompletionList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_message_custom_tool_call {
    #[doc = "The type of the tool. Always `custom`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom");
    #[doc = "The custom tool that the model called."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Custom {
        #[doc = "The name of the custom tool to call."]
        #[serde(rename = "name")]
        pub name: String,
        #[doc = "The input for the custom tool call generated by the model."]
        #[serde(rename = "input")]
        pub input: String,
    }
}
#[doc = "A call to a custom tool created by the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageCustomToolCall {
    #[doc = "The ID of the tool call."]
    pub id: String,
    #[doc = "The custom tool that the model called."]
    pub custom: crate::__types::chat_completion_message_custom_tool_call::Custom,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageCustomToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageCustomToolCall {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_message_custom_tool_call::Type,
            #[serde(rename = "custom")]
            custom: crate::__types::chat_completion_message_custom_tool_call::Custom,
        }
        let ChatCompletionMessageCustomToolCall { id, custom, .. } =
            ChatCompletionMessageCustomToolCall::deserialize(deserializer)?;
        Ok(Self { id, custom })
    }
}
impl serde::Serialize for ChatCompletionMessageCustomToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageCustomToolCall<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_message_custom_tool_call::Type,
            #[serde(rename = "custom")]
            custom: &'a crate::__types::chat_completion_message_custom_tool_call::Custom,
        }
        let Self { id, custom } = self;
        ChatCompletionMessageCustomToolCall {
            id,
            r#type: &Default::default(),
            custom,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_message_list {
    #[doc = "The type of this object. It is always set to \"list\".\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
    #[allow(clippy::module_inception)]
    pub mod data {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[allow(clippy::module_inception)]
            pub mod annotations {
                #[allow(clippy::module_inception)]
                pub mod item {
                    #[doc = "The type of the URL citation. Always `url_citation`."]
                    #[derive(Clone, Copy, Debug, Default, PartialEq)]
                    pub(crate) struct Type;
                    impl_serde!(Type, "url_citation");
                    #[doc = "A URL citation when using web search."]
                    #[derive(Clone, Debug, PartialEq)]
                    #[serde_with::serde_as]
                    #[derive(
                        serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder,
                    )]
                    pub struct UrlCitation {
                        #[doc = "The index of the last character of the URL citation in the message."]
                        #[serde(rename = "end_index")]
                        pub end_index: i64,
                        #[doc = "The index of the first character of the URL citation in the message."]
                        #[serde(rename = "start_index")]
                        pub start_index: i64,
                        #[doc = "The URL of the web resource."]
                        #[serde(rename = "url")]
                        pub url: String,
                        #[doc = "The title of the web resource."]
                        #[serde(rename = "title")]
                        pub title: String,
                    }
                }
                #[doc = "A URL citation when using web search.\n"]
                #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
                pub struct Item { # [doc = "A URL citation when using web search."] pub url_citation : crate :: __types :: chat_completion_message_list :: data :: item :: annotations :: item :: UrlCitation }
                impl<'de> serde::Deserialize<'de> for Item {
                    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        #[serde_with::serde_as]
                        #[derive(serde :: Deserialize)]
                        struct Item { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: chat_completion_message_list :: data :: item :: annotations :: item :: Type , # [serde (rename = "url_citation")] url_citation : crate :: __types :: chat_completion_message_list :: data :: item :: annotations :: item :: UrlCitation }
                        let Item { url_citation, .. } = Item::deserialize(deserializer)?;
                        Ok(Self { url_citation })
                    }
                }
                impl serde::Serialize for Item {
                    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                    where
                        S: serde::Serializer,
                    {
                        #[serde_with::serde_as]
                        #[derive(serde :: Serialize)]
                        struct Item < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: chat_completion_message_list :: data :: item :: annotations :: item :: Type , # [serde (rename = "url_citation")] url_citation : & 'a crate :: __types :: chat_completion_message_list :: data :: item :: annotations :: item :: UrlCitation }
                        let Self { url_citation } = self;
                        Item {
                            r#type: &Default::default(),
                            url_citation,
                        }
                        .serialize(serializer)
                    }
                }
            }
            #[doc = "The role of the author of this message."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Role;
            impl_serde!(Role, "assistant");
            #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct FunctionCall {
                #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
                #[serde(rename = "arguments")]
                pub arguments: String,
                #[doc = "The name of the function to call."]
                #[serde(rename = "name")]
                pub name: String,
            }
            #[doc = "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Audio {
                #[doc = "Unique identifier for this audio response."]
                #[serde(rename = "id")]
                pub id: String,
                #[doc = "The Unix timestamp (in seconds) for when this audio response will\nno longer be accessible on the server for use in multi-turn\nconversations.\n"]
                #[serde(rename = "expires_at")]
                pub expires_at: i64,
                #[doc = "Base64 encoded audio bytes generated by the model, in the format\nspecified in the request.\n"]
                #[serde(rename = "data")]
                pub data: String,
                #[doc = "Transcript of the audio generated by the model."]
                #[serde(rename = "transcript")]
                pub transcript: String,
            }
            #[allow(clippy::module_inception)]
            pub mod content_parts {
                #[derive(Clone, Debug, PartialEq)]
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize, serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::large_enum_variant)]
                pub enum Item {
                    Text(crate::__types::ChatCompletionRequestMessageContentPartText),
                    ImageUrl(crate::__types::ChatCompletionRequestMessageContentPartImage),
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The contents of the message."]
            #[builder(default)]
            pub content: Option<String>,
            #[doc = "The refusal message generated by the model."]
            #[builder(default)]
            pub refusal: Option<String>,
            #[builder(default)]
            pub tool_calls: Option<crate::__types::ChatCompletionMessageToolCalls>,
            #[doc = "Annotations for the message, when applicable, as when using the\n[web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\n"]
            #[builder(default)]
            pub annotations: Option<
                Vec<crate::__types::chat_completion_message_list::data::item::annotations::Item>,
            >,
            #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
            #[builder(default)]
            pub function_call:
                Option<crate::__types::chat_completion_message_list::data::item::FunctionCall>,
            #[doc = "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
            #[builder(default)]
            pub audio: Option<crate::__types::chat_completion_message_list::data::item::Audio>,
            #[doc = "The identifier of the chat message."]
            pub id: String,
            #[doc = "If a content parts array was provided, this is an array of `text` and `image_url` parts. \nOtherwise, null.\n"]
            #[builder(default)]
            pub content_parts: Option<
                Vec<crate::__types::chat_completion_message_list::data::item::content_parts::Item>,
            >,
        }
        impl<'de> serde::Deserialize<'de> for Item {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct Item { # [serde (rename = "content")] content : Option < String > , # [serde (rename = "refusal")] refusal : Option < String > , # [serde (rename = "tool_calls")] tool_calls : Option < crate :: __types :: ChatCompletionMessageToolCalls > , # [serde (rename = "annotations")] annotations : Option < Vec < crate :: __types :: chat_completion_message_list :: data :: item :: annotations :: Item > > , # [serde (rename = "role")] # [allow (dead_code)] role : crate :: __types :: chat_completion_message_list :: data :: item :: Role , # [serde (rename = "function_call")] function_call : Option < crate :: __types :: chat_completion_message_list :: data :: item :: FunctionCall > , # [serde (rename = "audio")] audio : Option < crate :: __types :: chat_completion_message_list :: data :: item :: Audio > , # [serde (rename = "id")] id : String , # [serde (rename = "content_parts")] content_parts : Option < Vec < crate :: __types :: chat_completion_message_list :: data :: item :: content_parts :: Item > > }
                let Item {
                    content,
                    refusal,
                    tool_calls,
                    annotations,
                    function_call,
                    audio,
                    id,
                    content_parts,
                    ..
                } = Item::deserialize(deserializer)?;
                Ok(Self {
                    content,
                    refusal,
                    tool_calls,
                    annotations,
                    function_call,
                    audio,
                    id,
                    content_parts,
                })
            }
        }
        impl serde::Serialize for Item {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct Item < 'a > { # [serde (rename = "content")] # [serde (skip_serializing_if = "Option::is_none")] content : & 'a Option < String > , # [serde (rename = "refusal")] # [serde (skip_serializing_if = "Option::is_none")] refusal : & 'a Option < String > , # [serde (rename = "tool_calls")] # [serde (skip_serializing_if = "Option::is_none")] tool_calls : & 'a Option < crate :: __types :: ChatCompletionMessageToolCalls > , # [serde (rename = "annotations")] # [serde (skip_serializing_if = "Option::is_none")] annotations : & 'a Option < Vec < crate :: __types :: chat_completion_message_list :: data :: item :: annotations :: Item > > , # [serde (rename = "role")] role : & 'a crate :: __types :: chat_completion_message_list :: data :: item :: Role , # [serde (rename = "function_call")] # [serde (skip_serializing_if = "Option::is_none")] function_call : & 'a Option < crate :: __types :: chat_completion_message_list :: data :: item :: FunctionCall > , # [serde (rename = "audio")] # [serde (skip_serializing_if = "Option::is_none")] audio : & 'a Option < crate :: __types :: chat_completion_message_list :: data :: item :: Audio > , # [serde (rename = "id")] id : & 'a String , # [serde (rename = "content_parts")] # [serde (skip_serializing_if = "Option::is_none")] content_parts : & 'a Option < Vec < crate :: __types :: chat_completion_message_list :: data :: item :: content_parts :: Item > > }
                let Self {
                    content,
                    refusal,
                    tool_calls,
                    annotations,
                    function_call,
                    audio,
                    id,
                    content_parts,
                } = self;
                Item {
                    content,
                    refusal,
                    tool_calls,
                    annotations,
                    role: &Default::default(),
                    function_call,
                    audio,
                    id,
                    content_parts,
                }
                .serialize(serializer)
            }
        }
    }
}
#[doc = "An object representing a list of chat completion messages.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageList {
    #[doc = "An array of chat completion message objects.\n"]
    pub data: Vec<crate::__types::chat_completion_message_list::data::Item>,
    #[doc = "The identifier of the first chat message in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last chat message in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more chat messages available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::chat_completion_message_list::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::chat_completion_message_list::data::Item>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ChatCompletionMessageList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ChatCompletionMessageList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ChatCompletionMessageList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageList<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::chat_completion_message_list::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::chat_completion_message_list::data::Item>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ChatCompletionMessageList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_message_tool_call {
    #[doc = "The type of the tool. Currently, only `function` is supported."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
    #[doc = "The function that the model called."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Function {
        #[doc = "The name of the function to call."]
        #[serde(rename = "name")]
        pub name: String,
        #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
        #[serde(rename = "arguments")]
        pub arguments: String,
    }
}
#[doc = "A call to a function tool created by the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCall {
    #[doc = "The ID of the tool call."]
    pub id: String,
    #[doc = "The function that the model called."]
    pub function: crate::__types::chat_completion_message_tool_call::Function,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionMessageToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionMessageToolCall {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_message_tool_call::Type,
            #[serde(rename = "function")]
            function: crate::__types::chat_completion_message_tool_call::Function,
        }
        let ChatCompletionMessageToolCall { id, function, .. } =
            ChatCompletionMessageToolCall::deserialize(deserializer)?;
        Ok(Self { id, function })
    }
}
impl serde::Serialize for ChatCompletionMessageToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionMessageToolCall<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_message_tool_call::Type,
            #[serde(rename = "function")]
            function: &'a crate::__types::chat_completion_message_tool_call::Function,
        }
        let Self { id, function } = self;
        ChatCompletionMessageToolCall {
            id,
            r#type: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_message_tool_call_chunk {
    #[doc = "The type of the tool. Currently, only `function` is supported."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Type;
    impl_serde!(Type, "function");
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Function {
        #[doc = "The name of the function to call."]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
        #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
        #[serde(rename = "arguments")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub arguments: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ChatCompletionMessageToolCallChunk {
    #[serde(rename = "index")]
    pub index: i64,
    #[doc = "The ID of the tool call."]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the tool. Currently, only `function` is supported."]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::chat_completion_message_tool_call_chunk::Type>,
    #[serde(rename = "function")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub function: Option<crate::__types::chat_completion_message_tool_call_chunk::Function>,
}
#[allow(clippy::module_inception)]
pub mod chat_completion_message_tool_calls {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Item {
        Function(crate::__types::ChatCompletionMessageToolCall),
        Custom(crate::__types::ChatCompletionMessageCustomToolCall),
    }
}
#[doc = "The tool calls generated by the model, such as function calls."]
pub type ChatCompletionMessageToolCalls =
    Vec<crate::__types::chat_completion_message_tool_calls::Item>;
#[allow(clippy::module_inception)]
pub mod chat_completion_modalities {
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Item {
        #[doc = "`text`"]
        #[serde(rename = "text")]
        Text,
        #[doc = "`audio`"]
        #[serde(rename = "audio")]
        Audio,
    }
}
#[doc = "Output types that you would like the model to generate for this request.\nMost models are capable of generating text, which is the default:\n\n`[\"text\"]`\n\nThe `gpt-4o-audio-preview` model can also be used to [generate audio](https://platform.openai.com/docs/guides/audio). To\nrequest that this model generate both text and audio responses, you can\nuse:\n\n`[\"text\", \"audio\"]`\n"]
pub type ChatCompletionModalities = Vec<crate::__types::chat_completion_modalities::Item>;
#[allow(clippy::module_inception)]
pub mod chat_completion_named_tool_choice {
    #[doc = "For function calling, the type is always `function`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Function {
        #[doc = "The name of the function to call."]
        #[serde(rename = "name")]
        pub name: String,
    }
}
#[doc = "Specifies a tool the model should use. Use to force the model to call a specific function."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionNamedToolChoice {
    pub function: crate::__types::chat_completion_named_tool_choice::Function,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionNamedToolChoice {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionNamedToolChoice {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_named_tool_choice::Type,
            #[serde(rename = "function")]
            function: crate::__types::chat_completion_named_tool_choice::Function,
        }
        let ChatCompletionNamedToolChoice { function, .. } =
            ChatCompletionNamedToolChoice::deserialize(deserializer)?;
        Ok(Self { function })
    }
}
impl serde::Serialize for ChatCompletionNamedToolChoice {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionNamedToolChoice<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_named_tool_choice::Type,
            #[serde(rename = "function")]
            function: &'a crate::__types::chat_completion_named_tool_choice::Function,
        }
        let Self { function } = self;
        ChatCompletionNamedToolChoice {
            r#type: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_named_tool_choice_custom {
    #[doc = "For custom tool calling, the type is always `custom`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom");
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Custom {
        #[doc = "The name of the custom tool to call."]
        #[serde(rename = "name")]
        pub name: String,
    }
}
#[doc = "Specifies a tool the model should use. Use to force the model to call a specific custom tool."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionNamedToolChoiceCustom {
    pub custom: crate::__types::chat_completion_named_tool_choice_custom::Custom,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionNamedToolChoiceCustom {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionNamedToolChoiceCustom {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_named_tool_choice_custom::Type,
            #[serde(rename = "custom")]
            custom: crate::__types::chat_completion_named_tool_choice_custom::Custom,
        }
        let ChatCompletionNamedToolChoiceCustom { custom, .. } =
            ChatCompletionNamedToolChoiceCustom::deserialize(deserializer)?;
        Ok(Self { custom })
    }
}
impl serde::Serialize for ChatCompletionNamedToolChoiceCustom {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionNamedToolChoiceCustom<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_named_tool_choice_custom::Type,
            #[serde(rename = "custom")]
            custom: &'a crate::__types::chat_completion_named_tool_choice_custom::Custom,
        }
        let Self { custom } = self;
        ChatCompletionNamedToolChoiceCustom {
            r#type: &Default::default(),
            custom,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_request_assistant_message {
    #[doc = "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "The contents of the assistant message."]
        String(String),
        #[doc = "An array of content parts with a defined type. Can be one or more of type `text`, or exactly one of type `refusal`."]
        Array(Vec<crate::__types::ChatCompletionRequestAssistantMessageContentPart>),
    }
    #[doc = "The role of the messages author, in this case `assistant`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "assistant");
    #[doc = "Data about a previous audio response from the model. \n[Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Audio {
        #[doc = "Unique identifier for a previous audio response from the model.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FunctionCall {
        #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
        #[serde(rename = "arguments")]
        pub arguments: String,
        #[doc = "The name of the function to call."]
        #[serde(rename = "name")]
        pub name: String,
    }
}
#[doc = "Messages sent by the model in response to user messages.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestAssistantMessage {
    #[doc = "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"]
    #[builder(default)]
    pub content: Option<crate::__types::chat_completion_request_assistant_message::Content>,
    #[doc = "The refusal message by the assistant."]
    #[builder(default)]
    pub refusal: Option<String>,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "Data about a previous audio response from the model. \n[Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<crate::__types::chat_completion_request_assistant_message::Audio>,
    #[builder(default)]
    pub tool_calls: Option<crate::__types::ChatCompletionMessageToolCalls>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call:
        Option<crate::__types::chat_completion_request_assistant_message::FunctionCall>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestAssistantMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestAssistantMessage {
            #[serde(rename = "content")]
            content: Option<crate::__types::chat_completion_request_assistant_message::Content>,
            #[serde(rename = "refusal")]
            refusal: Option<String>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::chat_completion_request_assistant_message::Role,
            #[serde(rename = "name")]
            name: Option<String>,
            #[serde(rename = "audio")]
            audio: Option<crate::__types::chat_completion_request_assistant_message::Audio>,
            #[serde(rename = "tool_calls")]
            tool_calls: Option<crate::__types::ChatCompletionMessageToolCalls>,
            #[serde(rename = "function_call")]
            function_call:
                Option<crate::__types::chat_completion_request_assistant_message::FunctionCall>,
        }
        let ChatCompletionRequestAssistantMessage {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
            ..
        } = ChatCompletionRequestAssistantMessage::deserialize(deserializer)?;
        Ok(Self {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestAssistantMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestAssistantMessage<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<crate::__types::chat_completion_request_assistant_message::Content>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
            #[serde(rename = "role")]
            role: &'a crate::__types::chat_completion_request_assistant_message::Role,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<crate::__types::chat_completion_request_assistant_message::Audio>,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<crate::__types::ChatCompletionMessageToolCalls>,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call:
                &'a Option<crate::__types::chat_completion_request_assistant_message::FunctionCall>,
        }
        let Self {
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
        } = self;
        ChatCompletionRequestAssistantMessage {
            content,
            refusal,
            role: &Default::default(),
            name,
            audio,
            tool_calls,
            function_call,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestAssistantMessageContentPart {
    Text(crate::__types::ChatCompletionRequestMessageContentPartText),
    Refusal(crate::__types::ChatCompletionRequestMessageContentPartRefusal),
}
#[allow(clippy::module_inception)]
pub mod chat_completion_request_developer_message {
    #[doc = "The contents of the developer message."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "The contents of the developer message."]
        String(String),
        #[doc = "An array of content parts with a defined type. For developer messages, only type `text` is supported."]
        Array(Vec<crate::__types::ChatCompletionRequestMessageContentPartText>),
    }
    #[doc = "The role of the messages author, in this case `developer`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "developer");
}
#[doc = "Developer-provided instructions that the model should follow, regardless of\nmessages sent by the user. With o1 models and newer, `developer` messages\nreplace the previous `system` messages.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestDeveloperMessage {
    #[doc = "The contents of the developer message."]
    pub content: crate::__types::chat_completion_request_developer_message::Content,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestDeveloperMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestDeveloperMessage {
            #[serde(rename = "content")]
            content: crate::__types::chat_completion_request_developer_message::Content,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::chat_completion_request_developer_message::Role,
            #[serde(rename = "name")]
            name: Option<String>,
        }
        let ChatCompletionRequestDeveloperMessage { content, name, .. } =
            ChatCompletionRequestDeveloperMessage::deserialize(deserializer)?;
        Ok(Self { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestDeveloperMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestDeveloperMessage<'a> {
            #[serde(rename = "content")]
            content: &'a crate::__types::chat_completion_request_developer_message::Content,
            #[serde(rename = "role")]
            role: &'a crate::__types::chat_completion_request_developer_message::Role,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { content, name } = self;
        ChatCompletionRequestDeveloperMessage {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod chat_completion_request_function_message {
    #[doc = "The role of the messages author, in this case `function`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "function");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestFunctionMessage {
    #[doc = "The contents of the function message."]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestFunctionMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestFunctionMessage {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::chat_completion_request_function_message::Role,
            #[serde(rename = "content")]
            content: Option<String>,
            #[serde(rename = "name")]
            name: String,
        }
        let ChatCompletionRequestFunctionMessage { content, name, .. } =
            ChatCompletionRequestFunctionMessage::deserialize(deserializer)?;
        Ok(Self { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestFunctionMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestFunctionMessage<'a> {
            #[serde(rename = "role")]
            role: &'a crate::__types::chat_completion_request_function_message::Role,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { content, name } = self;
        ChatCompletionRequestFunctionMessage {
            role: &Default::default(),
            content,
            name,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestMessage {
    Developer(crate::__types::ChatCompletionRequestDeveloperMessage),
    System(crate::__types::ChatCompletionRequestSystemMessage),
    User(crate::__types::ChatCompletionRequestUserMessage),
    Assistant(crate::__types::ChatCompletionRequestAssistantMessage),
    Tool(crate::__types::ChatCompletionRequestToolMessage),
    Function(crate::__types::ChatCompletionRequestFunctionMessage),
}
#[allow(clippy::module_inception)]
pub mod chat_completion_request_message_content_part_audio {
    #[doc = "The type of the content part. Always `input_audio`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio");
    #[allow(clippy::module_inception)]
    pub mod input_audio {
        #[doc = "The format of the encoded audio data. Currently supports \"wav\" and \"mp3\".\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Format {
            #[doc = "`wav`"]
            #[serde(rename = "wav")]
            Wav,
            #[doc = "`mp3`"]
            #[serde(rename = "mp3")]
            Mp3,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudio {
        #[doc = "Base64 encoded audio data."]
        #[serde(rename = "data")]
        pub data: String,
        #[doc = "The format of the encoded audio data. Currently supports \"wav\" and \"mp3\".\n"]
        #[serde(rename = "format")]
        pub format:
            crate::__types::chat_completion_request_message_content_part_audio::input_audio::Format,
    }
}
#[doc = "Learn about [audio inputs](https://platform.openai.com/docs/guides/audio).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartAudio {
    pub input_audio: crate::__types::chat_completion_request_message_content_part_audio::InputAudio,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartAudio {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_request_message_content_part_audio::Type,
            #[serde(rename = "input_audio")]
            input_audio:
                crate::__types::chat_completion_request_message_content_part_audio::InputAudio,
        }
        let ChatCompletionRequestMessageContentPartAudio { input_audio, .. } =
            ChatCompletionRequestMessageContentPartAudio::deserialize(deserializer)?;
        Ok(Self { input_audio })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartAudio<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_request_message_content_part_audio::Type,
            #[serde(rename = "input_audio")]
            input_audio:
                &'a crate::__types::chat_completion_request_message_content_part_audio::InputAudio,
        }
        let Self { input_audio } = self;
        ChatCompletionRequestMessageContentPartAudio {
            r#type: &Default::default(),
            input_audio,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_request_message_content_part_file {
    #[doc = "The type of the content part. Always `file`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file");
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct File {
        #[doc = "The name of the file, used when passing the file to the model as a \nstring.\n"]
        #[serde(rename = "filename")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub filename: Option<String>,
        #[doc = "The base64 encoded file data, used when passing the file to the model \nas a string.\n"]
        #[serde(rename = "file_data")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_data: Option<String>,
        #[doc = "The ID of an uploaded file to use as input.\n"]
        #[serde(rename = "file_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_id: Option<String>,
    }
}
#[doc = "Learn about [file inputs](https://platform.openai.com/docs/guides/text) for text generation.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartFile {
    #[builder(default)]
    pub file: crate::__types::chat_completion_request_message_content_part_file::File,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartFile {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_request_message_content_part_file::Type,
            #[serde(rename = "file")]
            file: crate::__types::chat_completion_request_message_content_part_file::File,
        }
        let ChatCompletionRequestMessageContentPartFile { file, .. } =
            ChatCompletionRequestMessageContentPartFile::deserialize(deserializer)?;
        Ok(Self { file })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartFile<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_request_message_content_part_file::Type,
            #[serde(rename = "file")]
            file: &'a crate::__types::chat_completion_request_message_content_part_file::File,
        }
        let Self { file } = self;
        ChatCompletionRequestMessageContentPartFile {
            r#type: &Default::default(),
            file,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_request_message_content_part_image {
    #[doc = "The type of the content part."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_url");
    #[allow(clippy::module_inception)]
    pub mod image_url {
        #[doc = "Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding)."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Detail {
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
            #[doc = "`low`"]
            #[serde(rename = "low")]
            Low,
            #[doc = "`high`"]
            #[serde(rename = "high")]
            High,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ImageUrl {
        #[doc = "Either a URL of the image or the base64 encoded image data."]
        #[serde(rename = "url")]
        pub url: String,
        #[doc = "Specifies the detail level of the image. Learn more in the [Vision guide](https://platform.openai.com/docs/guides/vision#low-or-high-fidelity-image-understanding)."]
        #[serde(rename = "detail")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub detail: Option<
            crate::__types::chat_completion_request_message_content_part_image::image_url::Detail,
        >,
    }
}
#[doc = "Learn about [image inputs](https://platform.openai.com/docs/guides/vision).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartImage {
    pub image_url: crate::__types::chat_completion_request_message_content_part_image::ImageUrl,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartImage {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_request_message_content_part_image::Type,
            #[serde(rename = "image_url")]
            image_url: crate::__types::chat_completion_request_message_content_part_image::ImageUrl,
        }
        let ChatCompletionRequestMessageContentPartImage { image_url, .. } =
            ChatCompletionRequestMessageContentPartImage::deserialize(deserializer)?;
        Ok(Self { image_url })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartImage<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_request_message_content_part_image::Type,
            #[serde(rename = "image_url")]
            image_url:
                &'a crate::__types::chat_completion_request_message_content_part_image::ImageUrl,
        }
        let Self { image_url } = self;
        ChatCompletionRequestMessageContentPartImage {
            r#type: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod chat_completion_request_message_content_part_refusal {
    #[doc = "The type of the content part."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "refusal");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartRefusal {
    #[doc = "The refusal message generated by the model."]
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartRefusal {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartRefusal {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_request_message_content_part_refusal::Type,
            #[serde(rename = "refusal")]
            refusal: String,
        }
        let ChatCompletionRequestMessageContentPartRefusal { refusal, .. } =
            ChatCompletionRequestMessageContentPartRefusal::deserialize(deserializer)?;
        Ok(Self { refusal })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartRefusal {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartRefusal<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_request_message_content_part_refusal::Type,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let Self { refusal } = self;
        ChatCompletionRequestMessageContentPartRefusal {
            r#type: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod chat_completion_request_message_content_part_text {
    #[doc = "The type of the content part."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "text");
}
#[doc = "Learn about [text inputs](https://platform.openai.com/docs/guides/text-generation).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestMessageContentPartText {
    #[doc = "The text content."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestMessageContentPartText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestMessageContentPartText {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_request_message_content_part_text::Type,
            #[serde(rename = "text")]
            text: String,
        }
        let ChatCompletionRequestMessageContentPartText { text, .. } =
            ChatCompletionRequestMessageContentPartText::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for ChatCompletionRequestMessageContentPartText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestMessageContentPartText<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_request_message_content_part_text::Type,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        ChatCompletionRequestMessageContentPartText {
            r#type: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod chat_completion_request_system_message {
    #[doc = "The contents of the system message."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "The contents of the system message."]
        String(String),
        #[doc = "An array of content parts with a defined type. For system messages, only type `text` is supported."]
        Array(Vec<crate::__types::ChatCompletionRequestSystemMessageContentPart>),
    }
    #[doc = "The role of the messages author, in this case `system`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "system");
}
#[doc = "Developer-provided instructions that the model should follow, regardless of\nmessages sent by the user. With o1 models and newer, use `developer` messages\nfor this purpose instead.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestSystemMessage {
    #[doc = "The contents of the system message."]
    pub content: crate::__types::chat_completion_request_system_message::Content,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestSystemMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestSystemMessage {
            #[serde(rename = "content")]
            content: crate::__types::chat_completion_request_system_message::Content,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::chat_completion_request_system_message::Role,
            #[serde(rename = "name")]
            name: Option<String>,
        }
        let ChatCompletionRequestSystemMessage { content, name, .. } =
            ChatCompletionRequestSystemMessage::deserialize(deserializer)?;
        Ok(Self { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestSystemMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestSystemMessage<'a> {
            #[serde(rename = "content")]
            content: &'a crate::__types::chat_completion_request_system_message::Content,
            #[serde(rename = "role")]
            role: &'a crate::__types::chat_completion_request_system_message::Role,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { content, name } = self;
        ChatCompletionRequestSystemMessage {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestSystemMessageContentPart {
    ChatCompletionRequestMessageContentPartText(
        crate::__types::ChatCompletionRequestMessageContentPartText,
    ),
}
#[allow(clippy::module_inception)]
pub mod chat_completion_request_tool_message {
    #[doc = "The role of the messages author, in this case `tool`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "tool");
    #[doc = "The contents of the tool message."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "The contents of the tool message."]
        String(String),
        #[doc = "An array of content parts with a defined type. For tool messages, only type `text` is supported."]
        Array(Vec<crate::__types::ChatCompletionRequestToolMessageContentPart>),
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestToolMessage {
    #[doc = "The contents of the tool message."]
    pub content: crate::__types::chat_completion_request_tool_message::Content,
    #[doc = "Tool call that this message is responding to."]
    pub tool_call_id: String,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestToolMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestToolMessage {
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::chat_completion_request_tool_message::Role,
            #[serde(rename = "content")]
            content: crate::__types::chat_completion_request_tool_message::Content,
            #[serde(rename = "tool_call_id")]
            tool_call_id: String,
        }
        let ChatCompletionRequestToolMessage {
            content,
            tool_call_id,
            ..
        } = ChatCompletionRequestToolMessage::deserialize(deserializer)?;
        Ok(Self {
            content,
            tool_call_id,
        })
    }
}
impl serde::Serialize for ChatCompletionRequestToolMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestToolMessage<'a> {
            #[serde(rename = "role")]
            role: &'a crate::__types::chat_completion_request_tool_message::Role,
            #[serde(rename = "content")]
            content: &'a crate::__types::chat_completion_request_tool_message::Content,
            #[serde(rename = "tool_call_id")]
            tool_call_id: &'a String,
        }
        let Self {
            content,
            tool_call_id,
        } = self;
        ChatCompletionRequestToolMessage {
            role: &Default::default(),
            content,
            tool_call_id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestToolMessageContentPart {
    ChatCompletionRequestMessageContentPartText(
        crate::__types::ChatCompletionRequestMessageContentPartText,
    ),
}
#[allow(clippy::module_inception)]
pub mod chat_completion_request_user_message {
    #[doc = "The contents of the user message.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "The text contents of the message."]
        String(String),
        #[doc = "An array of content parts with a defined type. Supported options differ based on the [model](https://platform.openai.com/docs/models) being used to generate the response. Can contain text, image, or audio inputs."]
        Array(Vec<crate::__types::ChatCompletionRequestUserMessageContentPart>),
    }
    #[doc = "The role of the messages author, in this case `user`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "user");
}
#[doc = "Messages sent by an end user, containing prompts or additional context\ninformation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionRequestUserMessage {
    #[doc = "The contents of the user message.\n"]
    pub content: crate::__types::chat_completion_request_user_message::Content,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionRequestUserMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionRequestUserMessage {
            #[serde(rename = "content")]
            content: crate::__types::chat_completion_request_user_message::Content,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::chat_completion_request_user_message::Role,
            #[serde(rename = "name")]
            name: Option<String>,
        }
        let ChatCompletionRequestUserMessage { content, name, .. } =
            ChatCompletionRequestUserMessage::deserialize(deserializer)?;
        Ok(Self { content, name })
    }
}
impl serde::Serialize for ChatCompletionRequestUserMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionRequestUserMessage<'a> {
            #[serde(rename = "content")]
            content: &'a crate::__types::chat_completion_request_user_message::Content,
            #[serde(rename = "role")]
            role: &'a crate::__types::chat_completion_request_user_message::Role,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { content, name } = self;
        ChatCompletionRequestUserMessage {
            content,
            role: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionRequestUserMessageContentPart {
    Text(crate::__types::ChatCompletionRequestMessageContentPartText),
    ImageUrl(crate::__types::ChatCompletionRequestMessageContentPartImage),
    InputAudio(crate::__types::ChatCompletionRequestMessageContentPartAudio),
    File(crate::__types::ChatCompletionRequestMessageContentPartFile),
}
#[allow(clippy::module_inception)]
pub mod chat_completion_response_message {
    #[allow(clippy::module_inception)]
    pub mod annotations {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The type of the URL citation. Always `url_citation`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "url_citation");
            #[doc = "A URL citation when using web search."]
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct UrlCitation {
                #[doc = "The index of the last character of the URL citation in the message."]
                #[serde(rename = "end_index")]
                pub end_index: i64,
                #[doc = "The index of the first character of the URL citation in the message."]
                #[serde(rename = "start_index")]
                pub start_index: i64,
                #[doc = "The URL of the web resource."]
                #[serde(rename = "url")]
                pub url: String,
                #[doc = "The title of the web resource."]
                #[serde(rename = "title")]
                pub title: String,
            }
        }
        #[doc = "A URL citation when using web search.\n"]
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "A URL citation when using web search."]
            pub url_citation:
                crate::__types::chat_completion_response_message::annotations::item::UrlCitation,
        }
        impl<'de> serde::Deserialize<'de> for Item {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct Item { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: chat_completion_response_message :: annotations :: item :: Type , # [serde (rename = "url_citation")] url_citation : crate :: __types :: chat_completion_response_message :: annotations :: item :: UrlCitation }
                let Item { url_citation, .. } = Item::deserialize(deserializer)?;
                Ok(Self { url_citation })
            }
        }
        impl serde::Serialize for Item {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct Item < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: chat_completion_response_message :: annotations :: item :: Type , # [serde (rename = "url_citation")] url_citation : & 'a crate :: __types :: chat_completion_response_message :: annotations :: item :: UrlCitation }
                let Self { url_citation } = self;
                Item {
                    r#type: &Default::default(),
                    url_citation,
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "The role of the author of this message."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "assistant");
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FunctionCall {
        #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
        #[serde(rename = "arguments")]
        pub arguments: String,
        #[doc = "The name of the function to call."]
        #[serde(rename = "name")]
        pub name: String,
    }
    #[doc = "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Audio {
        #[doc = "Unique identifier for this audio response."]
        #[serde(rename = "id")]
        pub id: String,
        #[doc = "The Unix timestamp (in seconds) for when this audio response will\nno longer be accessible on the server for use in multi-turn\nconversations.\n"]
        #[serde(rename = "expires_at")]
        pub expires_at: i64,
        #[doc = "Base64 encoded audio bytes generated by the model, in the format\nspecified in the request.\n"]
        #[serde(rename = "data")]
        pub data: String,
        #[doc = "Transcript of the audio generated by the model."]
        #[serde(rename = "transcript")]
        pub transcript: String,
    }
}
#[doc = "A chat completion message generated by the model."]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionResponseMessage {
    #[doc = "The contents of the message."]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "The refusal message generated by the model."]
    #[builder(default)]
    pub refusal: Option<String>,
    #[builder(default)]
    pub tool_calls: Option<crate::__types::ChatCompletionMessageToolCalls>,
    #[doc = "Annotations for the message, when applicable, as when using the\n[web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\n"]
    #[builder(default)]
    pub annotations:
        Option<Vec<crate::__types::chat_completion_response_message::annotations::Item>>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call: Option<crate::__types::chat_completion_response_message::FunctionCall>,
    #[doc = "If the audio output modality is requested, this object contains data\nabout the audio response from the model. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<crate::__types::chat_completion_response_message::Audio>,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionResponseMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionResponseMessage {
            #[serde(rename = "content")]
            content: Option<String>,
            #[serde(rename = "refusal")]
            refusal: Option<String>,
            #[serde(rename = "tool_calls")]
            tool_calls: Option<crate::__types::ChatCompletionMessageToolCalls>,
            #[serde(rename = "annotations")]
            annotations:
                Option<Vec<crate::__types::chat_completion_response_message::annotations::Item>>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::chat_completion_response_message::Role,
            #[serde(rename = "function_call")]
            function_call: Option<crate::__types::chat_completion_response_message::FunctionCall>,
            #[serde(rename = "audio")]
            audio: Option<crate::__types::chat_completion_response_message::Audio>,
        }
        let ChatCompletionResponseMessage {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
            ..
        } = ChatCompletionResponseMessage::deserialize(deserializer)?;
        Ok(Self {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
        })
    }
}
impl serde::Serialize for ChatCompletionResponseMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionResponseMessage<'a> {
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<String>,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<crate::__types::ChatCompletionMessageToolCalls>,
            #[serde(rename = "annotations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            annotations: &'a Option<
                Vec<crate::__types::chat_completion_response_message::annotations::Item>,
            >,
            #[serde(rename = "role")]
            role: &'a crate::__types::chat_completion_response_message::Role,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call:
                &'a Option<crate::__types::chat_completion_response_message::FunctionCall>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<crate::__types::chat_completion_response_message::Audio>,
        }
        let Self {
            content,
            refusal,
            tool_calls,
            annotations,
            function_call,
            audio,
        } = self;
        ChatCompletionResponseMessage {
            content,
            refusal,
            tool_calls,
            annotations,
            role: &Default::default(),
            function_call,
            audio,
        }
        .serialize(serializer)
    }
}
#[doc = "The role of the author of a message"]
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum ChatCompletionRole {
    #[doc = "`developer`"]
    #[serde(rename = "developer")]
    Developer,
    #[doc = "`system`"]
    #[serde(rename = "system")]
    System,
    #[doc = "`user`"]
    #[serde(rename = "user")]
    User,
    #[doc = "`assistant`"]
    #[serde(rename = "assistant")]
    Assistant,
    #[doc = "`tool`"]
    #[serde(rename = "tool")]
    Tool,
    #[doc = "`function`"]
    #[serde(rename = "function")]
    Function,
}
#[doc = "Options for streaming response. Only set this when you set `stream: true`.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ChatCompletionStreamOptions {
    #[doc = "If set, an additional chunk will be streamed before the `data: [DONE]`\nmessage. The `usage` field on this chunk shows the token usage statistics\nfor the entire request, and the `choices` field will always be an empty\narray.\n\nAll other chunks will also include a `usage` field, but with a null\nvalue. **NOTE:** If the stream is interrupted, you may not receive the\nfinal usage chunk which contains the total token usage for the request.\n"]
    #[serde(rename = "include_usage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub include_usage: Option<bool>,
    #[doc = "When true, stream obfuscation will be enabled. Stream obfuscation adds\nrandom characters to an `obfuscation` field on streaming delta events to\nnormalize payload sizes as a mitigation to certain side-channel attacks.\nThese obfuscation fields are included by default, but add a small amount\nof overhead to the data stream. You can set `include_obfuscation` to\nfalse to optimize for bandwidth if you trust the network links between\nyour application and the OpenAI API.\n"]
    #[serde(rename = "include_obfuscation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub include_obfuscation: Option<bool>,
}
#[allow(clippy::module_inception)]
pub mod chat_completion_stream_response_delta {
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FunctionCall {
        #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
        #[serde(rename = "arguments")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub arguments: Option<String>,
        #[doc = "The name of the function to call."]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
    }
    #[doc = "The role of the author of this message."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`developer`"]
        #[serde(rename = "developer")]
        Developer,
        #[doc = "`system`"]
        #[serde(rename = "system")]
        System,
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`assistant`"]
        #[serde(rename = "assistant")]
        Assistant,
        #[doc = "`tool`"]
        #[serde(rename = "tool")]
        Tool,
    }
}
#[doc = "A chat completion delta generated by streamed model responses."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ChatCompletionStreamResponseDelta {
    #[doc = "The contents of the chunk message."]
    #[serde(rename = "content")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub content: Option<String>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[serde(rename = "function_call")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub function_call: Option<crate::__types::chat_completion_stream_response_delta::FunctionCall>,
    #[serde(rename = "tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_calls: Option<Vec<crate::__types::ChatCompletionMessageToolCallChunk>>,
    #[doc = "The role of the author of this message."]
    #[serde(rename = "role")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub role: Option<crate::__types::chat_completion_stream_response_delta::Role>,
    #[doc = "The refusal message generated by the model."]
    #[serde(rename = "refusal")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub refusal: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod chat_completion_token_logprob {
    #[allow(clippy::module_inception)]
    pub mod top_logprobs {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The token."]
            #[serde(rename = "token")]
            pub token: String,
            #[doc = "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely."]
            #[serde(rename = "logprob")]
            pub logprob: serde_json::Number,
            #[doc = "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token."]
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub bytes: Option<Vec<i64>>,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ChatCompletionTokenLogprob {
    #[doc = "The token."]
    #[serde(rename = "token")]
    pub token: String,
    #[doc = "The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value `-9999.0` is used to signify that the token is very unlikely."]
    #[serde(rename = "logprob")]
    pub logprob: serde_json::Number,
    #[doc = "A list of integers representing the UTF-8 bytes representation of the token. Useful in instances where characters are represented by multiple tokens and their byte representations must be combined to generate the correct text representation. Can be `null` if there is no bytes representation for the token."]
    #[serde(rename = "bytes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub bytes: Option<Vec<i64>>,
    #[doc = "List of the most likely tokens and their log probability, at this token position. In rare cases, there may be fewer than the number of requested `top_logprobs` returned."]
    #[serde(rename = "top_logprobs")]
    pub top_logprobs: Vec<crate::__types::chat_completion_token_logprob::top_logprobs::Item>,
}
#[allow(clippy::module_inception)]
pub(crate) mod chat_completion_tool {
    #[doc = "The type of the tool. Currently, only `function` is supported."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
}
#[doc = "A function tool that can be used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ChatCompletionTool {
    pub function: crate::__types::FunctionObject,
}
impl<'de> serde::Deserialize<'de> for ChatCompletionTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ChatCompletionTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::chat_completion_tool::Type,
            #[serde(rename = "function")]
            function: crate::__types::FunctionObject,
        }
        let ChatCompletionTool { function, .. } = ChatCompletionTool::deserialize(deserializer)?;
        Ok(Self { function })
    }
}
impl serde::Serialize for ChatCompletionTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ChatCompletionTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::chat_completion_tool::Type,
            #[serde(rename = "function")]
            function: &'a crate::__types::FunctionObject,
        }
        let Self { function } = self;
        ChatCompletionTool {
            r#type: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod chat_completion_tool_choice_option {
    #[doc = "none"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct None;
    impl_serde!(None, "none");
    #[doc = "auto"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Auto;
    impl_serde!(Auto, "auto");
    #[doc = "required"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Required;
    impl_serde!(Required, "required");
}
#[doc = "Controls which (if any) tool is called by the model.\n`none` means the model will not call any tool and instead generates a message.\n`auto` means the model can pick between generating a message or calling one or more tools.\n`required` means the model must call one or more tools.\nSpecifying a particular tool via `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}` forces the model to call that tool.\n\n`none` is the default when no tools are present. `auto` is the default if tools are present.\n"]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ChatCompletionToolChoiceOption {
    #[doc = "none"]
    None,
    #[doc = "auto"]
    Auto,
    #[doc = "required"]
    Required,
    AllowedTools(crate::__types::ChatCompletionAllowedToolsChoice),
    Function(crate::__types::ChatCompletionNamedToolChoice),
    Custom(crate::__types::ChatCompletionNamedToolChoiceCustom),
}
impl<'de> serde::Deserialize<'de> for ChatCompletionToolChoiceOption {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ChatCompletionToolChoiceOption {
            None(crate::__types::chat_completion_tool_choice_option::None),
            Auto(crate::__types::chat_completion_tool_choice_option::Auto),
            Required(crate::__types::chat_completion_tool_choice_option::Required),
            AllowedTools(crate::__types::ChatCompletionAllowedToolsChoice),
            Function(crate::__types::ChatCompletionNamedToolChoice),
            Custom(crate::__types::ChatCompletionNamedToolChoiceCustom),
        }
        Ok(
            match ChatCompletionToolChoiceOption::deserialize(deserializer)? {
                ChatCompletionToolChoiceOption::None(_) => Self::None,
                ChatCompletionToolChoiceOption::Auto(_) => Self::Auto,
                ChatCompletionToolChoiceOption::Required(_) => Self::Required,
                ChatCompletionToolChoiceOption::AllowedTools(v) => Self::AllowedTools(v),
                ChatCompletionToolChoiceOption::Function(v) => Self::Function(v),
                ChatCompletionToolChoiceOption::Custom(v) => Self::Custom(v),
            },
        )
    }
}
impl serde::Serialize for ChatCompletionToolChoiceOption {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ChatCompletionToolChoiceOption<'a> {
            None(crate::__types::chat_completion_tool_choice_option::None),
            Auto(crate::__types::chat_completion_tool_choice_option::Auto),
            Required(crate::__types::chat_completion_tool_choice_option::Required),
            AllowedTools(&'a crate::__types::ChatCompletionAllowedToolsChoice),
            Function(&'a crate::__types::ChatCompletionNamedToolChoice),
            Custom(&'a crate::__types::ChatCompletionNamedToolChoiceCustom),
        }
        match self {
            Self::None => ChatCompletionToolChoiceOption::None(Default::default()),
            Self::Auto => ChatCompletionToolChoiceOption::Auto(Default::default()),
            Self::Required => ChatCompletionToolChoiceOption::Required(Default::default()),
            Self::AllowedTools(v) => ChatCompletionToolChoiceOption::AllowedTools(v),
            Self::Function(v) => ChatCompletionToolChoiceOption::Function(v),
            Self::Custom(v) => ChatCompletionToolChoiceOption::Custom(v),
        }
        .serialize(serializer)
    }
}
#[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ChunkingStrategyRequestParam {
    Auto(crate::__types::AutoChunkingStrategyRequestParam),
    Static(crate::__types::StaticChunkingStrategyRequestParam),
}
#[allow(clippy::module_inception)]
pub mod click {
    #[doc = "Specifies the event type. For a click action, this property is \nalways set to `click`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "click");
    #[doc = "Indicates which mouse button was pressed during the click. One of `left`, `right`, `wheel`, `back`, or `forward`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Button {
        #[doc = "`left`"]
        #[serde(rename = "left")]
        Left,
        #[doc = "`right`"]
        #[serde(rename = "right")]
        Right,
        #[doc = "`wheel`"]
        #[serde(rename = "wheel")]
        Wheel,
        #[doc = "`back`"]
        #[serde(rename = "back")]
        Back,
        #[doc = "`forward`"]
        #[serde(rename = "forward")]
        Forward,
    }
}
#[doc = "A click action.\n"]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Click {
    #[doc = "Indicates which mouse button was pressed during the click. One of `left`, `right`, `wheel`, `back`, or `forward`.\n"]
    pub button: crate::__types::click::Button,
    #[doc = "The x-coordinate where the click occurred.\n"]
    pub x: i64,
    #[doc = "The y-coordinate where the click occurred.\n"]
    pub y: i64,
}
impl<'de> serde::Deserialize<'de> for Click {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Click {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::click::Type,
            #[serde(rename = "button")]
            button: crate::__types::click::Button,
            #[serde(rename = "x")]
            x: i64,
            #[serde(rename = "y")]
            y: i64,
        }
        let Click { button, x, y, .. } = Click::deserialize(deserializer)?;
        Ok(Self { button, x, y })
    }
}
impl serde::Serialize for Click {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Click<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::click::Type,
            #[serde(rename = "button")]
            button: &'a crate::__types::click::Button,
            #[serde(rename = "x")]
            x: &'a i64,
            #[serde(rename = "y")]
            y: &'a i64,
        }
        let Self { button, x, y } = self;
        Click {
            r#type: &Default::default(),
            button,
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod code_interpreter_file_output {
    #[doc = "The type of the code interpreter file output. Always `files`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "files");
    #[allow(clippy::module_inception)]
    pub mod files {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The MIME type of the file.\n"]
            #[serde(rename = "mime_type")]
            pub mime_type: String,
            #[doc = "The ID of the file.\n"]
            #[serde(rename = "file_id")]
            pub file_id: String,
        }
    }
}
#[doc = "The output of a code interpreter tool call that is a file.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterFileOutput {
    pub files: Vec<crate::__types::code_interpreter_file_output::files::Item>,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterFileOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterFileOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::code_interpreter_file_output::Type,
            #[serde(rename = "files")]
            files: Vec<crate::__types::code_interpreter_file_output::files::Item>,
        }
        let CodeInterpreterFileOutput { files, .. } =
            CodeInterpreterFileOutput::deserialize(deserializer)?;
        Ok(Self { files })
    }
}
impl serde::Serialize for CodeInterpreterFileOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterFileOutput<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::code_interpreter_file_output::Type,
            #[serde(rename = "files")]
            files: &'a Vec<crate::__types::code_interpreter_file_output::files::Item>,
        }
        let Self { files } = self;
        CodeInterpreterFileOutput {
            r#type: &Default::default(),
            files,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod code_interpreter_output_image {
    #[doc = "The type of the output. Always 'image'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image");
}
#[doc = "The image output from the code interpreter.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterOutputImage {
    #[doc = "The URL of the image output from the code interpreter."]
    pub url: String,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterOutputImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterOutputImage {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::code_interpreter_output_image::Type,
            #[serde(rename = "url")]
            url: String,
        }
        let CodeInterpreterOutputImage { url, .. } =
            CodeInterpreterOutputImage::deserialize(deserializer)?;
        Ok(Self { url })
    }
}
impl serde::Serialize for CodeInterpreterOutputImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterOutputImage<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::code_interpreter_output_image::Type,
            #[serde(rename = "url")]
            url: &'a String,
        }
        let Self { url } = self;
        CodeInterpreterOutputImage {
            r#type: &Default::default(),
            url,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod code_interpreter_output_logs {
    #[doc = "The type of the output. Always 'logs'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "logs");
}
#[doc = "The logs output from the code interpreter.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterOutputLogs {
    #[doc = "The logs output from the code interpreter."]
    pub logs: String,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterOutputLogs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterOutputLogs {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::code_interpreter_output_logs::Type,
            #[serde(rename = "logs")]
            logs: String,
        }
        let CodeInterpreterOutputLogs { logs, .. } =
            CodeInterpreterOutputLogs::deserialize(deserializer)?;
        Ok(Self { logs })
    }
}
impl serde::Serialize for CodeInterpreterOutputLogs {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterOutputLogs<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::code_interpreter_output_logs::Type,
            #[serde(rename = "logs")]
            logs: &'a String,
        }
        let Self { logs } = self;
        CodeInterpreterOutputLogs {
            r#type: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod code_interpreter_text_output {
    #[doc = "The type of the code interpreter text output. Always `logs`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "logs");
}
#[doc = "The output of a code interpreter tool call that is text.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterTextOutput {
    #[doc = "The logs of the code interpreter tool call.\n"]
    pub logs: String,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterTextOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterTextOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::code_interpreter_text_output::Type,
            #[serde(rename = "logs")]
            logs: String,
        }
        let CodeInterpreterTextOutput { logs, .. } =
            CodeInterpreterTextOutput::deserialize(deserializer)?;
        Ok(Self { logs })
    }
}
impl serde::Serialize for CodeInterpreterTextOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterTextOutput<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::code_interpreter_text_output::Type,
            #[serde(rename = "logs")]
            logs: &'a String,
        }
        let Self { logs } = self;
        CodeInterpreterTextOutput {
            r#type: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod code_interpreter_tool {
    #[doc = "The type of the code interpreter tool. Always `code_interpreter`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "code_interpreter");
    #[doc = "The code interpreter container. Can be a container ID or an object that\nspecifies uploaded file IDs to make available to your code.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Container {
        #[doc = "The container ID."]
        String(String),
        CodeInterpreterToolAuto(crate::__types::CodeInterpreterToolAuto),
    }
}
#[doc = "A tool that runs Python code to help generate a response to a prompt.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterTool {
    #[doc = "The code interpreter container. Can be a container ID or an object that\nspecifies uploaded file IDs to make available to your code.\n"]
    pub container: crate::__types::code_interpreter_tool::Container,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::code_interpreter_tool::Type,
            #[serde(rename = "container")]
            container: crate::__types::code_interpreter_tool::Container,
        }
        let CodeInterpreterTool { container, .. } = CodeInterpreterTool::deserialize(deserializer)?;
        Ok(Self { container })
    }
}
impl serde::Serialize for CodeInterpreterTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::code_interpreter_tool::Type,
            #[serde(rename = "container")]
            container: &'a crate::__types::code_interpreter_tool::Container,
        }
        let Self { container } = self;
        CodeInterpreterTool {
            r#type: &Default::default(),
            container,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod code_interpreter_tool_auto {
    #[doc = "Always `auto`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "auto");
}
#[doc = "Configuration for a code interpreter container. Optionally specify the IDs\nof the files to run the code on.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterToolAuto {
    #[doc = "An optional list of uploaded files to make available to your code.\n"]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolAuto {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterToolAuto {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::code_interpreter_tool_auto::Type,
            #[serde(rename = "file_ids")]
            file_ids: Option<Vec<String>>,
        }
        let CodeInterpreterToolAuto { file_ids, .. } =
            CodeInterpreterToolAuto::deserialize(deserializer)?;
        Ok(Self { file_ids })
    }
}
impl serde::Serialize for CodeInterpreterToolAuto {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterToolAuto<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::code_interpreter_tool_auto::Type,
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_ids: &'a Option<Vec<String>>,
        }
        let Self { file_ids } = self;
        CodeInterpreterToolAuto {
            r#type: &Default::default(),
            file_ids,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod code_interpreter_tool_call {
    #[doc = "The type of the code interpreter tool call. Always `code_interpreter_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "code_interpreter_call");
    #[doc = "The status of the code interpreter tool call. Valid values are `in_progress`, `completed`, `incomplete`, `interpreting`, and `failed`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
        #[doc = "`interpreting`"]
        #[serde(rename = "interpreting")]
        Interpreting,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
    }
    #[allow(clippy::module_inception)]
    pub mod outputs {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            Logs(crate::__types::CodeInterpreterOutputLogs),
            Image(crate::__types::CodeInterpreterOutputImage),
        }
    }
}
#[doc = "A tool call to run code.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CodeInterpreterToolCall {
    #[doc = "The unique ID of the code interpreter tool call.\n"]
    pub id: String,
    #[doc = "The status of the code interpreter tool call. Valid values are `in_progress`, `completed`, `incomplete`, `interpreting`, and `failed`.\n"]
    pub status: crate::__types::code_interpreter_tool_call::Status,
    #[doc = "The ID of the container used to run the code.\n"]
    pub container_id: String,
    #[doc = "The code to run, or null if not available.\n"]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "The outputs generated by the code interpreter, such as logs or images. \nCan be null if no outputs are available.\n"]
    #[builder(default)]
    pub outputs: Option<Vec<crate::__types::code_interpreter_tool_call::outputs::Item>>,
}
impl<'de> serde::Deserialize<'de> for CodeInterpreterToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CodeInterpreterToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::code_interpreter_tool_call::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "status")]
            status: crate::__types::code_interpreter_tool_call::Status,
            #[serde(rename = "container_id")]
            container_id: String,
            #[serde(rename = "code")]
            code: Option<String>,
            #[serde(rename = "outputs")]
            outputs: Option<Vec<crate::__types::code_interpreter_tool_call::outputs::Item>>,
        }
        let CodeInterpreterToolCall {
            id,
            status,
            container_id,
            code,
            outputs,
            ..
        } = CodeInterpreterToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            status,
            container_id,
            code,
            outputs,
        })
    }
}
impl serde::Serialize for CodeInterpreterToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CodeInterpreterToolCall<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::code_interpreter_tool_call::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "status")]
            status: &'a crate::__types::code_interpreter_tool_call::Status,
            #[serde(rename = "container_id")]
            container_id: &'a String,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "outputs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            outputs: &'a Option<Vec<crate::__types::code_interpreter_tool_call::outputs::Item>>,
        }
        let Self {
            id,
            status,
            container_id,
            code,
            outputs,
        } = self;
        CodeInterpreterToolCall {
            r#type: &Default::default(),
            id,
            status,
            container_id,
            code,
            outputs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod comparison_filter {
    #[doc = "Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`eq`"]
        #[default]
        #[serde(rename = "eq")]
        Eq,
        #[doc = "`ne`"]
        #[serde(rename = "ne")]
        Ne,
        #[doc = "`gt`"]
        #[serde(rename = "gt")]
        Gt,
        #[doc = "`gte`"]
        #[serde(rename = "gte")]
        Gte,
        #[doc = "`lt`"]
        #[serde(rename = "lt")]
        Lt,
        #[doc = "`lte`"]
        #[serde(rename = "lte")]
        Lte,
    }
    #[doc = "The value to compare against the attribute key; supports string, number, or boolean types."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Value {
        String(String),
        Number(serde_json::Number),
        Bool(bool),
    }
}
#[doc = "A filter used to compare a specified attribute key to a given value using a defined comparison operation.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ComparisonFilter {
    #[doc = "Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n"]
    #[serde(rename = "type")]
    #[builder(default)]
    pub r#type: crate::__types::comparison_filter::Type,
    #[doc = "The key to compare against the value."]
    #[serde(rename = "key")]
    pub key: String,
    #[doc = "The value to compare against the attribute key; supports string, number, or boolean types."]
    #[serde(rename = "value")]
    pub value: crate::__types::comparison_filter::Value,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CompleteUploadRequest {
    #[doc = "The ordered list of Part IDs.\n"]
    #[serde(rename = "part_ids")]
    pub part_ids: Vec<String>,
    #[doc = "The optional md5 checksum for the file contents to verify if the bytes uploaded matches what you expect.\n"]
    #[serde(rename = "md5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub md5: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod completion_usage {
    #[doc = "Breakdown of tokens used in a completion."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CompletionTokensDetails {
        #[doc = "When using Predicted Outputs, the number of tokens in the\nprediction that appeared in the completion.\n"]
        #[serde(rename = "accepted_prediction_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub accepted_prediction_tokens: Option<i64>,
        #[doc = "Audio input tokens generated by the model."]
        #[serde(rename = "audio_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub audio_tokens: Option<i64>,
        #[doc = "Tokens generated by the model for reasoning."]
        #[serde(rename = "reasoning_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub reasoning_tokens: Option<i64>,
        #[doc = "When using Predicted Outputs, the number of tokens in the\nprediction that did not appear in the completion. However, like\nreasoning tokens, these tokens are still counted in the total\ncompletion tokens for purposes of billing, output, and context window\nlimits.\n"]
        #[serde(rename = "rejected_prediction_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub rejected_prediction_tokens: Option<i64>,
    }
    #[doc = "Breakdown of tokens used in the prompt."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct PromptTokensDetails {
        #[doc = "Audio input tokens present in the prompt."]
        #[serde(rename = "audio_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub audio_tokens: Option<i64>,
        #[doc = "Cached tokens present in the prompt."]
        #[serde(rename = "cached_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub cached_tokens: Option<i64>,
    }
}
#[doc = "Usage statistics for the completion request."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CompletionUsage {
    #[doc = "Number of tokens in the generated completion."]
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i64,
    #[doc = "Number of tokens in the prompt."]
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i64,
    #[doc = "Total number of tokens used in the request (prompt + completion)."]
    #[serde(rename = "total_tokens")]
    pub total_tokens: i64,
    #[doc = "Breakdown of tokens used in a completion."]
    #[serde(rename = "completion_tokens_details")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub completion_tokens_details:
        Option<crate::__types::completion_usage::CompletionTokensDetails>,
    #[doc = "Breakdown of tokens used in the prompt."]
    #[serde(rename = "prompt_tokens_details")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt_tokens_details: Option<crate::__types::completion_usage::PromptTokensDetails>,
}
#[allow(clippy::module_inception)]
pub mod compound_filter {
    #[doc = "Type of operation: `and` or `or`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`and`"]
        #[serde(rename = "and")]
        And,
        #[doc = "`or`"]
        #[serde(rename = "or")]
        Or,
    }
    #[allow(clippy::module_inception)]
    pub mod filters {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            ComparisonFilter(crate::__types::ComparisonFilter),
            CompoundFilter(crate::__types::CompoundFilter),
        }
    }
}
#[doc = "Combine multiple filters using `and` or `or`."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CompoundFilter {
    #[doc = "Type of operation: `and` or `or`."]
    #[serde(rename = "type")]
    pub r#type: crate::__types::compound_filter::Type,
    #[doc = "Array of filters to combine. Items can be `ComparisonFilter` or `CompoundFilter`."]
    #[serde(rename = "filters")]
    pub filters: Vec<crate::__types::compound_filter::filters::Item>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ComputerAction {
    Click(crate::__types::Click),
    DoubleClick(crate::__types::DoubleClick),
    Drag(crate::__types::Drag),
    Keypress(crate::__types::KeyPress),
    Move(crate::__types::Move),
    Screenshot(crate::__types::Screenshot),
    Scroll(crate::__types::Scroll),
    Type(crate::__types::Type),
    Wait(crate::__types::Wait),
}
#[allow(clippy::module_inception)]
pub(crate) mod computer_screenshot_image {
    #[doc = "Specifies the event type. For a computer screenshot, this property is \nalways set to `computer_screenshot`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "computer_screenshot");
}
#[doc = "A computer screenshot image used with the computer use tool.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerScreenshotImage {
    #[doc = "The URL of the screenshot image."]
    #[builder(default)]
    pub image_url: Option<String>,
    #[doc = "The identifier of an uploaded file that contains the screenshot."]
    #[builder(default)]
    pub file_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ComputerScreenshotImage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerScreenshotImage {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::computer_screenshot_image::Type,
            #[serde(rename = "image_url")]
            image_url: Option<String>,
            #[serde(rename = "file_id")]
            file_id: Option<String>,
        }
        let ComputerScreenshotImage {
            image_url, file_id, ..
        } = ComputerScreenshotImage::deserialize(deserializer)?;
        Ok(Self { image_url, file_id })
    }
}
impl serde::Serialize for ComputerScreenshotImage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerScreenshotImage<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::computer_screenshot_image::Type,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
        }
        let Self { image_url, file_id } = self;
        ComputerScreenshotImage {
            r#type: &Default::default(),
            image_url,
            file_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod computer_tool_call {
    #[doc = "The type of the computer call. Always `computer_call`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "computer_call");
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "A tool call to a computer use tool. See the \n[computer use guide](https://platform.openai.com/docs/guides/tools-computer-use) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCall {
    #[doc = "The unique ID of the computer call."]
    pub id: String,
    #[doc = "An identifier used when responding to the tool call with output.\n"]
    pub call_id: String,
    pub action: crate::__types::ComputerAction,
    #[doc = "The pending safety checks for the computer call.\n"]
    pub pending_safety_checks: Vec<crate::__types::ComputerToolCallSafetyCheck>,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    pub status: crate::__types::computer_tool_call::Status,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::computer_tool_call::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "action")]
            action: crate::__types::ComputerAction,
            #[serde(rename = "pending_safety_checks")]
            pending_safety_checks: Vec<crate::__types::ComputerToolCallSafetyCheck>,
            #[serde(rename = "status")]
            status: crate::__types::computer_tool_call::Status,
        }
        let ComputerToolCall {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
            ..
        } = ComputerToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        })
    }
}
impl serde::Serialize for ComputerToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerToolCall<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::computer_tool_call::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "action")]
            action: &'a crate::__types::ComputerAction,
            #[serde(rename = "pending_safety_checks")]
            pending_safety_checks: &'a Vec<crate::__types::ComputerToolCallSafetyCheck>,
            #[serde(rename = "status")]
            status: &'a crate::__types::computer_tool_call::Status,
        }
        let Self {
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        } = self;
        ComputerToolCall {
            r#type: &Default::default(),
            id,
            call_id,
            action,
            pending_safety_checks,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod computer_tool_call_output {
    #[doc = "The type of the computer tool call output. Always `computer_call_output`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "computer_call_output");
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "The output of a computer tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallOutput {
    #[doc = "The ID of the computer tool call output.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The ID of the computer tool call that produced the output.\n"]
    pub call_id: String,
    #[doc = "The safety checks reported by the API that have been acknowledged by the \ndeveloper.\n"]
    #[builder(default)]
    pub acknowledged_safety_checks: Option<Vec<crate::__types::ComputerToolCallSafetyCheck>>,
    #[builder(default)]
    pub output: crate::__types::ComputerScreenshotImage,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::computer_tool_call_output::Status>,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerToolCallOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::computer_tool_call_output::Type,
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "acknowledged_safety_checks")]
            acknowledged_safety_checks: Option<Vec<crate::__types::ComputerToolCallSafetyCheck>>,
            #[serde(rename = "output")]
            output: crate::__types::ComputerScreenshotImage,
            #[serde(rename = "status")]
            status: Option<crate::__types::computer_tool_call_output::Status>,
        }
        let ComputerToolCallOutput {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
            ..
        } = ComputerToolCallOutput::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        })
    }
}
impl serde::Serialize for ComputerToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerToolCallOutput<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::computer_tool_call_output::Type,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "acknowledged_safety_checks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            acknowledged_safety_checks:
                &'a Option<Vec<crate::__types::ComputerToolCallSafetyCheck>>,
            #[serde(rename = "output")]
            output: &'a crate::__types::ComputerScreenshotImage,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::computer_tool_call_output::Status>,
        }
        let Self {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        } = self;
        ComputerToolCallOutput {
            r#type: &Default::default(),
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod computer_tool_call_output_resource {
    #[doc = "The type of the computer tool call output. Always `computer_call_output`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "computer_call_output");
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallOutputResource {
    #[doc = "The ID of the computer tool call output.\n"]
    pub id: String,
    #[doc = "The ID of the computer tool call that produced the output.\n"]
    pub call_id: String,
    #[doc = "The safety checks reported by the API that have been acknowledged by the \ndeveloper.\n"]
    #[builder(default)]
    pub acknowledged_safety_checks: Option<Vec<crate::__types::ComputerToolCallSafetyCheck>>,
    #[builder(default)]
    pub output: crate::__types::ComputerScreenshotImage,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::computer_tool_call_output_resource::Status>,
}
impl<'de> serde::Deserialize<'de> for ComputerToolCallOutputResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerToolCallOutputResource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::computer_tool_call_output_resource::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "acknowledged_safety_checks")]
            acknowledged_safety_checks: Option<Vec<crate::__types::ComputerToolCallSafetyCheck>>,
            #[serde(rename = "output")]
            output: crate::__types::ComputerScreenshotImage,
            #[serde(rename = "status")]
            status: Option<crate::__types::computer_tool_call_output_resource::Status>,
        }
        let ComputerToolCallOutputResource {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
            ..
        } = ComputerToolCallOutputResource::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        })
    }
}
impl serde::Serialize for ComputerToolCallOutputResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerToolCallOutputResource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::computer_tool_call_output_resource::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "acknowledged_safety_checks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            acknowledged_safety_checks:
                &'a Option<Vec<crate::__types::ComputerToolCallSafetyCheck>>,
            #[serde(rename = "output")]
            output: &'a crate::__types::ComputerScreenshotImage,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::computer_tool_call_output_resource::Status>,
        }
        let Self {
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        } = self;
        ComputerToolCallOutputResource {
            r#type: &Default::default(),
            id,
            call_id,
            acknowledged_safety_checks,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "A pending safety check for the computer call.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ComputerToolCallSafetyCheck {
    #[doc = "The ID of the pending safety check."]
    #[serde(rename = "id")]
    pub id: String,
    #[doc = "The type of the pending safety check."]
    #[serde(rename = "code")]
    pub code: String,
    #[doc = "Details about the pending safety check."]
    #[serde(rename = "message")]
    pub message: String,
}
#[allow(clippy::module_inception)]
pub(crate) mod container_file_list_resource {
    #[doc = "The type of object returned, must be 'list'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ContainerFileListResource {
    #[doc = "A list of container files."]
    pub data: Vec<crate::__types::ContainerFileResource>,
    #[doc = "The ID of the first file in the list."]
    pub first_id: String,
    #[doc = "The ID of the last file in the list."]
    pub last_id: String,
    #[doc = "Whether there are more files available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ContainerFileListResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerFileListResource {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::container_file_list_resource::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::ContainerFileResource>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ContainerFileListResource {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ContainerFileListResource::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ContainerFileListResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerFileListResource<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::container_file_list_resource::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::ContainerFileResource>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ContainerFileListResource {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ContainerFileResource {
    #[doc = "Unique identifier for the file."]
    #[serde(rename = "id")]
    pub id: String,
    #[doc = "The type of this object (`container.file`)."]
    #[serde(rename = "object")]
    pub object: String,
    #[doc = "The container this file belongs to."]
    #[serde(rename = "container_id")]
    pub container_id: String,
    #[doc = "Unix timestamp (in seconds) when the file was created."]
    #[serde(rename = "created_at")]
    pub created_at: i64,
    #[doc = "Size of the file in bytes."]
    #[serde(rename = "bytes")]
    pub bytes: i64,
    #[doc = "Path of the file in the container."]
    #[serde(rename = "path")]
    pub path: String,
    #[doc = "Source of the file (e.g., `user`, `assistant`)."]
    #[serde(rename = "source")]
    pub source: String,
}
#[allow(clippy::module_inception)]
pub(crate) mod container_list_resource {
    #[doc = "The type of object returned, must be 'list'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ContainerListResource {
    #[doc = "A list of containers."]
    pub data: Vec<crate::__types::ContainerResource>,
    #[doc = "The ID of the first container in the list."]
    pub first_id: String,
    #[doc = "The ID of the last container in the list."]
    pub last_id: String,
    #[doc = "Whether there are more containers available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ContainerListResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerListResource {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::container_list_resource::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::ContainerResource>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ContainerListResource {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ContainerListResource::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ContainerListResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerListResource<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::container_list_resource::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::ContainerResource>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ContainerListResource {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod container_resource {
    #[allow(clippy::module_inception)]
    pub mod expires_after {
        #[doc = "The reference point for the expiration."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Anchor {
            #[doc = "`last_active_at`"]
            #[serde(rename = "last_active_at")]
            LastActiveAt,
        }
    }
    #[doc = "The container will expire after this time period.\nThe anchor is the reference point for the expiration.\nThe minutes is the number of minutes after the anchor before the container expires.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ExpiresAfter {
        #[doc = "The reference point for the expiration."]
        #[serde(rename = "anchor")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub anchor: Option<crate::__types::container_resource::expires_after::Anchor>,
        #[doc = "The number of minutes after the anchor before the container expires."]
        #[serde(rename = "minutes")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub minutes: Option<i64>,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ContainerResource {
    #[doc = "Unique identifier for the container."]
    #[serde(rename = "id")]
    pub id: String,
    #[doc = "The type of this object."]
    #[serde(rename = "object")]
    pub object: String,
    #[doc = "Name of the container."]
    #[serde(rename = "name")]
    pub name: String,
    #[doc = "Unix timestamp (in seconds) when the container was created."]
    #[serde(rename = "created_at")]
    pub created_at: i64,
    #[doc = "Status of the container (e.g., active, deleted)."]
    #[serde(rename = "status")]
    pub status: String,
    #[doc = "The container will expire after this time period.\nThe anchor is the reference point for the expiration.\nThe minutes is the number of minutes after the anchor before the container expires.\n"]
    #[serde(rename = "expires_after")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expires_after: Option<crate::__types::container_resource::ExpiresAfter>,
}
#[doc = "Multi-modal input and output contents.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum Content {
    InputContent(crate::__types::InputContent),
    OutputContent(crate::__types::OutputContent),
}
#[doc = "An x/y coordinate pair, e.g. `{ x: 100, y: 200 }`.\n"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct Coordinate {
    #[doc = "The x-coordinate.\n"]
    #[serde(rename = "x")]
    pub x: i64,
    #[doc = "The y-coordinate.\n"]
    #[serde(rename = "y")]
    pub y: i64,
}
#[allow(clippy::module_inception)]
pub mod costs_result {
    #[doc = "organization.costs.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.costs.result");
    #[doc = "The monetary value in its associated currency."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Amount {
        #[doc = "The numeric value of the cost."]
        #[serde(rename = "value")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub value: Option<serde_json::Number>,
        #[doc = "Lowercase ISO-4217 currency e.g. \"usd\""]
        #[serde(rename = "currency")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub currency: Option<String>,
    }
}
#[doc = "The aggregated costs details of the specific time bucket."]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct CostsResult {
    #[doc = "The monetary value in its associated currency."]
    #[builder(default)]
    pub amount: Option<crate::__types::costs_result::Amount>,
    #[doc = "When `group_by=line_item`, this field provides the line item of the grouped costs result."]
    #[builder(default)]
    pub line_item: Option<String>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped costs result."]
    #[builder(default)]
    pub project_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for CostsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CostsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::costs_result::Object,
            #[serde(rename = "amount")]
            amount: Option<crate::__types::costs_result::Amount>,
            #[serde(rename = "line_item")]
            line_item: Option<String>,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
        }
        let CostsResult {
            amount,
            line_item,
            project_id,
            ..
        } = CostsResult::deserialize(deserializer)?;
        Ok(Self {
            amount,
            line_item,
            project_id,
        })
    }
}
impl serde::Serialize for CostsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CostsResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::costs_result::Object,
            #[serde(rename = "amount")]
            #[serde(skip_serializing_if = "Option::is_none")]
            amount: &'a Option<crate::__types::costs_result::Amount>,
            #[serde(rename = "line_item")]
            #[serde(skip_serializing_if = "Option::is_none")]
            line_item: &'a Option<String>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
        }
        let Self {
            amount,
            line_item,
            project_id,
        } = self;
        CostsResult {
            object: &Default::default(),
            amount,
            line_item,
            project_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod create_assistant_request {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        AssistantSupportedModels(crate::__types::AssistantSupportedModels),
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                AssistantSupportedModels(crate::__types::AssistantSupportedModels),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::AssistantSupportedModels(v) => Self::AssistantSupportedModels(v),
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                AssistantSupportedModels(&'a crate::__types::AssistantSupportedModels),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::AssistantSupportedModels(v) => Model::AssistantSupportedModels(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod tool_resources {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct CodeInterpreter {
            #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_ids: Option<Vec<String>>,
        }
        #[allow(clippy::module_inception)]
        pub mod file_search {
            #[allow(clippy::module_inception)]
            pub mod variant0 {
                #[allow(clippy::module_inception)]
                pub mod vector_stores {
                    #[allow(clippy::module_inception)]
                    pub mod item {
                        #[allow(clippy::module_inception)]
                        pub mod chunking_strategy {
                            #[allow(clippy::module_inception)]
                            pub(crate) mod auto {
                                #[doc = "Always `auto`."]
                                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                                pub(crate) struct Type;
                                impl_serde!(Type, "auto");
                            }
                            #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
                            #[derive(
                                Clone,
                                Copy,
                                Debug,
                                Default,
                                PartialEq,
                                typed_builder :: TypedBuilder,
                            )]
                            pub struct Auto {}
                            impl<'de> serde::Deserialize<'de> for Auto {
                                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Deserialize)]
                                    struct Auto { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: auto :: Type }
                                    let Auto { .. } = Auto::deserialize(deserializer)?;
                                    Ok(Self {})
                                }
                            }
                            impl serde::Serialize for Auto {
                                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                                where
                                    S: serde::Serializer,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Serialize)]
                                    struct Auto < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: auto :: Type }
                                    let Self {} = self;
                                    Auto {
                                        r#type: &Default::default(),
                                    }
                                    .serialize(serializer)
                                }
                            }
                            #[allow(clippy::module_inception)]
                            pub mod r#static {
                                #[doc = "Always `static`."]
                                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                                pub(crate) struct Type;
                                impl_serde!(Type, "static");
                                #[derive(Clone, Copy, Debug, PartialEq)]
                                #[serde_with::serde_as]
                                #[derive(
                                    serde :: Deserialize,
                                    serde :: Serialize,
                                    typed_builder :: TypedBuilder,
                                )]
                                pub struct Static {
                                    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
                                    #[serde(rename = "max_chunk_size_tokens")]
                                    pub max_chunk_size_tokens: i64,
                                    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
                                    #[serde(rename = "chunk_overlap_tokens")]
                                    pub chunk_overlap_tokens: i64,
                                }
                            }
                            #[derive(
                                Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder,
                            )]
                            pub struct Static { pub r#static : crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                            impl<'de> serde::Deserialize<'de> for Static {
                                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Deserialize)]
                                    struct Static { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Type , # [serde (rename = "static")] r#static : crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                                    let Static { r#static, .. } =
                                        Static::deserialize(deserializer)?;
                                    Ok(Self { r#static })
                                }
                            }
                            impl serde::Serialize for Static {
                                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                                where
                                    S: serde::Serializer,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Serialize)]
                                    struct Static < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Type , # [serde (rename = "static")] r#static : & 'a crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                                    let Self { r#static } = self;
                                    Static {
                                        r#type: &Default::default(),
                                        r#static,
                                    }
                                    .serialize(serializer)
                                }
                            }
                        }
                        #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
                        #[derive(Clone, Copy, Debug, PartialEq)]
                        #[serde_with::serde_as]
                        #[derive(serde :: Deserialize, serde :: Serialize)]
                        #[serde(untagged)]
                        #[allow(clippy::large_enum_variant)]
                        pub enum ChunkingStrategy {
                            # [doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."] Auto (crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: Auto) , Static (crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: Static) }
                    }
                    #[derive(Clone, Debug, Default, PartialEq)]
                    #[serde_with::serde_as]
                    #[derive(
                        serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder,
                    )]
                    pub struct Item { # [doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"] # [serde (rename = "file_ids")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub file_ids : Option < Vec < String > > , # [doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."] # [serde (rename = "chunking_strategy")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub chunking_strategy : Option < crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: ChunkingStrategy > , # [serde (rename = "metadata")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub metadata : Option < crate :: __types :: Metadata > }
                }
            }
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Variant0 { # [doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"] # [serde (rename = "vector_store_ids")] pub vector_store_ids : Vec < String > , # [doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"] # [serde (rename = "vector_stores")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub vector_stores : Option < Vec < crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant0 :: vector_stores :: Item > > }
            #[allow(clippy::module_inception)]
            pub mod variant1 {
                #[allow(clippy::module_inception)]
                pub mod vector_stores {
                    #[allow(clippy::module_inception)]
                    pub mod item {
                        #[allow(clippy::module_inception)]
                        pub mod chunking_strategy {
                            #[allow(clippy::module_inception)]
                            pub(crate) mod auto {
                                #[doc = "Always `auto`."]
                                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                                pub(crate) struct Type;
                                impl_serde!(Type, "auto");
                            }
                            #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
                            #[derive(
                                Clone,
                                Copy,
                                Debug,
                                Default,
                                PartialEq,
                                typed_builder :: TypedBuilder,
                            )]
                            pub struct Auto {}
                            impl<'de> serde::Deserialize<'de> for Auto {
                                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Deserialize)]
                                    struct Auto { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: auto :: Type }
                                    let Auto { .. } = Auto::deserialize(deserializer)?;
                                    Ok(Self {})
                                }
                            }
                            impl serde::Serialize for Auto {
                                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                                where
                                    S: serde::Serializer,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Serialize)]
                                    struct Auto < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: auto :: Type }
                                    let Self {} = self;
                                    Auto {
                                        r#type: &Default::default(),
                                    }
                                    .serialize(serializer)
                                }
                            }
                            #[allow(clippy::module_inception)]
                            pub mod r#static {
                                #[doc = "Always `static`."]
                                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                                pub(crate) struct Type;
                                impl_serde!(Type, "static");
                                #[derive(Clone, Copy, Debug, PartialEq)]
                                #[serde_with::serde_as]
                                #[derive(
                                    serde :: Deserialize,
                                    serde :: Serialize,
                                    typed_builder :: TypedBuilder,
                                )]
                                pub struct Static {
                                    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
                                    #[serde(rename = "max_chunk_size_tokens")]
                                    pub max_chunk_size_tokens: i64,
                                    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
                                    #[serde(rename = "chunk_overlap_tokens")]
                                    pub chunk_overlap_tokens: i64,
                                }
                            }
                            #[derive(
                                Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder,
                            )]
                            pub struct Static { pub r#static : crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                            impl<'de> serde::Deserialize<'de> for Static {
                                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Deserialize)]
                                    struct Static { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Type , # [serde (rename = "static")] r#static : crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                                    let Static { r#static, .. } =
                                        Static::deserialize(deserializer)?;
                                    Ok(Self { r#static })
                                }
                            }
                            impl serde::Serialize for Static {
                                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                                where
                                    S: serde::Serializer,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Serialize)]
                                    struct Static < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Type , # [serde (rename = "static")] r#static : & 'a crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                                    let Self { r#static } = self;
                                    Static {
                                        r#type: &Default::default(),
                                        r#static,
                                    }
                                    .serialize(serializer)
                                }
                            }
                        }
                        #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
                        #[derive(Clone, Copy, Debug, PartialEq)]
                        #[serde_with::serde_as]
                        #[derive(serde :: Deserialize, serde :: Serialize)]
                        #[serde(untagged)]
                        #[allow(clippy::large_enum_variant)]
                        pub enum ChunkingStrategy {
                            # [doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."] Auto (crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: Auto) , Static (crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: Static) }
                    }
                    #[derive(Clone, Debug, Default, PartialEq)]
                    #[serde_with::serde_as]
                    #[derive(
                        serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder,
                    )]
                    pub struct Item { # [doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"] # [serde (rename = "file_ids")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub file_ids : Option < Vec < String > > , # [doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."] # [serde (rename = "chunking_strategy")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub chunking_strategy : Option < crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: ChunkingStrategy > , # [serde (rename = "metadata")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub metadata : Option < crate :: __types :: Metadata > }
                }
            }
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Variant1 { # [doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"] # [serde (rename = "vector_store_ids")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub vector_store_ids : Option < Vec < String > > , # [doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"] # [serde (rename = "vector_stores")] pub vector_stores : Vec < crate :: __types :: create_assistant_request :: tool_resources :: file_search :: variant1 :: vector_stores :: Item > }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum FileSearch {
            Variant0(
                crate::__types::create_assistant_request::tool_resources::file_search::Variant0,
            ),
            Variant1(
                crate::__types::create_assistant_request::tool_resources::file_search::Variant1,
            ),
        }
    }
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ToolResources {
        #[serde(rename = "code_interpreter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code_interpreter:
            Option<crate::__types::create_assistant_request::tool_resources::CodeInterpreter>,
        #[serde(rename = "file_search")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_search:
            Option<crate::__types::create_assistant_request::tool_resources::FileSearch>,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateAssistantRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[serde(rename = "model")]
    pub model: crate::__types::create_assistant_request::Model,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[serde(rename = "reasoning_effort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reasoning_effort: Option<crate::__types::ReasoningEffort>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::AssistantTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[serde(rename = "tool_resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_resources: Option<crate::__types::create_assistant_request::ToolResources>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
}
#[allow(clippy::module_inception)]
pub mod create_chat_completion_request {
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Text {
        #[serde(rename = "verbosity")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub verbosity: Option<crate::__types::Verbosity>,
    }
    #[allow(clippy::module_inception)]
    pub mod web_search_options {
        #[allow(clippy::module_inception)]
        pub(crate) mod user_location {
            #[doc = "The type of location approximation. Always `approximate`.\n"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "approximate");
        }
        #[doc = "Approximate location parameters for the search.\n"]
        #[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
        pub struct UserLocation {
            #[builder(default)]
            pub approximate: crate::__types::WebSearchLocation,
        }
        impl<'de> serde::Deserialize<'de> for UserLocation {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct UserLocation { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_chat_completion_request :: web_search_options :: user_location :: Type , # [serde (rename = "approximate")] approximate : crate :: __types :: WebSearchLocation }
                let UserLocation { approximate, .. } = UserLocation::deserialize(deserializer)?;
                Ok(Self { approximate })
            }
        }
        impl serde::Serialize for UserLocation {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct UserLocation < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_chat_completion_request :: web_search_options :: user_location :: Type , # [serde (rename = "approximate")] approximate : & 'a crate :: __types :: WebSearchLocation }
                let Self { approximate } = self;
                UserLocation {
                    r#type: &Default::default(),
                    approximate,
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "This tool searches the web for relevant results to use in a response.\nLearn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct WebSearchOptions {
        #[doc = "Approximate location parameters for the search.\n"]
        #[serde(rename = "user_location")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub user_location: Option<
            crate::__types::create_chat_completion_request::web_search_options::UserLocation,
        >,
        #[serde(rename = "search_context_size")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub search_context_size: Option<crate::__types::WebSearchContextSize>,
    }
    #[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum ResponseFormat {
        Text(crate::__types::ResponseFormatText),
        JsonSchema(crate::__types::ResponseFormatJsonSchema),
        JsonObject(crate::__types::ResponseFormatJsonObject),
    }
    #[allow(clippy::module_inception)]
    pub mod audio {
        #[doc = "Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,\n`opus`, or `pcm16`.\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Format {
            #[doc = "`wav`"]
            #[serde(rename = "wav")]
            Wav,
            #[doc = "`aac`"]
            #[serde(rename = "aac")]
            Aac,
            #[doc = "`mp3`"]
            #[serde(rename = "mp3")]
            Mp3,
            #[doc = "`flac`"]
            #[serde(rename = "flac")]
            Flac,
            #[doc = "`opus`"]
            #[serde(rename = "opus")]
            Opus,
            #[doc = "`pcm16`"]
            #[serde(rename = "pcm16")]
            Pcm16,
        }
    }
    #[doc = "Parameters for audio output. Required when audio output is requested with\n`modalities: [\"audio\"]`. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Audio {
        #[doc = "The voice the model uses to respond. Supported voices are\n`alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`, `nova`, `onyx`, `sage`, and `shimmer`.\n"]
        #[serde(rename = "voice")]
        pub voice: crate::__types::VoiceIdsShared,
        #[doc = "Specifies the output audio format. Must be one of `wav`, `mp3`, `flac`,\n`opus`, or `pcm16`.\n"]
        #[serde(rename = "format")]
        pub format: crate::__types::create_chat_completion_request::audio::Format,
    }
    #[doc = "Configuration for a [Predicted Output](https://platform.openai.com/docs/guides/predicted-outputs),\nwhich can greatly improve response times when large parts of the model\nresponse are known ahead of time. This is most common when you are\nregenerating a file with only minor changes to most of the content.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Prediction {
        PredictionContent(crate::__types::PredictionContent),
    }
    #[allow(clippy::module_inception)]
    pub mod tools {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            Function(crate::__types::ChatCompletionTool),
            Custom(crate::__types::CustomToolChatCompletions),
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod function_call {
        #[doc = "none"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct None;
        impl_serde!(None, "none");
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Deprecated in favor of `tool_choice`.\n\nControls which (if any) function is called by the model.\n\n`none` means the model will not call a function and instead generates a\nmessage.\n\n`auto` means the model can pick between generating a message or calling a\nfunction.\n\nSpecifying a particular function via `{\"name\": \"my_function\"}` forces the\nmodel to call that function.\n\n`none` is the default when no functions are present. `auto` is the default\nif functions are present.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum FunctionCall {
        #[doc = "none"]
        None,
        #[doc = "auto"]
        Auto,
        ChatCompletionFunctionCallOption(crate::__types::ChatCompletionFunctionCallOption),
    }
    impl<'de> serde::Deserialize<'de> for FunctionCall {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum FunctionCall {
                None(crate::__types::create_chat_completion_request::function_call::None),
                Auto(crate::__types::create_chat_completion_request::function_call::Auto),
                ChatCompletionFunctionCallOption(crate::__types::ChatCompletionFunctionCallOption),
            }
            Ok(match FunctionCall::deserialize(deserializer)? {
                FunctionCall::None(_) => Self::None,
                FunctionCall::Auto(_) => Self::Auto,
                FunctionCall::ChatCompletionFunctionCallOption(v) => {
                    Self::ChatCompletionFunctionCallOption(v)
                }
            })
        }
    }
    impl serde::Serialize for FunctionCall {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum FunctionCall<'a> {
                None(crate::__types::create_chat_completion_request::function_call::None),
                Auto(crate::__types::create_chat_completion_request::function_call::Auto),
                ChatCompletionFunctionCallOption(
                    &'a crate::__types::ChatCompletionFunctionCallOption,
                ),
            }
            match self {
                Self::None => FunctionCall::None(Default::default()),
                Self::Auto => FunctionCall::Auto(Default::default()),
                Self::ChatCompletionFunctionCallOption(v) => {
                    FunctionCall::ChatCompletionFunctionCallOption(v)
                }
            }
            .serialize(serializer)
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionRequest {
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<crate::__types::create_chat_completion_request::Text>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"]
    #[serde(rename = "top_logprobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_logprobs: Option<i64>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users. \nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
    #[doc = "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. \nThe IDs should be a string that uniquely identifies each user. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[serde(rename = "safety_identifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub safety_identifier: Option<String>,
    #[doc = "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](https://platform.openai.com/docs/guides/prompt-caching).\n"]
    #[serde(rename = "prompt_cache_key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt_cache_key: Option<String>,
    #[serde(rename = "service_tier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service_tier: Option<crate::__types::ServiceTier>,
    #[doc = "A list of messages comprising the conversation so far. Depending on the\n[model](https://platform.openai.com/docs/models) you use, different message types (modalities) are\nsupported, like [text](https://platform.openai.com/docs/guides/text-generation),\n[images](https://platform.openai.com/docs/guides/vision), and [audio](https://platform.openai.com/docs/guides/audio).\n"]
    #[serde(rename = "messages")]
    pub messages: Vec<crate::__types::ChatCompletionRequestMessage>,
    #[doc = "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\nto browse and compare available models.\n"]
    #[serde(rename = "model")]
    pub model: crate::__types::ModelIdsShared,
    #[serde(rename = "modalities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub modalities: Option<crate::__types::ResponseModalities>,
    #[serde(rename = "reasoning_effort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reasoning_effort: Option<crate::__types::ReasoningEffort>,
    #[doc = "An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\n"]
    #[serde(rename = "max_completion_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_completion_tokens: Option<i64>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on\ntheir existing frequency in the text so far, decreasing the model's\nlikelihood to repeat the same line verbatim.\n"]
    #[serde(rename = "frequency_penalty")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub frequency_penalty: Option<serde_json::Number>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on\nwhether they appear in the text so far, increasing the model's likelihood\nto talk about new topics.\n"]
    #[serde(rename = "presence_penalty")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub presence_penalty: Option<serde_json::Number>,
    #[doc = "This tool searches the web for relevant results to use in a response.\nLearn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search?api-mode=chat).\n"]
    #[serde(rename = "web_search_options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub web_search_options:
        Option<crate::__types::create_chat_completion_request::WebSearchOptions>,
    #[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::create_chat_completion_request::ResponseFormat>,
    #[doc = "Parameters for audio output. Required when audio output is requested with\n`modalities: [\"audio\"]`. [Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[serde(rename = "audio")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub audio: Option<crate::__types::create_chat_completion_request::Audio>,
    #[doc = "Whether or not to store the output of this chat completion request for\nuse in our [model distillation](https://platform.openai.com/docs/guides/distillation) or\n[evals](https://platform.openai.com/docs/guides/evals) products.\n\nSupports text and image inputs. Note: image inputs over 10MB will be dropped.\n"]
    #[serde(rename = "store")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub store: Option<bool>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](https://platform.openai.com/docs/api-reference/chat/streaming)\nfor more information, along with the [streaming responses](https://platform.openai.com/docs/guides/streaming-responses)\nguide for more information on how to handle the streaming events.\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
    #[serde(rename = "stop")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stop: Option<crate::__types::StopConfiguration>,
    #[doc = "Modify the likelihood of specified tokens appearing in the completion.\n\nAccepts a JSON object that maps tokens (specified by their token ID in the\ntokenizer) to an associated bias value from -100 to 100. Mathematically,\nthe bias is added to the logits generated by the model prior to sampling.\nThe exact effect will vary per model, but values between -1 and 1 should\ndecrease or increase likelihood of selection; values like -100 or 100\nshould result in a ban or exclusive selection of the relevant token.\n"]
    #[serde(rename = "logit_bias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logit_bias: Option<indexmap::IndexMap<String, i64>>,
    #[doc = "Whether to return log probabilities of the output tokens or not. If true,\nreturns the log probabilities of each output token returned in the\n`content` of `message`.\n"]
    #[serde(rename = "logprobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logprobs: Option<bool>,
    #[doc = "The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the\nchat completion. This value can be used to control\n[costs](https://openai.com/api/pricing/) for text generated via API.\n\nThis value is now deprecated in favor of `max_completion_tokens`, and is\nnot compatible with [o-series models](https://platform.openai.com/docs/guides/reasoning).\n"]
    #[serde(rename = "max_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_tokens: Option<i64>,
    #[doc = "How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep `n` as `1` to minimize costs."]
    #[serde(rename = "n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub n: Option<i64>,
    #[doc = "Configuration for a [Predicted Output](https://platform.openai.com/docs/guides/predicted-outputs),\nwhich can greatly improve response times when large parts of the model\nresponse are known ahead of time. This is most common when you are\nregenerating a file with only minor changes to most of the content.\n"]
    #[serde(rename = "prediction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prediction: Option<crate::__types::create_chat_completion_request::Prediction>,
    #[doc = "This feature is in Beta.\nIf specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.\nDeterminism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.\n"]
    #[serde(rename = "seed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seed: Option<i64>,
    #[serde(rename = "stream_options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream_options: Option<crate::__types::ChatCompletionStreamOptions>,
    #[doc = "A list of tools the model may call. You can provide either\n[custom tools](https://platform.openai.com/docs/guides/function-calling#custom-tools) or\n[function tools](https://platform.openai.com/docs/guides/function-calling).\n"]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::create_chat_completion_request::tools::Item>>,
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<crate::__types::ChatCompletionToolChoiceOption>,
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parallel_tool_calls: Option<crate::__types::ParallelToolCalls>,
    #[doc = "Deprecated in favor of `tool_choice`.\n\nControls which (if any) function is called by the model.\n\n`none` means the model will not call a function and instead generates a\nmessage.\n\n`auto` means the model can pick between generating a message or calling a\nfunction.\n\nSpecifying a particular function via `{\"name\": \"my_function\"}` forces the\nmodel to call that function.\n\n`none` is the default when no functions are present. `auto` is the default\nif functions are present.\n"]
    #[serde(rename = "function_call")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub function_call: Option<crate::__types::create_chat_completion_request::FunctionCall>,
    #[doc = "Deprecated in favor of `tools`.\n\nA list of functions the model may generate JSON inputs for.\n"]
    #[serde(rename = "functions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub functions: Option<Vec<crate::__types::ChatCompletionFunctions>>,
    #[serde(rename = "verbosity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub verbosity: Option<crate::__types::Verbosity>,
}
#[allow(clippy::module_inception)]
pub mod create_chat_completion_response {
    #[allow(clippy::module_inception)]
    pub mod choices {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum FinishReason {
                #[doc = "`stop`"]
                #[serde(rename = "stop")]
                Stop,
                #[doc = "`length`"]
                #[serde(rename = "length")]
                Length,
                #[doc = "`tool_calls`"]
                #[serde(rename = "tool_calls")]
                ToolCalls,
                #[doc = "`content_filter`"]
                #[serde(rename = "content_filter")]
                ContentFilter,
                #[doc = "`function_call`"]
                #[serde(rename = "function_call")]
                FunctionCall,
            }
            #[doc = "Log probability information for the choice."]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Logprobs {
                #[doc = "A list of message content tokens with log probability information."]
                #[serde(rename = "content")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub content: Option<Vec<crate::__types::ChatCompletionTokenLogprob>>,
                #[doc = "A list of message refusal tokens with log probability information."]
                #[serde(rename = "refusal")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub refusal: Option<Vec<crate::__types::ChatCompletionTokenLogprob>>,
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
            #[serde(rename = "finish_reason")]
            pub finish_reason:
                crate::__types::create_chat_completion_response::choices::item::FinishReason,
            #[doc = "The index of the choice in the list of choices."]
            #[serde(rename = "index")]
            pub index: i64,
            #[serde(rename = "message")]
            #[builder(default)]
            pub message: crate::__types::ChatCompletionResponseMessage,
            #[doc = "Log probability information for the choice."]
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub logprobs:
                Option<crate::__types::create_chat_completion_response::choices::item::Logprobs>,
        }
    }
    #[doc = "The object type, which is always `chat.completion`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "chat.completion");
}
#[doc = "Represents a chat completion response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionResponse {
    #[doc = "A unique identifier for the chat completion."]
    pub id: String,
    #[doc = "A list of chat completion choices. Can be more than one if `n` is greater than 1."]
    pub choices: Vec<crate::__types::create_chat_completion_response::choices::Item>,
    #[doc = "The Unix timestamp (in seconds) of when the chat completion was created."]
    pub created: i64,
    #[doc = "The model used for the chat completion."]
    pub model: String,
    #[builder(default)]
    pub service_tier: Option<crate::__types::ServiceTier>,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\n\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[builder(default)]
    pub usage: Option<crate::__types::CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "choices")]
            choices: Vec<crate::__types::create_chat_completion_response::choices::Item>,
            #[serde(rename = "created")]
            created: i64,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "service_tier")]
            service_tier: Option<crate::__types::ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::create_chat_completion_response::Object,
            #[serde(rename = "usage")]
            usage: Option<crate::__types::CompletionUsage>,
        }
        let CreateChatCompletionResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
            ..
        } = CreateChatCompletionResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateChatCompletionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<crate::__types::create_chat_completion_response::choices::Item>,
            #[serde(rename = "created")]
            created: &'a i64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<crate::__types::ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a crate::__types::create_chat_completion_response::Object,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<crate::__types::CompletionUsage>,
        }
        let Self {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        } = self;
        CreateChatCompletionResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod create_chat_completion_stream_response {
    #[allow(clippy::module_inception)]
    pub mod choices {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "Log probability information for the choice."]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Logprobs {
                #[doc = "A list of message content tokens with log probability information."]
                #[serde(rename = "content")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub content: Option<Vec<crate::__types::ChatCompletionTokenLogprob>>,
                #[doc = "A list of message refusal tokens with log probability information."]
                #[serde(rename = "refusal")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub refusal: Option<Vec<crate::__types::ChatCompletionTokenLogprob>>,
            }
            #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum FinishReason {
                #[doc = "`stop`"]
                #[serde(rename = "stop")]
                Stop,
                #[doc = "`length`"]
                #[serde(rename = "length")]
                Length,
                #[doc = "`tool_calls`"]
                #[serde(rename = "tool_calls")]
                ToolCalls,
                #[doc = "`content_filter`"]
                #[serde(rename = "content_filter")]
                ContentFilter,
                #[doc = "`function_call`"]
                #[serde(rename = "function_call")]
                FunctionCall,
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[serde(rename = "delta")]
            #[builder(default)]
            pub delta: crate::__types::ChatCompletionStreamResponseDelta,
            #[doc = "Log probability information for the choice."]
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub logprobs: Option<
                crate::__types::create_chat_completion_stream_response::choices::item::Logprobs,
            >,
            #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\n`content_filter` if content was omitted due to a flag from our content filters,\n`tool_calls` if the model called a tool, or `function_call` (deprecated) if the model called a function.\n"]
            #[serde(rename = "finish_reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub finish_reason: Option<
                crate::__types::create_chat_completion_stream_response::choices::item::FinishReason,
            >,
            #[doc = "The index of the choice in the list of choices."]
            #[serde(rename = "index")]
            pub index: i64,
        }
    }
    #[doc = "The object type, which is always `chat.completion.chunk`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "chat.completion.chunk");
}
#[doc = "Represents a streamed chunk of a chat completion response returned\nby the model, based on the provided input. \n[Learn more](https://platform.openai.com/docs/guides/streaming-responses).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateChatCompletionStreamResponse {
    #[doc = "A unique identifier for the chat completion. Each chunk has the same ID."]
    pub id: String,
    #[doc = "A list of chat completion choices. Can contain more than one elements if `n` is greater than 1. Can also be empty for the\nlast chunk if you set `stream_options: {\"include_usage\": true}`.\n"]
    pub choices: Vec<crate::__types::create_chat_completion_stream_response::choices::Item>,
    #[doc = "The Unix timestamp (in seconds) of when the chat completion was created. Each chunk has the same timestamp."]
    pub created: i64,
    #[doc = "The model to generate the completion."]
    pub model: String,
    #[builder(default)]
    pub service_tier: Option<crate::__types::ServiceTier>,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[doc = "An optional field that will only be present when you set\n`stream_options: {\"include_usage\": true}` in your request. When present, it\ncontains a null value **except for the last chunk** which contains the\ntoken usage statistics for the entire request.\n\n**NOTE:** If the stream is interrupted or cancelled, you may not\nreceive the final usage chunk which contains the total token usage for\nthe request.\n"]
    #[builder(default)]
    pub usage: Option<crate::__types::CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateChatCompletionStreamResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateChatCompletionStreamResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "choices")]
            choices: Vec<crate::__types::create_chat_completion_stream_response::choices::Item>,
            #[serde(rename = "created")]
            created: i64,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "service_tier")]
            service_tier: Option<crate::__types::ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::create_chat_completion_stream_response::Object,
            #[serde(rename = "usage")]
            usage: Option<crate::__types::CompletionUsage>,
        }
        let CreateChatCompletionStreamResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
            ..
        } = CreateChatCompletionStreamResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateChatCompletionStreamResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateChatCompletionStreamResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<crate::__types::create_chat_completion_stream_response::choices::Item>,
            #[serde(rename = "created")]
            created: &'a i64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<crate::__types::ServiceTier>,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a crate::__types::create_chat_completion_stream_response::Object,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<crate::__types::CompletionUsage>,
        }
        let Self {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            usage,
        } = self;
        CreateChatCompletionStreamResponse {
            id,
            choices,
            created,
            model,
            service_tier,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod create_completion_request {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "gpt-3.5-turbo-instruct"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5TurboInstruct;
        impl_serde!(Gpt3_5TurboInstruct, "gpt-3.5-turbo-instruct");
        #[doc = "davinci-002"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Davinci002;
        impl_serde!(Davinci002, "davinci-002");
        #[doc = "babbage-002"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Babbage002;
        impl_serde!(Babbage002, "babbage-002");
    }
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "gpt-3.5-turbo-instruct"]
        Gpt3_5TurboInstruct,
        #[doc = "davinci-002"]
        Davinci002,
        #[doc = "babbage-002"]
        Babbage002,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                Gpt3_5TurboInstruct(
                    crate::__types::create_completion_request::model::Gpt3_5TurboInstruct,
                ),
                Davinci002(crate::__types::create_completion_request::model::Davinci002),
                Babbage002(crate::__types::create_completion_request::model::Babbage002),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::Gpt3_5TurboInstruct(_) => Self::Gpt3_5TurboInstruct,
                Model::Davinci002(_) => Self::Davinci002,
                Model::Babbage002(_) => Self::Babbage002,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                Gpt3_5TurboInstruct(
                    crate::__types::create_completion_request::model::Gpt3_5TurboInstruct,
                ),
                Davinci002(crate::__types::create_completion_request::model::Davinci002),
                Babbage002(crate::__types::create_completion_request::model::Babbage002),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::Gpt3_5TurboInstruct => Model::Gpt3_5TurboInstruct(Default::default()),
                Self::Davinci002 => Model::Davinci002(Default::default()),
                Self::Babbage002 => Model::Babbage002(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.\n\nNote that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Prompt {
        String(String),
        ArrayOfString(Vec<String>),
        ArrayOfInteger(Vec<i64>),
        ArrayOfArray(Vec<Vec<i64>>),
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateCompletionRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[serde(rename = "model")]
    pub model: crate::__types::create_completion_request::Model,
    #[doc = "The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.\n\nNote that <|endoftext|> is the document separator that the model sees during training, so if a prompt is not specified the model will generate as if from the beginning of a new document.\n"]
    #[serde(rename = "prompt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt: Option<crate::__types::create_completion_request::Prompt>,
    #[doc = "Generates `best_of` completions server-side and returns the \"best\" (the one with the highest log probability per token). Results cannot be streamed.\n\nWhen used with `n`, `best_of` controls the number of candidate completions and `n` specifies how many to return  `best_of` must be greater than `n`.\n\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.\n"]
    #[serde(rename = "best_of")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub best_of: Option<i64>,
    #[doc = "Echo back the prompt in addition to the completion\n"]
    #[serde(rename = "echo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub echo: Option<bool>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.\n\n[See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation)\n"]
    #[serde(rename = "frequency_penalty")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub frequency_penalty: Option<serde_json::Number>,
    #[doc = "Modify the likelihood of specified tokens appearing in the completion.\n\nAccepts a JSON object that maps tokens (specified by their token ID in the GPT tokenizer) to an associated bias value from -100 to 100. You can use this [tokenizer tool](https://platform.openai.com/tokenizer?view=bpe) to convert text to token IDs. Mathematically, the bias is added to the logits generated by the model prior to sampling. The exact effect will vary per model, but values between -1 and 1 should decrease or increase likelihood of selection; values like -100 or 100 should result in a ban or exclusive selection of the relevant token.\n\nAs an example, you can pass `{\"50256\": -100}` to prevent the <|endoftext|> token from being generated.\n"]
    #[serde(rename = "logit_bias")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logit_bias: Option<indexmap::IndexMap<String, i64>>,
    #[doc = "Include the log probabilities on the `logprobs` most likely output tokens, as well the chosen tokens. For example, if `logprobs` is 5, the API will return a list of the 5 most likely tokens. The API will always return the `logprob` of the sampled token, so there may be up to `logprobs+1` elements in the response.\n\nThe maximum value for `logprobs` is 5.\n"]
    #[serde(rename = "logprobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logprobs: Option<i64>,
    #[doc = "The maximum number of [tokens](https://platform.openai.com/tokenizer) that can be generated in the completion.\n\nThe token count of your prompt plus `max_tokens` cannot exceed the model's context length. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens.\n"]
    #[serde(rename = "max_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_tokens: Option<i64>,
    #[doc = "How many completions to generate for each prompt.\n\n**Note:** Because this parameter generates many completions, it can quickly consume your token quota. Use carefully and ensure that you have reasonable settings for `max_tokens` and `stop`.\n"]
    #[serde(rename = "n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub n: Option<i64>,
    #[doc = "Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.\n\n[See more information about frequency and presence penalties.](https://platform.openai.com/docs/guides/text-generation)\n"]
    #[serde(rename = "presence_penalty")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub presence_penalty: Option<serde_json::Number>,
    #[doc = "If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same `seed` and parameters should return the same result.\n\nDeterminism is not guaranteed, and you should refer to the `system_fingerprint` response parameter to monitor changes in the backend.\n"]
    #[serde(rename = "seed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seed: Option<i64>,
    #[serde(rename = "stop")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stop: Option<crate::__types::StopConfiguration>,
    #[doc = "Whether to stream back partial progress. If set, tokens will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available, with the stream terminated by a `data: [DONE]` message. [Example Python code](https://cookbook.openai.com/examples/how_to_stream_completions).\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
    #[serde(rename = "stream_options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream_options: Option<crate::__types::ChatCompletionStreamOptions>,
    #[doc = "The suffix that comes after a completion of inserted text.\n\nThis parameter is only supported for `gpt-3.5-turbo-instruct`.\n"]
    #[serde(rename = "suffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub suffix: Option<String>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod create_completion_response {
    #[allow(clippy::module_inception)]
    pub mod choices {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\nor `content_filter` if content was omitted due to a flag from our content filters.\n"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum FinishReason {
                #[doc = "`stop`"]
                #[serde(rename = "stop")]
                Stop,
                #[doc = "`length`"]
                #[serde(rename = "length")]
                Length,
                #[doc = "`content_filter`"]
                #[serde(rename = "content_filter")]
                ContentFilter,
            }
            #[derive(Clone, Debug, Default, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Logprobs {
                #[serde(rename = "text_offset")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub text_offset: Option<Vec<i64>>,
                #[serde(rename = "token_logprobs")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub token_logprobs: Option<Vec<serde_json::Number>>,
                #[serde(rename = "tokens")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub tokens: Option<Vec<String>>,
                #[serde(rename = "top_logprobs")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub top_logprobs: Option<Vec<indexmap::IndexMap<String, serde_json::Number>>>,
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The reason the model stopped generating tokens. This will be `stop` if the model hit a natural stop point or a provided stop sequence,\n`length` if the maximum number of tokens specified in the request was reached,\nor `content_filter` if content was omitted due to a flag from our content filters.\n"]
            #[serde(rename = "finish_reason")]
            pub finish_reason:
                crate::__types::create_completion_response::choices::item::FinishReason,
            #[serde(rename = "index")]
            pub index: i64,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub logprobs:
                Option<crate::__types::create_completion_response::choices::item::Logprobs>,
            #[serde(rename = "text")]
            pub text: String,
        }
    }
    #[doc = "The object type, which is always \"text_completion\""]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "text_completion");
}
#[doc = "Represents a completion response from the API. Note: both the streamed and non-streamed response objects share the same shape (unlike the chat endpoint).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateCompletionResponse {
    #[doc = "A unique identifier for the completion."]
    pub id: String,
    #[doc = "The list of completion choices the model generated for the input prompt."]
    pub choices: Vec<crate::__types::create_completion_response::choices::Item>,
    #[doc = "The Unix timestamp (in seconds) of when the completion was created."]
    pub created: i64,
    #[doc = "The model used for completion."]
    pub model: String,
    #[doc = "This fingerprint represents the backend configuration that the model runs with.\n\nCan be used in conjunction with the `seed` request parameter to understand when backend changes have been made that might impact determinism.\n"]
    #[builder(default)]
    pub system_fingerprint: Option<String>,
    #[builder(default)]
    pub usage: Option<crate::__types::CompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for CreateCompletionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateCompletionResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "choices")]
            choices: Vec<crate::__types::create_completion_response::choices::Item>,
            #[serde(rename = "created")]
            created: i64,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "system_fingerprint")]
            system_fingerprint: Option<String>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::create_completion_response::Object,
            #[serde(rename = "usage")]
            usage: Option<crate::__types::CompletionUsage>,
        }
        let CreateCompletionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
            ..
        } = CreateCompletionResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
        })
    }
}
impl serde::Serialize for CreateCompletionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateCompletionResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "choices")]
            choices: &'a Vec<crate::__types::create_completion_response::choices::Item>,
            #[serde(rename = "created")]
            created: &'a i64,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "system_fingerprint")]
            #[serde(skip_serializing_if = "Option::is_none")]
            system_fingerprint: &'a Option<String>,
            #[serde(rename = "object")]
            object: &'a crate::__types::create_completion_response::Object,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<crate::__types::CompletionUsage>,
        }
        let Self {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            usage,
        } = self;
        CreateCompletionResponse {
            id,
            choices,
            created,
            model,
            system_fingerprint,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod create_container_body {
    #[allow(clippy::module_inception)]
    pub mod expires_after {
        #[doc = "Time anchor for the expiration time. Currently only 'last_active_at' is supported."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Anchor {
            #[doc = "`last_active_at`"]
            #[serde(rename = "last_active_at")]
            LastActiveAt,
        }
    }
    #[doc = "Container expiration time in seconds relative to the 'anchor' time."]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ExpiresAfter {
        #[doc = "Time anchor for the expiration time. Currently only 'last_active_at' is supported."]
        #[serde(rename = "anchor")]
        pub anchor: crate::__types::create_container_body::expires_after::Anchor,
        #[serde(rename = "minutes")]
        pub minutes: i64,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateContainerBody {
    #[doc = "Name of the container to create."]
    #[serde(rename = "name")]
    pub name: String,
    #[doc = "IDs of files to copy to the container."]
    #[serde(rename = "file_ids")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "Container expiration time in seconds relative to the 'anchor' time."]
    #[serde(rename = "expires_after")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expires_after: Option<crate::__types::create_container_body::ExpiresAfter>,
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateContainerFileBody {
    #[doc = "Name of the file to create."]
    #[serde(rename = "file_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The File object (not file name) to be uploaded.\n"]
    #[serde_as(as = "Option<serde_with::base64::Base64>")]
    #[serde(rename = "file")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub file: Option<Vec<u8>>,
}
#[allow(clippy::module_inception)]
pub mod create_embedding_request {
    #[doc = "Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for all embedding models), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. In addition to the per-input token limit, all embedding  models enforce a maximum of 300,000 tokens summed across all inputs in a  single request.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Input {
        #[doc = "The string that will be turned into an embedding."]
        String(String),
        #[doc = "The array of strings that will be turned into an embedding."]
        ArrayOfString(Vec<String>),
        #[doc = "The array of integers that will be turned into an embedding."]
        ArrayOfInteger(Vec<i64>),
        #[doc = "The array of arrays containing integers that will be turned into an embedding."]
        ArrayOfArray(Vec<Vec<i64>>),
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "text-embedding-ada-002"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct TextEmbeddingAda002;
        impl_serde!(TextEmbeddingAda002, "text-embedding-ada-002");
        #[doc = "text-embedding-3-small"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct TextEmbedding3Small;
        impl_serde!(TextEmbedding3Small, "text-embedding-3-small");
        #[doc = "text-embedding-3-large"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct TextEmbedding3Large;
        impl_serde!(TextEmbedding3Large, "text-embedding-3-large");
    }
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "text-embedding-ada-002"]
        TextEmbeddingAda002,
        #[doc = "text-embedding-3-small"]
        TextEmbedding3Small,
        #[doc = "text-embedding-3-large"]
        TextEmbedding3Large,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                TextEmbeddingAda002(
                    crate::__types::create_embedding_request::model::TextEmbeddingAda002,
                ),
                TextEmbedding3Small(
                    crate::__types::create_embedding_request::model::TextEmbedding3Small,
                ),
                TextEmbedding3Large(
                    crate::__types::create_embedding_request::model::TextEmbedding3Large,
                ),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::TextEmbeddingAda002(_) => Self::TextEmbeddingAda002,
                Model::TextEmbedding3Small(_) => Self::TextEmbedding3Small,
                Model::TextEmbedding3Large(_) => Self::TextEmbedding3Large,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                TextEmbeddingAda002(
                    crate::__types::create_embedding_request::model::TextEmbeddingAda002,
                ),
                TextEmbedding3Small(
                    crate::__types::create_embedding_request::model::TextEmbedding3Small,
                ),
                TextEmbedding3Large(
                    crate::__types::create_embedding_request::model::TextEmbedding3Large,
                ),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::TextEmbeddingAda002 => Model::TextEmbeddingAda002(Default::default()),
                Self::TextEmbedding3Small => Model::TextEmbedding3Small(Default::default()),
                Self::TextEmbedding3Large => Model::TextEmbedding3Large(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/)."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum EncodingFormat {
        #[doc = "`float`"]
        #[default]
        #[serde(rename = "float")]
        Float,
        #[doc = "`base64`"]
        #[serde(rename = "base64")]
        Base64,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateEmbeddingRequest {
    #[doc = "Input text to embed, encoded as a string or array of tokens. To embed multiple inputs in a single request, pass an array of strings or array of token arrays. The input must not exceed the max input tokens for the model (8192 tokens for all embedding models), cannot be an empty string, and any array must be 2048 dimensions or less. [Example Python code](https://cookbook.openai.com/examples/how_to_count_tokens_with_tiktoken) for counting tokens. In addition to the per-input token limit, all embedding  models enforce a maximum of 300,000 tokens summed across all inputs in a  single request.\n"]
    #[serde(rename = "input")]
    pub input: crate::__types::create_embedding_request::Input,
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[serde(rename = "model")]
    pub model: crate::__types::create_embedding_request::Model,
    #[doc = "The format to return the embeddings in. Can be either `float` or [`base64`](https://pypi.org/project/pybase64/)."]
    #[serde(rename = "encoding_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub encoding_format: Option<crate::__types::create_embedding_request::EncodingFormat>,
    #[doc = "The number of dimensions the resulting output embeddings should have. Only supported in `text-embedding-3` and later models.\n"]
    #[serde(rename = "dimensions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dimensions: Option<i64>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod create_embedding_response {
    #[doc = "The object type, which is always \"list\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
    #[doc = "The usage information for the request."]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Usage {
        #[doc = "The number of tokens used by the prompt."]
        #[serde(rename = "prompt_tokens")]
        pub prompt_tokens: i64,
        #[doc = "The total number of tokens used by the request."]
        #[serde(rename = "total_tokens")]
        pub total_tokens: i64,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEmbeddingResponse {
    #[doc = "The list of embeddings generated by the model."]
    pub data: Vec<crate::__types::Embedding>,
    #[doc = "The name of the model used to generate the embedding."]
    pub model: String,
    #[doc = "The usage information for the request."]
    pub usage: crate::__types::create_embedding_response::Usage,
}
impl<'de> serde::Deserialize<'de> for CreateEmbeddingResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEmbeddingResponse {
            #[serde(rename = "data")]
            data: Vec<crate::__types::Embedding>,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::create_embedding_response::Object,
            #[serde(rename = "usage")]
            usage: crate::__types::create_embedding_response::Usage,
        }
        let CreateEmbeddingResponse {
            data, model, usage, ..
        } = CreateEmbeddingResponse::deserialize(deserializer)?;
        Ok(Self { data, model, usage })
    }
}
impl serde::Serialize for CreateEmbeddingResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEmbeddingResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::Embedding>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::create_embedding_response::Object,
            #[serde(rename = "usage")]
            usage: &'a crate::__types::create_embedding_response::Usage,
        }
        let Self { data, model, usage } = self;
        CreateEmbeddingResponse {
            data,
            model,
            object: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod create_eval_completions_run_data_source {
    #[doc = "The type of run data source. Always `completions`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "completions");
    #[allow(clippy::module_inception)]
    pub mod input_messages {
        #[allow(clippy::module_inception)]
        pub mod template {
            #[doc = "The type of input messages. Always `template`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "template");
            #[allow(clippy::module_inception)]
            pub mod template {
                #[derive(Clone, Debug, PartialEq)]
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize, serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::large_enum_variant)]
                pub enum Item {
                    EasyInputMessage(crate::__types::EasyInputMessage),
                    EvalItem(crate::__types::EvalItem),
                }
            }
        }
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct Template { # [doc = "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."] pub template : Vec < crate :: __types :: create_eval_completions_run_data_source :: input_messages :: template :: template :: Item > }
        impl<'de> serde::Deserialize<'de> for Template {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct Template { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_eval_completions_run_data_source :: input_messages :: template :: Type , # [serde (rename = "template")] template : Vec < crate :: __types :: create_eval_completions_run_data_source :: input_messages :: template :: template :: Item > }
                let Template { template, .. } = Template::deserialize(deserializer)?;
                Ok(Self { template })
            }
        }
        impl serde::Serialize for Template {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct Template < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_eval_completions_run_data_source :: input_messages :: template :: Type , # [serde (rename = "template")] template : & 'a Vec < crate :: __types :: create_eval_completions_run_data_source :: input_messages :: template :: template :: Item > }
                let Self { template } = self;
                Template {
                    r#type: &Default::default(),
                    template,
                }
                .serialize(serializer)
            }
        }
        #[allow(clippy::module_inception)]
        pub(crate) mod item_reference {
            #[doc = "The type of input messages. Always `item_reference`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "item_reference");
        }
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct ItemReference {
            #[doc = "A reference to a variable in the `item` namespace. Ie, \"item.input_trajectory\""]
            pub item_reference: String,
        }
        impl<'de> serde::Deserialize<'de> for ItemReference {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct ItemReference { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_eval_completions_run_data_source :: input_messages :: item_reference :: Type , # [serde (rename = "item_reference")] item_reference : String }
                let ItemReference { item_reference, .. } =
                    ItemReference::deserialize(deserializer)?;
                Ok(Self { item_reference })
            }
        }
        impl serde::Serialize for ItemReference {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct ItemReference < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_eval_completions_run_data_source :: input_messages :: item_reference :: Type , # [serde (rename = "item_reference")] item_reference : & 'a String }
                let Self { item_reference } = self;
                ItemReference {
                    r#type: &Default::default(),
                    item_reference,
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum InputMessages {
        Template(crate::__types::create_eval_completions_run_data_source::input_messages::Template),
        ItemReference(
            crate::__types::create_eval_completions_run_data_source::input_messages::ItemReference,
        ),
    }
    #[allow(clippy::module_inception)]
    pub mod sampling_params {
        #[doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum ResponseFormat {
            Text(crate::__types::ResponseFormatText),
            JsonSchema(crate::__types::ResponseFormatJsonSchema),
            JsonObject(crate::__types::ResponseFormatJsonObject),
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct SamplingParams { # [doc = "A higher temperature increases randomness in the outputs."] # [serde (rename = "temperature")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub temperature : Option < serde_json :: Number > , # [doc = "The maximum number of tokens in the generated output."] # [serde (rename = "max_completion_tokens")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub max_completion_tokens : Option < i64 > , # [doc = "An alternative to temperature for nucleus sampling; 1.0 includes all tokens."] # [serde (rename = "top_p")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub top_p : Option < serde_json :: Number > , # [doc = "A seed value to initialize the randomness, during sampling."] # [serde (rename = "seed")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub seed : Option < i64 > , # [doc = "An object specifying the format that the model must output.\n\nSetting to `{ \"type\": \"json_schema\", \"json_schema\": {...} }` enables\nStructured Outputs which ensures the model will match your supplied JSON\nschema. Learn more in the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"] # [serde (rename = "response_format")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub response_format : Option < crate :: __types :: create_eval_completions_run_data_source :: sampling_params :: ResponseFormat > , # [doc = "A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for. A max of 128 functions are supported.\n"] # [serde (rename = "tools")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub tools : Option < Vec < crate :: __types :: ChatCompletionTool > > }
    #[doc = "Determines what populates the `item` namespace in this run's data source."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Source {
        FileContent(crate::__types::EvalJsonlFileContentSource),
        FileId(crate::__types::EvalJsonlFileIdSource),
        StoredCompletions(crate::__types::EvalStoredCompletionsSource),
    }
}
#[doc = "A CompletionsRunDataSource object describing a model sampling configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCompletionsRunDataSource {
    #[doc = "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."]
    #[builder(default)]
    pub input_messages:
        Option<crate::__types::create_eval_completions_run_data_source::InputMessages>,
    #[builder(default)]
    pub sampling_params:
        Option<crate::__types::create_eval_completions_run_data_source::SamplingParams>,
    #[doc = "The name of the model to use for generating completions (e.g. \"o3-mini\")."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Determines what populates the `item` namespace in this run's data source."]
    pub source: crate::__types::create_eval_completions_run_data_source::Source,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCompletionsRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalCompletionsRunDataSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::create_eval_completions_run_data_source::Type,
            #[serde(rename = "input_messages")]
            input_messages:
                Option<crate::__types::create_eval_completions_run_data_source::InputMessages>,
            #[serde(rename = "sampling_params")]
            sampling_params:
                Option<crate::__types::create_eval_completions_run_data_source::SamplingParams>,
            #[serde(rename = "model")]
            model: Option<String>,
            #[serde(rename = "source")]
            source: crate::__types::create_eval_completions_run_data_source::Source,
        }
        let CreateEvalCompletionsRunDataSource {
            input_messages,
            sampling_params,
            model,
            source,
            ..
        } = CreateEvalCompletionsRunDataSource::deserialize(deserializer)?;
        Ok(Self {
            input_messages,
            sampling_params,
            model,
            source,
        })
    }
}
impl serde::Serialize for CreateEvalCompletionsRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalCompletionsRunDataSource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::create_eval_completions_run_data_source::Type,
            #[serde(rename = "input_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_messages:
                &'a Option<crate::__types::create_eval_completions_run_data_source::InputMessages>,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params:
                &'a Option<crate::__types::create_eval_completions_run_data_source::SamplingParams>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "source")]
            source: &'a crate::__types::create_eval_completions_run_data_source::Source,
        }
        let Self {
            input_messages,
            sampling_params,
            model,
            source,
        } = self;
        CreateEvalCompletionsRunDataSource {
            r#type: &Default::default(),
            input_messages,
            sampling_params,
            model,
            source,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod create_eval_custom_data_source_config {
    #[doc = "The type of data source. Always `custom`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom");
}
#[doc = "A CustomDataSourceConfig object that defines the schema for the data source used for the evaluation runs.\nThis schema is used to define the shape of the data that will be:\n- Used to define your testing criteria and\n- What data is required when creating a run\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalCustomDataSourceConfig {
    #[doc = "The json schema for each row in the data source."]
    pub item_schema: indexmap::IndexMap<String, serde_json::Value>,
    #[doc = "Whether the eval should expect you to populate the sample namespace (ie, by generating responses off of your data source)"]
    #[builder(default)]
    pub include_sample_schema: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalCustomDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalCustomDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::create_eval_custom_data_source_config::Type,
            #[serde(rename = "item_schema")]
            item_schema: indexmap::IndexMap<String, serde_json::Value>,
            #[serde(rename = "include_sample_schema")]
            include_sample_schema: Option<bool>,
        }
        let CreateEvalCustomDataSourceConfig {
            item_schema,
            include_sample_schema,
            ..
        } = CreateEvalCustomDataSourceConfig::deserialize(deserializer)?;
        Ok(Self {
            item_schema,
            include_sample_schema,
        })
    }
}
impl serde::Serialize for CreateEvalCustomDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalCustomDataSourceConfig<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::create_eval_custom_data_source_config::Type,
            #[serde(rename = "item_schema")]
            item_schema: &'a indexmap::IndexMap<String, serde_json::Value>,
            #[serde(rename = "include_sample_schema")]
            #[serde(skip_serializing_if = "Option::is_none")]
            include_sample_schema: &'a Option<bool>,
        }
        let Self {
            item_schema,
            include_sample_schema,
        } = self;
        CreateEvalCustomDataSourceConfig {
            r#type: &Default::default(),
            item_schema,
            include_sample_schema,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod create_eval_item {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Variant0 {
        #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
        #[serde(rename = "role")]
        pub role: String,
        #[doc = "The content of the message."]
        #[serde(rename = "content")]
        pub content: String,
    }
}
#[doc = "A chat message that makes up the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum CreateEvalItem {
    Variant0(crate::__types::create_eval_item::Variant0),
    EvalItem(crate::__types::EvalItem),
}
#[allow(clippy::module_inception)]
pub mod create_eval_jsonl_run_data_source {
    #[doc = "The type of data source. Always `jsonl`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "jsonl");
    #[doc = "Determines what populates the `item` namespace in the data source."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Source {
        FileContent(crate::__types::EvalJsonlFileContentSource),
        FileId(crate::__types::EvalJsonlFileIdSource),
    }
}
#[doc = "A JsonlRunDataSource object with that specifies a JSONL file that matches the eval \n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalJsonlRunDataSource {
    #[doc = "Determines what populates the `item` namespace in the data source."]
    pub source: crate::__types::create_eval_jsonl_run_data_source::Source,
}
impl<'de> serde::Deserialize<'de> for CreateEvalJsonlRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalJsonlRunDataSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::create_eval_jsonl_run_data_source::Type,
            #[serde(rename = "source")]
            source: crate::__types::create_eval_jsonl_run_data_source::Source,
        }
        let CreateEvalJsonlRunDataSource { source, .. } =
            CreateEvalJsonlRunDataSource::deserialize(deserializer)?;
        Ok(Self { source })
    }
}
impl serde::Serialize for CreateEvalJsonlRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalJsonlRunDataSource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::create_eval_jsonl_run_data_source::Type,
            #[serde(rename = "source")]
            source: &'a crate::__types::create_eval_jsonl_run_data_source::Source,
        }
        let Self { source } = self;
        CreateEvalJsonlRunDataSource {
            r#type: &Default::default(),
            source,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod create_eval_label_model_grader {
    #[doc = "The object type, which is always `label_model`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "label_model");
}
#[doc = "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalLabelModelGrader {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation. Must support structured outputs."]
    pub model: String,
    #[doc = "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."]
    pub input: Vec<crate::__types::CreateEvalItem>,
    #[doc = "The labels to classify to each item in the evaluation."]
    pub labels: Vec<String>,
    #[doc = "The labels that indicate a passing result. Must be a subset of labels."]
    pub passing_labels: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalLabelModelGrader {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalLabelModelGrader {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::create_eval_label_model_grader::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "input")]
            input: Vec<crate::__types::CreateEvalItem>,
            #[serde(rename = "labels")]
            labels: Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: Vec<String>,
        }
        let CreateEvalLabelModelGrader {
            name,
            model,
            input,
            labels,
            passing_labels,
            ..
        } = CreateEvalLabelModelGrader::deserialize(deserializer)?;
        Ok(Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        })
    }
}
impl serde::Serialize for CreateEvalLabelModelGrader {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalLabelModelGrader<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::create_eval_label_model_grader::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a Vec<crate::__types::CreateEvalItem>,
            #[serde(rename = "labels")]
            labels: &'a Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: &'a Vec<String>,
        }
        let Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        } = self;
        CreateEvalLabelModelGrader {
            r#type: &Default::default(),
            name,
            model,
            input,
            labels,
            passing_labels,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod create_eval_logs_data_source_config {
    #[doc = "The type of data source. Always `logs`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "logs");
}
#[doc = "A data source config which specifies the metadata property of your logs query.\nThis is usually metadata like `usecase=chatbot` or `prompt-version=v2`, etc.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalLogsDataSourceConfig {
    #[doc = "Metadata filters for the logs data source."]
    #[builder(default)]
    pub metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalLogsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalLogsDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::create_eval_logs_data_source_config::Type,
            #[serde(rename = "metadata")]
            metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
        let CreateEvalLogsDataSourceConfig { metadata, .. } =
            CreateEvalLogsDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { metadata })
    }
}
impl serde::Serialize for CreateEvalLogsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalLogsDataSourceConfig<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::create_eval_logs_data_source_config::Type,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
        let Self { metadata } = self;
        CreateEvalLogsDataSourceConfig {
            r#type: &Default::default(),
            metadata,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod create_eval_request {
    #[doc = "The configuration for the data source used for the evaluation runs. Dictates the schema of the data used in the evaluation."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum DataSourceConfig {
        Custom(crate::__types::CreateEvalCustomDataSourceConfig),
        Logs(crate::__types::CreateEvalLogsDataSourceConfig),
        StoredCompletions(crate::__types::CreateEvalStoredCompletionsDataSourceConfig),
    }
    #[allow(clippy::module_inception)]
    pub mod testing_criteria {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            LabelModel(crate::__types::CreateEvalLabelModelGrader),
            StringCheck(crate::__types::EvalGraderStringCheck),
            TextSimilarity(crate::__types::EvalGraderTextSimilarity),
            Python(crate::__types::EvalGraderPython),
            ScoreModel(crate::__types::EvalGraderScoreModel),
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateEvalRequest {
    #[doc = "The name of the evaluation."]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "The configuration for the data source used for the evaluation runs. Dictates the schema of the data used in the evaluation."]
    #[serde(rename = "data_source_config")]
    pub data_source_config: crate::__types::create_eval_request::DataSourceConfig,
    #[doc = "A list of graders for all eval runs in this group. Graders can reference variables in the data source using double curly braces notation, like `{{item.variable_name}}`. To reference the model's output, use the `sample` namespace (ie, `{{sample.output_text}}`)."]
    #[serde(rename = "testing_criteria")]
    pub testing_criteria: Vec<crate::__types::create_eval_request::testing_criteria::Item>,
}
#[allow(clippy::module_inception)]
pub mod create_eval_responses_run_data_source {
    #[doc = "The type of run data source. Always `responses`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "responses");
    #[allow(clippy::module_inception)]
    pub mod input_messages {
        #[allow(clippy::module_inception)]
        pub mod template {
            #[doc = "The type of input messages. Always `template`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "template");
            #[allow(clippy::module_inception)]
            pub mod template {
                #[allow(clippy::module_inception)]
                pub mod item {
                    #[derive(Clone, Debug, PartialEq)]
                    #[serde_with::serde_as]
                    #[derive(
                        serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder,
                    )]
                    pub struct Variant0 {
                        #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
                        #[serde(rename = "role")]
                        pub role: String,
                        #[doc = "The content of the message."]
                        #[serde(rename = "content")]
                        pub content: String,
                    }
                }
                #[derive(Clone, Debug, PartialEq)]
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize, serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::large_enum_variant)]
                pub enum Item {
                    Variant0 (crate :: __types :: create_eval_responses_run_data_source :: input_messages :: template :: template :: item :: Variant0) , EvalItem (crate :: __types :: EvalItem) }
            }
        }
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct Template { # [doc = "A list of chat messages forming the prompt or context. May include variable references to the `item` namespace, ie {{item.name}}."] pub template : Vec < crate :: __types :: create_eval_responses_run_data_source :: input_messages :: template :: template :: Item > }
        impl<'de> serde::Deserialize<'de> for Template {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct Template { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_eval_responses_run_data_source :: input_messages :: template :: Type , # [serde (rename = "template")] template : Vec < crate :: __types :: create_eval_responses_run_data_source :: input_messages :: template :: template :: Item > }
                let Template { template, .. } = Template::deserialize(deserializer)?;
                Ok(Self { template })
            }
        }
        impl serde::Serialize for Template {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct Template < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_eval_responses_run_data_source :: input_messages :: template :: Type , # [serde (rename = "template")] template : & 'a Vec < crate :: __types :: create_eval_responses_run_data_source :: input_messages :: template :: template :: Item > }
                let Self { template } = self;
                Template {
                    r#type: &Default::default(),
                    template,
                }
                .serialize(serializer)
            }
        }
        #[allow(clippy::module_inception)]
        pub(crate) mod item_reference {
            #[doc = "The type of input messages. Always `item_reference`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "item_reference");
        }
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct ItemReference {
            #[doc = "A reference to a variable in the `item` namespace. Ie, \"item.name\""]
            pub item_reference: String,
        }
        impl<'de> serde::Deserialize<'de> for ItemReference {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct ItemReference { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_eval_responses_run_data_source :: input_messages :: item_reference :: Type , # [serde (rename = "item_reference")] item_reference : String }
                let ItemReference { item_reference, .. } =
                    ItemReference::deserialize(deserializer)?;
                Ok(Self { item_reference })
            }
        }
        impl serde::Serialize for ItemReference {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct ItemReference < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_eval_responses_run_data_source :: input_messages :: item_reference :: Type , # [serde (rename = "item_reference")] item_reference : & 'a String }
                let Self { item_reference } = self;
                ItemReference {
                    r#type: &Default::default(),
                    item_reference,
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum InputMessages {
        Template(crate::__types::create_eval_responses_run_data_source::input_messages::Template),
        ItemReference(
            crate::__types::create_eval_responses_run_data_source::input_messages::ItemReference,
        ),
    }
    #[allow(clippy::module_inception)]
    pub mod sampling_params {
        #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Text {
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub format: Option<crate::__types::TextResponseFormatConfiguration>,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct SamplingParams {
        #[doc = "A higher temperature increases randomness in the outputs."]
        #[serde(rename = "temperature")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub temperature: Option<serde_json::Number>,
        #[doc = "The maximum number of tokens in the generated output."]
        #[serde(rename = "max_completion_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub max_completion_tokens: Option<i64>,
        #[doc = "An alternative to temperature for nucleus sampling; 1.0 includes all tokens."]
        #[serde(rename = "top_p")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub top_p: Option<serde_json::Number>,
        #[doc = "A seed value to initialize the randomness, during sampling."]
        #[serde(rename = "seed")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub seed: Option<i64>,
        #[doc = "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nThe two categories of tools you can provide the model are:\n\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code. Learn more about\n  [function calling](https://platform.openai.com/docs/guides/function-calling).\n"]
        #[serde(rename = "tools")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub tools: Option<Vec<crate::__types::Tool>>,
        #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
        #[serde(rename = "text")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub text:
            Option<crate::__types::create_eval_responses_run_data_source::sampling_params::Text>,
    }
    #[doc = "Determines what populates the `item` namespace in this run's data source."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Source {
        FileContent(crate::__types::EvalJsonlFileContentSource),
        FileId(crate::__types::EvalJsonlFileIdSource),
        Responses(crate::__types::EvalResponsesSource),
    }
}
#[doc = "A ResponsesRunDataSource object describing a model sampling configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalResponsesRunDataSource {
    #[doc = "Used when sampling from a model. Dictates the structure of the messages passed into the model. Can either be a reference to a prebuilt trajectory (ie, `item.input_trajectory`), or a template with variable references to the `item` namespace."]
    #[builder(default)]
    pub input_messages:
        Option<crate::__types::create_eval_responses_run_data_source::InputMessages>,
    #[builder(default)]
    pub sampling_params:
        Option<crate::__types::create_eval_responses_run_data_source::SamplingParams>,
    #[doc = "The name of the model to use for generating completions (e.g. \"o3-mini\")."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Determines what populates the `item` namespace in this run's data source."]
    pub source: crate::__types::create_eval_responses_run_data_source::Source,
}
impl<'de> serde::Deserialize<'de> for CreateEvalResponsesRunDataSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalResponsesRunDataSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::create_eval_responses_run_data_source::Type,
            #[serde(rename = "input_messages")]
            input_messages:
                Option<crate::__types::create_eval_responses_run_data_source::InputMessages>,
            #[serde(rename = "sampling_params")]
            sampling_params:
                Option<crate::__types::create_eval_responses_run_data_source::SamplingParams>,
            #[serde(rename = "model")]
            model: Option<String>,
            #[serde(rename = "source")]
            source: crate::__types::create_eval_responses_run_data_source::Source,
        }
        let CreateEvalResponsesRunDataSource {
            input_messages,
            sampling_params,
            model,
            source,
            ..
        } = CreateEvalResponsesRunDataSource::deserialize(deserializer)?;
        Ok(Self {
            input_messages,
            sampling_params,
            model,
            source,
        })
    }
}
impl serde::Serialize for CreateEvalResponsesRunDataSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalResponsesRunDataSource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::create_eval_responses_run_data_source::Type,
            #[serde(rename = "input_messages")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_messages:
                &'a Option<crate::__types::create_eval_responses_run_data_source::InputMessages>,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params:
                &'a Option<crate::__types::create_eval_responses_run_data_source::SamplingParams>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "source")]
            source: &'a crate::__types::create_eval_responses_run_data_source::Source,
        }
        let Self {
            input_messages,
            sampling_params,
            model,
            source,
        } = self;
        CreateEvalResponsesRunDataSource {
            r#type: &Default::default(),
            input_messages,
            sampling_params,
            model,
            source,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod create_eval_run_request {
    #[doc = "Details about the run's data source."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum DataSource {
        Jsonl(crate::__types::CreateEvalJsonlRunDataSource),
        Completions(crate::__types::CreateEvalCompletionsRunDataSource),
        Responses(crate::__types::CreateEvalResponsesRunDataSource),
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateEvalRunRequest {
    #[doc = "The name of the run."]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "Details about the run's data source."]
    #[serde(rename = "data_source")]
    pub data_source: crate::__types::create_eval_run_request::DataSource,
}
#[allow(clippy::module_inception)]
pub(crate) mod create_eval_stored_completions_data_source_config {
    #[doc = "The type of data source. Always `stored_completions`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "stored_completions");
}
#[doc = "Deprecated in favor of LogsDataSourceConfig.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct CreateEvalStoredCompletionsDataSourceConfig {
    #[doc = "Metadata filters for the stored completions data source."]
    #[builder(default)]
    pub metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for CreateEvalStoredCompletionsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CreateEvalStoredCompletionsDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::create_eval_stored_completions_data_source_config::Type,
            #[serde(rename = "metadata")]
            metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
        let CreateEvalStoredCompletionsDataSourceConfig { metadata, .. } =
            CreateEvalStoredCompletionsDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { metadata })
    }
}
impl serde::Serialize for CreateEvalStoredCompletionsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CreateEvalStoredCompletionsDataSourceConfig<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::create_eval_stored_completions_data_source_config::Type,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
        let Self { metadata } = self;
        CreateEvalStoredCompletionsDataSourceConfig {
            r#type: &Default::default(),
            metadata,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateFileRequest {
    #[doc = "The File object (not file name) to be uploaded.\n"]
    #[serde_as(as = "serde_with::base64::Base64")]
    #[serde(rename = "file")]
    pub file: Vec<u8>,
    #[serde(rename = "purpose")]
    pub purpose: crate::__types::FilePurpose,
    #[serde(rename = "expires_after")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expires_after: Option<crate::__types::FileExpirationAfter>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningCheckpointPermissionRequest {
    #[doc = "The project identifiers to grant access to."]
    #[serde(rename = "project_ids")]
    pub project_ids: Vec<String>,
}
#[allow(clippy::module_inception)]
pub mod create_fine_tuning_job_request {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "babbage-002"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Babbage002;
        impl_serde!(Babbage002, "babbage-002");
        #[doc = "davinci-002"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Davinci002;
        impl_serde!(Davinci002, "davinci-002");
        #[doc = "gpt-3.5-turbo"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo;
        impl_serde!(Gpt3_5Turbo, "gpt-3.5-turbo");
        #[doc = "gpt-4o-mini"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4oMini;
        impl_serde!(Gpt4oMini, "gpt-4o-mini");
    }
    #[doc = "The name of the model to fine-tune. You can select one of the\n[supported models](https://platform.openai.com/docs/guides/fine-tuning#which-models-can-be-fine-tuned).\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "babbage-002"]
        Babbage002,
        #[doc = "davinci-002"]
        Davinci002,
        #[doc = "gpt-3.5-turbo"]
        Gpt3_5Turbo,
        #[doc = "gpt-4o-mini"]
        Gpt4oMini,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                Babbage002(crate::__types::create_fine_tuning_job_request::model::Babbage002),
                Davinci002(crate::__types::create_fine_tuning_job_request::model::Davinci002),
                Gpt3_5Turbo(crate::__types::create_fine_tuning_job_request::model::Gpt3_5Turbo),
                Gpt4oMini(crate::__types::create_fine_tuning_job_request::model::Gpt4oMini),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::Babbage002(_) => Self::Babbage002,
                Model::Davinci002(_) => Self::Davinci002,
                Model::Gpt3_5Turbo(_) => Self::Gpt3_5Turbo,
                Model::Gpt4oMini(_) => Self::Gpt4oMini,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                Babbage002(crate::__types::create_fine_tuning_job_request::model::Babbage002),
                Davinci002(crate::__types::create_fine_tuning_job_request::model::Davinci002),
                Gpt3_5Turbo(crate::__types::create_fine_tuning_job_request::model::Gpt3_5Turbo),
                Gpt4oMini(crate::__types::create_fine_tuning_job_request::model::Gpt4oMini),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::Babbage002 => Model::Babbage002(Default::default()),
                Self::Davinci002 => Model::Davinci002(Default::default()),
                Self::Gpt3_5Turbo => Model::Gpt3_5Turbo(Default::default()),
                Self::Gpt4oMini => Model::Gpt4oMini(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod hyperparameters {
        #[allow(clippy::module_inception)]
        pub(crate) mod batch_size {
            #[doc = "auto"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Auto;
            impl_serde!(Auto, "auto");
        }
        #[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[allow(clippy::large_enum_variant)]
        pub enum BatchSize {
            #[doc = "auto"]
            Auto,
            Integer(i64),
        }
        impl<'de> serde::Deserialize<'de> for BatchSize {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
                enum BatchSize {
                    Auto (crate :: __types :: create_fine_tuning_job_request :: hyperparameters :: batch_size :: Auto) , Integer (i64) }
                Ok(match BatchSize::deserialize(deserializer)? {
                    BatchSize::Auto(_) => Self::Auto,
                    BatchSize::Integer(v) => Self::Integer(v),
                })
            }
        }
        impl serde::Serialize for BatchSize {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names)]
                enum BatchSize<'a> {
                    Auto (crate :: __types :: create_fine_tuning_job_request :: hyperparameters :: batch_size :: Auto) , Integer (& 'a i64) }
                match self {
                    Self::Auto => BatchSize::Auto(Default::default()),
                    Self::Integer(v) => BatchSize::Integer(v),
                }
                .serialize(serializer)
            }
        }
        #[allow(clippy::module_inception)]
        pub(crate) mod learning_rate_multiplier {
            #[doc = "auto"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Auto;
            impl_serde!(Auto, "auto");
        }
        #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
        #[derive(Clone, Debug, PartialEq)]
        #[allow(clippy::large_enum_variant)]
        pub enum LearningRateMultiplier {
            #[doc = "auto"]
            Auto,
            Number(serde_json::Number),
        }
        impl<'de> serde::Deserialize<'de> for LearningRateMultiplier {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
                enum LearningRateMultiplier {
                    Auto (crate :: __types :: create_fine_tuning_job_request :: hyperparameters :: learning_rate_multiplier :: Auto) , Number (serde_json :: Number) }
                Ok(match LearningRateMultiplier::deserialize(deserializer)? {
                    LearningRateMultiplier::Auto(_) => Self::Auto,
                    LearningRateMultiplier::Number(v) => Self::Number(v),
                })
            }
        }
        impl serde::Serialize for LearningRateMultiplier {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names)]
                enum LearningRateMultiplier<'a> {
                    Auto (crate :: __types :: create_fine_tuning_job_request :: hyperparameters :: learning_rate_multiplier :: Auto) , Number (& 'a serde_json :: Number) }
                match self {
                    Self::Auto => LearningRateMultiplier::Auto(Default::default()),
                    Self::Number(v) => LearningRateMultiplier::Number(v),
                }
                .serialize(serializer)
            }
        }
        #[allow(clippy::module_inception)]
        pub(crate) mod n_epochs {
            #[doc = "auto"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Auto;
            impl_serde!(Auto, "auto");
        }
        #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[allow(clippy::large_enum_variant)]
        pub enum NEpochs {
            #[doc = "auto"]
            Auto,
            Integer(i64),
        }
        impl<'de> serde::Deserialize<'de> for NEpochs {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
                enum NEpochs {
                    Auto (crate :: __types :: create_fine_tuning_job_request :: hyperparameters :: n_epochs :: Auto) , Integer (i64) }
                Ok(match NEpochs::deserialize(deserializer)? {
                    NEpochs::Auto(_) => Self::Auto,
                    NEpochs::Integer(v) => Self::Integer(v),
                })
            }
        }
        impl serde::Serialize for NEpochs {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names)]
                enum NEpochs<'a> {
                    Auto (crate :: __types :: create_fine_tuning_job_request :: hyperparameters :: n_epochs :: Auto) , Integer (& 'a i64) }
                match self {
                    Self::Auto => NEpochs::Auto(Default::default()),
                    Self::Integer(v) => NEpochs::Integer(v),
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "The hyperparameters used for the fine-tuning job.\nThis value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Hyperparameters {
        #[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
        #[serde(rename = "batch_size")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub batch_size:
            Option<crate::__types::create_fine_tuning_job_request::hyperparameters::BatchSize>,
        #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
        #[serde(rename = "learning_rate_multiplier")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub learning_rate_multiplier: Option<
            crate::__types::create_fine_tuning_job_request::hyperparameters::LearningRateMultiplier,
        >,
        #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
        #[serde(rename = "n_epochs")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub n_epochs:
            Option<crate::__types::create_fine_tuning_job_request::hyperparameters::NEpochs>,
    }
    #[allow(clippy::module_inception)]
    pub mod integrations {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The type of integration to enable. Currently, only \"wandb\" (Weights and Biases) is supported.\n"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Type {
                #[doc = "`wandb`"]
                #[serde(rename = "wandb")]
                Wandb,
            }
            #[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Wandb {
                #[doc = "The name of the project that the new run will be created under.\n"]
                #[serde(rename = "project")]
                pub project: String,
                #[doc = "A display name to set for the run. If not set, we will use the Job ID as the name.\n"]
                #[serde(rename = "name")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub name: Option<String>,
                #[doc = "The entity to use for the run. This allows you to set the team or username of the WandB user that you would\nlike associated with the run. If not set, the default entity for the registered WandB API key is used.\n"]
                #[serde(rename = "entity")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub entity: Option<String>,
                #[doc = "A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some\ndefault tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n"]
                #[serde(rename = "tags")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub tags: Option<Vec<String>>,
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The type of integration to enable. Currently, only \"wandb\" (Weights and Biases) is supported.\n"]
            #[serde(rename = "type")]
            pub r#type: crate::__types::create_fine_tuning_job_request::integrations::item::Type,
            #[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
            #[serde(rename = "wandb")]
            pub wandb: crate::__types::create_fine_tuning_job_request::integrations::item::Wandb,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateFineTuningJobRequest {
    #[doc = "The name of the model to fine-tune. You can select one of the\n[supported models](https://platform.openai.com/docs/guides/fine-tuning#which-models-can-be-fine-tuned).\n"]
    #[serde(rename = "model")]
    pub model: crate::__types::create_fine_tuning_job_request::Model,
    #[doc = "The ID of an uploaded file that contains training data.\n\nSee [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.\n\nYour dataset must be formatted as a JSONL file. Additionally, you must upload your file with the purpose `fine-tune`.\n\nThe contents of the file should differ depending on if the model uses the [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input), [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input) format, or if the fine-tuning method uses the [preference](https://platform.openai.com/docs/api-reference/fine-tuning/preference-input) format.\n\nSee the [fine-tuning guide](https://platform.openai.com/docs/guides/model-optimization) for more details.\n"]
    #[serde(rename = "training_file")]
    pub training_file: String,
    #[doc = "The hyperparameters used for the fine-tuning job.\nThis value is now deprecated in favor of `method`, and should be passed in under the `method` parameter.\n"]
    #[serde(rename = "hyperparameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hyperparameters: Option<crate::__types::create_fine_tuning_job_request::Hyperparameters>,
    #[doc = "A string of up to 64 characters that will be added to your fine-tuned model name.\n\nFor example, a `suffix` of \"custom-model-name\" would produce a model name like `ft:gpt-4o-mini:openai:custom-model-name:7p4lURel`.\n"]
    #[serde(rename = "suffix")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub suffix: Option<String>,
    #[doc = "The ID of an uploaded file that contains validation data.\n\nIf you provide this file, the data is used to generate validation\nmetrics periodically during fine-tuning. These metrics can be viewed in\nthe fine-tuning results file.\nThe same data should not be present in both train and validation files.\n\nYour dataset must be formatted as a JSONL file. You must upload your file with the purpose `fine-tune`.\n\nSee the [fine-tuning guide](https://platform.openai.com/docs/guides/model-optimization) for more details.\n"]
    #[serde(rename = "validation_file")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub validation_file: Option<String>,
    #[doc = "A list of integrations to enable for your fine-tuning job."]
    #[serde(rename = "integrations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub integrations:
        Option<Vec<crate::__types::create_fine_tuning_job_request::integrations::Item>>,
    #[doc = "The seed controls the reproducibility of the job. Passing in the same seed and job parameters should produce the same results, but may differ in rare cases.\nIf a seed is not specified, one will be generated for you.\n"]
    #[serde(rename = "seed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub seed: Option<i64>,
    #[serde(rename = "method")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub method: Option<crate::__types::FineTuneMethod>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
#[allow(clippy::module_inception)]
pub mod create_image_edit_request {
    #[doc = "The image(s) to edit. Must be a supported image file or an array of images.\n\nFor `gpt-image-1`, each image should be a `png`, `webp`, or `jpg` file less \nthan 50MB. You can provide up to 16 images.\n\nFor `dall-e-2`, you can only provide one image, and it should be a square \n`png` file less than 4MB.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Image {
        Bytes(#[serde_as(as = "serde_with::base64::Base64")] Vec<u8>),
        Array(#[serde_as(as = "Vec<serde_with::base64::Base64>")] Vec<Vec<u8>>),
    }
    #[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Background {
        #[doc = "`transparent`"]
        #[serde(rename = "transparent")]
        Transparent,
        #[doc = "`opaque`"]
        #[serde(rename = "opaque")]
        Opaque,
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "dall-e-2"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct DallE2;
        impl_serde!(DallE2, "dall-e-2");
        #[doc = "gpt-image-1"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct GptImage1;
        impl_serde!(GptImage1, "gpt-image-1");
    }
    #[doc = "The model to use for image generation. Only `dall-e-2` and `gpt-image-1` are supported. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used."]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "dall-e-2"]
        DallE2,
        #[doc = "gpt-image-1"]
        GptImage1,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                DallE2(crate::__types::create_image_edit_request::model::DallE2),
                GptImage1(crate::__types::create_image_edit_request::model::GptImage1),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::DallE2(_) => Self::DallE2,
                Model::GptImage1(_) => Self::GptImage1,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                DallE2(crate::__types::create_image_edit_request::model::DallE2),
                GptImage1(crate::__types::create_image_edit_request::model::GptImage1),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::DallE2 => Model::DallE2(Default::default()),
                Self::GptImage1 => Model::GptImage1(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, and one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`256x256`"]
        #[serde(rename = "256x256")]
        _256x256,
        #[doc = "`512x512`"]
        #[serde(rename = "512x512")]
        _512x512,
        #[doc = "`1024x1024`"]
        #[default]
        #[serde(rename = "1024x1024")]
        _1024x1024,
        #[doc = "`1536x1024`"]
        #[serde(rename = "1536x1024")]
        _1536x1024,
        #[doc = "`1024x1536`"]
        #[serde(rename = "1024x1536")]
        _1024x1536,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter is only supported for `dall-e-2`, as `gpt-image-1` will always return base64-encoded images."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum ResponseFormat {
        #[doc = "`url`"]
        #[default]
        #[serde(rename = "url")]
        Url,
        #[doc = "`b64_json`"]
        #[serde(rename = "b64_json")]
        B64Json,
    }
    #[doc = "The format in which the generated images are returned. This parameter is\nonly supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`.\nThe default value is `png`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputFormat {
        #[doc = "`png`"]
        #[default]
        #[serde(rename = "png")]
        Png,
        #[doc = "`jpeg`"]
        #[serde(rename = "jpeg")]
        Jpeg,
        #[doc = "`webp`"]
        #[serde(rename = "webp")]
        Webp,
    }
    #[doc = "The quality of the image that will be generated. `high`, `medium` and `low` are only supported for `gpt-image-1`. `dall-e-2` only supports `standard` quality. Defaults to `auto`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Quality {
        #[doc = "`standard`"]
        #[serde(rename = "standard")]
        Standard,
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateImageEditRequest {
    #[doc = "The image(s) to edit. Must be a supported image file or an array of images.\n\nFor `gpt-image-1`, each image should be a `png`, `webp`, or `jpg` file less \nthan 50MB. You can provide up to 16 images.\n\nFor `dall-e-2`, you can only provide one image, and it should be a square \n`png` file less than 4MB.\n"]
    #[serde(rename = "image")]
    pub image: crate::__types::create_image_edit_request::Image,
    #[doc = "A text description of the desired image(s). The maximum length is 1000 characters for `dall-e-2`, and 32000 characters for `gpt-image-1`."]
    #[serde(rename = "prompt")]
    pub prompt: String,
    #[doc = "An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where `image` should be edited. If there are multiple images provided, the mask will be applied on the first image. Must be a valid PNG file, less than 4MB, and have the same dimensions as `image`."]
    #[serde_as(as = "Option<serde_with::base64::Base64>")]
    #[serde(rename = "mask")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub mask: Option<Vec<u8>>,
    #[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
    #[serde(rename = "background")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub background: Option<crate::__types::create_image_edit_request::Background>,
    #[doc = "The model to use for image generation. Only `dall-e-2` and `gpt-image-1` are supported. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used."]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::create_image_edit_request::Model>,
    #[doc = "The number of images to generate. Must be between 1 and 10."]
    #[serde(rename = "n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub n: Option<i64>,
    #[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, and one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`."]
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<crate::__types::create_image_edit_request::Size>,
    #[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter is only supported for `dall-e-2`, as `gpt-image-1` will always return base64-encoded images."]
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::create_image_edit_request::ResponseFormat>,
    #[doc = "The format in which the generated images are returned. This parameter is\nonly supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`.\nThe default value is `png`.\n"]
    #[serde(rename = "output_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_format: Option<crate::__types::create_image_edit_request::OutputFormat>,
    #[doc = "The compression level (0-100%) for the generated images. This parameter \nis only supported for `gpt-image-1` with the `webp` or `jpeg` output \nformats, and defaults to 100.\n"]
    #[serde(rename = "output_compression")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_compression: Option<i64>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
    #[serde(rename = "input_fidelity")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_fidelity: Option<crate::__types::ImageInputFidelity>,
    #[doc = "Edit the image in streaming mode. Defaults to `false`. See the \n[Image generation guide](https://platform.openai.com/docs/guides/image-generation) for more information.\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
    #[serde(rename = "partial_images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub partial_images: Option<crate::__types::PartialImages>,
    #[doc = "The quality of the image that will be generated. `high`, `medium` and `low` are only supported for `gpt-image-1`. `dall-e-2` only supports `standard` quality. Defaults to `auto`.\n"]
    #[serde(rename = "quality")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub quality: Option<crate::__types::create_image_edit_request::Quality>,
}
#[allow(clippy::module_inception)]
pub mod create_image_request {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "dall-e-2"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct DallE2;
        impl_serde!(DallE2, "dall-e-2");
        #[doc = "dall-e-3"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct DallE3;
        impl_serde!(DallE3, "dall-e-3");
        #[doc = "gpt-image-1"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct GptImage1;
        impl_serde!(GptImage1, "gpt-image-1");
    }
    #[doc = "The model to use for image generation. One of `dall-e-2`, `dall-e-3`, or `gpt-image-1`. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used."]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "dall-e-2"]
        DallE2,
        #[doc = "dall-e-3"]
        DallE3,
        #[doc = "gpt-image-1"]
        GptImage1,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                DallE2(crate::__types::create_image_request::model::DallE2),
                DallE3(crate::__types::create_image_request::model::DallE3),
                GptImage1(crate::__types::create_image_request::model::GptImage1),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::DallE2(_) => Self::DallE2,
                Model::DallE3(_) => Self::DallE3,
                Model::GptImage1(_) => Self::GptImage1,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                DallE2(crate::__types::create_image_request::model::DallE2),
                DallE3(crate::__types::create_image_request::model::DallE3),
                GptImage1(crate::__types::create_image_request::model::GptImage1),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::DallE2 => Model::DallE2(Default::default()),
                Self::DallE3 => Model::DallE3(Default::default()),
                Self::GptImage1 => Model::GptImage1(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The quality of the image that will be generated. \n\n- `auto` (default value) will automatically select the best quality for the given model.\n- `high`, `medium` and `low` are supported for `gpt-image-1`.\n- `hd` and `standard` are supported for `dall-e-3`.\n- `standard` is the only option for `dall-e-2`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Quality {
        #[doc = "`standard`"]
        #[serde(rename = "standard")]
        Standard,
        #[doc = "`hd`"]
        #[serde(rename = "hd")]
        Hd,
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum ResponseFormat {
        #[doc = "`url`"]
        #[default]
        #[serde(rename = "url")]
        Url,
        #[doc = "`b64_json`"]
        #[serde(rename = "b64_json")]
        B64Json,
    }
    #[doc = "The format in which the generated images are returned. This parameter is only supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputFormat {
        #[doc = "`png`"]
        #[default]
        #[serde(rename = "png")]
        Png,
        #[doc = "`jpeg`"]
        #[serde(rename = "jpeg")]
        Jpeg,
        #[doc = "`webp`"]
        #[serde(rename = "webp")]
        Webp,
    }
    #[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`1024x1024`"]
        #[serde(rename = "1024x1024")]
        _1024x1024,
        #[doc = "`1536x1024`"]
        #[serde(rename = "1536x1024")]
        _1536x1024,
        #[doc = "`1024x1536`"]
        #[serde(rename = "1024x1536")]
        _1024x1536,
        #[doc = "`256x256`"]
        #[serde(rename = "256x256")]
        _256x256,
        #[doc = "`512x512`"]
        #[serde(rename = "512x512")]
        _512x512,
        #[doc = "`1792x1024`"]
        #[serde(rename = "1792x1024")]
        _1792x1024,
        #[doc = "`1024x1792`"]
        #[serde(rename = "1024x1792")]
        _1024x1792,
    }
    #[doc = "Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` for less restrictive filtering or `auto` (default value)."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Moderation {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Background {
        #[doc = "`transparent`"]
        #[serde(rename = "transparent")]
        Transparent,
        #[doc = "`opaque`"]
        #[serde(rename = "opaque")]
        Opaque,
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Style {
        #[doc = "`vivid`"]
        #[default]
        #[serde(rename = "vivid")]
        Vivid,
        #[doc = "`natural`"]
        #[serde(rename = "natural")]
        Natural,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateImageRequest {
    #[doc = "A text description of the desired image(s). The maximum length is 32000 characters for `gpt-image-1`, 1000 characters for `dall-e-2` and 4000 characters for `dall-e-3`."]
    #[serde(rename = "prompt")]
    pub prompt: String,
    #[doc = "The model to use for image generation. One of `dall-e-2`, `dall-e-3`, or `gpt-image-1`. Defaults to `dall-e-2` unless a parameter specific to `gpt-image-1` is used."]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::create_image_request::Model>,
    #[doc = "The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported."]
    #[serde(rename = "n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub n: Option<i64>,
    #[doc = "The quality of the image that will be generated. \n\n- `auto` (default value) will automatically select the best quality for the given model.\n- `high`, `medium` and `low` are supported for `gpt-image-1`.\n- `hd` and `standard` are supported for `dall-e-3`.\n- `standard` is the only option for `dall-e-2`.\n"]
    #[serde(rename = "quality")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub quality: Option<crate::__types::create_image_request::Quality>,
    #[doc = "The format in which generated images with `dall-e-2` and `dall-e-3` are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images."]
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::create_image_request::ResponseFormat>,
    #[doc = "The format in which the generated images are returned. This parameter is only supported for `gpt-image-1`. Must be one of `png`, `jpeg`, or `webp`."]
    #[serde(rename = "output_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_format: Option<crate::__types::create_image_request::OutputFormat>,
    #[doc = "The compression level (0-100%) for the generated images. This parameter is only supported for `gpt-image-1` with the `webp` or `jpeg` output formats, and defaults to 100."]
    #[serde(rename = "output_compression")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_compression: Option<i64>,
    #[doc = "Generate the image in streaming mode. Defaults to `false`. See the \n[Image generation guide](https://platform.openai.com/docs/guides/image-generation) for more information.\nThis parameter is only supported for `gpt-image-1`.\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
    #[serde(rename = "partial_images")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub partial_images: Option<crate::__types::PartialImages>,
    #[doc = "The size of the generated images. Must be one of `1024x1024`, `1536x1024` (landscape), `1024x1536` (portrait), or `auto` (default value) for `gpt-image-1`, one of `256x256`, `512x512`, or `1024x1024` for `dall-e-2`, and one of `1024x1024`, `1792x1024`, or `1024x1792` for `dall-e-3`."]
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<crate::__types::create_image_request::Size>,
    #[doc = "Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` for less restrictive filtering or `auto` (default value)."]
    #[serde(rename = "moderation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub moderation: Option<crate::__types::create_image_request::Moderation>,
    #[doc = "Allows to set transparency for the background of the generated image(s). \nThis parameter is only supported for `gpt-image-1`. Must be one of \n`transparent`, `opaque` or `auto` (default value). When `auto` is used, the \nmodel will automatically determine the best background for the image.\n\nIf `transparent`, the output format needs to support transparency, so it \nshould be set to either `png` (default value) or `webp`.\n"]
    #[serde(rename = "background")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub background: Option<crate::__types::create_image_request::Background>,
    #[doc = "The style of the generated images. This parameter is only supported for `dall-e-3`. Must be one of `vivid` or `natural`. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images."]
    #[serde(rename = "style")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub style: Option<crate::__types::create_image_request::Style>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod create_image_variation_request {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "dall-e-2"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct DallE2;
        impl_serde!(DallE2, "dall-e-2");
    }
    #[doc = "The model to use for image generation. Only `dall-e-2` is supported at this time."]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "dall-e-2"]
        DallE2,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                DallE2(crate::__types::create_image_variation_request::model::DallE2),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::DallE2(_) => Self::DallE2,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                DallE2(crate::__types::create_image_variation_request::model::DallE2),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::DallE2 => Model::DallE2(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum ResponseFormat {
        #[doc = "`url`"]
        #[default]
        #[serde(rename = "url")]
        Url,
        #[doc = "`b64_json`"]
        #[serde(rename = "b64_json")]
        B64Json,
    }
    #[doc = "The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`256x256`"]
        #[serde(rename = "256x256")]
        _256x256,
        #[doc = "`512x512`"]
        #[serde(rename = "512x512")]
        _512x512,
        #[doc = "`1024x1024`"]
        #[default]
        #[serde(rename = "1024x1024")]
        _1024x1024,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateImageVariationRequest {
    #[doc = "The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square."]
    #[serde_as(as = "serde_with::base64::Base64")]
    #[serde(rename = "image")]
    pub image: Vec<u8>,
    #[doc = "The model to use for image generation. Only `dall-e-2` is supported at this time."]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::create_image_variation_request::Model>,
    #[doc = "The number of images to generate. Must be between 1 and 10."]
    #[serde(rename = "n")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub n: Option<i64>,
    #[doc = "The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated."]
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::create_image_variation_request::ResponseFormat>,
    #[doc = "The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`."]
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<crate::__types::create_image_variation_request::Size>,
    #[doc = "A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#end-user-ids).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod create_message_request {
    #[doc = "The role of the entity that is creating the message. Allowed values include:\n- `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.\n- `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`assistant`"]
        #[serde(rename = "assistant")]
        Assistant,
    }
    #[allow(clippy::module_inception)]
    pub mod content {
        #[allow(clippy::module_inception)]
        pub mod array {
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::large_enum_variant)]
            pub enum Item {
                ImageFile(crate::__types::MessageContentImageFileObject),
                ImageUrl(crate::__types::MessageContentImageUrlObject),
                Text(crate::__types::MessageRequestContentTextObject),
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "The text contents of the message."]
        String(String),
        #[doc = "An array of content parts with a defined type, each can be of type `text` or images can be passed with `image_url` or `image_file`. Image types are only supported on [Vision-compatible models](https://platform.openai.com/docs/models)."]
        Array(Vec<crate::__types::create_message_request::content::array::Item>),
    }
    #[allow(clippy::module_inception)]
    pub mod attachments {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[allow(clippy::module_inception)]
            pub mod tools {
                #[derive(Clone, Copy, Debug, PartialEq)]
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize, serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::large_enum_variant)]
                pub enum Item {
                    CodeInterpreter(crate::__types::AssistantToolsCode),
                    FileSearch(crate::__types::AssistantToolsFileSearchTypeOnly),
                }
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The ID of the file to attach to the message."]
            #[serde(rename = "file_id")]
            pub file_id: String,
            #[doc = "The tools to add this file to."]
            #[serde(rename = "tools")]
            pub tools: Vec<crate::__types::create_message_request::attachments::item::tools::Item>,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateMessageRequest {
    #[doc = "The role of the entity that is creating the message. Allowed values include:\n- `user`: Indicates the message is sent by an actual user and should be used in most cases to represent user-generated messages.\n- `assistant`: Indicates the message is generated by the assistant. Use this value to insert messages from the assistant into the conversation.\n"]
    #[serde(rename = "role")]
    pub role: crate::__types::create_message_request::Role,
    #[serde(rename = "content")]
    pub content: crate::__types::create_message_request::Content,
    #[doc = "A list of files attached to the message, and the tools they should be added to."]
    #[serde(rename = "attachments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attachments: Option<Vec<crate::__types::create_message_request::attachments::Item>>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
#[allow(clippy::module_inception)]
pub mod create_model_response_properties {
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Text {
        #[serde(rename = "verbosity")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub verbosity: Option<crate::__types::Verbosity>,
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateModelResponseProperties {
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<crate::__types::create_model_response_properties::Text>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"]
    #[serde(rename = "top_logprobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_logprobs: Option<i64>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users. \nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
    #[doc = "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. \nThe IDs should be a string that uniquely identifies each user. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[serde(rename = "safety_identifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub safety_identifier: Option<String>,
    #[doc = "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](https://platform.openai.com/docs/guides/prompt-caching).\n"]
    #[serde(rename = "prompt_cache_key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt_cache_key: Option<String>,
    #[serde(rename = "service_tier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service_tier: Option<crate::__types::ServiceTier>,
}
#[allow(clippy::module_inception)]
pub mod create_moderation_request {
    #[allow(clippy::module_inception)]
    pub mod input {
        #[allow(clippy::module_inception)]
        pub mod variant2 {
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::large_enum_variant)]
            pub enum Item {
                ImageUrl(crate::__types::ModerationImageUrlInput),
                Text(crate::__types::ModerationTextInput),
            }
        }
    }
    #[doc = "Input (or inputs) to classify. Can be a single string, an array of strings, or\nan array of multi-modal input objects similar to other models.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Input {
        #[doc = "A string of text to classify for moderation."]
        String(String),
        #[doc = "An array of strings to classify for moderation."]
        ArrayOfString(Vec<String>),
        #[doc = "An array of multi-modal inputs to the moderation model."]
        Variant2(Vec<crate::__types::create_moderation_request::input::variant2::Item>),
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "omni-moderation-latest"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct OmniModerationLatest;
        impl_serde!(OmniModerationLatest, "omni-moderation-latest");
        #[doc = "omni-moderation-2024-09-26"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct OmniModeration2024_09_26;
        impl_serde!(OmniModeration2024_09_26, "omni-moderation-2024-09-26");
        #[doc = "text-moderation-latest"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct TextModerationLatest;
        impl_serde!(TextModerationLatest, "text-moderation-latest");
        #[doc = "text-moderation-stable"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct TextModerationStable;
        impl_serde!(TextModerationStable, "text-moderation-stable");
    }
    #[doc = "The content moderation model you would like to use. Learn more in\n[the moderation guide](https://platform.openai.com/docs/guides/moderation), and learn about\navailable models [here](https://platform.openai.com/docs/models#moderation).\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "omni-moderation-latest"]
        OmniModerationLatest,
        #[doc = "omni-moderation-2024-09-26"]
        OmniModeration2024_09_26,
        #[doc = "text-moderation-latest"]
        TextModerationLatest,
        #[doc = "text-moderation-stable"]
        TextModerationStable,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                OmniModerationLatest(
                    crate::__types::create_moderation_request::model::OmniModerationLatest,
                ),
                OmniModeration2024_09_26(
                    crate::__types::create_moderation_request::model::OmniModeration2024_09_26,
                ),
                TextModerationLatest(
                    crate::__types::create_moderation_request::model::TextModerationLatest,
                ),
                TextModerationStable(
                    crate::__types::create_moderation_request::model::TextModerationStable,
                ),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::OmniModerationLatest(_) => Self::OmniModerationLatest,
                Model::OmniModeration2024_09_26(_) => Self::OmniModeration2024_09_26,
                Model::TextModerationLatest(_) => Self::TextModerationLatest,
                Model::TextModerationStable(_) => Self::TextModerationStable,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                OmniModerationLatest(
                    crate::__types::create_moderation_request::model::OmniModerationLatest,
                ),
                OmniModeration2024_09_26(
                    crate::__types::create_moderation_request::model::OmniModeration2024_09_26,
                ),
                TextModerationLatest(
                    crate::__types::create_moderation_request::model::TextModerationLatest,
                ),
                TextModerationStable(
                    crate::__types::create_moderation_request::model::TextModerationStable,
                ),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::OmniModerationLatest => Model::OmniModerationLatest(Default::default()),
                Self::OmniModeration2024_09_26 => {
                    Model::OmniModeration2024_09_26(Default::default())
                }
                Self::TextModerationLatest => Model::TextModerationLatest(Default::default()),
                Self::TextModerationStable => Model::TextModerationStable(Default::default()),
            }
            .serialize(serializer)
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateModerationRequest {
    #[doc = "Input (or inputs) to classify. Can be a single string, an array of strings, or\nan array of multi-modal input objects similar to other models.\n"]
    #[serde(rename = "input")]
    pub input: crate::__types::create_moderation_request::Input,
    #[doc = "The content moderation model you would like to use. Learn more in\n[the moderation guide](https://platform.openai.com/docs/guides/moderation), and learn about\navailable models [here](https://platform.openai.com/docs/models#moderation).\n"]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::create_moderation_request::Model>,
}
#[allow(clippy::module_inception)]
pub mod create_moderation_response {
    #[allow(clippy::module_inception)]
    pub mod results {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "A list of the categories, and whether they are flagged or not."]
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Categories {
                #[doc = "Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste. Hateful content aimed at non-protected groups (e.g., chess players) is harassment."]
                #[serde(rename = "hate")]
                pub hate: bool,
                #[doc = "Hateful content that also includes violence or serious harm towards the targeted group based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste."]
                #[serde(rename = "hate/threatening")]
                pub hate_threatening: bool,
                #[doc = "Content that expresses, incites, or promotes harassing language towards any target."]
                #[serde(rename = "harassment")]
                pub harassment: bool,
                #[doc = "Harassment content that also includes violence or serious harm towards any target."]
                #[serde(rename = "harassment/threatening")]
                pub harassment_threatening: bool,
                #[doc = "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing, or that gives advice or instruction on how to commit illicit acts. For example, \"how to shoplift\" would fit this category."]
                #[serde(rename = "illicit")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub illicit: Option<bool>,
                #[doc = "Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence, or that gives advice or instruction on the procurement of any weapon."]
                #[serde(rename = "illicit/violent")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub illicit_violent: Option<bool>,
                #[doc = "Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders."]
                #[serde(rename = "self-harm")]
                pub self_harm: bool,
                #[doc = "Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm, such as suicide, cutting, and eating disorders."]
                #[serde(rename = "self-harm/intent")]
                pub self_harm_intent: bool,
                #[doc = "Content that encourages performing acts of self-harm, such as suicide, cutting, and eating disorders, or that gives instructions or advice on how to commit such acts."]
                #[serde(rename = "self-harm/instructions")]
                pub self_harm_instructions: bool,
                #[doc = "Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services (excluding sex education and wellness)."]
                #[serde(rename = "sexual")]
                pub sexual: bool,
                #[doc = "Sexual content that includes an individual who is under 18 years old."]
                #[serde(rename = "sexual/minors")]
                pub sexual_minors: bool,
                #[doc = "Content that depicts death, violence, or physical injury."]
                #[serde(rename = "violence")]
                pub violence: bool,
                #[doc = "Content that depicts death, violence, or physical injury in graphic detail."]
                #[serde(rename = "violence/graphic")]
                pub violence_graphic: bool,
            }
            #[doc = "A list of the categories along with their scores as predicted by model."]
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct CategoryScores {
                #[doc = "The score for the category 'hate'."]
                #[serde(rename = "hate")]
                pub hate: serde_json::Number,
                #[doc = "The score for the category 'hate/threatening'."]
                #[serde(rename = "hate/threatening")]
                pub hate_threatening: serde_json::Number,
                #[doc = "The score for the category 'harassment'."]
                #[serde(rename = "harassment")]
                pub harassment: serde_json::Number,
                #[doc = "The score for the category 'harassment/threatening'."]
                #[serde(rename = "harassment/threatening")]
                pub harassment_threatening: serde_json::Number,
                #[doc = "The score for the category 'illicit'."]
                #[serde(rename = "illicit")]
                pub illicit: serde_json::Number,
                #[doc = "The score for the category 'illicit/violent'."]
                #[serde(rename = "illicit/violent")]
                pub illicit_violent: serde_json::Number,
                #[doc = "The score for the category 'self-harm'."]
                #[serde(rename = "self-harm")]
                pub self_harm: serde_json::Number,
                #[doc = "The score for the category 'self-harm/intent'."]
                #[serde(rename = "self-harm/intent")]
                pub self_harm_intent: serde_json::Number,
                #[doc = "The score for the category 'self-harm/instructions'."]
                #[serde(rename = "self-harm/instructions")]
                pub self_harm_instructions: serde_json::Number,
                #[doc = "The score for the category 'sexual'."]
                #[serde(rename = "sexual")]
                pub sexual: serde_json::Number,
                #[doc = "The score for the category 'sexual/minors'."]
                #[serde(rename = "sexual/minors")]
                pub sexual_minors: serde_json::Number,
                #[doc = "The score for the category 'violence'."]
                #[serde(rename = "violence")]
                pub violence: serde_json::Number,
                #[doc = "The score for the category 'violence/graphic'."]
                #[serde(rename = "violence/graphic")]
                pub violence_graphic: serde_json::Number,
            }
            #[allow(clippy::module_inception)]
            pub mod category_applied_input_types {
                #[allow(clippy::module_inception)]
                pub mod hate {
                    #[doc = "text"]
                    #[derive(Clone, Copy, Debug, Default, PartialEq)]
                    pub struct Item;
                    impl_serde!(Item, "text");
                }
                #[allow(clippy::module_inception)]
                pub mod hate_threatening {
                    #[doc = "text"]
                    #[derive(Clone, Copy, Debug, Default, PartialEq)]
                    pub struct Item;
                    impl_serde!(Item, "text");
                }
                #[allow(clippy::module_inception)]
                pub mod harassment {
                    #[doc = "text"]
                    #[derive(Clone, Copy, Debug, Default, PartialEq)]
                    pub struct Item;
                    impl_serde!(Item, "text");
                }
                #[allow(clippy::module_inception)]
                pub mod harassment_threatening {
                    #[doc = "text"]
                    #[derive(Clone, Copy, Debug, Default, PartialEq)]
                    pub struct Item;
                    impl_serde!(Item, "text");
                }
                #[allow(clippy::module_inception)]
                pub mod illicit {
                    #[doc = "text"]
                    #[derive(Clone, Copy, Debug, Default, PartialEq)]
                    pub struct Item;
                    impl_serde!(Item, "text");
                }
                #[allow(clippy::module_inception)]
                pub mod illicit_violent {
                    #[doc = "text"]
                    #[derive(Clone, Copy, Debug, Default, PartialEq)]
                    pub struct Item;
                    impl_serde!(Item, "text");
                }
                #[allow(clippy::module_inception)]
                pub mod self_harm {
                    #[derive(
                        Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize,
                    )]
                    pub enum Item {
                        #[doc = "`text`"]
                        #[serde(rename = "text")]
                        Text,
                        #[doc = "`image`"]
                        #[serde(rename = "image")]
                        Image,
                    }
                }
                #[allow(clippy::module_inception)]
                pub mod self_harm_intent {
                    #[derive(
                        Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize,
                    )]
                    pub enum Item {
                        #[doc = "`text`"]
                        #[serde(rename = "text")]
                        Text,
                        #[doc = "`image`"]
                        #[serde(rename = "image")]
                        Image,
                    }
                }
                #[allow(clippy::module_inception)]
                pub mod self_harm_instructions {
                    #[derive(
                        Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize,
                    )]
                    pub enum Item {
                        #[doc = "`text`"]
                        #[serde(rename = "text")]
                        Text,
                        #[doc = "`image`"]
                        #[serde(rename = "image")]
                        Image,
                    }
                }
                #[allow(clippy::module_inception)]
                pub mod sexual {
                    #[derive(
                        Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize,
                    )]
                    pub enum Item {
                        #[doc = "`text`"]
                        #[serde(rename = "text")]
                        Text,
                        #[doc = "`image`"]
                        #[serde(rename = "image")]
                        Image,
                    }
                }
                #[allow(clippy::module_inception)]
                pub mod sexual_minors {
                    #[doc = "text"]
                    #[derive(Clone, Copy, Debug, Default, PartialEq)]
                    pub struct Item;
                    impl_serde!(Item, "text");
                }
                #[allow(clippy::module_inception)]
                pub mod violence {
                    #[derive(
                        Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize,
                    )]
                    pub enum Item {
                        #[doc = "`text`"]
                        #[serde(rename = "text")]
                        Text,
                        #[doc = "`image`"]
                        #[serde(rename = "image")]
                        Image,
                    }
                }
                #[allow(clippy::module_inception)]
                pub mod violence_graphic {
                    #[derive(
                        Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize,
                    )]
                    pub enum Item {
                        #[doc = "`text`"]
                        #[serde(rename = "text")]
                        Text,
                        #[doc = "`image`"]
                        #[serde(rename = "image")]
                        Image,
                    }
                }
            }
            #[doc = "A list of the categories along with the input type(s) that the score applies to."]
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct CategoryAppliedInputTypes { # [doc = "The applied input type(s) for the category 'hate'."] # [serde (rename = "hate")] pub hate : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: hate :: Item > , # [doc = "The applied input type(s) for the category 'hate/threatening'."] # [serde (rename = "hate/threatening")] pub hate_threatening : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: hate_threatening :: Item > , # [doc = "The applied input type(s) for the category 'harassment'."] # [serde (rename = "harassment")] pub harassment : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: harassment :: Item > , # [doc = "The applied input type(s) for the category 'harassment/threatening'."] # [serde (rename = "harassment/threatening")] pub harassment_threatening : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: harassment_threatening :: Item > , # [doc = "The applied input type(s) for the category 'illicit'."] # [serde (rename = "illicit")] pub illicit : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: illicit :: Item > , # [doc = "The applied input type(s) for the category 'illicit/violent'."] # [serde (rename = "illicit/violent")] pub illicit_violent : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: illicit_violent :: Item > , # [doc = "The applied input type(s) for the category 'self-harm'."] # [serde (rename = "self-harm")] pub self_harm : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: self_harm :: Item > , # [doc = "The applied input type(s) for the category 'self-harm/intent'."] # [serde (rename = "self-harm/intent")] pub self_harm_intent : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: self_harm_intent :: Item > , # [doc = "The applied input type(s) for the category 'self-harm/instructions'."] # [serde (rename = "self-harm/instructions")] pub self_harm_instructions : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: self_harm_instructions :: Item > , # [doc = "The applied input type(s) for the category 'sexual'."] # [serde (rename = "sexual")] pub sexual : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: sexual :: Item > , # [doc = "The applied input type(s) for the category 'sexual/minors'."] # [serde (rename = "sexual/minors")] pub sexual_minors : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: sexual_minors :: Item > , # [doc = "The applied input type(s) for the category 'violence'."] # [serde (rename = "violence")] pub violence : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: violence :: Item > , # [doc = "The applied input type(s) for the category 'violence/graphic'."] # [serde (rename = "violence/graphic")] pub violence_graphic : Vec < crate :: __types :: create_moderation_response :: results :: item :: category_applied_input_types :: violence_graphic :: Item > }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item { # [doc = "Whether any of the below categories are flagged."] # [serde (rename = "flagged")] pub flagged : bool , # [doc = "A list of the categories, and whether they are flagged or not."] # [serde (rename = "categories")] pub categories : crate :: __types :: create_moderation_response :: results :: item :: Categories , # [doc = "A list of the categories along with their scores as predicted by model."] # [serde (rename = "category_scores")] pub category_scores : crate :: __types :: create_moderation_response :: results :: item :: CategoryScores , # [doc = "A list of the categories along with the input type(s) that the score applies to."] # [serde (rename = "category_applied_input_types")] pub category_applied_input_types : crate :: __types :: create_moderation_response :: results :: item :: CategoryAppliedInputTypes }
    }
}
#[doc = "Represents if a given text input is potentially harmful."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateModerationResponse {
    #[doc = "The unique identifier for the moderation request."]
    #[serde(rename = "id")]
    pub id: String,
    #[doc = "The model used to generate the moderation results."]
    #[serde(rename = "model")]
    pub model: String,
    #[doc = "A list of moderation objects."]
    #[serde(rename = "results")]
    pub results: Vec<crate::__types::create_moderation_response::results::Item>,
}
#[allow(clippy::module_inception)]
pub mod create_response {
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Text {
        #[serde(rename = "format")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub format: Option<crate::__types::TextResponseFormatConfiguration>,
        #[serde(rename = "verbosity")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub verbosity: Option<crate::__types::Verbosity>,
    }
    #[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum ToolChoice {
        ToolChoiceOptions(crate::__types::ToolChoiceOptions),
        ToolChoiceAllowed(crate::__types::ToolChoiceAllowed),
        ToolChoiceTypes(crate::__types::ToolChoiceTypes),
        ToolChoiceFunction(crate::__types::ToolChoiceFunction),
        ToolChoiceMcp(crate::__types::ToolChoiceMcp),
        ToolChoiceCustom(crate::__types::ToolChoiceCustom),
    }
    impl<'de> serde::Deserialize<'de> for ToolChoice {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum ToolChoice {
                ToolChoiceOptions(crate::__types::ToolChoiceOptions),
                ToolChoiceAllowed(crate::__types::ToolChoiceAllowed),
                ToolChoiceTypes(crate::__types::ToolChoiceTypes),
                ToolChoiceFunction(crate::__types::ToolChoiceFunction),
                ToolChoiceMcp(crate::__types::ToolChoiceMcp),
                ToolChoiceCustom(crate::__types::ToolChoiceCustom),
            }
            Ok(match ToolChoice::deserialize(deserializer)? {
                ToolChoice::ToolChoiceOptions(v) => Self::ToolChoiceOptions(v),
                ToolChoice::ToolChoiceAllowed(v) => Self::ToolChoiceAllowed(v),
                ToolChoice::ToolChoiceTypes(v) => Self::ToolChoiceTypes(v),
                ToolChoice::ToolChoiceFunction(v) => Self::ToolChoiceFunction(v),
                ToolChoice::ToolChoiceMcp(v) => Self::ToolChoiceMcp(v),
                ToolChoice::ToolChoiceCustom(v) => Self::ToolChoiceCustom(v),
            })
        }
    }
    impl serde::Serialize for ToolChoice {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum ToolChoice<'a> {
                ToolChoiceOptions(&'a crate::__types::ToolChoiceOptions),
                ToolChoiceAllowed(&'a crate::__types::ToolChoiceAllowed),
                ToolChoiceTypes(&'a crate::__types::ToolChoiceTypes),
                ToolChoiceFunction(&'a crate::__types::ToolChoiceFunction),
                ToolChoiceMcp(&'a crate::__types::ToolChoiceMcp),
                ToolChoiceCustom(&'a crate::__types::ToolChoiceCustom),
            }
            match self {
                Self::ToolChoiceOptions(v) => ToolChoice::ToolChoiceOptions(v),
                Self::ToolChoiceAllowed(v) => ToolChoice::ToolChoiceAllowed(v),
                Self::ToolChoiceTypes(v) => ToolChoice::ToolChoiceTypes(v),
                Self::ToolChoiceFunction(v) => ToolChoice::ToolChoiceFunction(v),
                Self::ToolChoiceMcp(v) => ToolChoice::ToolChoiceMcp(v),
                Self::ToolChoiceCustom(v) => ToolChoice::ToolChoiceCustom(v),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping input items in the\n  middle of the conversation.\n- `disabled` (default): If a model response will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Truncation {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`disabled`"]
        #[default]
        #[serde(rename = "disabled")]
        Disabled,
    }
    #[doc = "Text, image, or file inputs to the model, used to generate a response.\n\nLearn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Image inputs](https://platform.openai.com/docs/guides/images)\n- [File inputs](https://platform.openai.com/docs/guides/pdf-files)\n- [Conversation state](https://platform.openai.com/docs/guides/conversation-state)\n- [Function calling](https://platform.openai.com/docs/guides/function-calling)\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Input {
        #[doc = "A text input to the model, equivalent to a text input with the\n`user` role.\n"]
        String(String),
        #[doc = "A list of one or many input items to the model, containing\ndifferent content types.\n"]
        Array(Vec<crate::__types::InputItem>),
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateResponse {
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<crate::__types::create_response::Text>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"]
    #[serde(rename = "top_logprobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_logprobs: Option<i64>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users. \nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
    #[doc = "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. \nThe IDs should be a string that uniquely identifies each user. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[serde(rename = "safety_identifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub safety_identifier: Option<String>,
    #[doc = "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](https://platform.openai.com/docs/guides/prompt-caching).\n"]
    #[serde(rename = "prompt_cache_key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt_cache_key: Option<String>,
    #[serde(rename = "service_tier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service_tier: Option<crate::__types::ServiceTier>,
    #[doc = "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](https://platform.openai.com/docs/guides/conversation-state).\n"]
    #[serde(rename = "previous_response_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub previous_response_id: Option<String>,
    #[doc = "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\nto browse and compare available models.\n"]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::ModelIdsResponses>,
    #[serde(rename = "reasoning")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reasoning: Option<crate::__types::Reasoning>,
    #[doc = "Whether to run the model response in the background.\n[Learn more](https://platform.openai.com/docs/guides/background).\n"]
    #[serde(rename = "background")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub background: Option<bool>,
    #[doc = "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\n"]
    #[serde(rename = "max_output_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_output_tokens: Option<i64>,
    #[doc = "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"]
    #[serde(rename = "max_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_tool_calls: Option<i64>,
    #[doc = "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nThe two categories of tools you can provide the model are:\n\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](https://platform.openai.com/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::Tool>>,
    #[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<crate::__types::create_response::ToolChoice>,
    #[serde(rename = "prompt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt: Option<crate::__types::Prompt>,
    #[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping input items in the\n  middle of the conversation.\n- `disabled` (default): If a model response will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"]
    #[serde(rename = "truncation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub truncation: Option<crate::__types::create_response::Truncation>,
    #[doc = "Text, image, or file inputs to the model, used to generate a response.\n\nLearn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Image inputs](https://platform.openai.com/docs/guides/images)\n- [File inputs](https://platform.openai.com/docs/guides/pdf-files)\n- [Conversation state](https://platform.openai.com/docs/guides/conversation-state)\n- [Function calling](https://platform.openai.com/docs/guides/function-calling)\n"]
    #[serde(rename = "input")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input: Option<crate::__types::create_response::Input>,
    #[doc = "Specify additional output data to include in the model response. Currently\nsupported values are:\n- `code_interpreter_call.outputs`: Includes the outputs of python code execution\n  in code interpreter tool call items.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n- `file_search_call.results`: Include the search results of\n  the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `message.output_text.logprobs`: Include logprobs with assistant messages.\n- `reasoning.encrypted_content`: Includes an encrypted version of reasoning\n  tokens in reasoning item outputs. This enables reasoning items to be used in\n  multi-turn conversations when using the Responses API statelessly (like\n  when the `store` parameter is set to `false`, or when an organization is\n  enrolled in the zero data retention program).\n"]
    #[serde(rename = "include")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub include: Option<Vec<crate::__types::Includable>>,
    #[doc = "Whether to allow the model to run tool calls in parallel.\n"]
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parallel_tool_calls: Option<bool>,
    #[doc = "Whether to store the generated model response for later retrieval via\nAPI.\n"]
    #[serde(rename = "store")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub store: Option<bool>,
    #[doc = "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](https://platform.openai.com/docs/api-reference/responses-streaming)\nfor more information.\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
    #[serde(rename = "stream_options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream_options: Option<crate::__types::ResponseStreamOptions>,
}
#[allow(clippy::module_inception)]
pub mod create_run_request {
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        AssistantSupportedModels(crate::__types::AssistantSupportedModels),
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                AssistantSupportedModels(crate::__types::AssistantSupportedModels),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::AssistantSupportedModels(v) => Self::AssistantSupportedModels(v),
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                AssistantSupportedModels(&'a crate::__types::AssistantSupportedModels),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::AssistantSupportedModels(v) => Model::AssistantSupportedModels(v),
            }
            .serialize(serializer)
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateRunRequest {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::create_run_request::Model>,
    #[serde(rename = "reasoning_effort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reasoning_effort: Option<crate::__types::ReasoningEffort>,
    #[doc = "Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions."]
    #[serde(rename = "additional_instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub additional_instructions: Option<String>,
    #[doc = "Adds additional messages to the thread before creating the run."]
    #[serde(rename = "additional_messages")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub additional_messages: Option<Vec<crate::__types::CreateMessageRequest>>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::AssistantTool>>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[serde(rename = "max_prompt_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_prompt_tokens: Option<i64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[serde(rename = "max_completion_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_completion_tokens: Option<i64>,
    #[serde(rename = "truncation_strategy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub truncation_strategy: Option<crate::__types::TruncationObject>,
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<crate::__types::AssistantsApiToolChoiceOption>,
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parallel_tool_calls: Option<crate::__types::ParallelToolCalls>,
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
}
#[allow(clippy::module_inception)]
pub mod create_speech_request {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "tts-1"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Tts1;
        impl_serde!(Tts1, "tts-1");
        #[doc = "tts-1-hd"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Tts1Hd;
        impl_serde!(Tts1Hd, "tts-1-hd");
        #[doc = "gpt-4o-mini-tts"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4oMiniTts;
        impl_serde!(Gpt4oMiniTts, "gpt-4o-mini-tts");
    }
    #[doc = "One of the available [TTS models](https://platform.openai.com/docs/models#tts): `tts-1`, `tts-1-hd` or `gpt-4o-mini-tts`.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "tts-1"]
        Tts1,
        #[doc = "tts-1-hd"]
        Tts1Hd,
        #[doc = "gpt-4o-mini-tts"]
        Gpt4oMiniTts,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                Tts1(crate::__types::create_speech_request::model::Tts1),
                Tts1Hd(crate::__types::create_speech_request::model::Tts1Hd),
                Gpt4oMiniTts(crate::__types::create_speech_request::model::Gpt4oMiniTts),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::Tts1(_) => Self::Tts1,
                Model::Tts1Hd(_) => Self::Tts1Hd,
                Model::Gpt4oMiniTts(_) => Self::Gpt4oMiniTts,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                Tts1(crate::__types::create_speech_request::model::Tts1),
                Tts1Hd(crate::__types::create_speech_request::model::Tts1Hd),
                Gpt4oMiniTts(crate::__types::create_speech_request::model::Gpt4oMiniTts),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::Tts1 => Model::Tts1(Default::default()),
                Self::Tts1Hd => Model::Tts1Hd(Default::default()),
                Self::Gpt4oMiniTts => Model::Gpt4oMiniTts(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum ResponseFormat {
        #[doc = "`mp3`"]
        #[default]
        #[serde(rename = "mp3")]
        Mp3,
        #[doc = "`opus`"]
        #[serde(rename = "opus")]
        Opus,
        #[doc = "`aac`"]
        #[serde(rename = "aac")]
        Aac,
        #[doc = "`flac`"]
        #[serde(rename = "flac")]
        Flac,
        #[doc = "`wav`"]
        #[serde(rename = "wav")]
        Wav,
        #[doc = "`pcm`"]
        #[serde(rename = "pcm")]
        Pcm,
    }
    #[doc = "The format to stream the audio in. Supported formats are `sse` and `audio`. `sse` is not supported for `tts-1` or `tts-1-hd`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum StreamFormat {
        #[doc = "`sse`"]
        #[serde(rename = "sse")]
        Sse,
        #[doc = "`audio`"]
        #[default]
        #[serde(rename = "audio")]
        Audio,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateSpeechRequest {
    #[doc = "One of the available [TTS models](https://platform.openai.com/docs/models#tts): `tts-1`, `tts-1-hd` or `gpt-4o-mini-tts`.\n"]
    #[serde(rename = "model")]
    pub model: crate::__types::create_speech_request::Model,
    #[doc = "The text to generate audio for. The maximum length is 4096 characters."]
    #[serde(rename = "input")]
    pub input: String,
    #[doc = "Control the voice of your generated audio with additional instructions. Does not work with `tts-1` or `tts-1-hd`."]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice to use when generating the audio. Supported voices are `alloy`, `ash`, `ballad`, `coral`, `echo`, `fable`, `onyx`, `nova`, `sage`, `shimmer`, and `verse`. Previews of the voices are available in the [Text to speech guide](https://platform.openai.com/docs/guides/text-to-speech#voice-options)."]
    #[serde(rename = "voice")]
    pub voice: crate::__types::VoiceIdsShared,
    #[doc = "The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`."]
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::create_speech_request::ResponseFormat>,
    #[doc = "The speed of the generated audio. Select a value from `0.25` to `4.0`. `1.0` is the default."]
    #[serde(rename = "speed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub speed: Option<serde_json::Number>,
    #[doc = "The format to stream the audio in. Supported formats are `sse` and `audio`. `sse` is not supported for `tts-1` or `tts-1-hd`."]
    #[serde(rename = "stream_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream_format: Option<crate::__types::create_speech_request::StreamFormat>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum CreateSpeechResponseStreamEvent {
    SpeechAudioDelta(crate::__types::SpeechAudioDeltaEvent),
    SpeechAudioDone(crate::__types::SpeechAudioDoneEvent),
}
#[allow(clippy::module_inception)]
pub mod create_thread_and_run_request {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "gpt-5"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5;
        impl_serde!(Gpt5, "gpt-5");
        #[doc = "gpt-5-mini"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5Mini;
        impl_serde!(Gpt5Mini, "gpt-5-mini");
        #[doc = "gpt-5-nano"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5Nano;
        impl_serde!(Gpt5Nano, "gpt-5-nano");
        #[doc = "gpt-5-2025-08-07"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5_2025_08_07;
        impl_serde!(Gpt5_2025_08_07, "gpt-5-2025-08-07");
        #[doc = "gpt-5-mini-2025-08-07"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5Mini2025_08_07;
        impl_serde!(Gpt5Mini2025_08_07, "gpt-5-mini-2025-08-07");
        #[doc = "gpt-5-nano-2025-08-07"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5Nano2025_08_07;
        impl_serde!(Gpt5Nano2025_08_07, "gpt-5-nano-2025-08-07");
        #[doc = "gpt-4.1"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1;
        impl_serde!(Gpt4_1, "gpt-4.1");
        #[doc = "gpt-4.1-mini"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1Mini;
        impl_serde!(Gpt4_1Mini, "gpt-4.1-mini");
        #[doc = "gpt-4.1-nano"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1Nano;
        impl_serde!(Gpt4_1Nano, "gpt-4.1-nano");
        #[doc = "gpt-4.1-2025-04-14"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1_2025_04_14;
        impl_serde!(Gpt4_1_2025_04_14, "gpt-4.1-2025-04-14");
        #[doc = "gpt-4.1-mini-2025-04-14"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1Mini2025_04_14;
        impl_serde!(Gpt4_1Mini2025_04_14, "gpt-4.1-mini-2025-04-14");
        #[doc = "gpt-4.1-nano-2025-04-14"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1Nano2025_04_14;
        impl_serde!(Gpt4_1Nano2025_04_14, "gpt-4.1-nano-2025-04-14");
        #[doc = "gpt-4o"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4o;
        impl_serde!(Gpt4o, "gpt-4o");
        #[doc = "gpt-4o-2024-11-20"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4o2024_11_20;
        impl_serde!(Gpt4o2024_11_20, "gpt-4o-2024-11-20");
        #[doc = "gpt-4o-2024-08-06"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4o2024_08_06;
        impl_serde!(Gpt4o2024_08_06, "gpt-4o-2024-08-06");
        #[doc = "gpt-4o-2024-05-13"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4o2024_05_13;
        impl_serde!(Gpt4o2024_05_13, "gpt-4o-2024-05-13");
        #[doc = "gpt-4o-mini"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4oMini;
        impl_serde!(Gpt4oMini, "gpt-4o-mini");
        #[doc = "gpt-4o-mini-2024-07-18"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4oMini2024_07_18;
        impl_serde!(Gpt4oMini2024_07_18, "gpt-4o-mini-2024-07-18");
        #[doc = "gpt-4.5-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_5Preview;
        impl_serde!(Gpt4_5Preview, "gpt-4.5-preview");
        #[doc = "gpt-4.5-preview-2025-02-27"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_5Preview2025_02_27;
        impl_serde!(Gpt4_5Preview2025_02_27, "gpt-4.5-preview-2025-02-27");
        #[doc = "gpt-4-turbo"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4Turbo;
        impl_serde!(Gpt4Turbo, "gpt-4-turbo");
        #[doc = "gpt-4-turbo-2024-04-09"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4Turbo2024_04_09;
        impl_serde!(Gpt4Turbo2024_04_09, "gpt-4-turbo-2024-04-09");
        #[doc = "gpt-4-0125-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_0125Preview;
        impl_serde!(Gpt4_0125Preview, "gpt-4-0125-preview");
        #[doc = "gpt-4-turbo-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4TurboPreview;
        impl_serde!(Gpt4TurboPreview, "gpt-4-turbo-preview");
        #[doc = "gpt-4-1106-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1106Preview;
        impl_serde!(Gpt4_1106Preview, "gpt-4-1106-preview");
        #[doc = "gpt-4-vision-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4VisionPreview;
        impl_serde!(Gpt4VisionPreview, "gpt-4-vision-preview");
        #[doc = "gpt-4"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4;
        impl_serde!(Gpt4, "gpt-4");
        #[doc = "gpt-4-0314"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_0314;
        impl_serde!(Gpt4_0314, "gpt-4-0314");
        #[doc = "gpt-4-0613"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_0613;
        impl_serde!(Gpt4_0613, "gpt-4-0613");
        #[doc = "gpt-4-32k"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_32k;
        impl_serde!(Gpt4_32k, "gpt-4-32k");
        #[doc = "gpt-4-32k-0314"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_32k0314;
        impl_serde!(Gpt4_32k0314, "gpt-4-32k-0314");
        #[doc = "gpt-4-32k-0613"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_32k0613;
        impl_serde!(Gpt4_32k0613, "gpt-4-32k-0613");
        #[doc = "gpt-3.5-turbo"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo;
        impl_serde!(Gpt3_5Turbo, "gpt-3.5-turbo");
        #[doc = "gpt-3.5-turbo-16k"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo16k;
        impl_serde!(Gpt3_5Turbo16k, "gpt-3.5-turbo-16k");
        #[doc = "gpt-3.5-turbo-0613"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo0613;
        impl_serde!(Gpt3_5Turbo0613, "gpt-3.5-turbo-0613");
        #[doc = "gpt-3.5-turbo-1106"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo1106;
        impl_serde!(Gpt3_5Turbo1106, "gpt-3.5-turbo-1106");
        #[doc = "gpt-3.5-turbo-0125"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo0125;
        impl_serde!(Gpt3_5Turbo0125, "gpt-3.5-turbo-0125");
        #[doc = "gpt-3.5-turbo-16k-0613"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo16k0613;
        impl_serde!(Gpt3_5Turbo16k0613, "gpt-3.5-turbo-16k-0613");
    }
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "gpt-5"]
        Gpt5,
        #[doc = "gpt-5-mini"]
        Gpt5Mini,
        #[doc = "gpt-5-nano"]
        Gpt5Nano,
        #[doc = "gpt-5-2025-08-07"]
        Gpt5_2025_08_07,
        #[doc = "gpt-5-mini-2025-08-07"]
        Gpt5Mini2025_08_07,
        #[doc = "gpt-5-nano-2025-08-07"]
        Gpt5Nano2025_08_07,
        #[doc = "gpt-4.1"]
        Gpt4_1,
        #[doc = "gpt-4.1-mini"]
        Gpt4_1Mini,
        #[doc = "gpt-4.1-nano"]
        Gpt4_1Nano,
        #[doc = "gpt-4.1-2025-04-14"]
        Gpt4_1_2025_04_14,
        #[doc = "gpt-4.1-mini-2025-04-14"]
        Gpt4_1Mini2025_04_14,
        #[doc = "gpt-4.1-nano-2025-04-14"]
        Gpt4_1Nano2025_04_14,
        #[doc = "gpt-4o"]
        Gpt4o,
        #[doc = "gpt-4o-2024-11-20"]
        Gpt4o2024_11_20,
        #[doc = "gpt-4o-2024-08-06"]
        Gpt4o2024_08_06,
        #[doc = "gpt-4o-2024-05-13"]
        Gpt4o2024_05_13,
        #[doc = "gpt-4o-mini"]
        Gpt4oMini,
        #[doc = "gpt-4o-mini-2024-07-18"]
        Gpt4oMini2024_07_18,
        #[doc = "gpt-4.5-preview"]
        Gpt4_5Preview,
        #[doc = "gpt-4.5-preview-2025-02-27"]
        Gpt4_5Preview2025_02_27,
        #[doc = "gpt-4-turbo"]
        Gpt4Turbo,
        #[doc = "gpt-4-turbo-2024-04-09"]
        Gpt4Turbo2024_04_09,
        #[doc = "gpt-4-0125-preview"]
        Gpt4_0125Preview,
        #[doc = "gpt-4-turbo-preview"]
        Gpt4TurboPreview,
        #[doc = "gpt-4-1106-preview"]
        Gpt4_1106Preview,
        #[doc = "gpt-4-vision-preview"]
        Gpt4VisionPreview,
        #[doc = "gpt-4"]
        Gpt4,
        #[doc = "gpt-4-0314"]
        Gpt4_0314,
        #[doc = "gpt-4-0613"]
        Gpt4_0613,
        #[doc = "gpt-4-32k"]
        Gpt4_32k,
        #[doc = "gpt-4-32k-0314"]
        Gpt4_32k0314,
        #[doc = "gpt-4-32k-0613"]
        Gpt4_32k0613,
        #[doc = "gpt-3.5-turbo"]
        Gpt3_5Turbo,
        #[doc = "gpt-3.5-turbo-16k"]
        Gpt3_5Turbo16k,
        #[doc = "gpt-3.5-turbo-0613"]
        Gpt3_5Turbo0613,
        #[doc = "gpt-3.5-turbo-1106"]
        Gpt3_5Turbo1106,
        #[doc = "gpt-3.5-turbo-0125"]
        Gpt3_5Turbo0125,
        #[doc = "gpt-3.5-turbo-16k-0613"]
        Gpt3_5Turbo16k0613,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                Gpt5(crate::__types::create_thread_and_run_request::model::Gpt5),
                Gpt5Mini(crate::__types::create_thread_and_run_request::model::Gpt5Mini),
                Gpt5Nano(crate::__types::create_thread_and_run_request::model::Gpt5Nano),
                Gpt5_2025_08_07(
                    crate::__types::create_thread_and_run_request::model::Gpt5_2025_08_07,
                ),
                Gpt5Mini2025_08_07(
                    crate::__types::create_thread_and_run_request::model::Gpt5Mini2025_08_07,
                ),
                Gpt5Nano2025_08_07(
                    crate::__types::create_thread_and_run_request::model::Gpt5Nano2025_08_07,
                ),
                Gpt4_1(crate::__types::create_thread_and_run_request::model::Gpt4_1),
                Gpt4_1Mini(crate::__types::create_thread_and_run_request::model::Gpt4_1Mini),
                Gpt4_1Nano(crate::__types::create_thread_and_run_request::model::Gpt4_1Nano),
                Gpt4_1_2025_04_14(
                    crate::__types::create_thread_and_run_request::model::Gpt4_1_2025_04_14,
                ),
                Gpt4_1Mini2025_04_14(
                    crate::__types::create_thread_and_run_request::model::Gpt4_1Mini2025_04_14,
                ),
                Gpt4_1Nano2025_04_14(
                    crate::__types::create_thread_and_run_request::model::Gpt4_1Nano2025_04_14,
                ),
                Gpt4o(crate::__types::create_thread_and_run_request::model::Gpt4o),
                Gpt4o2024_11_20(
                    crate::__types::create_thread_and_run_request::model::Gpt4o2024_11_20,
                ),
                Gpt4o2024_08_06(
                    crate::__types::create_thread_and_run_request::model::Gpt4o2024_08_06,
                ),
                Gpt4o2024_05_13(
                    crate::__types::create_thread_and_run_request::model::Gpt4o2024_05_13,
                ),
                Gpt4oMini(crate::__types::create_thread_and_run_request::model::Gpt4oMini),
                Gpt4oMini2024_07_18(
                    crate::__types::create_thread_and_run_request::model::Gpt4oMini2024_07_18,
                ),
                Gpt4_5Preview(crate::__types::create_thread_and_run_request::model::Gpt4_5Preview),
                Gpt4_5Preview2025_02_27(
                    crate::__types::create_thread_and_run_request::model::Gpt4_5Preview2025_02_27,
                ),
                Gpt4Turbo(crate::__types::create_thread_and_run_request::model::Gpt4Turbo),
                Gpt4Turbo2024_04_09(
                    crate::__types::create_thread_and_run_request::model::Gpt4Turbo2024_04_09,
                ),
                Gpt4_0125Preview(
                    crate::__types::create_thread_and_run_request::model::Gpt4_0125Preview,
                ),
                Gpt4TurboPreview(
                    crate::__types::create_thread_and_run_request::model::Gpt4TurboPreview,
                ),
                Gpt4_1106Preview(
                    crate::__types::create_thread_and_run_request::model::Gpt4_1106Preview,
                ),
                Gpt4VisionPreview(
                    crate::__types::create_thread_and_run_request::model::Gpt4VisionPreview,
                ),
                Gpt4(crate::__types::create_thread_and_run_request::model::Gpt4),
                Gpt4_0314(crate::__types::create_thread_and_run_request::model::Gpt4_0314),
                Gpt4_0613(crate::__types::create_thread_and_run_request::model::Gpt4_0613),
                Gpt4_32k(crate::__types::create_thread_and_run_request::model::Gpt4_32k),
                Gpt4_32k0314(crate::__types::create_thread_and_run_request::model::Gpt4_32k0314),
                Gpt4_32k0613(crate::__types::create_thread_and_run_request::model::Gpt4_32k0613),
                Gpt3_5Turbo(crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo),
                Gpt3_5Turbo16k(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo16k,
                ),
                Gpt3_5Turbo0613(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo0613,
                ),
                Gpt3_5Turbo1106(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo1106,
                ),
                Gpt3_5Turbo0125(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo0125,
                ),
                Gpt3_5Turbo16k0613(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo16k0613,
                ),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::Gpt5(_) => Self::Gpt5,
                Model::Gpt5Mini(_) => Self::Gpt5Mini,
                Model::Gpt5Nano(_) => Self::Gpt5Nano,
                Model::Gpt5_2025_08_07(_) => Self::Gpt5_2025_08_07,
                Model::Gpt5Mini2025_08_07(_) => Self::Gpt5Mini2025_08_07,
                Model::Gpt5Nano2025_08_07(_) => Self::Gpt5Nano2025_08_07,
                Model::Gpt4_1(_) => Self::Gpt4_1,
                Model::Gpt4_1Mini(_) => Self::Gpt4_1Mini,
                Model::Gpt4_1Nano(_) => Self::Gpt4_1Nano,
                Model::Gpt4_1_2025_04_14(_) => Self::Gpt4_1_2025_04_14,
                Model::Gpt4_1Mini2025_04_14(_) => Self::Gpt4_1Mini2025_04_14,
                Model::Gpt4_1Nano2025_04_14(_) => Self::Gpt4_1Nano2025_04_14,
                Model::Gpt4o(_) => Self::Gpt4o,
                Model::Gpt4o2024_11_20(_) => Self::Gpt4o2024_11_20,
                Model::Gpt4o2024_08_06(_) => Self::Gpt4o2024_08_06,
                Model::Gpt4o2024_05_13(_) => Self::Gpt4o2024_05_13,
                Model::Gpt4oMini(_) => Self::Gpt4oMini,
                Model::Gpt4oMini2024_07_18(_) => Self::Gpt4oMini2024_07_18,
                Model::Gpt4_5Preview(_) => Self::Gpt4_5Preview,
                Model::Gpt4_5Preview2025_02_27(_) => Self::Gpt4_5Preview2025_02_27,
                Model::Gpt4Turbo(_) => Self::Gpt4Turbo,
                Model::Gpt4Turbo2024_04_09(_) => Self::Gpt4Turbo2024_04_09,
                Model::Gpt4_0125Preview(_) => Self::Gpt4_0125Preview,
                Model::Gpt4TurboPreview(_) => Self::Gpt4TurboPreview,
                Model::Gpt4_1106Preview(_) => Self::Gpt4_1106Preview,
                Model::Gpt4VisionPreview(_) => Self::Gpt4VisionPreview,
                Model::Gpt4(_) => Self::Gpt4,
                Model::Gpt4_0314(_) => Self::Gpt4_0314,
                Model::Gpt4_0613(_) => Self::Gpt4_0613,
                Model::Gpt4_32k(_) => Self::Gpt4_32k,
                Model::Gpt4_32k0314(_) => Self::Gpt4_32k0314,
                Model::Gpt4_32k0613(_) => Self::Gpt4_32k0613,
                Model::Gpt3_5Turbo(_) => Self::Gpt3_5Turbo,
                Model::Gpt3_5Turbo16k(_) => Self::Gpt3_5Turbo16k,
                Model::Gpt3_5Turbo0613(_) => Self::Gpt3_5Turbo0613,
                Model::Gpt3_5Turbo1106(_) => Self::Gpt3_5Turbo1106,
                Model::Gpt3_5Turbo0125(_) => Self::Gpt3_5Turbo0125,
                Model::Gpt3_5Turbo16k0613(_) => Self::Gpt3_5Turbo16k0613,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                Gpt5(crate::__types::create_thread_and_run_request::model::Gpt5),
                Gpt5Mini(crate::__types::create_thread_and_run_request::model::Gpt5Mini),
                Gpt5Nano(crate::__types::create_thread_and_run_request::model::Gpt5Nano),
                Gpt5_2025_08_07(
                    crate::__types::create_thread_and_run_request::model::Gpt5_2025_08_07,
                ),
                Gpt5Mini2025_08_07(
                    crate::__types::create_thread_and_run_request::model::Gpt5Mini2025_08_07,
                ),
                Gpt5Nano2025_08_07(
                    crate::__types::create_thread_and_run_request::model::Gpt5Nano2025_08_07,
                ),
                Gpt4_1(crate::__types::create_thread_and_run_request::model::Gpt4_1),
                Gpt4_1Mini(crate::__types::create_thread_and_run_request::model::Gpt4_1Mini),
                Gpt4_1Nano(crate::__types::create_thread_and_run_request::model::Gpt4_1Nano),
                Gpt4_1_2025_04_14(
                    crate::__types::create_thread_and_run_request::model::Gpt4_1_2025_04_14,
                ),
                Gpt4_1Mini2025_04_14(
                    crate::__types::create_thread_and_run_request::model::Gpt4_1Mini2025_04_14,
                ),
                Gpt4_1Nano2025_04_14(
                    crate::__types::create_thread_and_run_request::model::Gpt4_1Nano2025_04_14,
                ),
                Gpt4o(crate::__types::create_thread_and_run_request::model::Gpt4o),
                Gpt4o2024_11_20(
                    crate::__types::create_thread_and_run_request::model::Gpt4o2024_11_20,
                ),
                Gpt4o2024_08_06(
                    crate::__types::create_thread_and_run_request::model::Gpt4o2024_08_06,
                ),
                Gpt4o2024_05_13(
                    crate::__types::create_thread_and_run_request::model::Gpt4o2024_05_13,
                ),
                Gpt4oMini(crate::__types::create_thread_and_run_request::model::Gpt4oMini),
                Gpt4oMini2024_07_18(
                    crate::__types::create_thread_and_run_request::model::Gpt4oMini2024_07_18,
                ),
                Gpt4_5Preview(crate::__types::create_thread_and_run_request::model::Gpt4_5Preview),
                Gpt4_5Preview2025_02_27(
                    crate::__types::create_thread_and_run_request::model::Gpt4_5Preview2025_02_27,
                ),
                Gpt4Turbo(crate::__types::create_thread_and_run_request::model::Gpt4Turbo),
                Gpt4Turbo2024_04_09(
                    crate::__types::create_thread_and_run_request::model::Gpt4Turbo2024_04_09,
                ),
                Gpt4_0125Preview(
                    crate::__types::create_thread_and_run_request::model::Gpt4_0125Preview,
                ),
                Gpt4TurboPreview(
                    crate::__types::create_thread_and_run_request::model::Gpt4TurboPreview,
                ),
                Gpt4_1106Preview(
                    crate::__types::create_thread_and_run_request::model::Gpt4_1106Preview,
                ),
                Gpt4VisionPreview(
                    crate::__types::create_thread_and_run_request::model::Gpt4VisionPreview,
                ),
                Gpt4(crate::__types::create_thread_and_run_request::model::Gpt4),
                Gpt4_0314(crate::__types::create_thread_and_run_request::model::Gpt4_0314),
                Gpt4_0613(crate::__types::create_thread_and_run_request::model::Gpt4_0613),
                Gpt4_32k(crate::__types::create_thread_and_run_request::model::Gpt4_32k),
                Gpt4_32k0314(crate::__types::create_thread_and_run_request::model::Gpt4_32k0314),
                Gpt4_32k0613(crate::__types::create_thread_and_run_request::model::Gpt4_32k0613),
                Gpt3_5Turbo(crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo),
                Gpt3_5Turbo16k(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo16k,
                ),
                Gpt3_5Turbo0613(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo0613,
                ),
                Gpt3_5Turbo1106(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo1106,
                ),
                Gpt3_5Turbo0125(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo0125,
                ),
                Gpt3_5Turbo16k0613(
                    crate::__types::create_thread_and_run_request::model::Gpt3_5Turbo16k0613,
                ),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::Gpt5 => Model::Gpt5(Default::default()),
                Self::Gpt5Mini => Model::Gpt5Mini(Default::default()),
                Self::Gpt5Nano => Model::Gpt5Nano(Default::default()),
                Self::Gpt5_2025_08_07 => Model::Gpt5_2025_08_07(Default::default()),
                Self::Gpt5Mini2025_08_07 => Model::Gpt5Mini2025_08_07(Default::default()),
                Self::Gpt5Nano2025_08_07 => Model::Gpt5Nano2025_08_07(Default::default()),
                Self::Gpt4_1 => Model::Gpt4_1(Default::default()),
                Self::Gpt4_1Mini => Model::Gpt4_1Mini(Default::default()),
                Self::Gpt4_1Nano => Model::Gpt4_1Nano(Default::default()),
                Self::Gpt4_1_2025_04_14 => Model::Gpt4_1_2025_04_14(Default::default()),
                Self::Gpt4_1Mini2025_04_14 => Model::Gpt4_1Mini2025_04_14(Default::default()),
                Self::Gpt4_1Nano2025_04_14 => Model::Gpt4_1Nano2025_04_14(Default::default()),
                Self::Gpt4o => Model::Gpt4o(Default::default()),
                Self::Gpt4o2024_11_20 => Model::Gpt4o2024_11_20(Default::default()),
                Self::Gpt4o2024_08_06 => Model::Gpt4o2024_08_06(Default::default()),
                Self::Gpt4o2024_05_13 => Model::Gpt4o2024_05_13(Default::default()),
                Self::Gpt4oMini => Model::Gpt4oMini(Default::default()),
                Self::Gpt4oMini2024_07_18 => Model::Gpt4oMini2024_07_18(Default::default()),
                Self::Gpt4_5Preview => Model::Gpt4_5Preview(Default::default()),
                Self::Gpt4_5Preview2025_02_27 => Model::Gpt4_5Preview2025_02_27(Default::default()),
                Self::Gpt4Turbo => Model::Gpt4Turbo(Default::default()),
                Self::Gpt4Turbo2024_04_09 => Model::Gpt4Turbo2024_04_09(Default::default()),
                Self::Gpt4_0125Preview => Model::Gpt4_0125Preview(Default::default()),
                Self::Gpt4TurboPreview => Model::Gpt4TurboPreview(Default::default()),
                Self::Gpt4_1106Preview => Model::Gpt4_1106Preview(Default::default()),
                Self::Gpt4VisionPreview => Model::Gpt4VisionPreview(Default::default()),
                Self::Gpt4 => Model::Gpt4(Default::default()),
                Self::Gpt4_0314 => Model::Gpt4_0314(Default::default()),
                Self::Gpt4_0613 => Model::Gpt4_0613(Default::default()),
                Self::Gpt4_32k => Model::Gpt4_32k(Default::default()),
                Self::Gpt4_32k0314 => Model::Gpt4_32k0314(Default::default()),
                Self::Gpt4_32k0613 => Model::Gpt4_32k0613(Default::default()),
                Self::Gpt3_5Turbo => Model::Gpt3_5Turbo(Default::default()),
                Self::Gpt3_5Turbo16k => Model::Gpt3_5Turbo16k(Default::default()),
                Self::Gpt3_5Turbo0613 => Model::Gpt3_5Turbo0613(Default::default()),
                Self::Gpt3_5Turbo1106 => Model::Gpt3_5Turbo1106(Default::default()),
                Self::Gpt3_5Turbo0125 => Model::Gpt3_5Turbo0125(Default::default()),
                Self::Gpt3_5Turbo16k0613 => Model::Gpt3_5Turbo16k0613(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod tool_resources {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct CodeInterpreter {
            #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_ids: Option<Vec<String>>,
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct FileSearch {
            #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub vector_store_ids: Option<Vec<String>>,
        }
    }
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ToolResources {
        #[serde(rename = "code_interpreter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code_interpreter:
            Option<crate::__types::create_thread_and_run_request::tool_resources::CodeInterpreter>,
        #[serde(rename = "file_search")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_search:
            Option<crate::__types::create_thread_and_run_request::tool_resources::FileSearch>,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequest {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,
    #[serde(rename = "thread")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub thread: Option<crate::__types::CreateThreadRequest>,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::create_thread_and_run_request::Model>,
    #[doc = "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::AssistantTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[serde(rename = "tool_resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_resources: Option<crate::__types::create_thread_and_run_request::ToolResources>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[serde(rename = "max_prompt_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_prompt_tokens: Option<i64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[serde(rename = "max_completion_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_completion_tokens: Option<i64>,
    #[serde(rename = "truncation_strategy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub truncation_strategy: Option<crate::__types::TruncationObject>,
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<crate::__types::AssistantsApiToolChoiceOption>,
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parallel_tool_calls: Option<crate::__types::ParallelToolCalls>,
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
}
#[allow(clippy::module_inception)]
pub mod create_thread_request {
    #[allow(clippy::module_inception)]
    pub mod tool_resources {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct CodeInterpreter {
            #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_ids: Option<Vec<String>>,
        }
        #[allow(clippy::module_inception)]
        pub mod file_search {
            #[allow(clippy::module_inception)]
            pub mod variant0 {
                #[allow(clippy::module_inception)]
                pub mod vector_stores {
                    #[allow(clippy::module_inception)]
                    pub mod item {
                        #[allow(clippy::module_inception)]
                        pub mod chunking_strategy {
                            #[allow(clippy::module_inception)]
                            pub(crate) mod auto {
                                #[doc = "Always `auto`."]
                                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                                pub(crate) struct Type;
                                impl_serde!(Type, "auto");
                            }
                            #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
                            #[derive(
                                Clone,
                                Copy,
                                Debug,
                                Default,
                                PartialEq,
                                typed_builder :: TypedBuilder,
                            )]
                            pub struct Auto {}
                            impl<'de> serde::Deserialize<'de> for Auto {
                                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Deserialize)]
                                    struct Auto { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: auto :: Type }
                                    let Auto { .. } = Auto::deserialize(deserializer)?;
                                    Ok(Self {})
                                }
                            }
                            impl serde::Serialize for Auto {
                                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                                where
                                    S: serde::Serializer,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Serialize)]
                                    struct Auto < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: auto :: Type }
                                    let Self {} = self;
                                    Auto {
                                        r#type: &Default::default(),
                                    }
                                    .serialize(serializer)
                                }
                            }
                            #[allow(clippy::module_inception)]
                            pub mod r#static {
                                #[doc = "Always `static`."]
                                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                                pub(crate) struct Type;
                                impl_serde!(Type, "static");
                                #[derive(Clone, Copy, Debug, PartialEq)]
                                #[serde_with::serde_as]
                                #[derive(
                                    serde :: Deserialize,
                                    serde :: Serialize,
                                    typed_builder :: TypedBuilder,
                                )]
                                pub struct Static {
                                    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
                                    #[serde(rename = "max_chunk_size_tokens")]
                                    pub max_chunk_size_tokens: i64,
                                    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
                                    #[serde(rename = "chunk_overlap_tokens")]
                                    pub chunk_overlap_tokens: i64,
                                }
                            }
                            #[derive(
                                Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder,
                            )]
                            pub struct Static { pub r#static : crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                            impl<'de> serde::Deserialize<'de> for Static {
                                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Deserialize)]
                                    struct Static { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Type , # [serde (rename = "static")] r#static : crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                                    let Static { r#static, .. } =
                                        Static::deserialize(deserializer)?;
                                    Ok(Self { r#static })
                                }
                            }
                            impl serde::Serialize for Static {
                                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                                where
                                    S: serde::Serializer,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Serialize)]
                                    struct Static < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Type , # [serde (rename = "static")] r#static : & 'a crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                                    let Self { r#static } = self;
                                    Static {
                                        r#type: &Default::default(),
                                        r#static,
                                    }
                                    .serialize(serializer)
                                }
                            }
                        }
                        #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
                        #[derive(Clone, Copy, Debug, PartialEq)]
                        #[serde_with::serde_as]
                        #[derive(serde :: Deserialize, serde :: Serialize)]
                        #[serde(untagged)]
                        #[allow(clippy::large_enum_variant)]
                        pub enum ChunkingStrategy {
                            # [doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."] Auto (crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: Auto) , Static (crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: chunking_strategy :: Static) }
                    }
                    #[derive(Clone, Debug, Default, PartialEq)]
                    #[serde_with::serde_as]
                    #[derive(
                        serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder,
                    )]
                    pub struct Item { # [doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"] # [serde (rename = "file_ids")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub file_ids : Option < Vec < String > > , # [doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."] # [serde (rename = "chunking_strategy")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub chunking_strategy : Option < crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: item :: ChunkingStrategy > , # [serde (rename = "metadata")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub metadata : Option < crate :: __types :: Metadata > }
                }
            }
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Variant0 { # [doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"] # [serde (rename = "vector_store_ids")] pub vector_store_ids : Vec < String > , # [doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.\n"] # [serde (rename = "vector_stores")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub vector_stores : Option < Vec < crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant0 :: vector_stores :: Item > > }
            #[allow(clippy::module_inception)]
            pub mod variant1 {
                #[allow(clippy::module_inception)]
                pub mod vector_stores {
                    #[allow(clippy::module_inception)]
                    pub mod item {
                        #[allow(clippy::module_inception)]
                        pub mod chunking_strategy {
                            #[allow(clippy::module_inception)]
                            pub(crate) mod auto {
                                #[doc = "Always `auto`."]
                                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                                pub(crate) struct Type;
                                impl_serde!(Type, "auto");
                            }
                            #[doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."]
                            #[derive(
                                Clone,
                                Copy,
                                Debug,
                                Default,
                                PartialEq,
                                typed_builder :: TypedBuilder,
                            )]
                            pub struct Auto {}
                            impl<'de> serde::Deserialize<'de> for Auto {
                                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Deserialize)]
                                    struct Auto { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: auto :: Type }
                                    let Auto { .. } = Auto::deserialize(deserializer)?;
                                    Ok(Self {})
                                }
                            }
                            impl serde::Serialize for Auto {
                                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                                where
                                    S: serde::Serializer,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Serialize)]
                                    struct Auto < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: auto :: Type }
                                    let Self {} = self;
                                    Auto {
                                        r#type: &Default::default(),
                                    }
                                    .serialize(serializer)
                                }
                            }
                            #[allow(clippy::module_inception)]
                            pub mod r#static {
                                #[doc = "Always `static`."]
                                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                                pub(crate) struct Type;
                                impl_serde!(Type, "static");
                                #[derive(Clone, Copy, Debug, PartialEq)]
                                #[serde_with::serde_as]
                                #[derive(
                                    serde :: Deserialize,
                                    serde :: Serialize,
                                    typed_builder :: TypedBuilder,
                                )]
                                pub struct Static {
                                    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
                                    #[serde(rename = "max_chunk_size_tokens")]
                                    pub max_chunk_size_tokens: i64,
                                    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
                                    #[serde(rename = "chunk_overlap_tokens")]
                                    pub chunk_overlap_tokens: i64,
                                }
                            }
                            #[derive(
                                Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder,
                            )]
                            pub struct Static { pub r#static : crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                            impl<'de> serde::Deserialize<'de> for Static {
                                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                                where
                                    D: serde::Deserializer<'de>,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Deserialize)]
                                    struct Static { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Type , # [serde (rename = "static")] r#static : crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                                    let Static { r#static, .. } =
                                        Static::deserialize(deserializer)?;
                                    Ok(Self { r#static })
                                }
                            }
                            impl serde::Serialize for Static {
                                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                                where
                                    S: serde::Serializer,
                                {
                                    #[serde_with::serde_as]
                                    #[derive(serde :: Serialize)]
                                    struct Static < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Type , # [serde (rename = "static")] r#static : & 'a crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: r#static :: Static }
                                    let Self { r#static } = self;
                                    Static {
                                        r#type: &Default::default(),
                                        r#static,
                                    }
                                    .serialize(serializer)
                                }
                            }
                        }
                        #[doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."]
                        #[derive(Clone, Copy, Debug, PartialEq)]
                        #[serde_with::serde_as]
                        #[derive(serde :: Deserialize, serde :: Serialize)]
                        #[serde(untagged)]
                        #[allow(clippy::large_enum_variant)]
                        pub enum ChunkingStrategy {
                            # [doc = "The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`."] Auto (crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: Auto) , Static (crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: chunking_strategy :: Static) }
                    }
                    #[derive(Clone, Debug, Default, PartialEq)]
                    #[serde_with::serde_as]
                    #[derive(
                        serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder,
                    )]
                    pub struct Item { # [doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs to add to the vector store. There can be a maximum of 10000 files in a vector store.\n"] # [serde (rename = "file_ids")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub file_ids : Option < Vec < String > > , # [doc = "The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy."] # [serde (rename = "chunking_strategy")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub chunking_strategy : Option < crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: item :: ChunkingStrategy > , # [serde (rename = "metadata")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub metadata : Option < crate :: __types :: Metadata > }
                }
            }
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Variant1 { # [doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"] # [serde (rename = "vector_store_ids")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub vector_store_ids : Option < Vec < String > > , # [doc = "A helper to create a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) with file_ids and attach it to this thread. There can be a maximum of 1 vector store attached to the thread.\n"] # [serde (rename = "vector_stores")] pub vector_stores : Vec < crate :: __types :: create_thread_request :: tool_resources :: file_search :: variant1 :: vector_stores :: Item > }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum FileSearch {
            Variant0(crate::__types::create_thread_request::tool_resources::file_search::Variant0),
            Variant1(crate::__types::create_thread_request::tool_resources::file_search::Variant1),
        }
    }
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ToolResources {
        #[serde(rename = "code_interpreter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code_interpreter:
            Option<crate::__types::create_thread_request::tool_resources::CodeInterpreter>,
        #[serde(rename = "file_search")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_search: Option<crate::__types::create_thread_request::tool_resources::FileSearch>,
    }
}
#[doc = "Options to create a new thread. If no thread is provided when running a \nrequest, an empty thread will be created.\n"]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateThreadRequest {
    #[doc = "A list of [messages](https://platform.openai.com/docs/api-reference/messages) to start the thread with."]
    #[serde(rename = "messages")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub messages: Option<Vec<crate::__types::CreateMessageRequest>>,
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[serde(rename = "tool_resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_resources: Option<crate::__types::create_thread_request::ToolResources>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
#[allow(clippy::module_inception)]
pub mod create_transcription_request {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "whisper-1"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Whisper1;
        impl_serde!(Whisper1, "whisper-1");
        #[doc = "gpt-4o-transcribe"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4oTranscribe;
        impl_serde!(Gpt4oTranscribe, "gpt-4o-transcribe");
        #[doc = "gpt-4o-mini-transcribe"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4oMiniTranscribe;
        impl_serde!(Gpt4oMiniTranscribe, "gpt-4o-mini-transcribe");
    }
    #[doc = "ID of the model to use. The options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1` (which is powered by our open source Whisper V2 model).\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "whisper-1"]
        Whisper1,
        #[doc = "gpt-4o-transcribe"]
        Gpt4oTranscribe,
        #[doc = "gpt-4o-mini-transcribe"]
        Gpt4oMiniTranscribe,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                Whisper1(crate::__types::create_transcription_request::model::Whisper1),
                Gpt4oTranscribe(
                    crate::__types::create_transcription_request::model::Gpt4oTranscribe,
                ),
                Gpt4oMiniTranscribe(
                    crate::__types::create_transcription_request::model::Gpt4oMiniTranscribe,
                ),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::Whisper1(_) => Self::Whisper1,
                Model::Gpt4oTranscribe(_) => Self::Gpt4oTranscribe,
                Model::Gpt4oMiniTranscribe(_) => Self::Gpt4oMiniTranscribe,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                Whisper1(crate::__types::create_transcription_request::model::Whisper1),
                Gpt4oTranscribe(
                    crate::__types::create_transcription_request::model::Gpt4oTranscribe,
                ),
                Gpt4oMiniTranscribe(
                    crate::__types::create_transcription_request::model::Gpt4oMiniTranscribe,
                ),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::Whisper1 => Model::Whisper1(Default::default()),
                Self::Gpt4oTranscribe => Model::Gpt4oTranscribe(Default::default()),
                Self::Gpt4oMiniTranscribe => Model::Gpt4oMiniTranscribe(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod timestamp_granularities {
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Item {
            #[doc = "`word`"]
            #[serde(rename = "word")]
            Word,
            #[doc = "`segment`"]
            #[serde(rename = "segment")]
            Segment,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionRequest {
    #[doc = "The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n"]
    #[serde_as(as = "serde_with::base64::Base64")]
    #[serde(rename = "file")]
    pub file: Vec<u8>,
    #[doc = "ID of the model to use. The options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1` (which is powered by our open source Whisper V2 model).\n"]
    #[serde(rename = "model")]
    pub model: crate::__types::create_transcription_request::Model,
    #[doc = "The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format will improve accuracy and latency.\n"]
    #[serde(rename = "language")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub language: Option<String>,
    #[doc = "An optional text to guide the model's style or continue a previous audio segment. The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting) should match the audio language.\n"]
    #[serde(rename = "prompt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt: Option<String>,
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::AudioResponseFormat>,
    #[doc = "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format). \nSee the [Streaming section of the Speech-to-Text guide](https://platform.openai.com/docs/guides/speech-to-text?lang=curl#streaming-transcriptions)\nfor more information.\n\nNote: Streaming is not supported for the `whisper-1` model and will be ignored.\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
    #[serde(rename = "chunking_strategy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub chunking_strategy: Option<crate::__types::TranscriptionChunkingStrategy>,
    #[doc = "The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.\n"]
    #[serde(rename = "timestamp_granularities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timestamp_granularities:
        Option<Vec<crate::__types::create_transcription_request::timestamp_granularities::Item>>,
    #[doc = "Additional information to include in the transcription response. \n`logprobs` will return the log probabilities of the tokens in the \nresponse to understand the model's confidence in the transcription. \n`logprobs` only works with response_format set to `json` and only with \nthe models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe`.\n"]
    #[serde(rename = "include")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub include: Option<Vec<crate::__types::TranscriptionInclude>>,
}
#[allow(clippy::module_inception)]
pub mod create_transcription_response_json {
    #[allow(clippy::module_inception)]
    pub mod logprobs {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The token in the transcription."]
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub token: Option<String>,
            #[doc = "The log probability of the token."]
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub logprob: Option<serde_json::Number>,
            #[doc = "The bytes of the token."]
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub bytes: Option<Vec<serde_json::Number>>,
        }
    }
    #[doc = "Token usage statistics for the request."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Usage {
        Tokens(crate::__types::TranscriptTextUsageTokens),
        Duration(crate::__types::TranscriptTextUsageDuration),
    }
}
#[doc = "Represents a transcription response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionResponseJson {
    #[doc = "The transcribed text."]
    #[serde(rename = "text")]
    pub text: String,
    #[doc = "The log probabilities of the tokens in the transcription. Only returned with the models `gpt-4o-transcribe` and `gpt-4o-mini-transcribe` if `logprobs` is added to the `include` array.\n"]
    #[serde(rename = "logprobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub logprobs: Option<Vec<crate::__types::create_transcription_response_json::logprobs::Item>>,
    #[doc = "Token usage statistics for the request."]
    #[serde(rename = "usage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub usage: Option<crate::__types::create_transcription_response_json::Usage>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum CreateTranscriptionResponseStreamEvent {
    TranscriptTextDelta(crate::__types::TranscriptTextDeltaEvent),
    TranscriptTextDone(crate::__types::TranscriptTextDoneEvent),
}
#[doc = "Represents a verbose json transcription response returned by model, based on the provided input."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateTranscriptionResponseVerboseJson {
    #[doc = "The language of the input audio."]
    #[serde(rename = "language")]
    pub language: String,
    #[doc = "The duration of the input audio."]
    #[serde(rename = "duration")]
    pub duration: serde_json::Number,
    #[doc = "The transcribed text."]
    #[serde(rename = "text")]
    pub text: String,
    #[doc = "Extracted words and their corresponding timestamps."]
    #[serde(rename = "words")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub words: Option<Vec<crate::__types::TranscriptionWord>>,
    #[doc = "Segments of the transcribed text and their corresponding details."]
    #[serde(rename = "segments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub segments: Option<Vec<crate::__types::TranscriptionSegment>>,
    #[serde(rename = "usage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub usage: Option<crate::__types::TranscriptTextUsageDuration>,
}
#[allow(clippy::module_inception)]
pub mod create_translation_request {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "whisper-1"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Whisper1;
        impl_serde!(Whisper1, "whisper-1");
    }
    #[doc = "ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "whisper-1"]
        Whisper1,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                Whisper1(crate::__types::create_translation_request::model::Whisper1),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::Whisper1(_) => Self::Whisper1,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                Whisper1(crate::__types::create_translation_request::model::Whisper1),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::Whisper1 => Model::Whisper1(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum ResponseFormat {
        #[doc = "`json`"]
        #[default]
        #[serde(rename = "json")]
        Json,
        #[doc = "`text`"]
        #[serde(rename = "text")]
        Text,
        #[doc = "`srt`"]
        #[serde(rename = "srt")]
        Srt,
        #[doc = "`verbose_json`"]
        #[serde(rename = "verbose_json")]
        VerboseJson,
        #[doc = "`vtt`"]
        #[serde(rename = "vtt")]
        Vtt,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateTranslationRequest {
    #[doc = "The audio file object (not file name) translate, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.\n"]
    #[serde_as(as = "serde_with::base64::Base64")]
    #[serde(rename = "file")]
    pub file: Vec<u8>,
    #[doc = "ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.\n"]
    #[serde(rename = "model")]
    pub model: crate::__types::create_translation_request::Model,
    #[doc = "An optional text to guide the model's style or continue a previous audio segment. The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting) should be in English.\n"]
    #[serde(rename = "prompt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt: Option<String>,
    #[doc = "The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.\n"]
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::create_translation_request::ResponseFormat>,
    #[doc = "The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateTranslationResponseJson {
    #[serde(rename = "text")]
    pub text: String,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateTranslationResponseVerboseJson {
    #[doc = "The language of the output translation (always `english`)."]
    #[serde(rename = "language")]
    pub language: String,
    #[doc = "The duration of the input audio."]
    #[serde(rename = "duration")]
    pub duration: serde_json::Number,
    #[doc = "The translated text."]
    #[serde(rename = "text")]
    pub text: String,
    #[doc = "Segments of the translated text and their corresponding details."]
    #[serde(rename = "segments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub segments: Option<Vec<crate::__types::TranscriptionSegment>>,
}
#[allow(clippy::module_inception)]
pub mod create_upload_request {
    #[doc = "The intended purpose of the uploaded file.\n\nSee the [documentation on File purposes](https://platform.openai.com/docs/api-reference/files/create#files-create-purpose).\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Purpose {
        #[doc = "`assistants`"]
        #[serde(rename = "assistants")]
        Assistants,
        #[doc = "`batch`"]
        #[serde(rename = "batch")]
        Batch,
        #[doc = "`fine-tune`"]
        #[serde(rename = "fine-tune")]
        FineTune,
        #[doc = "`vision`"]
        #[serde(rename = "vision")]
        Vision,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateUploadRequest {
    #[doc = "The name of the file to upload.\n"]
    #[serde(rename = "filename")]
    pub filename: String,
    #[doc = "The intended purpose of the uploaded file.\n\nSee the [documentation on File purposes](https://platform.openai.com/docs/api-reference/files/create#files-create-purpose).\n"]
    #[serde(rename = "purpose")]
    pub purpose: crate::__types::create_upload_request::Purpose,
    #[doc = "The number of bytes in the file you are uploading.\n"]
    #[serde(rename = "bytes")]
    pub bytes: i64,
    #[doc = "The MIME type of the file.\n\nThis must fall within the supported MIME types for your file purpose. See the supported MIME types for assistants and vision.\n"]
    #[serde(rename = "mime_type")]
    pub mime_type: String,
    #[serde(rename = "expires_after")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expires_after: Option<crate::__types::FileExpirationAfter>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreFileBatchRequest {
    #[doc = "A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files."]
    #[serde(rename = "file_ids")]
    pub file_ids: Vec<String>,
    #[serde(rename = "chunking_strategy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub chunking_strategy: Option<crate::__types::ChunkingStrategyRequestParam>,
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attributes: Option<crate::__types::VectorStoreFileAttributes>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreFileRequest {
    #[doc = "A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files."]
    #[serde(rename = "file_id")]
    pub file_id: String,
    #[serde(rename = "chunking_strategy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub chunking_strategy: Option<crate::__types::ChunkingStrategyRequestParam>,
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attributes: Option<crate::__types::VectorStoreFileAttributes>,
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateVectorStoreRequest {
    #[doc = "A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files."]
    #[serde(rename = "file_ids")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub file_ids: Option<Vec<String>>,
    #[doc = "The name of the vector store."]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[serde(rename = "expires_after")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expires_after: Option<crate::__types::VectorStoreExpirationAfter>,
    #[serde(rename = "chunking_strategy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub chunking_strategy: Option<crate::__types::ChunkingStrategyRequestParam>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
#[allow(clippy::module_inception)]
pub mod custom_tool {
    #[doc = "The type of the custom tool. Always `custom`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom");
    #[allow(clippy::module_inception)]
    pub mod format {
        #[allow(clippy::module_inception)]
        pub(crate) mod text {
            #[doc = "Unconstrained text format. Always `text`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "text");
        }
        #[doc = "Unconstrained free-form text."]
        #[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
        pub struct Text {}
        impl<'de> serde::Deserialize<'de> for Text {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct Text {
                    #[serde(rename = "type")]
                    #[allow(dead_code)]
                    r#type: crate::__types::custom_tool::format::text::Type,
                }
                let Text { .. } = Text::deserialize(deserializer)?;
                Ok(Self {})
            }
        }
        impl serde::Serialize for Text {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct Text<'a> {
                    #[serde(rename = "type")]
                    r#type: &'a crate::__types::custom_tool::format::text::Type,
                }
                let Self {} = self;
                Text {
                    r#type: &Default::default(),
                }
                .serialize(serializer)
            }
        }
        #[allow(clippy::module_inception)]
        pub mod grammar {
            #[doc = "Grammar format. Always `grammar`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "grammar");
            #[doc = "The syntax of the grammar definition. One of `lark` or `regex`."]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Syntax {
                #[doc = "`lark`"]
                #[serde(rename = "lark")]
                Lark,
                #[doc = "`regex`"]
                #[serde(rename = "regex")]
                Regex,
            }
        }
        #[doc = "A grammar defined by the user."]
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct Grammar {
            #[doc = "The grammar definition."]
            pub definition: String,
            #[doc = "The syntax of the grammar definition. One of `lark` or `regex`."]
            pub syntax: crate::__types::custom_tool::format::grammar::Syntax,
        }
        impl<'de> serde::Deserialize<'de> for Grammar {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct Grammar {
                    #[serde(rename = "type")]
                    #[allow(dead_code)]
                    r#type: crate::__types::custom_tool::format::grammar::Type,
                    #[serde(rename = "definition")]
                    definition: String,
                    #[serde(rename = "syntax")]
                    syntax: crate::__types::custom_tool::format::grammar::Syntax,
                }
                let Grammar {
                    definition, syntax, ..
                } = Grammar::deserialize(deserializer)?;
                Ok(Self { definition, syntax })
            }
        }
        impl serde::Serialize for Grammar {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct Grammar<'a> {
                    #[serde(rename = "type")]
                    r#type: &'a crate::__types::custom_tool::format::grammar::Type,
                    #[serde(rename = "definition")]
                    definition: &'a String,
                    #[serde(rename = "syntax")]
                    syntax: &'a crate::__types::custom_tool::format::grammar::Syntax,
                }
                let Self { definition, syntax } = self;
                Grammar {
                    r#type: &Default::default(),
                    definition,
                    syntax,
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "The input format for the custom tool. Default is unconstrained text.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Format {
        #[doc = "Unconstrained free-form text."]
        Text(crate::__types::custom_tool::format::Text),
        #[doc = "A grammar defined by the user."]
        Grammar(crate::__types::custom_tool::format::Grammar),
    }
}
#[doc = "A custom tool that processes input using a specified format. Learn more about\n[custom tools](https://platform.openai.com/docs/guides/function-calling#custom-tools).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CustomTool {
    #[doc = "The name of the custom tool, used to identify it in tool calls."]
    pub name: String,
    #[doc = "Optional description of the custom tool, used to provide more context.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The input format for the custom tool. Default is unconstrained text.\n"]
    #[builder(default)]
    pub format: Option<crate::__types::custom_tool::Format>,
}
impl<'de> serde::Deserialize<'de> for CustomTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CustomTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::custom_tool::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "description")]
            description: Option<String>,
            #[serde(rename = "format")]
            format: Option<crate::__types::custom_tool::Format>,
        }
        let CustomTool {
            name,
            description,
            format,
            ..
        } = CustomTool::deserialize(deserializer)?;
        Ok(Self {
            name,
            description,
            format,
        })
    }
}
impl serde::Serialize for CustomTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CustomTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::custom_tool::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            format: &'a Option<crate::__types::custom_tool::Format>,
        }
        let Self {
            name,
            description,
            format,
        } = self;
        CustomTool {
            r#type: &Default::default(),
            name,
            description,
            format,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod custom_tool_call {
    #[doc = "The type of the custom tool call. Always `custom_tool_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom_tool_call");
}
#[doc = "A call to a custom tool created by the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CustomToolCall {
    #[doc = "The unique ID of the custom tool call in the OpenAI platform.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "An identifier used to map this custom tool call to a tool call output.\n"]
    pub call_id: String,
    #[doc = "The name of the custom tool being called.\n"]
    pub name: String,
    #[doc = "The input for the custom tool call generated by the model.\n"]
    pub input: String,
}
impl<'de> serde::Deserialize<'de> for CustomToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CustomToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::custom_tool_call::Type,
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "input")]
            input: String,
        }
        let CustomToolCall {
            id,
            call_id,
            name,
            input,
            ..
        } = CustomToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            name,
            input,
        })
    }
}
impl serde::Serialize for CustomToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CustomToolCall<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::custom_tool_call::Type,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
        }
        let Self {
            id,
            call_id,
            name,
            input,
        } = self;
        CustomToolCall {
            r#type: &Default::default(),
            id,
            call_id,
            name,
            input,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod custom_tool_call_output {
    #[doc = "The type of the custom tool call output. Always `custom_tool_call_output`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom_tool_call_output");
}
#[doc = "The output of a custom tool call from your code, being sent back to the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CustomToolCallOutput {
    #[doc = "The unique ID of the custom tool call output in the OpenAI platform.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The call ID, used to map this custom tool call output to a custom tool call.\n"]
    pub call_id: String,
    #[doc = "The output from the custom tool call generated by your code.\n"]
    pub output: String,
}
impl<'de> serde::Deserialize<'de> for CustomToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CustomToolCallOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::custom_tool_call_output::Type,
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "output")]
            output: String,
        }
        let CustomToolCallOutput {
            id,
            call_id,
            output,
            ..
        } = CustomToolCallOutput::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            output,
        })
    }
}
impl serde::Serialize for CustomToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CustomToolCallOutput<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::custom_tool_call_output::Type,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "output")]
            output: &'a String,
        }
        let Self {
            id,
            call_id,
            output,
        } = self;
        CustomToolCallOutput {
            r#type: &Default::default(),
            id,
            call_id,
            output,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod custom_tool_chat_completions {
    #[doc = "The type of the custom tool. Always `custom`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom");
    #[allow(clippy::module_inception)]
    pub mod custom {
        #[allow(clippy::module_inception)]
        pub mod format {
            #[allow(clippy::module_inception)]
            pub(crate) mod text {
                #[doc = "Unconstrained text format. Always `text`."]
                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                pub(crate) struct Type;
                impl_serde!(Type, "text");
            }
            #[doc = "Unconstrained free-form text."]
            #[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
            pub struct Text {}
            impl<'de> serde::Deserialize<'de> for Text {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[serde_with::serde_as]
                    #[derive(serde :: Deserialize)]
                    struct Text { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: custom_tool_chat_completions :: custom :: format :: text :: Type }
                    let Text { .. } = Text::deserialize(deserializer)?;
                    Ok(Self {})
                }
            }
            impl serde::Serialize for Text {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    #[serde_with::serde_as]
                    #[derive(serde :: Serialize)]
                    struct Text < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: custom_tool_chat_completions :: custom :: format :: text :: Type }
                    let Self {} = self;
                    Text {
                        r#type: &Default::default(),
                    }
                    .serialize(serializer)
                }
            }
            #[allow(clippy::module_inception)]
            pub mod grammar {
                #[doc = "Grammar format. Always `grammar`."]
                #[derive(Clone, Copy, Debug, Default, PartialEq)]
                pub(crate) struct Type;
                impl_serde!(Type, "grammar");
                #[allow(clippy::module_inception)]
                pub mod grammar {
                    #[doc = "The syntax of the grammar definition. One of `lark` or `regex`."]
                    #[derive(
                        Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize,
                    )]
                    pub enum Syntax {
                        #[doc = "`lark`"]
                        #[serde(rename = "lark")]
                        Lark,
                        #[doc = "`regex`"]
                        #[serde(rename = "regex")]
                        Regex,
                    }
                }
                #[doc = "Your chosen grammar."]
                #[derive(Clone, Debug, PartialEq)]
                #[serde_with::serde_as]
                #[derive(
                    serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder,
                )]
                pub struct Grammar { # [doc = "The grammar definition."] # [serde (rename = "definition")] pub definition : String , # [doc = "The syntax of the grammar definition. One of `lark` or `regex`."] # [serde (rename = "syntax")] pub syntax : crate :: __types :: custom_tool_chat_completions :: custom :: format :: grammar :: grammar :: Syntax }
            }
            #[doc = "A grammar defined by the user."]
            #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
            pub struct Grammar {
                #[doc = "Your chosen grammar."]
                pub grammar:
                    crate::__types::custom_tool_chat_completions::custom::format::grammar::Grammar,
            }
            impl<'de> serde::Deserialize<'de> for Grammar {
                fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[serde_with::serde_as]
                    #[derive(serde :: Deserialize)]
                    struct Grammar { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: custom_tool_chat_completions :: custom :: format :: grammar :: Type , # [serde (rename = "grammar")] grammar : crate :: __types :: custom_tool_chat_completions :: custom :: format :: grammar :: Grammar }
                    let Grammar { grammar, .. } = Grammar::deserialize(deserializer)?;
                    Ok(Self { grammar })
                }
            }
            impl serde::Serialize for Grammar {
                fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    #[serde_with::serde_as]
                    #[derive(serde :: Serialize)]
                    struct Grammar < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: custom_tool_chat_completions :: custom :: format :: grammar :: Type , # [serde (rename = "grammar")] grammar : & 'a crate :: __types :: custom_tool_chat_completions :: custom :: format :: grammar :: Grammar }
                    let Self { grammar } = self;
                    Grammar {
                        r#type: &Default::default(),
                        grammar,
                    }
                    .serialize(serializer)
                }
            }
        }
        #[doc = "The input format for the custom tool. Default is unconstrained text.\n"]
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Format {
            #[doc = "Unconstrained free-form text."]
            Text(crate::__types::custom_tool_chat_completions::custom::format::Text),
            #[doc = "A grammar defined by the user."]
            Grammar(crate::__types::custom_tool_chat_completions::custom::format::Grammar),
        }
    }
    #[doc = "Properties of the custom tool.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Custom {
        #[doc = "The name of the custom tool, used to identify it in tool calls."]
        #[serde(rename = "name")]
        pub name: String,
        #[doc = "Optional description of the custom tool, used to provide more context.\n"]
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub description: Option<String>,
        #[doc = "The input format for the custom tool. Default is unconstrained text.\n"]
        #[serde(rename = "format")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub format: Option<crate::__types::custom_tool_chat_completions::custom::Format>,
    }
}
#[doc = "A custom tool that processes input using a specified format.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct CustomToolChatCompletions {
    #[doc = "Properties of the custom tool.\n"]
    pub custom: crate::__types::custom_tool_chat_completions::Custom,
}
impl<'de> serde::Deserialize<'de> for CustomToolChatCompletions {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct CustomToolChatCompletions {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::custom_tool_chat_completions::Type,
            #[serde(rename = "custom")]
            custom: crate::__types::custom_tool_chat_completions::Custom,
        }
        let CustomToolChatCompletions { custom, .. } =
            CustomToolChatCompletions::deserialize(deserializer)?;
        Ok(Self { custom })
    }
}
impl serde::Serialize for CustomToolChatCompletions {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct CustomToolChatCompletions<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::custom_tool_chat_completions::Type,
            #[serde(rename = "custom")]
            custom: &'a crate::__types::custom_tool_chat_completions::Custom,
        }
        let Self { custom } = self;
        CustomToolChatCompletions {
            r#type: &Default::default(),
            custom,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod delete_assistant_response {
    #[doc = "assistant.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "assistant.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteAssistantResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteAssistantResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteAssistantResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::delete_assistant_response::Object,
        }
        let DeleteAssistantResponse { id, deleted, .. } =
            DeleteAssistantResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteAssistantResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteAssistantResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a crate::__types::delete_assistant_response::Object,
        }
        let Self { id, deleted } = self;
        DeleteAssistantResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod delete_certificate_response {
    #[doc = "The object type, must be `certificate.deleted`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "certificate.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteCertificateResponse {
    #[doc = "The ID of the certificate that was deleted."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for DeleteCertificateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteCertificateResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::delete_certificate_response::Object,
            #[serde(rename = "id")]
            id: String,
        }
        let DeleteCertificateResponse { id, .. } =
            DeleteCertificateResponse::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for DeleteCertificateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteCertificateResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::delete_certificate_response::Object,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self { id } = self;
        DeleteCertificateResponse {
            object: &Default::default(),
            id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod delete_file_response {
    #[doc = "file"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "file");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteFileResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteFileResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteFileResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::delete_file_response::Object,
            #[serde(rename = "deleted")]
            deleted: bool,
        }
        let DeleteFileResponse { id, deleted, .. } = DeleteFileResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteFileResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteFileResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::delete_file_response::Object,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        DeleteFileResponse {
            id,
            object: &Default::default(),
            deleted,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod delete_fine_tuning_checkpoint_permission_response {
    #[doc = "The object type, which is always \"checkpoint.permission\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "checkpoint.permission");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteFineTuningCheckpointPermissionResponse {
    #[doc = "The ID of the fine-tuned model checkpoint permission that was deleted."]
    pub id: String,
    #[doc = "Whether the fine-tuned model checkpoint permission was successfully deleted."]
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteFineTuningCheckpointPermissionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteFineTuningCheckpointPermissionResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::delete_fine_tuning_checkpoint_permission_response::Object,
            #[serde(rename = "deleted")]
            deleted: bool,
        }
        let DeleteFineTuningCheckpointPermissionResponse { id, deleted, .. } =
            DeleteFineTuningCheckpointPermissionResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteFineTuningCheckpointPermissionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteFineTuningCheckpointPermissionResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::delete_fine_tuning_checkpoint_permission_response::Object,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        DeleteFineTuningCheckpointPermissionResponse {
            id,
            object: &Default::default(),
            deleted,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod delete_message_response {
    #[doc = "thread.message.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "thread.message.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteMessageResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteMessageResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteMessageResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::delete_message_response::Object,
        }
        let DeleteMessageResponse { id, deleted, .. } =
            DeleteMessageResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteMessageResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteMessageResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a crate::__types::delete_message_response::Object,
        }
        let Self { id, deleted } = self;
        DeleteMessageResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct DeleteModelResponse {
    #[serde(rename = "id")]
    pub id: String,
    #[serde(rename = "deleted")]
    pub deleted: bool,
    #[serde(rename = "object")]
    pub object: String,
}
#[allow(clippy::module_inception)]
pub(crate) mod delete_thread_response {
    #[doc = "thread.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "thread.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteThreadResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteThreadResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteThreadResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::delete_thread_response::Object,
        }
        let DeleteThreadResponse { id, deleted, .. } =
            DeleteThreadResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteThreadResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteThreadResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a crate::__types::delete_thread_response::Object,
        }
        let Self { id, deleted } = self;
        DeleteThreadResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod delete_vector_store_file_response {
    #[doc = "vector_store.file.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "vector_store.file.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteVectorStoreFileResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteVectorStoreFileResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteVectorStoreFileResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::delete_vector_store_file_response::Object,
        }
        let DeleteVectorStoreFileResponse { id, deleted, .. } =
            DeleteVectorStoreFileResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteVectorStoreFileResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteVectorStoreFileResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a crate::__types::delete_vector_store_file_response::Object,
        }
        let Self { id, deleted } = self;
        DeleteVectorStoreFileResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod delete_vector_store_response {
    #[doc = "vector_store.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "vector_store.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DeleteVectorStoreResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for DeleteVectorStoreResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DeleteVectorStoreResponse {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::delete_vector_store_response::Object,
        }
        let DeleteVectorStoreResponse { id, deleted, .. } =
            DeleteVectorStoreResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for DeleteVectorStoreResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DeleteVectorStoreResponse<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
            #[serde(rename = "object")]
            object: &'a crate::__types::delete_vector_store_response::Object,
        }
        let Self { id, deleted } = self;
        DeleteVectorStoreResponse {
            id,
            deleted,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod done_event {
    #[doc = "done"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Event;
    impl_serde!(Event, "done");
    #[doc = "[DONE]"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Data;
    impl_serde!(Data, "[DONE]");
}
#[doc = "Occurs when a stream ends."]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct DoneEvent {}
impl<'de> serde::Deserialize<'de> for DoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DoneEvent {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: crate::__types::done_event::Event,
            #[serde(rename = "data")]
            #[allow(dead_code)]
            data: crate::__types::done_event::Data,
        }
        let DoneEvent { .. } = DoneEvent::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for DoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DoneEvent<'a> {
            #[serde(rename = "event")]
            event: &'a crate::__types::done_event::Event,
            #[serde(rename = "data")]
            data: &'a crate::__types::done_event::Data,
        }
        let Self {} = self;
        DoneEvent {
            event: &Default::default(),
            data: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod double_click {
    #[doc = "Specifies the event type. For a double click action, this property is \nalways set to `double_click`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "double_click");
}
#[doc = "A double click action.\n"]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct DoubleClick {
    #[doc = "The x-coordinate where the double click occurred.\n"]
    pub x: i64,
    #[doc = "The y-coordinate where the double click occurred.\n"]
    pub y: i64,
}
impl<'de> serde::Deserialize<'de> for DoubleClick {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct DoubleClick {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::double_click::Type,
            #[serde(rename = "x")]
            x: i64,
            #[serde(rename = "y")]
            y: i64,
        }
        let DoubleClick { x, y, .. } = DoubleClick::deserialize(deserializer)?;
        Ok(Self { x, y })
    }
}
impl serde::Serialize for DoubleClick {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct DoubleClick<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::double_click::Type,
            #[serde(rename = "x")]
            x: &'a i64,
            #[serde(rename = "y")]
            y: &'a i64,
        }
        let Self { x, y } = self;
        DoubleClick {
            r#type: &Default::default(),
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod drag {
    #[doc = "Specifies the event type. For a drag action, this property is \nalways set to `drag`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "drag");
}
#[doc = "A drag action.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Drag {
    #[doc = "An array of coordinates representing the path of the drag action. Coordinates will appear as an array\nof objects, eg\n```text\n[\n  { x: 100, y: 200 },\n  { x: 200, y: 300 }\n]\n```\n"]
    pub path: Vec<crate::__types::Coordinate>,
}
impl<'de> serde::Deserialize<'de> for Drag {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Drag {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::drag::Type,
            #[serde(rename = "path")]
            path: Vec<crate::__types::Coordinate>,
        }
        let Drag { path, .. } = Drag::deserialize(deserializer)?;
        Ok(Self { path })
    }
}
impl serde::Serialize for Drag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Drag<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::drag::Type,
            #[serde(rename = "path")]
            path: &'a Vec<crate::__types::Coordinate>,
        }
        let Self { path } = self;
        Drag {
            r#type: &Default::default(),
            path,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod easy_input_message {
    #[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`assistant`"]
        #[serde(rename = "assistant")]
        Assistant,
        #[doc = "`system`"]
        #[serde(rename = "system")]
        System,
        #[doc = "`developer`"]
        #[serde(rename = "developer")]
        Developer,
    }
    #[doc = "Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "A text input to the model.\n"]
        String(String),
        InputMessageContentList(crate::__types::InputMessageContentList),
    }
    #[doc = "The type of the message input. Always `message`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Type;
    impl_serde!(Type, "message");
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct EasyInputMessage {
    #[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
    #[serde(rename = "role")]
    pub role: crate::__types::easy_input_message::Role,
    #[doc = "Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n"]
    #[serde(rename = "content")]
    pub content: crate::__types::easy_input_message::Content,
    #[doc = "The type of the message input. Always `message`.\n"]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::easy_input_message::Type>,
}
#[allow(clippy::module_inception)]
pub(crate) mod embedding {
    #[doc = "The object type, which is always \"embedding\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "embedding");
}
#[doc = "Represents an embedding vector returned by embedding endpoint.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Embedding {
    #[doc = "The index of the embedding in the list of embeddings."]
    pub index: i64,
    #[doc = "The embedding vector, which is a list of floats. The length of vector depends on the model as listed in the [embedding guide](https://platform.openai.com/docs/guides/embeddings).\n"]
    pub embedding: Vec<f64>,
}
impl<'de> serde::Deserialize<'de> for Embedding {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Embedding {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "embedding")]
            embedding: Vec<f64>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::embedding::Object,
        }
        let Embedding {
            index, embedding, ..
        } = Embedding::deserialize(deserializer)?;
        Ok(Self { index, embedding })
    }
}
impl serde::Serialize for Embedding {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Embedding<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "embedding")]
            embedding: &'a Vec<f64>,
            #[serde(rename = "object")]
            object: &'a crate::__types::embedding::Object,
        }
        let Self { index, embedding } = self;
        Embedding {
            index,
            embedding,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct Error {
    #[serde(rename = "code")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub code: Option<String>,
    #[serde(rename = "message")]
    pub message: String,
    #[serde(rename = "param")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub param: Option<String>,
    #[serde(rename = "type")]
    pub r#type: String,
}
#[allow(clippy::module_inception)]
pub(crate) mod error_event {
    #[doc = "error"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Event;
    impl_serde!(Event, "error");
}
#[doc = "Occurs when an [error](https://platform.openai.com/docs/guides/error-codes#api-errors) occurs. This can happen due to an internal server error or a timeout."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ErrorEvent {
    pub data: crate::__types::Error,
}
impl<'de> serde::Deserialize<'de> for ErrorEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ErrorEvent {
            #[serde(rename = "event")]
            #[allow(dead_code)]
            event: crate::__types::error_event::Event,
            #[serde(rename = "data")]
            data: crate::__types::Error,
        }
        let ErrorEvent { data, .. } = ErrorEvent::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for ErrorEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ErrorEvent<'a> {
            #[serde(rename = "event")]
            event: &'a crate::__types::error_event::Event,
            #[serde(rename = "data")]
            data: &'a crate::__types::Error,
        }
        let Self { data } = self;
        ErrorEvent {
            event: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ErrorResponse {
    #[serde(rename = "error")]
    pub error: crate::__types::Error,
}
#[allow(clippy::module_inception)]
pub mod eval {
    #[doc = "The object type."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "eval");
    #[doc = "Configuration of data sources used in runs of the evaluation."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum DataSourceConfig {
        Custom(crate::__types::EvalCustomDataSourceConfig),
        Logs(crate::__types::EvalLogsDataSourceConfig),
        StoredCompletions(crate::__types::EvalStoredCompletionsDataSourceConfig),
    }
    #[allow(clippy::module_inception)]
    pub mod testing_criteria {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            LabelModel(crate::__types::EvalGraderLabelModel),
            StringCheck(crate::__types::EvalGraderStringCheck),
            TextSimilarity(crate::__types::EvalGraderTextSimilarity),
            Python(crate::__types::EvalGraderPython),
            ScoreModel(crate::__types::EvalGraderScoreModel),
        }
    }
}
#[doc = "An Eval object with a data source config and testing criteria.\nAn Eval represents a task to be done for your LLM integration.\nLike:\n - Improve the quality of my chatbot\n - See how well my chatbot handles customer support\n - Check if o4-mini is better at my usecase than gpt-4o\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Eval {
    #[doc = "Unique identifier for the evaluation."]
    pub id: String,
    #[doc = "The name of the evaluation."]
    pub name: String,
    #[doc = "Configuration of data sources used in runs of the evaluation."]
    pub data_source_config: crate::__types::eval::DataSourceConfig,
    #[doc = "A list of testing criteria."]
    pub testing_criteria: Vec<crate::__types::eval::testing_criteria::Item>,
    #[doc = "The Unix timestamp (in seconds) for when the eval was created."]
    pub created_at: i64,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
impl<'de> serde::Deserialize<'de> for Eval {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Eval {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::eval::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "data_source_config")]
            data_source_config: crate::__types::eval::DataSourceConfig,
            #[serde(rename = "testing_criteria")]
            testing_criteria: Vec<crate::__types::eval::testing_criteria::Item>,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
        }
        let Eval {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
            ..
        } = Eval::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        })
    }
}
impl serde::Serialize for Eval {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Eval<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::eval::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "data_source_config")]
            data_source_config: &'a crate::__types::eval::DataSourceConfig,
            #[serde(rename = "testing_criteria")]
            testing_criteria: &'a Vec<crate::__types::eval::testing_criteria::Item>,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
        }
        let Self {
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        } = self;
        Eval {
            object: &Default::default(),
            id,
            name,
            data_source_config,
            testing_criteria,
            created_at,
            metadata,
        }
        .serialize(serializer)
    }
}
#[doc = "An object representing an error response from the Eval API.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct EvalApiError {
    #[doc = "The error code."]
    #[serde(rename = "code")]
    pub code: String,
    #[doc = "The error message."]
    #[serde(rename = "message")]
    pub message: String,
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_custom_data_source_config {
    #[doc = "The type of data source. Always `custom`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom");
}
#[doc = "A CustomDataSourceConfig which specifies the schema of your `item` and optionally `sample` namespaces.\nThe response schema defines the shape of the data that will be:\n- Used to define your testing criteria and\n- What data is required when creating a run\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalCustomDataSourceConfig {
    #[doc = "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
    pub schema: indexmap::IndexMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for EvalCustomDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalCustomDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_custom_data_source_config::Type,
            #[serde(rename = "schema")]
            schema: indexmap::IndexMap<String, serde_json::Value>,
        }
        let EvalCustomDataSourceConfig { schema, .. } =
            EvalCustomDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { schema })
    }
}
impl serde::Serialize for EvalCustomDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalCustomDataSourceConfig<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_custom_data_source_config::Type,
            #[serde(rename = "schema")]
            schema: &'a indexmap::IndexMap<String, serde_json::Value>,
        }
        let Self { schema } = self;
        EvalCustomDataSourceConfig {
            r#type: &Default::default(),
            schema,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_grader_label_model {
    #[doc = "The object type, which is always `label_model`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "label_model");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderLabelModel {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation. Must support structured outputs."]
    pub model: String,
    pub input: Vec<crate::__types::EvalItem>,
    #[doc = "The labels to assign to each item in the evaluation."]
    pub labels: Vec<String>,
    #[doc = "The labels that indicate a passing result. Must be a subset of labels."]
    pub passing_labels: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for EvalGraderLabelModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderLabelModel {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_grader_label_model::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "input")]
            input: Vec<crate::__types::EvalItem>,
            #[serde(rename = "labels")]
            labels: Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: Vec<String>,
        }
        let EvalGraderLabelModel {
            name,
            model,
            input,
            labels,
            passing_labels,
            ..
        } = EvalGraderLabelModel::deserialize(deserializer)?;
        Ok(Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        })
    }
}
impl serde::Serialize for EvalGraderLabelModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderLabelModel<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_grader_label_model::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a Vec<crate::__types::EvalItem>,
            #[serde(rename = "labels")]
            labels: &'a Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: &'a Vec<String>,
        }
        let Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        } = self;
        EvalGraderLabelModel {
            r#type: &Default::default(),
            name,
            model,
            input,
            labels,
            passing_labels,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_grader_python {
    #[doc = "The object type, which is always `python`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "python");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderPython {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The source code of the python script."]
    pub source: String,
    #[doc = "The image tag to use for the python script."]
    #[builder(default)]
    pub image_tag: Option<String>,
    #[doc = "The threshold for the score."]
    #[builder(default)]
    pub pass_threshold: Option<serde_json::Number>,
}
impl<'de> serde::Deserialize<'de> for EvalGraderPython {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderPython {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_grader_python::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "source")]
            source: String,
            #[serde(rename = "image_tag")]
            image_tag: Option<String>,
            #[serde(rename = "pass_threshold")]
            pass_threshold: Option<serde_json::Number>,
        }
        let EvalGraderPython {
            name,
            source,
            image_tag,
            pass_threshold,
            ..
        } = EvalGraderPython::deserialize(deserializer)?;
        Ok(Self {
            name,
            source,
            image_tag,
            pass_threshold,
        })
    }
}
impl serde::Serialize for EvalGraderPython {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderPython<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_grader_python::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "source")]
            source: &'a String,
            #[serde(rename = "image_tag")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_tag: &'a Option<String>,
            #[serde(rename = "pass_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pass_threshold: &'a Option<serde_json::Number>,
        }
        let Self {
            name,
            source,
            image_tag,
            pass_threshold,
        } = self;
        EvalGraderPython {
            r#type: &Default::default(),
            name,
            source,
            image_tag,
            pass_threshold,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_grader_score_model {
    #[doc = "The object type, which is always `score_model`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "score_model");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderScoreModel {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation."]
    pub model: String,
    #[doc = "The sampling parameters for the model."]
    #[builder(default)]
    pub sampling_params: Option<indexmap::IndexMap<String, serde_json::Value>>,
    #[doc = "The input text. This may include template strings."]
    pub input: Vec<crate::__types::EvalItem>,
    #[doc = "The range of the score. Defaults to `[0, 1]`."]
    #[builder(default)]
    pub range: Option<Vec<serde_json::Number>>,
    #[doc = "The threshold for the score."]
    #[builder(default)]
    pub pass_threshold: Option<serde_json::Number>,
}
impl<'de> serde::Deserialize<'de> for EvalGraderScoreModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderScoreModel {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_grader_score_model::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "sampling_params")]
            sampling_params: Option<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "input")]
            input: Vec<crate::__types::EvalItem>,
            #[serde(rename = "range")]
            range: Option<Vec<serde_json::Number>>,
            #[serde(rename = "pass_threshold")]
            pass_threshold: Option<serde_json::Number>,
        }
        let EvalGraderScoreModel {
            name,
            model,
            sampling_params,
            input,
            range,
            pass_threshold,
            ..
        } = EvalGraderScoreModel::deserialize(deserializer)?;
        Ok(Self {
            name,
            model,
            sampling_params,
            input,
            range,
            pass_threshold,
        })
    }
}
impl serde::Serialize for EvalGraderScoreModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderScoreModel<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_grader_score_model::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params: &'a Option<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "input")]
            input: &'a Vec<crate::__types::EvalItem>,
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            range: &'a Option<Vec<serde_json::Number>>,
            #[serde(rename = "pass_threshold")]
            #[serde(skip_serializing_if = "Option::is_none")]
            pass_threshold: &'a Option<serde_json::Number>,
        }
        let Self {
            name,
            model,
            sampling_params,
            input,
            range,
            pass_threshold,
        } = self;
        EvalGraderScoreModel {
            r#type: &Default::default(),
            name,
            model,
            sampling_params,
            input,
            range,
            pass_threshold,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod eval_grader_string_check {
    #[doc = "The object type, which is always `string_check`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "string_check");
    #[doc = "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Operation {
        #[doc = "`eq`"]
        #[serde(rename = "eq")]
        Eq,
        #[doc = "`ne`"]
        #[serde(rename = "ne")]
        Ne,
        #[doc = "`like`"]
        #[serde(rename = "like")]
        Like,
        #[doc = "`ilike`"]
        #[serde(rename = "ilike")]
        Ilike,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderStringCheck {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The input text. This may include template strings."]
    pub input: String,
    #[doc = "The reference text. This may include template strings."]
    pub reference: String,
    #[doc = "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."]
    pub operation: crate::__types::eval_grader_string_check::Operation,
}
impl<'de> serde::Deserialize<'de> for EvalGraderStringCheck {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderStringCheck {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_grader_string_check::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "input")]
            input: String,
            #[serde(rename = "reference")]
            reference: String,
            #[serde(rename = "operation")]
            operation: crate::__types::eval_grader_string_check::Operation,
        }
        let EvalGraderStringCheck {
            name,
            input,
            reference,
            operation,
            ..
        } = EvalGraderStringCheck::deserialize(deserializer)?;
        Ok(Self {
            name,
            input,
            reference,
            operation,
        })
    }
}
impl serde::Serialize for EvalGraderStringCheck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderStringCheck<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_grader_string_check::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "reference")]
            reference: &'a String,
            #[serde(rename = "operation")]
            operation: &'a crate::__types::eval_grader_string_check::Operation,
        }
        let Self {
            name,
            input,
            reference,
            operation,
        } = self;
        EvalGraderStringCheck {
            r#type: &Default::default(),
            name,
            input,
            reference,
            operation,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod eval_grader_text_similarity {
    #[doc = "The type of grader."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "text_similarity");
    #[doc = "The evaluation metric to use. One of `fuzzy_match`, `bleu`, `gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, or `rouge_l`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum EvaluationMetric {
        #[doc = "`fuzzy_match`"]
        #[serde(rename = "fuzzy_match")]
        FuzzyMatch,
        #[doc = "`bleu`"]
        #[serde(rename = "bleu")]
        Bleu,
        #[doc = "`gleu`"]
        #[serde(rename = "gleu")]
        Gleu,
        #[doc = "`meteor`"]
        #[serde(rename = "meteor")]
        Meteor,
        #[doc = "`rouge_1`"]
        #[serde(rename = "rouge_1")]
        Rouge1,
        #[doc = "`rouge_2`"]
        #[serde(rename = "rouge_2")]
        Rouge2,
        #[doc = "`rouge_3`"]
        #[serde(rename = "rouge_3")]
        Rouge3,
        #[doc = "`rouge_4`"]
        #[serde(rename = "rouge_4")]
        Rouge4,
        #[doc = "`rouge_5`"]
        #[serde(rename = "rouge_5")]
        Rouge5,
        #[doc = "`rouge_l`"]
        #[serde(rename = "rouge_l")]
        RougeL,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalGraderTextSimilarity {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The text being graded."]
    pub input: String,
    #[doc = "The text being graded against."]
    pub reference: String,
    #[doc = "The evaluation metric to use. One of `fuzzy_match`, `bleu`, `gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, or `rouge_l`."]
    pub evaluation_metric: crate::__types::eval_grader_text_similarity::EvaluationMetric,
    #[doc = "The threshold for the score."]
    pub pass_threshold: serde_json::Number,
}
impl<'de> serde::Deserialize<'de> for EvalGraderTextSimilarity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalGraderTextSimilarity {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_grader_text_similarity::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "input")]
            input: String,
            #[serde(rename = "reference")]
            reference: String,
            #[serde(rename = "evaluation_metric")]
            evaluation_metric: crate::__types::eval_grader_text_similarity::EvaluationMetric,
            #[serde(rename = "pass_threshold")]
            pass_threshold: serde_json::Number,
        }
        let EvalGraderTextSimilarity {
            name,
            input,
            reference,
            evaluation_metric,
            pass_threshold,
            ..
        } = EvalGraderTextSimilarity::deserialize(deserializer)?;
        Ok(Self {
            name,
            input,
            reference,
            evaluation_metric,
            pass_threshold,
        })
    }
}
impl serde::Serialize for EvalGraderTextSimilarity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalGraderTextSimilarity<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_grader_text_similarity::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "reference")]
            reference: &'a String,
            #[serde(rename = "evaluation_metric")]
            evaluation_metric: &'a crate::__types::eval_grader_text_similarity::EvaluationMetric,
            #[serde(rename = "pass_threshold")]
            pass_threshold: &'a serde_json::Number,
        }
        let Self {
            name,
            input,
            reference,
            evaluation_metric,
            pass_threshold,
        } = self;
        EvalGraderTextSimilarity {
            r#type: &Default::default(),
            name,
            input,
            reference,
            evaluation_metric,
            pass_threshold,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod eval_item {
    #[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`assistant`"]
        #[serde(rename = "assistant")]
        Assistant,
        #[doc = "`system`"]
        #[serde(rename = "system")]
        System,
        #[doc = "`developer`"]
        #[serde(rename = "developer")]
        Developer,
    }
    #[allow(clippy::module_inception)]
    pub mod content {
        #[allow(clippy::module_inception)]
        pub(crate) mod output_text {
            #[doc = "The type of the output text. Always `output_text`.\n"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "output_text");
        }
        #[doc = "A text output from the model.\n"]
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct OutputText {
            #[doc = "The text output from the model.\n"]
            pub text: String,
        }
        impl<'de> serde::Deserialize<'de> for OutputText {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct OutputText {
                    #[serde(rename = "type")]
                    #[allow(dead_code)]
                    r#type: crate::__types::eval_item::content::output_text::Type,
                    #[serde(rename = "text")]
                    text: String,
                }
                let OutputText { text, .. } = OutputText::deserialize(deserializer)?;
                Ok(Self { text })
            }
        }
        impl serde::Serialize for OutputText {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct OutputText<'a> {
                    #[serde(rename = "type")]
                    r#type: &'a crate::__types::eval_item::content::output_text::Type,
                    #[serde(rename = "text")]
                    text: &'a String,
                }
                let Self { text } = self;
                OutputText {
                    r#type: &Default::default(),
                    text,
                }
                .serialize(serializer)
            }
        }
        #[allow(clippy::module_inception)]
        pub(crate) mod input_image {
            #[doc = "The type of the image input. Always `input_image`.\n"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "input_image");
        }
        #[doc = "An image input to the model.\n"]
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct InputImage {
            #[doc = "The URL of the image input.\n"]
            pub image_url: String,
            #[doc = "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`.\n"]
            #[builder(default)]
            pub detail: Option<String>,
        }
        impl<'de> serde::Deserialize<'de> for InputImage {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct InputImage {
                    #[serde(rename = "type")]
                    #[allow(dead_code)]
                    r#type: crate::__types::eval_item::content::input_image::Type,
                    #[serde(rename = "image_url")]
                    image_url: String,
                    #[serde(rename = "detail")]
                    detail: Option<String>,
                }
                let InputImage {
                    image_url, detail, ..
                } = InputImage::deserialize(deserializer)?;
                Ok(Self { image_url, detail })
            }
        }
        impl serde::Serialize for InputImage {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct InputImage<'a> {
                    #[serde(rename = "type")]
                    r#type: &'a crate::__types::eval_item::content::input_image::Type,
                    #[serde(rename = "image_url")]
                    image_url: &'a String,
                    #[serde(rename = "detail")]
                    #[serde(skip_serializing_if = "Option::is_none")]
                    detail: &'a Option<String>,
                }
                let Self { image_url, detail } = self;
                InputImage {
                    r#type: &Default::default(),
                    image_url,
                    detail,
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "Inputs to the model - can contain template strings.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "A text input to the model.\n"]
        String(String),
        InputText(crate::__types::InputTextContent),
        #[doc = "A text output from the model.\n"]
        OutputText(crate::__types::eval_item::content::OutputText),
        #[doc = "An image input to the model.\n"]
        InputImage(crate::__types::eval_item::content::InputImage),
        #[doc = "A list of inputs, each of which may be either an input text or input image object.\n"]
        Array(Vec<serde_json::Value>),
    }
    #[doc = "The type of the message input. Always `message`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Type;
    impl_serde!(Type, "message");
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct EvalItem {
    #[doc = "The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n"]
    #[serde(rename = "role")]
    pub role: crate::__types::eval_item::Role,
    #[doc = "Inputs to the model - can contain template strings.\n"]
    #[serde(rename = "content")]
    pub content: crate::__types::eval_item::Content,
    #[doc = "The type of the message input. Always `message`.\n"]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::eval_item::Type>,
}
#[allow(clippy::module_inception)]
pub mod eval_jsonl_file_content_source {
    #[doc = "The type of jsonl source. Always `file_content`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_content");
    #[allow(clippy::module_inception)]
    pub mod content {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[serde(rename = "item")]
            pub item: indexmap::IndexMap<String, serde_json::Value>,
            #[serde(rename = "sample")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub sample: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalJsonlFileContentSource {
    #[doc = "The content of the jsonl file."]
    pub content: Vec<crate::__types::eval_jsonl_file_content_source::content::Item>,
}
impl<'de> serde::Deserialize<'de> for EvalJsonlFileContentSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalJsonlFileContentSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_jsonl_file_content_source::Type,
            #[serde(rename = "content")]
            content: Vec<crate::__types::eval_jsonl_file_content_source::content::Item>,
        }
        let EvalJsonlFileContentSource { content, .. } =
            EvalJsonlFileContentSource::deserialize(deserializer)?;
        Ok(Self { content })
    }
}
impl serde::Serialize for EvalJsonlFileContentSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalJsonlFileContentSource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_jsonl_file_content_source::Type,
            #[serde(rename = "content")]
            content: &'a Vec<crate::__types::eval_jsonl_file_content_source::content::Item>,
        }
        let Self { content } = self;
        EvalJsonlFileContentSource {
            r#type: &Default::default(),
            content,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_jsonl_file_id_source {
    #[doc = "The type of jsonl source. Always `file_id`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_id");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalJsonlFileIdSource {
    #[doc = "The identifier of the file."]
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for EvalJsonlFileIdSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalJsonlFileIdSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_jsonl_file_id_source::Type,
            #[serde(rename = "id")]
            id: String,
        }
        let EvalJsonlFileIdSource { id, .. } = EvalJsonlFileIdSource::deserialize(deserializer)?;
        Ok(Self { id })
    }
}
impl serde::Serialize for EvalJsonlFileIdSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalJsonlFileIdSource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_jsonl_file_id_source::Type,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self { id } = self;
        EvalJsonlFileIdSource {
            r#type: &Default::default(),
            id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_list {
    #[doc = "The type of this object. It is always set to \"list\".\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[doc = "An object representing a list of evals.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalList {
    #[doc = "An array of eval objects.\n"]
    pub data: Vec<crate::__types::Eval>,
    #[doc = "The identifier of the first eval in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more evals available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::eval_list::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::Eval>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let EvalList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = EvalList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalList<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::eval_list::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::Eval>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        EvalList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_logs_data_source_config {
    #[doc = "The type of data source. Always `logs`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "logs");
}
#[doc = "A LogsDataSourceConfig which specifies the metadata property of your logs query.\nThis is usually metadata like `usecase=chatbot` or `prompt-version=v2`, etc.\nThe schema returned by this data source config is used to defined what variables are available in your evals.\n`item` and `sample` are both defined when using this data source config.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalLogsDataSourceConfig {
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
    pub schema: indexmap::IndexMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for EvalLogsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalLogsDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_logs_data_source_config::Type,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
            #[serde(rename = "schema")]
            schema: indexmap::IndexMap<String, serde_json::Value>,
        }
        let EvalLogsDataSourceConfig {
            metadata, schema, ..
        } = EvalLogsDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { metadata, schema })
    }
}
impl serde::Serialize for EvalLogsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalLogsDataSourceConfig<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_logs_data_source_config::Type,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
            #[serde(rename = "schema")]
            schema: &'a indexmap::IndexMap<String, serde_json::Value>,
        }
        let Self { metadata, schema } = self;
        EvalLogsDataSourceConfig {
            r#type: &Default::default(),
            metadata,
            schema,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_responses_source {
    #[doc = "The type of run data source. Always `responses`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "responses");
}
#[doc = "A EvalResponsesSource object describing a run data source configuration.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalResponsesSource {
    #[doc = "Metadata filter for the responses. This is a query parameter used to select responses."]
    #[builder(default)]
    pub metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
    #[doc = "The name of the model to find responses for. This is a query parameter used to select responses."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "Optional string to search the 'instructions' field. This is a query parameter used to select responses."]
    #[builder(default)]
    pub instructions_search: Option<String>,
    #[doc = "Only include items created after this timestamp (inclusive). This is a query parameter used to select responses."]
    #[builder(default)]
    pub created_after: Option<i64>,
    #[doc = "Only include items created before this timestamp (inclusive). This is a query parameter used to select responses."]
    #[builder(default)]
    pub created_before: Option<i64>,
    #[doc = "Optional reasoning effort parameter. This is a query parameter used to select responses."]
    #[builder(default)]
    pub reasoning_effort: Option<crate::__types::ReasoningEffort>,
    #[doc = "Sampling temperature. This is a query parameter used to select responses."]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "Nucleus sampling parameter. This is a query parameter used to select responses."]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "List of user identifiers. This is a query parameter used to select responses."]
    #[builder(default)]
    pub users: Option<Vec<String>>,
    #[doc = "List of tool names. This is a query parameter used to select responses."]
    #[builder(default)]
    pub tools: Option<Vec<String>>,
}
impl<'de> serde::Deserialize<'de> for EvalResponsesSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalResponsesSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_responses_source::Type,
            #[serde(rename = "metadata")]
            metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "model")]
            model: Option<String>,
            #[serde(rename = "instructions_search")]
            instructions_search: Option<String>,
            #[serde(rename = "created_after")]
            created_after: Option<i64>,
            #[serde(rename = "created_before")]
            created_before: Option<i64>,
            #[serde(rename = "reasoning_effort")]
            reasoning_effort: Option<crate::__types::ReasoningEffort>,
            #[serde(rename = "temperature")]
            temperature: Option<serde_json::Number>,
            #[serde(rename = "top_p")]
            top_p: Option<serde_json::Number>,
            #[serde(rename = "users")]
            users: Option<Vec<String>>,
            #[serde(rename = "tools")]
            tools: Option<Vec<String>>,
        }
        let EvalResponsesSource {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            reasoning_effort,
            temperature,
            top_p,
            users,
            tools,
            ..
        } = EvalResponsesSource::deserialize(deserializer)?;
        Ok(Self {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            reasoning_effort,
            temperature,
            top_p,
            users,
            tools,
        })
    }
}
impl serde::Serialize for EvalResponsesSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalResponsesSource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_responses_source::Type,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "instructions_search")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions_search: &'a Option<String>,
            #[serde(rename = "created_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_after: &'a Option<i64>,
            #[serde(rename = "created_before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_before: &'a Option<i64>,
            #[serde(rename = "reasoning_effort")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning_effort: &'a Option<crate::__types::ReasoningEffort>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<serde_json::Number>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<serde_json::Number>,
            #[serde(rename = "users")]
            #[serde(skip_serializing_if = "Option::is_none")]
            users: &'a Option<Vec<String>>,
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tools: &'a Option<Vec<String>>,
        }
        let Self {
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            reasoning_effort,
            temperature,
            top_p,
            users,
            tools,
        } = self;
        EvalResponsesSource {
            r#type: &Default::default(),
            metadata,
            model,
            instructions_search,
            created_after,
            created_before,
            reasoning_effort,
            temperature,
            top_p,
            users,
            tools,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod eval_run {
    #[doc = "The type of the object. Always \"eval.run\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "eval.run");
    #[doc = "Counters summarizing the outcomes of the evaluation run."]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ResultCounts {
        #[doc = "Total number of executed output items."]
        #[serde(rename = "total")]
        pub total: i64,
        #[doc = "Number of output items that resulted in an error."]
        #[serde(rename = "errored")]
        pub errored: i64,
        #[doc = "Number of output items that failed to pass the evaluation."]
        #[serde(rename = "failed")]
        pub failed: i64,
        #[doc = "Number of output items that passed the evaluation."]
        #[serde(rename = "passed")]
        pub passed: i64,
    }
    #[allow(clippy::module_inception)]
    pub mod per_model_usage {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The name of the model."]
            #[serde(rename = "model_name")]
            pub model_name: String,
            #[doc = "The number of invocations."]
            #[serde(rename = "invocation_count")]
            pub invocation_count: i64,
            #[doc = "The number of prompt tokens used."]
            #[serde(rename = "prompt_tokens")]
            pub prompt_tokens: i64,
            #[doc = "The number of completion tokens generated."]
            #[serde(rename = "completion_tokens")]
            pub completion_tokens: i64,
            #[doc = "The total number of tokens used."]
            #[serde(rename = "total_tokens")]
            pub total_tokens: i64,
            #[doc = "The number of tokens retrieved from cache."]
            #[serde(rename = "cached_tokens")]
            pub cached_tokens: i64,
        }
    }
    #[allow(clippy::module_inception)]
    pub mod per_testing_criteria_results {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "A description of the testing criteria."]
            #[serde(rename = "testing_criteria")]
            pub testing_criteria: String,
            #[doc = "Number of tests passed for this criteria."]
            #[serde(rename = "passed")]
            pub passed: i64,
            #[doc = "Number of tests failed for this criteria."]
            #[serde(rename = "failed")]
            pub failed: i64,
        }
    }
    #[doc = "Information about the run's data source."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum DataSource {
        Jsonl(crate::__types::CreateEvalJsonlRunDataSource),
        Completions(crate::__types::CreateEvalCompletionsRunDataSource),
        Responses(crate::__types::CreateEvalResponsesRunDataSource),
    }
}
#[doc = "A schema representing an evaluation run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRun {
    #[doc = "Unique identifier for the evaluation run."]
    pub id: String,
    #[doc = "The identifier of the associated evaluation."]
    pub eval_id: String,
    #[doc = "The status of the evaluation run."]
    pub status: String,
    #[doc = "The model that is evaluated, if applicable."]
    pub model: String,
    #[doc = "The name of the evaluation run."]
    pub name: String,
    #[doc = "Unix timestamp (in seconds) when the evaluation run was created."]
    pub created_at: i64,
    #[doc = "The URL to the rendered evaluation run report on the UI dashboard."]
    pub report_url: String,
    #[doc = "Counters summarizing the outcomes of the evaluation run."]
    pub result_counts: crate::__types::eval_run::ResultCounts,
    #[doc = "Usage statistics for each model during the evaluation run."]
    pub per_model_usage: Vec<crate::__types::eval_run::per_model_usage::Item>,
    #[doc = "Results per testing criteria applied during the evaluation run."]
    pub per_testing_criteria_results:
        Vec<crate::__types::eval_run::per_testing_criteria_results::Item>,
    #[doc = "Information about the run's data source."]
    pub data_source: crate::__types::eval_run::DataSource,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    pub error: crate::__types::EvalApiError,
}
impl<'de> serde::Deserialize<'de> for EvalRun {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRun {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::eval_run::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "eval_id")]
            eval_id: String,
            #[serde(rename = "status")]
            status: String,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "report_url")]
            report_url: String,
            #[serde(rename = "result_counts")]
            result_counts: crate::__types::eval_run::ResultCounts,
            #[serde(rename = "per_model_usage")]
            per_model_usage: Vec<crate::__types::eval_run::per_model_usage::Item>,
            #[serde(rename = "per_testing_criteria_results")]
            per_testing_criteria_results:
                Vec<crate::__types::eval_run::per_testing_criteria_results::Item>,
            #[serde(rename = "data_source")]
            data_source: crate::__types::eval_run::DataSource,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
            #[serde(rename = "error")]
            error: crate::__types::EvalApiError,
        }
        let EvalRun {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
            ..
        } = EvalRun::deserialize(deserializer)?;
        Ok(Self {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        })
    }
}
impl serde::Serialize for EvalRun {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRun<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::eval_run::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "eval_id")]
            eval_id: &'a String,
            #[serde(rename = "status")]
            status: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "report_url")]
            report_url: &'a String,
            #[serde(rename = "result_counts")]
            result_counts: &'a crate::__types::eval_run::ResultCounts,
            #[serde(rename = "per_model_usage")]
            per_model_usage: &'a Vec<crate::__types::eval_run::per_model_usage::Item>,
            #[serde(rename = "per_testing_criteria_results")]
            per_testing_criteria_results:
                &'a Vec<crate::__types::eval_run::per_testing_criteria_results::Item>,
            #[serde(rename = "data_source")]
            data_source: &'a crate::__types::eval_run::DataSource,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
            #[serde(rename = "error")]
            error: &'a crate::__types::EvalApiError,
        }
        let Self {
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        } = self;
        EvalRun {
            object: &Default::default(),
            id,
            eval_id,
            status,
            model,
            name,
            created_at,
            report_url,
            result_counts,
            per_model_usage,
            per_testing_criteria_results,
            data_source,
            metadata,
            error,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_run_list {
    #[doc = "The type of this object. It is always set to \"list\".\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[doc = "An object representing a list of runs for an evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunList {
    #[doc = "An array of eval run objects.\n"]
    pub data: Vec<crate::__types::EvalRun>,
    #[doc = "The identifier of the first eval run in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval run in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more evals available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalRunList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::eval_run_list::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::EvalRun>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let EvalRunList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = EvalRunList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalRunList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunList<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::eval_run_list::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::EvalRun>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        EvalRunList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod eval_run_output_item {
    #[doc = "The type of the object. Always \"eval.run.output_item\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "eval.run.output_item");
    #[allow(clippy::module_inception)]
    pub mod sample {
        #[allow(clippy::module_inception)]
        pub mod input {
            #[doc = "An input message."]
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Item {
                #[doc = "The role of the message sender (e.g., system, user, developer)."]
                #[serde(rename = "role")]
                pub role: String,
                #[doc = "The content of the message."]
                #[serde(rename = "content")]
                pub content: String,
            }
        }
        #[allow(clippy::module_inception)]
        pub mod output {
            #[derive(Clone, Debug, Default, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Item {
                #[doc = "The role of the message (e.g. \"system\", \"assistant\", \"user\")."]
                #[serde(rename = "role")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub role: Option<String>,
                #[doc = "The content of the message."]
                #[serde(rename = "content")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub content: Option<String>,
            }
        }
        #[doc = "Token usage details for the sample."]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Usage {
            #[doc = "The total number of tokens used."]
            #[serde(rename = "total_tokens")]
            pub total_tokens: i64,
            #[doc = "The number of completion tokens generated."]
            #[serde(rename = "completion_tokens")]
            pub completion_tokens: i64,
            #[doc = "The number of prompt tokens used."]
            #[serde(rename = "prompt_tokens")]
            pub prompt_tokens: i64,
            #[doc = "The number of tokens retrieved from cache."]
            #[serde(rename = "cached_tokens")]
            pub cached_tokens: i64,
        }
    }
    #[doc = "A sample containing the input and output of the evaluation run."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Sample {
        #[doc = "An array of input messages."]
        #[serde(rename = "input")]
        pub input: Vec<crate::__types::eval_run_output_item::sample::input::Item>,
        #[doc = "An array of output messages."]
        #[serde(rename = "output")]
        pub output: Vec<crate::__types::eval_run_output_item::sample::output::Item>,
        #[doc = "The reason why the sample generation was finished."]
        #[serde(rename = "finish_reason")]
        pub finish_reason: String,
        #[doc = "The model used for generating the sample."]
        #[serde(rename = "model")]
        pub model: String,
        #[doc = "Token usage details for the sample."]
        #[serde(rename = "usage")]
        pub usage: crate::__types::eval_run_output_item::sample::Usage,
        #[serde(rename = "error")]
        pub error: crate::__types::EvalApiError,
        #[doc = "The sampling temperature used."]
        #[serde(rename = "temperature")]
        pub temperature: serde_json::Number,
        #[doc = "The maximum number of tokens allowed for completion."]
        #[serde(rename = "max_completion_tokens")]
        pub max_completion_tokens: i64,
        #[doc = "The top_p value used for sampling."]
        #[serde(rename = "top_p")]
        pub top_p: serde_json::Number,
        #[doc = "The seed used for generating the sample."]
        #[serde(rename = "seed")]
        pub seed: i64,
    }
}
#[doc = "A schema representing an evaluation run output item.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItem {
    #[doc = "Unique identifier for the evaluation run output item."]
    pub id: String,
    #[doc = "The identifier of the evaluation run associated with this output item."]
    pub run_id: String,
    #[doc = "The identifier of the evaluation group."]
    pub eval_id: String,
    #[doc = "Unix timestamp (in seconds) when the evaluation run was created."]
    pub created_at: i64,
    #[doc = "The status of the evaluation run."]
    pub status: String,
    #[doc = "The identifier for the data source item."]
    pub datasource_item_id: i64,
    #[doc = "Details of the input data source item."]
    pub datasource_item: indexmap::IndexMap<String, serde_json::Value>,
    #[doc = "A list of results from the evaluation run."]
    pub results: Vec<indexmap::IndexMap<String, serde_json::Value>>,
    #[doc = "A sample containing the input and output of the evaluation run."]
    pub sample: crate::__types::eval_run_output_item::Sample,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunOutputItem {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::eval_run_output_item::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "run_id")]
            run_id: String,
            #[serde(rename = "eval_id")]
            eval_id: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "status")]
            status: String,
            #[serde(rename = "datasource_item_id")]
            datasource_item_id: i64,
            #[serde(rename = "datasource_item")]
            datasource_item: indexmap::IndexMap<String, serde_json::Value>,
            #[serde(rename = "results")]
            results: Vec<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "sample")]
            sample: crate::__types::eval_run_output_item::Sample,
        }
        let EvalRunOutputItem {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
            ..
        } = EvalRunOutputItem::deserialize(deserializer)?;
        Ok(Self {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        })
    }
}
impl serde::Serialize for EvalRunOutputItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunOutputItem<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::eval_run_output_item::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "run_id")]
            run_id: &'a String,
            #[serde(rename = "eval_id")]
            eval_id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "status")]
            status: &'a String,
            #[serde(rename = "datasource_item_id")]
            datasource_item_id: &'a i64,
            #[serde(rename = "datasource_item")]
            datasource_item: &'a indexmap::IndexMap<String, serde_json::Value>,
            #[serde(rename = "results")]
            results: &'a Vec<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "sample")]
            sample: &'a crate::__types::eval_run_output_item::Sample,
        }
        let Self {
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        } = self;
        EvalRunOutputItem {
            object: &Default::default(),
            id,
            run_id,
            eval_id,
            created_at,
            status,
            datasource_item_id,
            datasource_item,
            results,
            sample,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_run_output_item_list {
    #[doc = "The type of this object. It is always set to \"list\".\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[doc = "An object representing a list of output items for an evaluation run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalRunOutputItemList {
    #[doc = "An array of eval run output item objects.\n"]
    pub data: Vec<crate::__types::EvalRunOutputItem>,
    #[doc = "The identifier of the first eval run output item in the data array."]
    pub first_id: String,
    #[doc = "The identifier of the last eval run output item in the data array."]
    pub last_id: String,
    #[doc = "Indicates whether there are more eval run output items available."]
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for EvalRunOutputItemList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalRunOutputItemList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::eval_run_output_item_list::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::EvalRunOutputItem>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let EvalRunOutputItemList {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = EvalRunOutputItemList::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for EvalRunOutputItemList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalRunOutputItemList<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::eval_run_output_item_list::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::EvalRunOutputItem>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        EvalRunOutputItemList {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_stored_completions_data_source_config {
    #[doc = "The type of data source. Always `stored_completions`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "stored_completions");
}
#[doc = "Deprecated in favor of LogsDataSourceConfig.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalStoredCompletionsDataSourceConfig {
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "The json schema for the run data source items.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
    pub schema: indexmap::IndexMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for EvalStoredCompletionsDataSourceConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalStoredCompletionsDataSourceConfig {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_stored_completions_data_source_config::Type,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
            #[serde(rename = "schema")]
            schema: indexmap::IndexMap<String, serde_json::Value>,
        }
        let EvalStoredCompletionsDataSourceConfig {
            metadata, schema, ..
        } = EvalStoredCompletionsDataSourceConfig::deserialize(deserializer)?;
        Ok(Self { metadata, schema })
    }
}
impl serde::Serialize for EvalStoredCompletionsDataSourceConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalStoredCompletionsDataSourceConfig<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_stored_completions_data_source_config::Type,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
            #[serde(rename = "schema")]
            schema: &'a indexmap::IndexMap<String, serde_json::Value>,
        }
        let Self { metadata, schema } = self;
        EvalStoredCompletionsDataSourceConfig {
            r#type: &Default::default(),
            metadata,
            schema,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod eval_stored_completions_source {
    #[doc = "The type of source. Always `stored_completions`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "stored_completions");
}
#[doc = "A StoredCompletionsRunDataSource configuration describing a set of filters\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct EvalStoredCompletionsSource {
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "An optional model to filter by (e.g., 'gpt-4o')."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "An optional Unix timestamp to filter items created after this time."]
    #[builder(default)]
    pub created_after: Option<i64>,
    #[doc = "An optional Unix timestamp to filter items created before this time."]
    #[builder(default)]
    pub created_before: Option<i64>,
    #[doc = "An optional maximum number of items to return."]
    #[builder(default)]
    pub limit: Option<i64>,
}
impl<'de> serde::Deserialize<'de> for EvalStoredCompletionsSource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct EvalStoredCompletionsSource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::eval_stored_completions_source::Type,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
            #[serde(rename = "model")]
            model: Option<String>,
            #[serde(rename = "created_after")]
            created_after: Option<i64>,
            #[serde(rename = "created_before")]
            created_before: Option<i64>,
            #[serde(rename = "limit")]
            limit: Option<i64>,
        }
        let EvalStoredCompletionsSource {
            metadata,
            model,
            created_after,
            created_before,
            limit,
            ..
        } = EvalStoredCompletionsSource::deserialize(deserializer)?;
        Ok(Self {
            metadata,
            model,
            created_after,
            created_before,
            limit,
        })
    }
}
impl serde::Serialize for EvalStoredCompletionsSource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct EvalStoredCompletionsSource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::eval_stored_completions_source::Type,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "created_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_after: &'a Option<i64>,
            #[serde(rename = "created_before")]
            #[serde(skip_serializing_if = "Option::is_none")]
            created_before: &'a Option<i64>,
            #[serde(rename = "limit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            limit: &'a Option<i64>,
        }
        let Self {
            metadata,
            model,
            created_after,
            created_before,
            limit,
        } = self;
        EvalStoredCompletionsSource {
            r#type: &Default::default(),
            metadata,
            model,
            created_after,
            created_before,
            limit,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod file_expiration_after {
    #[doc = "Anchor timestamp after which the expiration policy applies. Supported anchors: `created_at`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Anchor;
    impl_serde!(Anchor, "created_at");
}
#[doc = "The expiration policy for a file. By default, files with `purpose=batch` expire after 30 days and all other files are persisted until they are manually deleted."]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileExpirationAfter {
    #[doc = "The number of seconds after the anchor time that the file will expire. Must be between 3600 (1 hour) and 2592000 (30 days)."]
    pub seconds: i64,
}
impl<'de> serde::Deserialize<'de> for FileExpirationAfter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileExpirationAfter {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: crate::__types::file_expiration_after::Anchor,
            #[serde(rename = "seconds")]
            seconds: i64,
        }
        let FileExpirationAfter { seconds, .. } = FileExpirationAfter::deserialize(deserializer)?;
        Ok(Self { seconds })
    }
}
impl serde::Serialize for FileExpirationAfter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileExpirationAfter<'a> {
            #[serde(rename = "anchor")]
            anchor: &'a crate::__types::file_expiration_after::Anchor,
            #[serde(rename = "seconds")]
            seconds: &'a i64,
        }
        let Self { seconds } = self;
        FileExpirationAfter {
            anchor: &Default::default(),
            seconds,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod file_path {
    #[doc = "The type of the file path. Always `file_path`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_path");
}
#[doc = "A path to a file.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FilePath {
    #[doc = "The ID of the file.\n"]
    pub file_id: String,
    #[doc = "The index of the file in the list of files.\n"]
    pub index: i64,
}
impl<'de> serde::Deserialize<'de> for FilePath {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FilePath {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::file_path::Type,
            #[serde(rename = "file_id")]
            file_id: String,
            #[serde(rename = "index")]
            index: i64,
        }
        let FilePath { file_id, index, .. } = FilePath::deserialize(deserializer)?;
        Ok(Self { file_id, index })
    }
}
impl serde::Serialize for FilePath {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FilePath<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::file_path::Type,
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "index")]
            index: &'a i64,
        }
        let Self { file_id, index } = self;
        FilePath {
            r#type: &Default::default(),
            file_id,
            index,
        }
        .serialize(serializer)
    }
}
#[doc = "The ranker to use for the file search. If not specified will use the `auto` ranker."]
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum FileSearchRanker {
    #[doc = "`auto`"]
    #[serde(rename = "auto")]
    Auto,
    #[doc = "`default_2024_08_21`"]
    #[serde(rename = "default_2024_08_21")]
    Default2024_08_21,
}
#[doc = "The ranking options for the file search. If not specified, the file search tool will use the `auto` ranker and a score_threshold of 0.\n\nSee the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FileSearchRankingOptions {
    #[serde(rename = "ranker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ranker: Option<crate::__types::FileSearchRanker>,
    #[doc = "The score threshold for the file search. All values must be a floating point number between 0 and 1."]
    #[serde(rename = "score_threshold")]
    pub score_threshold: serde_json::Number,
}
#[allow(clippy::module_inception)]
pub mod file_search_tool_call {
    #[doc = "The type of the file search tool call. Always `file_search_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_search_call");
    #[doc = "The status of the file search tool call. One of `in_progress`, \n`searching`, `incomplete` or `failed`,\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`searching`"]
        #[serde(rename = "searching")]
        Searching,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
    }
    #[allow(clippy::module_inception)]
    pub mod results {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The unique ID of the file.\n"]
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_id: Option<String>,
            #[doc = "The text that was retrieved from the file.\n"]
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub text: Option<String>,
            #[doc = "The name of the file.\n"]
            #[serde(rename = "filename")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub filename: Option<String>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub attributes: Option<crate::__types::VectorStoreFileAttributes>,
            #[doc = "The relevance score of the file - a value between 0 and 1.\n"]
            #[serde(rename = "score")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub score: Option<f64>,
        }
    }
}
#[doc = "The results of a file search tool call. See the \n[file search guide](https://platform.openai.com/docs/guides/tools-file-search) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileSearchToolCall {
    #[doc = "The unique ID of the file search tool call.\n"]
    pub id: String,
    #[doc = "The status of the file search tool call. One of `in_progress`, \n`searching`, `incomplete` or `failed`,\n"]
    pub status: crate::__types::file_search_tool_call::Status,
    #[doc = "The queries used to search for files.\n"]
    pub queries: Vec<String>,
    #[doc = "The results of the file search tool call.\n"]
    #[builder(default)]
    pub results: Option<Vec<crate::__types::file_search_tool_call::results::Item>>,
}
impl<'de> serde::Deserialize<'de> for FileSearchToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileSearchToolCall {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::file_search_tool_call::Type,
            #[serde(rename = "status")]
            status: crate::__types::file_search_tool_call::Status,
            #[serde(rename = "queries")]
            queries: Vec<String>,
            #[serde(rename = "results")]
            results: Option<Vec<crate::__types::file_search_tool_call::results::Item>>,
        }
        let FileSearchToolCall {
            id,
            status,
            queries,
            results,
            ..
        } = FileSearchToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            status,
            queries,
            results,
        })
    }
}
impl serde::Serialize for FileSearchToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileSearchToolCall<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::file_search_tool_call::Type,
            #[serde(rename = "status")]
            status: &'a crate::__types::file_search_tool_call::Status,
            #[serde(rename = "queries")]
            queries: &'a Vec<String>,
            #[serde(rename = "results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            results: &'a Option<Vec<crate::__types::file_search_tool_call::results::Item>>,
        }
        let Self {
            id,
            status,
            queries,
            results,
        } = self;
        FileSearchToolCall {
            id,
            r#type: &Default::default(),
            status,
            queries,
            results,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod fine_tune_chat_completion_request_assistant_message {
    #[doc = "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "The contents of the assistant message."]
        String(String),
        #[doc = "An array of content parts with a defined type. Can be one or more of type `text`, or exactly one of type `refusal`."]
        Array(Vec<crate::__types::ChatCompletionRequestAssistantMessageContentPart>),
    }
    #[doc = "The role of the messages author, in this case `assistant`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "assistant");
    #[doc = "Data about a previous audio response from the model. \n[Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Audio {
        #[doc = "Unique identifier for a previous audio response from the model.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FunctionCall {
        #[doc = "The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function."]
        #[serde(rename = "arguments")]
        pub arguments: String,
        #[doc = "The name of the function to call."]
        #[serde(rename = "name")]
        pub name: String,
    }
}
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuneChatCompletionRequestAssistantMessage {
    #[doc = "Controls whether the assistant message is trained against (0 or 1)"]
    #[builder(default)]
    pub weight: Option<i64>,
    #[doc = "The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.\n"]
    #[builder(default)]
    pub content:
        Option<crate::__types::fine_tune_chat_completion_request_assistant_message::Content>,
    #[doc = "The refusal message by the assistant."]
    #[builder(default)]
    pub refusal: Option<String>,
    #[doc = "An optional name for the participant. Provides the model information to differentiate between participants of the same role."]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "Data about a previous audio response from the model. \n[Learn more](https://platform.openai.com/docs/guides/audio).\n"]
    #[builder(default)]
    pub audio: Option<crate::__types::fine_tune_chat_completion_request_assistant_message::Audio>,
    #[builder(default)]
    pub tool_calls: Option<crate::__types::ChatCompletionMessageToolCalls>,
    #[doc = "Deprecated and replaced by `tool_calls`. The name and arguments of a function that should be called, as generated by the model."]
    #[builder(default)]
    pub function_call:
        Option<crate::__types::fine_tune_chat_completion_request_assistant_message::FunctionCall>,
}
impl<'de> serde::Deserialize<'de> for FineTuneChatCompletionRequestAssistantMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuneChatCompletionRequestAssistantMessage {
            #[serde(rename = "weight")]
            weight: Option<i64>,
            #[serde(rename = "content")]
            content: Option<
                crate::__types::fine_tune_chat_completion_request_assistant_message::Content,
            >,
            #[serde(rename = "refusal")]
            refusal: Option<String>,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::fine_tune_chat_completion_request_assistant_message::Role,
            #[serde(rename = "name")]
            name: Option<String>,
            #[serde(rename = "audio")]
            audio:
                Option<crate::__types::fine_tune_chat_completion_request_assistant_message::Audio>,
            #[serde(rename = "tool_calls")]
            tool_calls: Option<crate::__types::ChatCompletionMessageToolCalls>,
            #[serde(rename = "function_call")]
            function_call: Option<
                crate::__types::fine_tune_chat_completion_request_assistant_message::FunctionCall,
            >,
        }
        let FineTuneChatCompletionRequestAssistantMessage {
            weight,
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
            ..
        } = FineTuneChatCompletionRequestAssistantMessage::deserialize(deserializer)?;
        Ok(Self {
            weight,
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
        })
    }
}
impl serde::Serialize for FineTuneChatCompletionRequestAssistantMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuneChatCompletionRequestAssistantMessage<'a> {
            #[serde(rename = "weight")]
            #[serde(skip_serializing_if = "Option::is_none")]
            weight: &'a Option<i64>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<
                crate::__types::fine_tune_chat_completion_request_assistant_message::Content,
            >,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
            #[serde(rename = "role")]
            role: &'a crate::__types::fine_tune_chat_completion_request_assistant_message::Role,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            audio: &'a Option<
                crate::__types::fine_tune_chat_completion_request_assistant_message::Audio,
            >,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<crate::__types::ChatCompletionMessageToolCalls>,
            #[serde(rename = "function_call")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function_call: &'a Option<
                crate::__types::fine_tune_chat_completion_request_assistant_message::FunctionCall,
            >,
        }
        let Self {
            weight,
            content,
            refusal,
            name,
            audio,
            tool_calls,
            function_call,
        } = self;
        FineTuneChatCompletionRequestAssistantMessage {
            weight,
            content,
            refusal,
            role: &Default::default(),
            name,
            audio,
            tool_calls,
            function_call,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod fine_tune_chat_request_input {
    #[allow(clippy::module_inception)]
    pub mod messages {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            System(crate::__types::ChatCompletionRequestSystemMessage),
            User(crate::__types::ChatCompletionRequestUserMessage),
            Assistant(crate::__types::FineTuneChatCompletionRequestAssistantMessage),
            Tool(crate::__types::ChatCompletionRequestToolMessage),
            Function(crate::__types::ChatCompletionRequestFunctionMessage),
        }
    }
}
#[doc = "The per-line training example of a fine-tuning input file for chat models using the supervised method.\nInput messages may contain text or image content only. Audio and file input messages\nare not currently supported for fine-tuning.\n"]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneChatRequestInput {
    #[serde(rename = "messages")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub messages: Option<Vec<crate::__types::fine_tune_chat_request_input::messages::Item>>,
    #[doc = "A list of tools the model may generate JSON inputs for."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::ChatCompletionTool>>,
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parallel_tool_calls: Option<crate::__types::ParallelToolCalls>,
    #[doc = "A list of functions the model may generate JSON inputs for."]
    #[serde(rename = "functions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub functions: Option<Vec<crate::__types::ChatCompletionFunctions>>,
}
#[allow(clippy::module_inception)]
pub mod fine_tune_dpo_hyperparameters {
    #[allow(clippy::module_inception)]
    pub(crate) mod beta {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Beta {
        #[doc = "auto"]
        Auto,
        Number(serde_json::Number),
    }
    impl<'de> serde::Deserialize<'de> for Beta {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Beta {
                Auto(crate::__types::fine_tune_dpo_hyperparameters::beta::Auto),
                Number(serde_json::Number),
            }
            Ok(match Beta::deserialize(deserializer)? {
                Beta::Auto(_) => Self::Auto,
                Beta::Number(v) => Self::Number(v),
            })
        }
    }
    impl serde::Serialize for Beta {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Beta<'a> {
                Auto(crate::__types::fine_tune_dpo_hyperparameters::beta::Auto),
                Number(&'a serde_json::Number),
            }
            match self {
                Self::Auto => Beta::Auto(Default::default()),
                Self::Number(v) => Beta::Number(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod batch_size {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum BatchSize {
        #[doc = "auto"]
        Auto,
        Integer(i64),
    }
    impl<'de> serde::Deserialize<'de> for BatchSize {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum BatchSize {
                Auto(crate::__types::fine_tune_dpo_hyperparameters::batch_size::Auto),
                Integer(i64),
            }
            Ok(match BatchSize::deserialize(deserializer)? {
                BatchSize::Auto(_) => Self::Auto,
                BatchSize::Integer(v) => Self::Integer(v),
            })
        }
    }
    impl serde::Serialize for BatchSize {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum BatchSize<'a> {
                Auto(crate::__types::fine_tune_dpo_hyperparameters::batch_size::Auto),
                Integer(&'a i64),
            }
            match self {
                Self::Auto => BatchSize::Auto(Default::default()),
                Self::Integer(v) => BatchSize::Integer(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod learning_rate_multiplier {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum LearningRateMultiplier {
        #[doc = "auto"]
        Auto,
        Number(serde_json::Number),
    }
    impl<'de> serde::Deserialize<'de> for LearningRateMultiplier {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum LearningRateMultiplier {
                Auto(crate::__types::fine_tune_dpo_hyperparameters::learning_rate_multiplier::Auto),
                Number(serde_json::Number),
            }
            Ok(match LearningRateMultiplier::deserialize(deserializer)? {
                LearningRateMultiplier::Auto(_) => Self::Auto,
                LearningRateMultiplier::Number(v) => Self::Number(v),
            })
        }
    }
    impl serde::Serialize for LearningRateMultiplier {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum LearningRateMultiplier<'a> {
                Auto(crate::__types::fine_tune_dpo_hyperparameters::learning_rate_multiplier::Auto),
                Number(&'a serde_json::Number),
            }
            match self {
                Self::Auto => LearningRateMultiplier::Auto(Default::default()),
                Self::Number(v) => LearningRateMultiplier::Number(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod n_epochs {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum NEpochs {
        #[doc = "auto"]
        Auto,
        Integer(i64),
    }
    impl<'de> serde::Deserialize<'de> for NEpochs {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum NEpochs {
                Auto(crate::__types::fine_tune_dpo_hyperparameters::n_epochs::Auto),
                Integer(i64),
            }
            Ok(match NEpochs::deserialize(deserializer)? {
                NEpochs::Auto(_) => Self::Auto,
                NEpochs::Integer(v) => Self::Integer(v),
            })
        }
    }
    impl serde::Serialize for NEpochs {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum NEpochs<'a> {
                Auto(crate::__types::fine_tune_dpo_hyperparameters::n_epochs::Auto),
                Integer(&'a i64),
            }
            match self {
                Self::Auto => NEpochs::Auto(Default::default()),
                Self::Integer(v) => NEpochs::Integer(v),
            }
            .serialize(serializer)
        }
    }
}
#[doc = "The hyperparameters used for the DPO fine-tuning job."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneDpoHyperparameters {
    #[doc = "The beta value for the DPO method. A higher beta value will increase the weight of the penalty between the policy and reference model.\n"]
    #[serde(rename = "beta")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub beta: Option<crate::__types::fine_tune_dpo_hyperparameters::Beta>,
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[serde(rename = "batch_size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub batch_size: Option<crate::__types::fine_tune_dpo_hyperparameters::BatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[serde(rename = "learning_rate_multiplier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub learning_rate_multiplier:
        Option<crate::__types::fine_tune_dpo_hyperparameters::LearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[serde(rename = "n_epochs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub n_epochs: Option<crate::__types::fine_tune_dpo_hyperparameters::NEpochs>,
}
#[doc = "Configuration for the DPO fine-tuning method."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneDpoMethod {
    #[serde(rename = "hyperparameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hyperparameters: Option<crate::__types::FineTuneDpoHyperparameters>,
}
#[allow(clippy::module_inception)]
pub mod fine_tune_method {
    #[doc = "The type of method. Is either `supervised`, `dpo`, or `reinforcement`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`supervised`"]
        #[serde(rename = "supervised")]
        Supervised,
        #[doc = "`dpo`"]
        #[serde(rename = "dpo")]
        Dpo,
        #[doc = "`reinforcement`"]
        #[serde(rename = "reinforcement")]
        Reinforcement,
    }
}
#[doc = "The method used for fine-tuning."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneMethod {
    #[doc = "The type of method. Is either `supervised`, `dpo`, or `reinforcement`."]
    #[serde(rename = "type")]
    pub r#type: crate::__types::fine_tune_method::Type,
    #[serde(rename = "supervised")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub supervised: Option<crate::__types::FineTuneSupervisedMethod>,
    #[serde(rename = "dpo")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub dpo: Option<crate::__types::FineTuneDpoMethod>,
    #[serde(rename = "reinforcement")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reinforcement: Option<crate::__types::FineTuneReinforcementMethod>,
}
#[allow(clippy::module_inception)]
pub mod fine_tune_preference_request_input {
    #[allow(clippy::module_inception)]
    pub mod input {
        #[allow(clippy::module_inception)]
        pub mod messages {
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::large_enum_variant)]
            pub enum Item {
                System(crate::__types::ChatCompletionRequestSystemMessage),
                User(crate::__types::ChatCompletionRequestUserMessage),
                Assistant(crate::__types::FineTuneChatCompletionRequestAssistantMessage),
                Tool(crate::__types::ChatCompletionRequestToolMessage),
                Function(crate::__types::ChatCompletionRequestFunctionMessage),
            }
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Input {
        #[serde(rename = "messages")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub messages:
            Option<Vec<crate::__types::fine_tune_preference_request_input::input::messages::Item>>,
        #[doc = "A list of tools the model may generate JSON inputs for."]
        #[serde(rename = "tools")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub tools: Option<Vec<crate::__types::ChatCompletionTool>>,
        #[serde(rename = "parallel_tool_calls")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub parallel_tool_calls: Option<crate::__types::ParallelToolCalls>,
    }
    #[allow(clippy::module_inception)]
    pub mod preferred_output {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            ChatCompletionRequestAssistantMessage(
                crate::__types::ChatCompletionRequestAssistantMessage,
            ),
        }
    }
    #[allow(clippy::module_inception)]
    pub mod non_preferred_output {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            ChatCompletionRequestAssistantMessage(
                crate::__types::ChatCompletionRequestAssistantMessage,
            ),
        }
    }
}
#[doc = "The per-line training example of a fine-tuning input file for chat models using the dpo method.\nInput messages may contain text or image content only. Audio and file input messages\nare not currently supported for fine-tuning.\n"]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTunePreferenceRequestInput {
    #[serde(rename = "input")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input: Option<crate::__types::fine_tune_preference_request_input::Input>,
    #[doc = "The preferred completion message for the output."]
    #[serde(rename = "preferred_output")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub preferred_output:
        Option<Vec<crate::__types::fine_tune_preference_request_input::preferred_output::Item>>,
    #[doc = "The non-preferred completion message for the output."]
    #[serde(rename = "non_preferred_output")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub non_preferred_output:
        Option<Vec<crate::__types::fine_tune_preference_request_input::non_preferred_output::Item>>,
}
#[allow(clippy::module_inception)]
pub mod fine_tune_reinforcement_hyperparameters {
    #[allow(clippy::module_inception)]
    pub(crate) mod batch_size {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum BatchSize {
        #[doc = "auto"]
        Auto,
        Integer(i64),
    }
    impl<'de> serde::Deserialize<'de> for BatchSize {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum BatchSize {
                Auto(crate::__types::fine_tune_reinforcement_hyperparameters::batch_size::Auto),
                Integer(i64),
            }
            Ok(match BatchSize::deserialize(deserializer)? {
                BatchSize::Auto(_) => Self::Auto,
                BatchSize::Integer(v) => Self::Integer(v),
            })
        }
    }
    impl serde::Serialize for BatchSize {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum BatchSize<'a> {
                Auto(crate::__types::fine_tune_reinforcement_hyperparameters::batch_size::Auto),
                Integer(&'a i64),
            }
            match self {
                Self::Auto => BatchSize::Auto(Default::default()),
                Self::Integer(v) => BatchSize::Integer(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod learning_rate_multiplier {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum LearningRateMultiplier {
        #[doc = "auto"]
        Auto,
        Number(serde_json::Number),
    }
    impl<'de> serde::Deserialize<'de> for LearningRateMultiplier {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum LearningRateMultiplier {
                Auto (crate :: __types :: fine_tune_reinforcement_hyperparameters :: learning_rate_multiplier :: Auto) , Number (serde_json :: Number) }
            Ok(match LearningRateMultiplier::deserialize(deserializer)? {
                LearningRateMultiplier::Auto(_) => Self::Auto,
                LearningRateMultiplier::Number(v) => Self::Number(v),
            })
        }
    }
    impl serde::Serialize for LearningRateMultiplier {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum LearningRateMultiplier<'a> {
                Auto (crate :: __types :: fine_tune_reinforcement_hyperparameters :: learning_rate_multiplier :: Auto) , Number (& 'a serde_json :: Number) }
            match self {
                Self::Auto => LearningRateMultiplier::Auto(Default::default()),
                Self::Number(v) => LearningRateMultiplier::Number(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod n_epochs {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum NEpochs {
        #[doc = "auto"]
        Auto,
        Integer(i64),
    }
    impl<'de> serde::Deserialize<'de> for NEpochs {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum NEpochs {
                Auto(crate::__types::fine_tune_reinforcement_hyperparameters::n_epochs::Auto),
                Integer(i64),
            }
            Ok(match NEpochs::deserialize(deserializer)? {
                NEpochs::Auto(_) => Self::Auto,
                NEpochs::Integer(v) => Self::Integer(v),
            })
        }
    }
    impl serde::Serialize for NEpochs {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum NEpochs<'a> {
                Auto(crate::__types::fine_tune_reinforcement_hyperparameters::n_epochs::Auto),
                Integer(&'a i64),
            }
            match self {
                Self::Auto => NEpochs::Auto(Default::default()),
                Self::Integer(v) => NEpochs::Integer(v),
            }
            .serialize(serializer)
        }
    }
    #[doc = "Level of reasoning effort.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum ReasoningEffort {
        #[doc = "`default`"]
        #[default]
        #[serde(rename = "default")]
        Default,
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod compute_multiplier {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Multiplier on amount of compute used for exploring search space during training.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum ComputeMultiplier {
        #[doc = "auto"]
        Auto,
        Number(serde_json::Number),
    }
    impl<'de> serde::Deserialize<'de> for ComputeMultiplier {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum ComputeMultiplier {
                Auto (crate :: __types :: fine_tune_reinforcement_hyperparameters :: compute_multiplier :: Auto) , Number (serde_json :: Number) }
            Ok(match ComputeMultiplier::deserialize(deserializer)? {
                ComputeMultiplier::Auto(_) => Self::Auto,
                ComputeMultiplier::Number(v) => Self::Number(v),
            })
        }
    }
    impl serde::Serialize for ComputeMultiplier {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum ComputeMultiplier<'a> {
                Auto (crate :: __types :: fine_tune_reinforcement_hyperparameters :: compute_multiplier :: Auto) , Number (& 'a serde_json :: Number) }
            match self {
                Self::Auto => ComputeMultiplier::Auto(Default::default()),
                Self::Number(v) => ComputeMultiplier::Number(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod eval_interval {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "The number of training steps between evaluation runs.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum EvalInterval {
        #[doc = "auto"]
        Auto,
        Integer(i64),
    }
    impl<'de> serde::Deserialize<'de> for EvalInterval {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum EvalInterval {
                Auto(crate::__types::fine_tune_reinforcement_hyperparameters::eval_interval::Auto),
                Integer(i64),
            }
            Ok(match EvalInterval::deserialize(deserializer)? {
                EvalInterval::Auto(_) => Self::Auto,
                EvalInterval::Integer(v) => Self::Integer(v),
            })
        }
    }
    impl serde::Serialize for EvalInterval {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum EvalInterval<'a> {
                Auto(crate::__types::fine_tune_reinforcement_hyperparameters::eval_interval::Auto),
                Integer(&'a i64),
            }
            match self {
                Self::Auto => EvalInterval::Auto(Default::default()),
                Self::Integer(v) => EvalInterval::Integer(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod eval_samples {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Number of evaluation samples to generate per training step.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum EvalSamples {
        #[doc = "auto"]
        Auto,
        Integer(i64),
    }
    impl<'de> serde::Deserialize<'de> for EvalSamples {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum EvalSamples {
                Auto(crate::__types::fine_tune_reinforcement_hyperparameters::eval_samples::Auto),
                Integer(i64),
            }
            Ok(match EvalSamples::deserialize(deserializer)? {
                EvalSamples::Auto(_) => Self::Auto,
                EvalSamples::Integer(v) => Self::Integer(v),
            })
        }
    }
    impl serde::Serialize for EvalSamples {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum EvalSamples<'a> {
                Auto(crate::__types::fine_tune_reinforcement_hyperparameters::eval_samples::Auto),
                Integer(&'a i64),
            }
            match self {
                Self::Auto => EvalSamples::Auto(Default::default()),
                Self::Integer(v) => EvalSamples::Integer(v),
            }
            .serialize(serializer)
        }
    }
}
#[doc = "The hyperparameters used for the reinforcement fine-tuning job."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneReinforcementHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[serde(rename = "batch_size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub batch_size: Option<crate::__types::fine_tune_reinforcement_hyperparameters::BatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[serde(rename = "learning_rate_multiplier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub learning_rate_multiplier:
        Option<crate::__types::fine_tune_reinforcement_hyperparameters::LearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[serde(rename = "n_epochs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub n_epochs: Option<crate::__types::fine_tune_reinforcement_hyperparameters::NEpochs>,
    #[doc = "Level of reasoning effort.\n"]
    #[serde(rename = "reasoning_effort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reasoning_effort:
        Option<crate::__types::fine_tune_reinforcement_hyperparameters::ReasoningEffort>,
    #[doc = "Multiplier on amount of compute used for exploring search space during training.\n"]
    #[serde(rename = "compute_multiplier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub compute_multiplier:
        Option<crate::__types::fine_tune_reinforcement_hyperparameters::ComputeMultiplier>,
    #[doc = "The number of training steps between evaluation runs.\n"]
    #[serde(rename = "eval_interval")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub eval_interval:
        Option<crate::__types::fine_tune_reinforcement_hyperparameters::EvalInterval>,
    #[doc = "Number of evaluation samples to generate per training step.\n"]
    #[serde(rename = "eval_samples")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub eval_samples: Option<crate::__types::fine_tune_reinforcement_hyperparameters::EvalSamples>,
}
#[allow(clippy::module_inception)]
pub mod fine_tune_reinforcement_method {
    #[doc = "The grader used for the fine-tuning job."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Grader {
        StringCheck(crate::__types::GraderStringCheck),
        TextSimilarity(crate::__types::GraderTextSimilarity),
        Python(crate::__types::GraderPython),
        ScoreModel(crate::__types::GraderScoreModel),
        Multi(crate::__types::GraderMulti),
    }
}
#[doc = "Configuration for the reinforcement fine-tuning method."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneReinforcementMethod {
    #[doc = "The grader used for the fine-tuning job."]
    #[serde(rename = "grader")]
    pub grader: crate::__types::fine_tune_reinforcement_method::Grader,
    #[serde(rename = "hyperparameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hyperparameters: Option<crate::__types::FineTuneReinforcementHyperparameters>,
}
#[allow(clippy::module_inception)]
pub mod fine_tune_reinforcement_request_input {
    #[allow(clippy::module_inception)]
    pub mod messages {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            Developer(crate::__types::ChatCompletionRequestDeveloperMessage),
            User(crate::__types::ChatCompletionRequestUserMessage),
            Assistant(crate::__types::FineTuneChatCompletionRequestAssistantMessage),
            Tool(crate::__types::ChatCompletionRequestToolMessage),
        }
    }
}
#[doc = "Per-line training example for reinforcement fine-tuning. Note that `messages` and `tools` are the only reserved keywords.\nAny other arbitrary key-value data can be included on training datapoints and will be available to reference during grading under the `{{ item.XXX }}` template variable.\nInput messages may contain text or image content only. Audio and file input messages\nare not currently supported for fine-tuning.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneReinforcementRequestInput {
    #[serde(rename = "messages")]
    pub messages: Vec<crate::__types::fine_tune_reinforcement_request_input::messages::Item>,
    #[doc = "A list of tools the model may generate JSON inputs for."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::ChatCompletionTool>>,
}
#[allow(clippy::module_inception)]
pub mod fine_tune_supervised_hyperparameters {
    #[allow(clippy::module_inception)]
    pub(crate) mod batch_size {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum BatchSize {
        #[doc = "auto"]
        Auto,
        Integer(i64),
    }
    impl<'de> serde::Deserialize<'de> for BatchSize {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum BatchSize {
                Auto(crate::__types::fine_tune_supervised_hyperparameters::batch_size::Auto),
                Integer(i64),
            }
            Ok(match BatchSize::deserialize(deserializer)? {
                BatchSize::Auto(_) => Self::Auto,
                BatchSize::Integer(v) => Self::Integer(v),
            })
        }
    }
    impl serde::Serialize for BatchSize {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum BatchSize<'a> {
                Auto(crate::__types::fine_tune_supervised_hyperparameters::batch_size::Auto),
                Integer(&'a i64),
            }
            match self {
                Self::Auto => BatchSize::Auto(Default::default()),
                Self::Integer(v) => BatchSize::Integer(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod learning_rate_multiplier {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum LearningRateMultiplier {
        #[doc = "auto"]
        Auto,
        Number(serde_json::Number),
    }
    impl<'de> serde::Deserialize<'de> for LearningRateMultiplier {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum LearningRateMultiplier {
                Auto (crate :: __types :: fine_tune_supervised_hyperparameters :: learning_rate_multiplier :: Auto) , Number (serde_json :: Number) }
            Ok(match LearningRateMultiplier::deserialize(deserializer)? {
                LearningRateMultiplier::Auto(_) => Self::Auto,
                LearningRateMultiplier::Number(v) => Self::Number(v),
            })
        }
    }
    impl serde::Serialize for LearningRateMultiplier {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum LearningRateMultiplier<'a> {
                Auto (crate :: __types :: fine_tune_supervised_hyperparameters :: learning_rate_multiplier :: Auto) , Number (& 'a serde_json :: Number) }
            match self {
                Self::Auto => LearningRateMultiplier::Auto(Default::default()),
                Self::Number(v) => LearningRateMultiplier::Number(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod n_epochs {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
    }
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum NEpochs {
        #[doc = "auto"]
        Auto,
        Integer(i64),
    }
    impl<'de> serde::Deserialize<'de> for NEpochs {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum NEpochs {
                Auto(crate::__types::fine_tune_supervised_hyperparameters::n_epochs::Auto),
                Integer(i64),
            }
            Ok(match NEpochs::deserialize(deserializer)? {
                NEpochs::Auto(_) => Self::Auto,
                NEpochs::Integer(v) => Self::Integer(v),
            })
        }
    }
    impl serde::Serialize for NEpochs {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum NEpochs<'a> {
                Auto(crate::__types::fine_tune_supervised_hyperparameters::n_epochs::Auto),
                Integer(&'a i64),
            }
            match self {
                Self::Auto => NEpochs::Auto(Default::default()),
                Self::Integer(v) => NEpochs::Integer(v),
            }
            .serialize(serializer)
        }
    }
}
#[doc = "The hyperparameters used for the fine-tuning job."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneSupervisedHyperparameters {
    #[doc = "Number of examples in each batch. A larger batch size means that model parameters are updated less frequently, but with lower variance.\n"]
    #[serde(rename = "batch_size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub batch_size: Option<crate::__types::fine_tune_supervised_hyperparameters::BatchSize>,
    #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid overfitting.\n"]
    #[serde(rename = "learning_rate_multiplier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub learning_rate_multiplier:
        Option<crate::__types::fine_tune_supervised_hyperparameters::LearningRateMultiplier>,
    #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle through the training dataset.\n"]
    #[serde(rename = "n_epochs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub n_epochs: Option<crate::__types::fine_tune_supervised_hyperparameters::NEpochs>,
}
#[doc = "Configuration for the supervised fine-tuning method."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FineTuneSupervisedMethod {
    #[serde(rename = "hyperparameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub hyperparameters: Option<crate::__types::FineTuneSupervisedHyperparameters>,
}
#[allow(clippy::module_inception)]
pub(crate) mod fine_tuning_checkpoint_permission {
    #[doc = "The object type, which is always \"checkpoint.permission\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "checkpoint.permission");
}
#[doc = "The `checkpoint.permission` object represents a permission for a fine-tuned model checkpoint.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningCheckpointPermission {
    #[doc = "The permission identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the permission was created."]
    pub created_at: i64,
    #[doc = "The project identifier that the permission is for."]
    pub project_id: String,
}
impl<'de> serde::Deserialize<'de> for FineTuningCheckpointPermission {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningCheckpointPermission {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "project_id")]
            project_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::fine_tuning_checkpoint_permission::Object,
        }
        let FineTuningCheckpointPermission {
            id,
            created_at,
            project_id,
            ..
        } = FineTuningCheckpointPermission::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            project_id,
        })
    }
}
impl serde::Serialize for FineTuningCheckpointPermission {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningCheckpointPermission<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "project_id")]
            project_id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::fine_tuning_checkpoint_permission::Object,
        }
        let Self {
            id,
            created_at,
            project_id,
        } = self;
        FineTuningCheckpointPermission {
            id,
            created_at,
            project_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod fine_tuning_integration {
    #[doc = "The type of the integration being enabled for the fine-tuning job"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "wandb");
    #[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Wandb {
        #[doc = "The name of the project that the new run will be created under.\n"]
        #[serde(rename = "project")]
        pub project: String,
        #[doc = "A display name to set for the run. If not set, we will use the Job ID as the name.\n"]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
        #[doc = "The entity to use for the run. This allows you to set the team or username of the WandB user that you would\nlike associated with the run. If not set, the default entity for the registered WandB API key is used.\n"]
        #[serde(rename = "entity")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub entity: Option<String>,
        #[doc = "A list of tags to be attached to the newly created run. These tags are passed through directly to WandB. Some\ndefault tags are generated by OpenAI: \"openai/finetune\", \"openai/{base-model}\", \"openai/{ftjob-abcdef}\".\n"]
        #[serde(rename = "tags")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub tags: Option<Vec<String>>,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningIntegration {
    #[doc = "The settings for your integration with Weights and Biases. This payload specifies the project that\nmetrics will be sent to. Optionally, you can set an explicit display name for your run, add tags\nto your run, and set a default entity (team, username, etc) to be associated with your run.\n"]
    pub wandb: crate::__types::fine_tuning_integration::Wandb,
}
impl<'de> serde::Deserialize<'de> for FineTuningIntegration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningIntegration {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::fine_tuning_integration::Type,
            #[serde(rename = "wandb")]
            wandb: crate::__types::fine_tuning_integration::Wandb,
        }
        let FineTuningIntegration { wandb, .. } = FineTuningIntegration::deserialize(deserializer)?;
        Ok(Self { wandb })
    }
}
impl serde::Serialize for FineTuningIntegration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningIntegration<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::fine_tuning_integration::Type,
            #[serde(rename = "wandb")]
            wandb: &'a crate::__types::fine_tuning_integration::Wandb,
        }
        let Self { wandb } = self;
        FineTuningIntegration {
            r#type: &Default::default(),
            wandb,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod fine_tuning_job {
    #[doc = "For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Error {
        #[doc = "A machine-readable error code."]
        #[serde(rename = "code")]
        pub code: String,
        #[doc = "A human-readable error message."]
        #[serde(rename = "message")]
        pub message: String,
        #[doc = "The parameter that was invalid, usually `training_file` or `validation_file`. This field will be null if the failure was not parameter-specific."]
        #[serde(rename = "param")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub param: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod hyperparameters {
        #[allow(clippy::module_inception)]
        pub(crate) mod batch_size {
            #[doc = "auto"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Auto;
            impl_serde!(Auto, "auto");
        }
        #[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[allow(clippy::large_enum_variant)]
        pub enum BatchSize {
            #[doc = "auto"]
            Auto,
            Integer(i64),
        }
        impl<'de> serde::Deserialize<'de> for BatchSize {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
                enum BatchSize {
                    Auto(crate::__types::fine_tuning_job::hyperparameters::batch_size::Auto),
                    Integer(i64),
                }
                Ok(match BatchSize::deserialize(deserializer)? {
                    BatchSize::Auto(_) => Self::Auto,
                    BatchSize::Integer(v) => Self::Integer(v),
                })
            }
        }
        impl serde::Serialize for BatchSize {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names)]
                enum BatchSize<'a> {
                    Auto(crate::__types::fine_tuning_job::hyperparameters::batch_size::Auto),
                    Integer(&'a i64),
                }
                match self {
                    Self::Auto => BatchSize::Auto(Default::default()),
                    Self::Integer(v) => BatchSize::Integer(v),
                }
                .serialize(serializer)
            }
        }
        #[allow(clippy::module_inception)]
        pub(crate) mod learning_rate_multiplier {
            #[doc = "auto"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Auto;
            impl_serde!(Auto, "auto");
        }
        #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
        #[derive(Clone, Debug, PartialEq)]
        #[allow(clippy::large_enum_variant)]
        pub enum LearningRateMultiplier {
            #[doc = "auto"]
            Auto,
            Number(serde_json::Number),
        }
        impl<'de> serde::Deserialize<'de> for LearningRateMultiplier {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
                enum LearningRateMultiplier {
                    Auto (crate :: __types :: fine_tuning_job :: hyperparameters :: learning_rate_multiplier :: Auto) , Number (serde_json :: Number) }
                Ok(match LearningRateMultiplier::deserialize(deserializer)? {
                    LearningRateMultiplier::Auto(_) => Self::Auto,
                    LearningRateMultiplier::Number(v) => Self::Number(v),
                })
            }
        }
        impl serde::Serialize for LearningRateMultiplier {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names)]
                enum LearningRateMultiplier<'a> {
                    Auto (crate :: __types :: fine_tuning_job :: hyperparameters :: learning_rate_multiplier :: Auto) , Number (& 'a serde_json :: Number) }
                match self {
                    Self::Auto => LearningRateMultiplier::Auto(Default::default()),
                    Self::Number(v) => LearningRateMultiplier::Number(v),
                }
                .serialize(serializer)
            }
        }
        #[allow(clippy::module_inception)]
        pub(crate) mod n_epochs {
            #[doc = "auto"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Auto;
            impl_serde!(Auto, "auto");
        }
        #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[allow(clippy::large_enum_variant)]
        pub enum NEpochs {
            #[doc = "auto"]
            Auto,
            Integer(i64),
        }
        impl<'de> serde::Deserialize<'de> for NEpochs {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
                enum NEpochs {
                    Auto(crate::__types::fine_tuning_job::hyperparameters::n_epochs::Auto),
                    Integer(i64),
                }
                Ok(match NEpochs::deserialize(deserializer)? {
                    NEpochs::Auto(_) => Self::Auto,
                    NEpochs::Integer(v) => Self::Integer(v),
                })
            }
        }
        impl serde::Serialize for NEpochs {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::enum_variant_names)]
                enum NEpochs<'a> {
                    Auto(crate::__types::fine_tuning_job::hyperparameters::n_epochs::Auto),
                    Integer(&'a i64),
                }
                match self {
                    Self::Auto => NEpochs::Auto(Default::default()),
                    Self::Integer(v) => NEpochs::Integer(v),
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Hyperparameters {
        #[doc = "Number of examples in each batch. A larger batch size means that model parameters\nare updated less frequently, but with lower variance.\n"]
        #[serde(rename = "batch_size")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub batch_size: Option<crate::__types::fine_tuning_job::hyperparameters::BatchSize>,
        #[doc = "Scaling factor for the learning rate. A smaller learning rate may be useful to avoid\noverfitting.\n"]
        #[serde(rename = "learning_rate_multiplier")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub learning_rate_multiplier:
            Option<crate::__types::fine_tuning_job::hyperparameters::LearningRateMultiplier>,
        #[doc = "The number of epochs to train the model for. An epoch refers to one full cycle\nthrough the training dataset.\n"]
        #[serde(rename = "n_epochs")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub n_epochs: Option<crate::__types::fine_tuning_job::hyperparameters::NEpochs>,
    }
    #[doc = "The object type, which is always \"fine_tuning.job\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "fine_tuning.job");
    #[doc = "The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`validating_files`"]
        #[serde(rename = "validating_files")]
        ValidatingFiles,
        #[doc = "`queued`"]
        #[serde(rename = "queued")]
        Queued,
        #[doc = "`running`"]
        #[serde(rename = "running")]
        Running,
        #[doc = "`succeeded`"]
        #[serde(rename = "succeeded")]
        Succeeded,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
        #[doc = "`cancelled`"]
        #[serde(rename = "cancelled")]
        Cancelled,
    }
    #[allow(clippy::module_inception)]
    pub mod integrations {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            FineTuningIntegration(crate::__types::FineTuningIntegration),
        }
    }
}
#[doc = "The `fine_tuning.job` object represents a fine-tuning job that has been created through the API.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJob {
    #[doc = "The object identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was created."]
    pub created_at: i64,
    #[doc = "For fine-tuning jobs that have `failed`, this will contain more information on the cause of the failure."]
    #[builder(default)]
    pub error: Option<crate::__types::fine_tuning_job::Error>,
    #[doc = "The name of the fine-tuned model that is being created. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub fine_tuned_model: Option<String>,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was finished. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub finished_at: Option<i64>,
    #[doc = "The hyperparameters used for the fine-tuning job. This value will only be returned when running `supervised` jobs."]
    #[builder(default)]
    pub hyperparameters: crate::__types::fine_tuning_job::Hyperparameters,
    #[doc = "The base model that is being fine-tuned."]
    pub model: String,
    #[doc = "The organization that owns the fine-tuning job."]
    pub organization_id: String,
    #[doc = "The compiled results file ID(s) for the fine-tuning job. You can retrieve the results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    pub result_files: Vec<String>,
    #[doc = "The current status of the fine-tuning job, which can be either `validating_files`, `queued`, `running`, `succeeded`, `failed`, or `cancelled`."]
    pub status: crate::__types::fine_tuning_job::Status,
    #[doc = "The total number of billable tokens processed by this fine-tuning job. The value will be null if the fine-tuning job is still running."]
    #[builder(default)]
    pub trained_tokens: Option<i64>,
    #[doc = "The file ID used for training. You can retrieve the training data with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    pub training_file: String,
    #[doc = "The file ID used for validation. You can retrieve the validation results with the [Files API](https://platform.openai.com/docs/api-reference/files/retrieve-contents)."]
    #[builder(default)]
    pub validation_file: Option<String>,
    #[doc = "A list of integrations to enable for this fine-tuning job."]
    #[builder(default)]
    pub integrations: Option<Vec<crate::__types::fine_tuning_job::integrations::Item>>,
    #[doc = "The seed used for the fine-tuning job."]
    pub seed: i64,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job is estimated to finish. The value will be null if the fine-tuning job is not running."]
    #[builder(default)]
    pub estimated_finish: Option<i64>,
    #[builder(default)]
    pub method: Option<crate::__types::FineTuneMethod>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJob {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJob {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "error")]
            error: Option<crate::__types::fine_tuning_job::Error>,
            #[serde(rename = "fine_tuned_model")]
            fine_tuned_model: Option<String>,
            #[serde(rename = "finished_at")]
            finished_at: Option<i64>,
            #[serde(rename = "hyperparameters")]
            hyperparameters: crate::__types::fine_tuning_job::Hyperparameters,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::fine_tuning_job::Object,
            #[serde(rename = "organization_id")]
            organization_id: String,
            #[serde(rename = "result_files")]
            result_files: Vec<String>,
            #[serde(rename = "status")]
            status: crate::__types::fine_tuning_job::Status,
            #[serde(rename = "trained_tokens")]
            trained_tokens: Option<i64>,
            #[serde(rename = "training_file")]
            training_file: String,
            #[serde(rename = "validation_file")]
            validation_file: Option<String>,
            #[serde(rename = "integrations")]
            integrations: Option<Vec<crate::__types::fine_tuning_job::integrations::Item>>,
            #[serde(rename = "seed")]
            seed: i64,
            #[serde(rename = "estimated_finish")]
            estimated_finish: Option<i64>,
            #[serde(rename = "method")]
            method: Option<crate::__types::FineTuneMethod>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
        }
        let FineTuningJob {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
            ..
        } = FineTuningJob::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        })
    }
}
impl serde::Serialize for FineTuningJob {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJob<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<crate::__types::fine_tuning_job::Error>,
            #[serde(rename = "fine_tuned_model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            fine_tuned_model: &'a Option<String>,
            #[serde(rename = "finished_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            finished_at: &'a Option<i64>,
            #[serde(rename = "hyperparameters")]
            hyperparameters: &'a crate::__types::fine_tuning_job::Hyperparameters,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::fine_tuning_job::Object,
            #[serde(rename = "organization_id")]
            organization_id: &'a String,
            #[serde(rename = "result_files")]
            result_files: &'a Vec<String>,
            #[serde(rename = "status")]
            status: &'a crate::__types::fine_tuning_job::Status,
            #[serde(rename = "trained_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            trained_tokens: &'a Option<i64>,
            #[serde(rename = "training_file")]
            training_file: &'a String,
            #[serde(rename = "validation_file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            validation_file: &'a Option<String>,
            #[serde(rename = "integrations")]
            #[serde(skip_serializing_if = "Option::is_none")]
            integrations: &'a Option<Vec<crate::__types::fine_tuning_job::integrations::Item>>,
            #[serde(rename = "seed")]
            seed: &'a i64,
            #[serde(rename = "estimated_finish")]
            #[serde(skip_serializing_if = "Option::is_none")]
            estimated_finish: &'a Option<i64>,
            #[serde(rename = "method")]
            #[serde(skip_serializing_if = "Option::is_none")]
            method: &'a Option<crate::__types::FineTuneMethod>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
        }
        let Self {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        } = self;
        FineTuningJob {
            id,
            created_at,
            error,
            fine_tuned_model,
            finished_at,
            hyperparameters,
            model,
            object: &Default::default(),
            organization_id,
            result_files,
            status,
            trained_tokens,
            training_file,
            validation_file,
            integrations,
            seed,
            estimated_finish,
            method,
            metadata,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod fine_tuning_job_checkpoint {
    #[doc = "Metrics at the step number during the fine-tuning job."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Metrics {
        #[serde(rename = "step")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub step: Option<serde_json::Number>,
        #[serde(rename = "train_loss")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub train_loss: Option<serde_json::Number>,
        #[serde(rename = "train_mean_token_accuracy")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub train_mean_token_accuracy: Option<serde_json::Number>,
        #[serde(rename = "valid_loss")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub valid_loss: Option<serde_json::Number>,
        #[serde(rename = "valid_mean_token_accuracy")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub valid_mean_token_accuracy: Option<serde_json::Number>,
        #[serde(rename = "full_valid_loss")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub full_valid_loss: Option<serde_json::Number>,
        #[serde(rename = "full_valid_mean_token_accuracy")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub full_valid_mean_token_accuracy: Option<serde_json::Number>,
    }
    #[doc = "The object type, which is always \"fine_tuning.job.checkpoint\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "fine_tuning.job.checkpoint");
}
#[doc = "The `fine_tuning.job.checkpoint` object represents a model checkpoint for a fine-tuning job that is ready to use.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJobCheckpoint {
    #[doc = "The checkpoint identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the checkpoint was created."]
    pub created_at: i64,
    #[doc = "The name of the fine-tuned checkpoint model that is created."]
    pub fine_tuned_model_checkpoint: String,
    #[doc = "The step number that the checkpoint was created at."]
    pub step_number: i64,
    #[doc = "Metrics at the step number during the fine-tuning job."]
    #[builder(default)]
    pub metrics: crate::__types::fine_tuning_job_checkpoint::Metrics,
    #[doc = "The name of the fine-tuning job that this checkpoint was created from."]
    pub fine_tuning_job_id: String,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobCheckpoint {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJobCheckpoint {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            fine_tuned_model_checkpoint: String,
            #[serde(rename = "step_number")]
            step_number: i64,
            #[serde(rename = "metrics")]
            metrics: crate::__types::fine_tuning_job_checkpoint::Metrics,
            #[serde(rename = "fine_tuning_job_id")]
            fine_tuning_job_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::fine_tuning_job_checkpoint::Object,
        }
        let FineTuningJobCheckpoint {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
            ..
        } = FineTuningJobCheckpoint::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
        })
    }
}
impl serde::Serialize for FineTuningJobCheckpoint {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJobCheckpoint<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "fine_tuned_model_checkpoint")]
            fine_tuned_model_checkpoint: &'a String,
            #[serde(rename = "step_number")]
            step_number: &'a i64,
            #[serde(rename = "metrics")]
            metrics: &'a crate::__types::fine_tuning_job_checkpoint::Metrics,
            #[serde(rename = "fine_tuning_job_id")]
            fine_tuning_job_id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::fine_tuning_job_checkpoint::Object,
        }
        let Self {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
        } = self;
        FineTuningJobCheckpoint {
            id,
            created_at,
            fine_tuned_model_checkpoint,
            step_number,
            metrics,
            fine_tuning_job_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod fine_tuning_job_event {
    #[doc = "The object type, which is always \"fine_tuning.job.event\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "fine_tuning.job.event");
    #[doc = "The log level of the event."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Level {
        #[doc = "`info`"]
        #[serde(rename = "info")]
        Info,
        #[doc = "`warn`"]
        #[serde(rename = "warn")]
        Warn,
        #[doc = "`error`"]
        #[serde(rename = "error")]
        Error,
    }
    #[doc = "The type of event."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`message`"]
        #[serde(rename = "message")]
        Message,
        #[doc = "`metrics`"]
        #[serde(rename = "metrics")]
        Metrics,
    }
}
#[doc = "Fine-tuning job event object"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FineTuningJobEvent {
    #[doc = "The object identifier."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the fine-tuning job was created."]
    pub created_at: i64,
    #[doc = "The log level of the event."]
    pub level: crate::__types::fine_tuning_job_event::Level,
    #[doc = "The message of the event."]
    pub message: String,
    #[doc = "The type of event."]
    #[builder(default)]
    pub r#type: Option<crate::__types::fine_tuning_job_event::Type>,
    #[doc = "The data associated with the event."]
    #[builder(default)]
    pub data: Option<indexmap::IndexMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for FineTuningJobEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FineTuningJobEvent {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::fine_tuning_job_event::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "level")]
            level: crate::__types::fine_tuning_job_event::Level,
            #[serde(rename = "message")]
            message: String,
            #[serde(rename = "type")]
            r#type: Option<crate::__types::fine_tuning_job_event::Type>,
            #[serde(rename = "data")]
            data: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
        let FineTuningJobEvent {
            id,
            created_at,
            level,
            message,
            r#type,
            data,
            ..
        } = FineTuningJobEvent::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            level,
            message,
            r#type,
            data,
        })
    }
}
impl serde::Serialize for FineTuningJobEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FineTuningJobEvent<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::fine_tuning_job_event::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "level")]
            level: &'a crate::__types::fine_tuning_job_event::Level,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            r#type: &'a Option<crate::__types::fine_tuning_job_event::Type>,
            #[serde(rename = "data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            data: &'a Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
        let Self {
            id,
            created_at,
            level,
            message,
            r#type,
            data,
        } = self;
        FineTuningJobEvent {
            object: &Default::default(),
            id,
            created_at,
            level,
            message,
            r#type,
            data,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct FunctionObject {
    #[doc = "A description of what the function does, used by the model to choose when and how to call the function."]
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64."]
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "parameters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parameters: Option<crate::__types::FunctionParameters>,
    #[doc = "Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Learn more about Structured Outputs in the [function calling guide](https://platform.openai.com/docs/guides/function-calling)."]
    #[serde(rename = "strict")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub strict: Option<bool>,
}
#[doc = "The parameters the functions accepts, described as a JSON Schema object. See the [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format. \n\nOmitting `parameters` defines a function with an empty parameter list."]
pub type FunctionParameters = indexmap::IndexMap<String, serde_json::Value>;
#[allow(clippy::module_inception)]
pub mod function_tool_call {
    #[doc = "The type of the function tool call. Always `function_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function_call");
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "A tool call to run a function. See the \n[function calling guide](https://platform.openai.com/docs/guides/function-calling) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCall {
    #[doc = "The unique ID of the function tool call.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model.\n"]
    pub call_id: String,
    #[doc = "The name of the function to run.\n"]
    pub name: String,
    #[doc = "A JSON string of the arguments to pass to the function.\n"]
    pub arguments: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::function_tool_call::Status>,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionToolCall {
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::function_tool_call::Type,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "arguments")]
            arguments: String,
            #[serde(rename = "status")]
            status: Option<crate::__types::function_tool_call::Status>,
        }
        let FunctionToolCall {
            id,
            call_id,
            name,
            arguments,
            status,
            ..
        } = FunctionToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            name,
            arguments,
            status,
        })
    }
}
impl serde::Serialize for FunctionToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionToolCall<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::function_tool_call::Type,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::function_tool_call::Status>,
        }
        let Self {
            id,
            call_id,
            name,
            arguments,
            status,
        } = self;
        FunctionToolCall {
            id,
            r#type: &Default::default(),
            call_id,
            name,
            arguments,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod function_tool_call_output {
    #[doc = "The type of the function tool call output. Always `function_call_output`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function_call_output");
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "The output of a function tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallOutput {
    #[doc = "The unique ID of the function tool call output. Populated when this item\nis returned via API.\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model.\n"]
    pub call_id: String,
    #[doc = "A JSON string of the output of the function tool call.\n"]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::function_tool_call_output::Status>,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionToolCallOutput {
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::function_tool_call_output::Type,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "output")]
            output: String,
            #[serde(rename = "status")]
            status: Option<crate::__types::function_tool_call_output::Status>,
        }
        let FunctionToolCallOutput {
            id,
            call_id,
            output,
            status,
            ..
        } = FunctionToolCallOutput::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            output,
            status,
        })
    }
}
impl serde::Serialize for FunctionToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionToolCallOutput<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::function_tool_call_output::Type,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::function_tool_call_output::Status>,
        }
        let Self {
            id,
            call_id,
            output,
            status,
        } = self;
        FunctionToolCallOutput {
            id,
            r#type: &Default::default(),
            call_id,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod function_tool_call_output_resource {
    #[doc = "The type of the function tool call output. Always `function_call_output`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function_call_output");
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallOutputResource {
    #[doc = "The unique ID of the function tool call output. Populated when this item\nis returned via API.\n"]
    pub id: String,
    #[doc = "The unique ID of the function tool call generated by the model.\n"]
    pub call_id: String,
    #[doc = "A JSON string of the output of the function tool call.\n"]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::function_tool_call_output_resource::Status>,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallOutputResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionToolCallOutputResource {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::function_tool_call_output_resource::Type,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "output")]
            output: String,
            #[serde(rename = "status")]
            status: Option<crate::__types::function_tool_call_output_resource::Status>,
        }
        let FunctionToolCallOutputResource {
            id,
            call_id,
            output,
            status,
            ..
        } = FunctionToolCallOutputResource::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            output,
            status,
        })
    }
}
impl serde::Serialize for FunctionToolCallOutputResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionToolCallOutputResource<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::function_tool_call_output_resource::Type,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::function_tool_call_output_resource::Status>,
        }
        let Self {
            id,
            call_id,
            output,
            status,
        } = self;
        FunctionToolCallOutputResource {
            id,
            r#type: &Default::default(),
            call_id,
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod function_tool_call_resource {
    #[doc = "The type of the function tool call. Always `function_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function_call");
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionToolCallResource {
    #[doc = "The unique ID of the function tool call.\n"]
    pub id: String,
    #[doc = "The unique ID of the function tool call generated by the model.\n"]
    pub call_id: String,
    #[doc = "The name of the function to run.\n"]
    pub name: String,
    #[doc = "A JSON string of the arguments to pass to the function.\n"]
    pub arguments: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::function_tool_call_resource::Status>,
}
impl<'de> serde::Deserialize<'de> for FunctionToolCallResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionToolCallResource {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::function_tool_call_resource::Type,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "arguments")]
            arguments: String,
            #[serde(rename = "status")]
            status: Option<crate::__types::function_tool_call_resource::Status>,
        }
        let FunctionToolCallResource {
            id,
            call_id,
            name,
            arguments,
            status,
            ..
        } = FunctionToolCallResource::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            name,
            arguments,
            status,
        })
    }
}
impl serde::Serialize for FunctionToolCallResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionToolCallResource<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::function_tool_call_resource::Type,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::function_tool_call_resource::Status>,
        }
        let Self {
            id,
            call_id,
            name,
            arguments,
            status,
        } = self;
        FunctionToolCallResource {
            id,
            r#type: &Default::default(),
            call_id,
            name,
            arguments,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod grader_label_model {
    #[doc = "The object type, which is always `label_model`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "label_model");
}
#[doc = "A LabelModelGrader object which uses a model to assign labels to each item\nin the evaluation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderLabelModel {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation. Must support structured outputs."]
    pub model: String,
    pub input: Vec<crate::__types::EvalItem>,
    #[doc = "The labels to assign to each item in the evaluation."]
    pub labels: Vec<String>,
    #[doc = "The labels that indicate a passing result. Must be a subset of labels."]
    pub passing_labels: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for GraderLabelModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderLabelModel {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::grader_label_model::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "input")]
            input: Vec<crate::__types::EvalItem>,
            #[serde(rename = "labels")]
            labels: Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: Vec<String>,
        }
        let GraderLabelModel {
            name,
            model,
            input,
            labels,
            passing_labels,
            ..
        } = GraderLabelModel::deserialize(deserializer)?;
        Ok(Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        })
    }
}
impl serde::Serialize for GraderLabelModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderLabelModel<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::grader_label_model::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "input")]
            input: &'a Vec<crate::__types::EvalItem>,
            #[serde(rename = "labels")]
            labels: &'a Vec<String>,
            #[serde(rename = "passing_labels")]
            passing_labels: &'a Vec<String>,
        }
        let Self {
            name,
            model,
            input,
            labels,
            passing_labels,
        } = self;
        GraderLabelModel {
            r#type: &Default::default(),
            name,
            model,
            input,
            labels,
            passing_labels,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod grader_multi {
    #[doc = "The object type, which is always `multi`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "multi");
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Graders {
        StringCheck(crate::__types::GraderStringCheck),
        TextSimilarity(crate::__types::GraderTextSimilarity),
        Python(crate::__types::GraderPython),
        ScoreModel(crate::__types::GraderScoreModel),
        LabelModel(crate::__types::GraderLabelModel),
    }
}
#[doc = "A MultiGrader object combines the output of multiple graders to produce a single score."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderMulti {
    #[doc = "The name of the grader."]
    pub name: String,
    pub graders: crate::__types::grader_multi::Graders,
    #[doc = "A formula to calculate the output based on grader results."]
    pub calculate_output: String,
}
impl<'de> serde::Deserialize<'de> for GraderMulti {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderMulti {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::grader_multi::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "graders")]
            graders: crate::__types::grader_multi::Graders,
            #[serde(rename = "calculate_output")]
            calculate_output: String,
        }
        let GraderMulti {
            name,
            graders,
            calculate_output,
            ..
        } = GraderMulti::deserialize(deserializer)?;
        Ok(Self {
            name,
            graders,
            calculate_output,
        })
    }
}
impl serde::Serialize for GraderMulti {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderMulti<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::grader_multi::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "graders")]
            graders: &'a crate::__types::grader_multi::Graders,
            #[serde(rename = "calculate_output")]
            calculate_output: &'a String,
        }
        let Self {
            name,
            graders,
            calculate_output,
        } = self;
        GraderMulti {
            r#type: &Default::default(),
            name,
            graders,
            calculate_output,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod grader_python {
    #[doc = "The object type, which is always `python`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "python");
}
#[doc = "A PythonGrader object that runs a python script on the input.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderPython {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The source code of the python script."]
    pub source: String,
    #[doc = "The image tag to use for the python script."]
    #[builder(default)]
    pub image_tag: Option<String>,
}
impl<'de> serde::Deserialize<'de> for GraderPython {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderPython {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::grader_python::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "source")]
            source: String,
            #[serde(rename = "image_tag")]
            image_tag: Option<String>,
        }
        let GraderPython {
            name,
            source,
            image_tag,
            ..
        } = GraderPython::deserialize(deserializer)?;
        Ok(Self {
            name,
            source,
            image_tag,
        })
    }
}
impl serde::Serialize for GraderPython {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderPython<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::grader_python::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "source")]
            source: &'a String,
            #[serde(rename = "image_tag")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_tag: &'a Option<String>,
        }
        let Self {
            name,
            source,
            image_tag,
        } = self;
        GraderPython {
            r#type: &Default::default(),
            name,
            source,
            image_tag,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod grader_score_model {
    #[doc = "The object type, which is always `score_model`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "score_model");
}
#[doc = "A ScoreModelGrader object that uses a model to assign a score to the input.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderScoreModel {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The model to use for the evaluation."]
    pub model: String,
    #[doc = "The sampling parameters for the model."]
    #[builder(default)]
    pub sampling_params: Option<indexmap::IndexMap<String, serde_json::Value>>,
    #[doc = "The input text. This may include template strings."]
    pub input: Vec<crate::__types::EvalItem>,
    #[doc = "The range of the score. Defaults to `[0, 1]`."]
    #[builder(default)]
    pub range: Option<Vec<serde_json::Number>>,
}
impl<'de> serde::Deserialize<'de> for GraderScoreModel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderScoreModel {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::grader_score_model::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "sampling_params")]
            sampling_params: Option<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "input")]
            input: Vec<crate::__types::EvalItem>,
            #[serde(rename = "range")]
            range: Option<Vec<serde_json::Number>>,
        }
        let GraderScoreModel {
            name,
            model,
            sampling_params,
            input,
            range,
            ..
        } = GraderScoreModel::deserialize(deserializer)?;
        Ok(Self {
            name,
            model,
            sampling_params,
            input,
            range,
        })
    }
}
impl serde::Serialize for GraderScoreModel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderScoreModel<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::grader_score_model::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "sampling_params")]
            #[serde(skip_serializing_if = "Option::is_none")]
            sampling_params: &'a Option<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "input")]
            input: &'a Vec<crate::__types::EvalItem>,
            #[serde(rename = "range")]
            #[serde(skip_serializing_if = "Option::is_none")]
            range: &'a Option<Vec<serde_json::Number>>,
        }
        let Self {
            name,
            model,
            sampling_params,
            input,
            range,
        } = self;
        GraderScoreModel {
            r#type: &Default::default(),
            name,
            model,
            sampling_params,
            input,
            range,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod grader_string_check {
    #[doc = "The object type, which is always `string_check`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "string_check");
    #[doc = "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Operation {
        #[doc = "`eq`"]
        #[serde(rename = "eq")]
        Eq,
        #[doc = "`ne`"]
        #[serde(rename = "ne")]
        Ne,
        #[doc = "`like`"]
        #[serde(rename = "like")]
        Like,
        #[doc = "`ilike`"]
        #[serde(rename = "ilike")]
        Ilike,
    }
}
#[doc = "A StringCheckGrader object that performs a string comparison between input and reference using a specified operation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderStringCheck {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The input text. This may include template strings."]
    pub input: String,
    #[doc = "The reference text. This may include template strings."]
    pub reference: String,
    #[doc = "The string check operation to perform. One of `eq`, `ne`, `like`, or `ilike`."]
    pub operation: crate::__types::grader_string_check::Operation,
}
impl<'de> serde::Deserialize<'de> for GraderStringCheck {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderStringCheck {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::grader_string_check::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "input")]
            input: String,
            #[serde(rename = "reference")]
            reference: String,
            #[serde(rename = "operation")]
            operation: crate::__types::grader_string_check::Operation,
        }
        let GraderStringCheck {
            name,
            input,
            reference,
            operation,
            ..
        } = GraderStringCheck::deserialize(deserializer)?;
        Ok(Self {
            name,
            input,
            reference,
            operation,
        })
    }
}
impl serde::Serialize for GraderStringCheck {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderStringCheck<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::grader_string_check::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "reference")]
            reference: &'a String,
            #[serde(rename = "operation")]
            operation: &'a crate::__types::grader_string_check::Operation,
        }
        let Self {
            name,
            input,
            reference,
            operation,
        } = self;
        GraderStringCheck {
            r#type: &Default::default(),
            name,
            input,
            reference,
            operation,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod grader_text_similarity {
    #[doc = "The type of grader."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "text_similarity");
    #[doc = "The evaluation metric to use. One of `fuzzy_match`, `bleu`, `gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, or `rouge_l`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum EvaluationMetric {
        #[doc = "`fuzzy_match`"]
        #[serde(rename = "fuzzy_match")]
        FuzzyMatch,
        #[doc = "`bleu`"]
        #[serde(rename = "bleu")]
        Bleu,
        #[doc = "`gleu`"]
        #[serde(rename = "gleu")]
        Gleu,
        #[doc = "`meteor`"]
        #[serde(rename = "meteor")]
        Meteor,
        #[doc = "`rouge_1`"]
        #[serde(rename = "rouge_1")]
        Rouge1,
        #[doc = "`rouge_2`"]
        #[serde(rename = "rouge_2")]
        Rouge2,
        #[doc = "`rouge_3`"]
        #[serde(rename = "rouge_3")]
        Rouge3,
        #[doc = "`rouge_4`"]
        #[serde(rename = "rouge_4")]
        Rouge4,
        #[doc = "`rouge_5`"]
        #[serde(rename = "rouge_5")]
        Rouge5,
        #[doc = "`rouge_l`"]
        #[serde(rename = "rouge_l")]
        RougeL,
    }
}
#[doc = "A TextSimilarityGrader object which grades text based on similarity metrics.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct GraderTextSimilarity {
    #[doc = "The name of the grader."]
    pub name: String,
    #[doc = "The text being graded."]
    pub input: String,
    #[doc = "The text being graded against."]
    pub reference: String,
    #[doc = "The evaluation metric to use. One of `fuzzy_match`, `bleu`, `gleu`, `meteor`, `rouge_1`, `rouge_2`, `rouge_3`, `rouge_4`, `rouge_5`, or `rouge_l`."]
    pub evaluation_metric: crate::__types::grader_text_similarity::EvaluationMetric,
}
impl<'de> serde::Deserialize<'de> for GraderTextSimilarity {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct GraderTextSimilarity {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::grader_text_similarity::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "input")]
            input: String,
            #[serde(rename = "reference")]
            reference: String,
            #[serde(rename = "evaluation_metric")]
            evaluation_metric: crate::__types::grader_text_similarity::EvaluationMetric,
        }
        let GraderTextSimilarity {
            name,
            input,
            reference,
            evaluation_metric,
            ..
        } = GraderTextSimilarity::deserialize(deserializer)?;
        Ok(Self {
            name,
            input,
            reference,
            evaluation_metric,
        })
    }
}
impl serde::Serialize for GraderTextSimilarity {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct GraderTextSimilarity<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::grader_text_similarity::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
            #[serde(rename = "reference")]
            reference: &'a String,
            #[serde(rename = "evaluation_metric")]
            evaluation_metric: &'a crate::__types::grader_text_similarity::EvaluationMetric,
        }
        let Self {
            name,
            input,
            reference,
            evaluation_metric,
        } = self;
        GraderTextSimilarity {
            r#type: &Default::default(),
            name,
            input,
            reference,
            evaluation_metric,
        }
        .serialize(serializer)
    }
}
#[doc = "Represents the content or the URL of an image generated by the OpenAI API."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct Image {
    #[doc = "The base64-encoded JSON of the generated image. Default value for `gpt-image-1`, and only present if `response_format` is set to `b64_json` for `dall-e-2` and `dall-e-3`."]
    #[serde(rename = "b64_json")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub b64_json: Option<String>,
    #[doc = "When using `dall-e-2` or `dall-e-3`, the URL of the generated image if `response_format` is set to `url` (default value). Unsupported for `gpt-image-1`."]
    #[serde(rename = "url")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub url: Option<String>,
    #[doc = "For `dall-e-3` only, the revised prompt that was used to generate the image."]
    #[serde(rename = "revised_prompt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub revised_prompt: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod image_edit_completed_event {
    #[doc = "The type of the event. Always `image_edit.completed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_edit.completed");
    #[doc = "The size of the edited image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`1024x1024`"]
        #[serde(rename = "1024x1024")]
        _1024x1024,
        #[doc = "`1024x1536`"]
        #[serde(rename = "1024x1536")]
        _1024x1536,
        #[doc = "`1536x1024`"]
        #[serde(rename = "1536x1024")]
        _1536x1024,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The quality setting for the edited image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Quality {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The background setting for the edited image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Background {
        #[doc = "`transparent`"]
        #[serde(rename = "transparent")]
        Transparent,
        #[doc = "`opaque`"]
        #[serde(rename = "opaque")]
        Opaque,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The output format for the edited image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputFormat {
        #[doc = "`png`"]
        #[serde(rename = "png")]
        Png,
        #[doc = "`webp`"]
        #[serde(rename = "webp")]
        Webp,
        #[doc = "`jpeg`"]
        #[serde(rename = "jpeg")]
        Jpeg,
    }
}
#[doc = "Emitted when image editing has completed and the final image is available.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImageEditCompletedEvent {
    #[doc = "Base64-encoded final edited image data, suitable for rendering as an image.\n"]
    pub b64_json: String,
    #[doc = "The Unix timestamp when the event was created.\n"]
    pub created_at: i64,
    #[doc = "The size of the edited image.\n"]
    pub size: crate::__types::image_edit_completed_event::Size,
    #[doc = "The quality setting for the edited image.\n"]
    pub quality: crate::__types::image_edit_completed_event::Quality,
    #[doc = "The background setting for the edited image.\n"]
    pub background: crate::__types::image_edit_completed_event::Background,
    #[doc = "The output format for the edited image.\n"]
    pub output_format: crate::__types::image_edit_completed_event::OutputFormat,
    pub usage: crate::__types::ImagesUsage,
}
impl<'de> serde::Deserialize<'de> for ImageEditCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageEditCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::image_edit_completed_event::Type,
            #[serde(rename = "b64_json")]
            b64_json: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "size")]
            size: crate::__types::image_edit_completed_event::Size,
            #[serde(rename = "quality")]
            quality: crate::__types::image_edit_completed_event::Quality,
            #[serde(rename = "background")]
            background: crate::__types::image_edit_completed_event::Background,
            #[serde(rename = "output_format")]
            output_format: crate::__types::image_edit_completed_event::OutputFormat,
            #[serde(rename = "usage")]
            usage: crate::__types::ImagesUsage,
        }
        let ImageEditCompletedEvent {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            usage,
            ..
        } = ImageEditCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            usage,
        })
    }
}
impl serde::Serialize for ImageEditCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageEditCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::image_edit_completed_event::Type,
            #[serde(rename = "b64_json")]
            b64_json: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "size")]
            size: &'a crate::__types::image_edit_completed_event::Size,
            #[serde(rename = "quality")]
            quality: &'a crate::__types::image_edit_completed_event::Quality,
            #[serde(rename = "background")]
            background: &'a crate::__types::image_edit_completed_event::Background,
            #[serde(rename = "output_format")]
            output_format: &'a crate::__types::image_edit_completed_event::OutputFormat,
            #[serde(rename = "usage")]
            usage: &'a crate::__types::ImagesUsage,
        }
        let Self {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            usage,
        } = self;
        ImageEditCompletedEvent {
            r#type: &Default::default(),
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod image_edit_partial_image_event {
    #[doc = "The type of the event. Always `image_edit.partial_image`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_edit.partial_image");
    #[doc = "The size of the requested edited image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`1024x1024`"]
        #[serde(rename = "1024x1024")]
        _1024x1024,
        #[doc = "`1024x1536`"]
        #[serde(rename = "1024x1536")]
        _1024x1536,
        #[doc = "`1536x1024`"]
        #[serde(rename = "1536x1024")]
        _1536x1024,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The quality setting for the requested edited image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Quality {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The background setting for the requested edited image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Background {
        #[doc = "`transparent`"]
        #[serde(rename = "transparent")]
        Transparent,
        #[doc = "`opaque`"]
        #[serde(rename = "opaque")]
        Opaque,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The output format for the requested edited image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputFormat {
        #[doc = "`png`"]
        #[serde(rename = "png")]
        Png,
        #[doc = "`webp`"]
        #[serde(rename = "webp")]
        Webp,
        #[doc = "`jpeg`"]
        #[serde(rename = "jpeg")]
        Jpeg,
    }
}
#[doc = "Emitted when a partial image is available during image editing streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImageEditPartialImageEvent {
    #[doc = "Base64-encoded partial image data, suitable for rendering as an image.\n"]
    pub b64_json: String,
    #[doc = "The Unix timestamp when the event was created.\n"]
    pub created_at: i64,
    #[doc = "The size of the requested edited image.\n"]
    pub size: crate::__types::image_edit_partial_image_event::Size,
    #[doc = "The quality setting for the requested edited image.\n"]
    pub quality: crate::__types::image_edit_partial_image_event::Quality,
    #[doc = "The background setting for the requested edited image.\n"]
    pub background: crate::__types::image_edit_partial_image_event::Background,
    #[doc = "The output format for the requested edited image.\n"]
    pub output_format: crate::__types::image_edit_partial_image_event::OutputFormat,
    #[doc = "0-based index for the partial image (streaming).\n"]
    pub partial_image_index: i64,
}
impl<'de> serde::Deserialize<'de> for ImageEditPartialImageEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageEditPartialImageEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::image_edit_partial_image_event::Type,
            #[serde(rename = "b64_json")]
            b64_json: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "size")]
            size: crate::__types::image_edit_partial_image_event::Size,
            #[serde(rename = "quality")]
            quality: crate::__types::image_edit_partial_image_event::Quality,
            #[serde(rename = "background")]
            background: crate::__types::image_edit_partial_image_event::Background,
            #[serde(rename = "output_format")]
            output_format: crate::__types::image_edit_partial_image_event::OutputFormat,
            #[serde(rename = "partial_image_index")]
            partial_image_index: i64,
        }
        let ImageEditPartialImageEvent {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            partial_image_index,
            ..
        } = ImageEditPartialImageEvent::deserialize(deserializer)?;
        Ok(Self {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            partial_image_index,
        })
    }
}
impl serde::Serialize for ImageEditPartialImageEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageEditPartialImageEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::image_edit_partial_image_event::Type,
            #[serde(rename = "b64_json")]
            b64_json: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "size")]
            size: &'a crate::__types::image_edit_partial_image_event::Size,
            #[serde(rename = "quality")]
            quality: &'a crate::__types::image_edit_partial_image_event::Quality,
            #[serde(rename = "background")]
            background: &'a crate::__types::image_edit_partial_image_event::Background,
            #[serde(rename = "output_format")]
            output_format: &'a crate::__types::image_edit_partial_image_event::OutputFormat,
            #[serde(rename = "partial_image_index")]
            partial_image_index: &'a i64,
        }
        let Self {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            partial_image_index,
        } = self;
        ImageEditPartialImageEvent {
            r#type: &Default::default(),
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            partial_image_index,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ImageEditStreamEvent {
    ImageEditPartialImage(crate::__types::ImageEditPartialImageEvent),
    ImageEditCompleted(crate::__types::ImageEditCompletedEvent),
}
#[allow(clippy::module_inception)]
pub mod image_gen_completed_event {
    #[doc = "The type of the event. Always `image_generation.completed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_generation.completed");
    #[doc = "The size of the generated image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`1024x1024`"]
        #[serde(rename = "1024x1024")]
        _1024x1024,
        #[doc = "`1024x1536`"]
        #[serde(rename = "1024x1536")]
        _1024x1536,
        #[doc = "`1536x1024`"]
        #[serde(rename = "1536x1024")]
        _1536x1024,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The quality setting for the generated image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Quality {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The background setting for the generated image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Background {
        #[doc = "`transparent`"]
        #[serde(rename = "transparent")]
        Transparent,
        #[doc = "`opaque`"]
        #[serde(rename = "opaque")]
        Opaque,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The output format for the generated image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputFormat {
        #[doc = "`png`"]
        #[serde(rename = "png")]
        Png,
        #[doc = "`webp`"]
        #[serde(rename = "webp")]
        Webp,
        #[doc = "`jpeg`"]
        #[serde(rename = "jpeg")]
        Jpeg,
    }
}
#[doc = "Emitted when image generation has completed and the final image is available.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImageGenCompletedEvent {
    #[doc = "Base64-encoded image data, suitable for rendering as an image.\n"]
    pub b64_json: String,
    #[doc = "The Unix timestamp when the event was created.\n"]
    pub created_at: i64,
    #[doc = "The size of the generated image.\n"]
    pub size: crate::__types::image_gen_completed_event::Size,
    #[doc = "The quality setting for the generated image.\n"]
    pub quality: crate::__types::image_gen_completed_event::Quality,
    #[doc = "The background setting for the generated image.\n"]
    pub background: crate::__types::image_gen_completed_event::Background,
    #[doc = "The output format for the generated image.\n"]
    pub output_format: crate::__types::image_gen_completed_event::OutputFormat,
    pub usage: crate::__types::ImagesUsage,
}
impl<'de> serde::Deserialize<'de> for ImageGenCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageGenCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::image_gen_completed_event::Type,
            #[serde(rename = "b64_json")]
            b64_json: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "size")]
            size: crate::__types::image_gen_completed_event::Size,
            #[serde(rename = "quality")]
            quality: crate::__types::image_gen_completed_event::Quality,
            #[serde(rename = "background")]
            background: crate::__types::image_gen_completed_event::Background,
            #[serde(rename = "output_format")]
            output_format: crate::__types::image_gen_completed_event::OutputFormat,
            #[serde(rename = "usage")]
            usage: crate::__types::ImagesUsage,
        }
        let ImageGenCompletedEvent {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            usage,
            ..
        } = ImageGenCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            usage,
        })
    }
}
impl serde::Serialize for ImageGenCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageGenCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::image_gen_completed_event::Type,
            #[serde(rename = "b64_json")]
            b64_json: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "size")]
            size: &'a crate::__types::image_gen_completed_event::Size,
            #[serde(rename = "quality")]
            quality: &'a crate::__types::image_gen_completed_event::Quality,
            #[serde(rename = "background")]
            background: &'a crate::__types::image_gen_completed_event::Background,
            #[serde(rename = "output_format")]
            output_format: &'a crate::__types::image_gen_completed_event::OutputFormat,
            #[serde(rename = "usage")]
            usage: &'a crate::__types::ImagesUsage,
        }
        let Self {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            usage,
        } = self;
        ImageGenCompletedEvent {
            r#type: &Default::default(),
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod image_gen_partial_image_event {
    #[doc = "The type of the event. Always `image_generation.partial_image`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_generation.partial_image");
    #[doc = "The size of the requested image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`1024x1024`"]
        #[serde(rename = "1024x1024")]
        _1024x1024,
        #[doc = "`1024x1536`"]
        #[serde(rename = "1024x1536")]
        _1024x1536,
        #[doc = "`1536x1024`"]
        #[serde(rename = "1536x1024")]
        _1536x1024,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The quality setting for the requested image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Quality {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The background setting for the requested image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Background {
        #[doc = "`transparent`"]
        #[serde(rename = "transparent")]
        Transparent,
        #[doc = "`opaque`"]
        #[serde(rename = "opaque")]
        Opaque,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The output format for the requested image.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputFormat {
        #[doc = "`png`"]
        #[serde(rename = "png")]
        Png,
        #[doc = "`webp`"]
        #[serde(rename = "webp")]
        Webp,
        #[doc = "`jpeg`"]
        #[serde(rename = "jpeg")]
        Jpeg,
    }
}
#[doc = "Emitted when a partial image is available during image generation streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImageGenPartialImageEvent {
    #[doc = "Base64-encoded partial image data, suitable for rendering as an image.\n"]
    pub b64_json: String,
    #[doc = "The Unix timestamp when the event was created.\n"]
    pub created_at: i64,
    #[doc = "The size of the requested image.\n"]
    pub size: crate::__types::image_gen_partial_image_event::Size,
    #[doc = "The quality setting for the requested image.\n"]
    pub quality: crate::__types::image_gen_partial_image_event::Quality,
    #[doc = "The background setting for the requested image.\n"]
    pub background: crate::__types::image_gen_partial_image_event::Background,
    #[doc = "The output format for the requested image.\n"]
    pub output_format: crate::__types::image_gen_partial_image_event::OutputFormat,
    #[doc = "0-based index for the partial image (streaming).\n"]
    pub partial_image_index: i64,
}
impl<'de> serde::Deserialize<'de> for ImageGenPartialImageEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageGenPartialImageEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::image_gen_partial_image_event::Type,
            #[serde(rename = "b64_json")]
            b64_json: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "size")]
            size: crate::__types::image_gen_partial_image_event::Size,
            #[serde(rename = "quality")]
            quality: crate::__types::image_gen_partial_image_event::Quality,
            #[serde(rename = "background")]
            background: crate::__types::image_gen_partial_image_event::Background,
            #[serde(rename = "output_format")]
            output_format: crate::__types::image_gen_partial_image_event::OutputFormat,
            #[serde(rename = "partial_image_index")]
            partial_image_index: i64,
        }
        let ImageGenPartialImageEvent {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            partial_image_index,
            ..
        } = ImageGenPartialImageEvent::deserialize(deserializer)?;
        Ok(Self {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            partial_image_index,
        })
    }
}
impl serde::Serialize for ImageGenPartialImageEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageGenPartialImageEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::image_gen_partial_image_event::Type,
            #[serde(rename = "b64_json")]
            b64_json: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "size")]
            size: &'a crate::__types::image_gen_partial_image_event::Size,
            #[serde(rename = "quality")]
            quality: &'a crate::__types::image_gen_partial_image_event::Quality,
            #[serde(rename = "background")]
            background: &'a crate::__types::image_gen_partial_image_event::Background,
            #[serde(rename = "output_format")]
            output_format: &'a crate::__types::image_gen_partial_image_event::OutputFormat,
            #[serde(rename = "partial_image_index")]
            partial_image_index: &'a i64,
        }
        let Self {
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            partial_image_index,
        } = self;
        ImageGenPartialImageEvent {
            r#type: &Default::default(),
            b64_json,
            created_at,
            size,
            quality,
            background,
            output_format,
            partial_image_index,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ImageGenStreamEvent {
    ImageGenerationPartialImage(crate::__types::ImageGenPartialImageEvent),
    ImageGenerationCompleted(crate::__types::ImageGenCompletedEvent),
}
#[allow(clippy::module_inception)]
pub mod image_gen_tool {
    #[doc = "The type of the image generation tool. Always `image_generation`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_generation");
    #[doc = "The image generation model to use. Default: `gpt-image-1`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Model {
        #[doc = "`gpt-image-1`"]
        #[default]
        #[serde(rename = "gpt-image-1")]
        GptImage1,
    }
    #[doc = "The quality of the generated image. One of `low`, `medium`, `high`, \nor `auto`. Default: `auto`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Quality {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The size of the generated image. One of `1024x1024`, `1024x1536`, \n`1536x1024`, or `auto`. Default: `auto`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`1024x1024`"]
        #[serde(rename = "1024x1024")]
        _1024x1024,
        #[doc = "`1024x1536`"]
        #[serde(rename = "1024x1536")]
        _1024x1536,
        #[doc = "`1536x1024`"]
        #[serde(rename = "1536x1024")]
        _1536x1024,
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "The output format of the generated image. One of `png`, `webp`, or \n`jpeg`. Default: `png`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputFormat {
        #[doc = "`png`"]
        #[default]
        #[serde(rename = "png")]
        Png,
        #[doc = "`webp`"]
        #[serde(rename = "webp")]
        Webp,
        #[doc = "`jpeg`"]
        #[serde(rename = "jpeg")]
        Jpeg,
    }
    #[doc = "Moderation level for the generated image. Default: `auto`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Moderation {
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
    }
    #[doc = "Background type for the generated image. One of `transparent`, \n`opaque`, or `auto`. Default: `auto`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Background {
        #[doc = "`transparent`"]
        #[serde(rename = "transparent")]
        Transparent,
        #[doc = "`opaque`"]
        #[serde(rename = "opaque")]
        Opaque,
        #[doc = "`auto`"]
        #[default]
        #[serde(rename = "auto")]
        Auto,
    }
    #[doc = "Optional mask for inpainting. Contains `image_url` \n(string, optional) and `file_id` (string, optional).\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputImageMask {
        #[doc = "Base64-encoded mask image.\n"]
        #[serde(rename = "image_url")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub image_url: Option<String>,
        #[doc = "File ID for the mask image.\n"]
        #[serde(rename = "file_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_id: Option<String>,
    }
}
#[doc = "A tool that generates images using a model like `gpt-image-1`.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImageGenTool {
    #[doc = "The image generation model to use. Default: `gpt-image-1`.\n"]
    #[builder(default)]
    pub model: Option<crate::__types::image_gen_tool::Model>,
    #[doc = "The quality of the generated image. One of `low`, `medium`, `high`, \nor `auto`. Default: `auto`.\n"]
    #[builder(default)]
    pub quality: Option<crate::__types::image_gen_tool::Quality>,
    #[doc = "The size of the generated image. One of `1024x1024`, `1024x1536`, \n`1536x1024`, or `auto`. Default: `auto`.\n"]
    #[builder(default)]
    pub size: Option<crate::__types::image_gen_tool::Size>,
    #[doc = "The output format of the generated image. One of `png`, `webp`, or \n`jpeg`. Default: `png`.\n"]
    #[builder(default)]
    pub output_format: Option<crate::__types::image_gen_tool::OutputFormat>,
    #[doc = "Compression level for the output image. Default: 100.\n"]
    #[builder(default)]
    pub output_compression: Option<i64>,
    #[doc = "Moderation level for the generated image. Default: `auto`.\n"]
    #[builder(default)]
    pub moderation: Option<crate::__types::image_gen_tool::Moderation>,
    #[doc = "Background type for the generated image. One of `transparent`, \n`opaque`, or `auto`. Default: `auto`.\n"]
    #[builder(default)]
    pub background: Option<crate::__types::image_gen_tool::Background>,
    #[builder(default)]
    pub input_fidelity: Option<crate::__types::ImageInputFidelity>,
    #[doc = "Optional mask for inpainting. Contains `image_url` \n(string, optional) and `file_id` (string, optional).\n"]
    #[builder(default)]
    pub input_image_mask: Option<crate::__types::image_gen_tool::InputImageMask>,
    #[doc = "Number of partial images to generate in streaming mode, from 0 (default value) to 3.\n"]
    #[builder(default)]
    pub partial_images: Option<i64>,
}
impl<'de> serde::Deserialize<'de> for ImageGenTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageGenTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::image_gen_tool::Type,
            #[serde(rename = "model")]
            model: Option<crate::__types::image_gen_tool::Model>,
            #[serde(rename = "quality")]
            quality: Option<crate::__types::image_gen_tool::Quality>,
            #[serde(rename = "size")]
            size: Option<crate::__types::image_gen_tool::Size>,
            #[serde(rename = "output_format")]
            output_format: Option<crate::__types::image_gen_tool::OutputFormat>,
            #[serde(rename = "output_compression")]
            output_compression: Option<i64>,
            #[serde(rename = "moderation")]
            moderation: Option<crate::__types::image_gen_tool::Moderation>,
            #[serde(rename = "background")]
            background: Option<crate::__types::image_gen_tool::Background>,
            #[serde(rename = "input_fidelity")]
            input_fidelity: Option<crate::__types::ImageInputFidelity>,
            #[serde(rename = "input_image_mask")]
            input_image_mask: Option<crate::__types::image_gen_tool::InputImageMask>,
            #[serde(rename = "partial_images")]
            partial_images: Option<i64>,
        }
        let ImageGenTool {
            model,
            quality,
            size,
            output_format,
            output_compression,
            moderation,
            background,
            input_fidelity,
            input_image_mask,
            partial_images,
            ..
        } = ImageGenTool::deserialize(deserializer)?;
        Ok(Self {
            model,
            quality,
            size,
            output_format,
            output_compression,
            moderation,
            background,
            input_fidelity,
            input_image_mask,
            partial_images,
        })
    }
}
impl serde::Serialize for ImageGenTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageGenTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::image_gen_tool::Type,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<crate::__types::image_gen_tool::Model>,
            #[serde(rename = "quality")]
            #[serde(skip_serializing_if = "Option::is_none")]
            quality: &'a Option<crate::__types::image_gen_tool::Quality>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<crate::__types::image_gen_tool::Size>,
            #[serde(rename = "output_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_format: &'a Option<crate::__types::image_gen_tool::OutputFormat>,
            #[serde(rename = "output_compression")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_compression: &'a Option<i64>,
            #[serde(rename = "moderation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            moderation: &'a Option<crate::__types::image_gen_tool::Moderation>,
            #[serde(rename = "background")]
            #[serde(skip_serializing_if = "Option::is_none")]
            background: &'a Option<crate::__types::image_gen_tool::Background>,
            #[serde(rename = "input_fidelity")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_fidelity: &'a Option<crate::__types::ImageInputFidelity>,
            #[serde(rename = "input_image_mask")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_image_mask: &'a Option<crate::__types::image_gen_tool::InputImageMask>,
            #[serde(rename = "partial_images")]
            #[serde(skip_serializing_if = "Option::is_none")]
            partial_images: &'a Option<i64>,
        }
        let Self {
            model,
            quality,
            size,
            output_format,
            output_compression,
            moderation,
            background,
            input_fidelity,
            input_image_mask,
            partial_images,
        } = self;
        ImageGenTool {
            r#type: &Default::default(),
            model,
            quality,
            size,
            output_format,
            output_compression,
            moderation,
            background,
            input_fidelity,
            input_image_mask,
            partial_images,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod image_gen_tool_call {
    #[doc = "The type of the image generation call. Always `image_generation_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_generation_call");
    #[doc = "The status of the image generation call.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`generating`"]
        #[serde(rename = "generating")]
        Generating,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
    }
}
#[doc = "An image generation request made by the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ImageGenToolCall {
    #[doc = "The unique ID of the image generation call.\n"]
    pub id: String,
    #[doc = "The status of the image generation call.\n"]
    pub status: crate::__types::image_gen_tool_call::Status,
    #[doc = "The generated image encoded in base64.\n"]
    #[builder(default)]
    pub result: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ImageGenToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ImageGenToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::image_gen_tool_call::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "status")]
            status: crate::__types::image_gen_tool_call::Status,
            #[serde(rename = "result")]
            result: Option<String>,
        }
        let ImageGenToolCall {
            id, status, result, ..
        } = ImageGenToolCall::deserialize(deserializer)?;
        Ok(Self { id, status, result })
    }
}
impl serde::Serialize for ImageGenToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ImageGenToolCall<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::image_gen_tool_call::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "status")]
            status: &'a crate::__types::image_gen_tool_call::Status,
            #[serde(rename = "result")]
            #[serde(skip_serializing_if = "Option::is_none")]
            result: &'a Option<String>,
        }
        let Self { id, status, result } = self;
        ImageGenToolCall {
            r#type: &Default::default(),
            id,
            status,
            result,
        }
        .serialize(serializer)
    }
}
#[doc = "Control how much effort the model will exert to match the style and features,\nespecially facial features, of input images. This parameter is only supported\nfor `gpt-image-1`. Supports `high` and `low`. Defaults to `low`.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum ImageInputFidelity {
    #[doc = "`high`"]
    #[serde(rename = "high")]
    High,
    #[doc = "`low`"]
    #[default]
    #[serde(rename = "low")]
    Low,
}
#[allow(clippy::module_inception)]
pub mod images_response {
    #[doc = "The background parameter used for the image generation. Either `transparent` or `opaque`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Background {
        #[doc = "`transparent`"]
        #[serde(rename = "transparent")]
        Transparent,
        #[doc = "`opaque`"]
        #[serde(rename = "opaque")]
        Opaque,
    }
    #[doc = "The output format of the image generation. Either `png`, `webp`, or `jpeg`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputFormat {
        #[doc = "`png`"]
        #[serde(rename = "png")]
        Png,
        #[doc = "`webp`"]
        #[serde(rename = "webp")]
        Webp,
        #[doc = "`jpeg`"]
        #[serde(rename = "jpeg")]
        Jpeg,
    }
    #[doc = "The size of the image generated. Either `1024x1024`, `1024x1536`, or `1536x1024`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Size {
        #[doc = "`1024x1024`"]
        #[serde(rename = "1024x1024")]
        _1024x1024,
        #[doc = "`1024x1536`"]
        #[serde(rename = "1024x1536")]
        _1024x1536,
        #[doc = "`1536x1024`"]
        #[serde(rename = "1536x1024")]
        _1536x1024,
    }
    #[doc = "The quality of the image generated. Either `low`, `medium`, or `high`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Quality {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
    }
}
#[doc = "The response from the image generation endpoint."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ImagesResponse {
    #[doc = "The Unix timestamp (in seconds) of when the image was created."]
    #[serde(rename = "created")]
    pub created: i64,
    #[doc = "The list of generated images."]
    #[serde(rename = "data")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub data: Option<Vec<crate::__types::Image>>,
    #[doc = "The background parameter used for the image generation. Either `transparent` or `opaque`."]
    #[serde(rename = "background")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub background: Option<crate::__types::images_response::Background>,
    #[doc = "The output format of the image generation. Either `png`, `webp`, or `jpeg`."]
    #[serde(rename = "output_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_format: Option<crate::__types::images_response::OutputFormat>,
    #[doc = "The size of the image generated. Either `1024x1024`, `1024x1536`, or `1536x1024`."]
    #[serde(rename = "size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub size: Option<crate::__types::images_response::Size>,
    #[doc = "The quality of the image generated. Either `low`, `medium`, or `high`."]
    #[serde(rename = "quality")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub quality: Option<crate::__types::images_response::Quality>,
    #[serde(rename = "usage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub usage: Option<crate::__types::ImageGenUsage>,
}
#[allow(clippy::module_inception)]
pub mod images_usage {
    #[doc = "The input tokens detailed information for the image generation."]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputTokensDetails {
        #[doc = "The number of text tokens in the input prompt."]
        #[serde(rename = "text_tokens")]
        pub text_tokens: i64,
        #[doc = "The number of image tokens in the input prompt."]
        #[serde(rename = "image_tokens")]
        pub image_tokens: i64,
    }
}
#[doc = "For `gpt-image-1` only, the token usage information for the image generation.\n"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ImagesUsage {
    #[doc = "The total number of tokens (images and text) used for the image generation.\n"]
    #[serde(rename = "total_tokens")]
    pub total_tokens: i64,
    #[doc = "The number of tokens (images and text) in the input prompt."]
    #[serde(rename = "input_tokens")]
    pub input_tokens: i64,
    #[doc = "The number of image tokens in the output image."]
    #[serde(rename = "output_tokens")]
    pub output_tokens: i64,
    #[doc = "The input tokens detailed information for the image generation."]
    #[serde(rename = "input_tokens_details")]
    pub input_tokens_details: crate::__types::images_usage::InputTokensDetails,
}
#[doc = "Specify additional output data to include in the model response. Currently\nsupported values are:\n- `code_interpreter_call.outputs`: Includes the outputs of python code execution\n  in code interpreter tool call items.\n- `computer_call_output.output.image_url`: Include image urls from the computer call output.\n- `file_search_call.results`: Include the search results of\n  the file search tool call.\n- `message.input_image.image_url`: Include image urls from the input message.\n- `message.output_text.logprobs`: Include logprobs with assistant messages.\n- `reasoning.encrypted_content`: Includes an encrypted version of reasoning\n  tokens in reasoning item outputs. This enables reasoning items to be used in\n  multi-turn conversations when using the Responses API statelessly (like\n  when the `store` parameter is set to `false`, or when an organization is\n  enrolled in the zero data retention program).\n"]
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum Includable {
    #[doc = "`code_interpreter_call.outputs`"]
    #[serde(rename = "code_interpreter_call.outputs")]
    CodeInterpreterCallOutputs,
    #[doc = "`computer_call_output.output.image_url`"]
    #[serde(rename = "computer_call_output.output.image_url")]
    ComputerCallOutputOutputImageUrl,
    #[doc = "`file_search_call.results`"]
    #[serde(rename = "file_search_call.results")]
    FileSearchCallResults,
    #[doc = "`message.input_image.image_url`"]
    #[serde(rename = "message.input_image.image_url")]
    MessageInputImageImageUrl,
    #[doc = "`message.output_text.logprobs`"]
    #[serde(rename = "message.output_text.logprobs")]
    MessageOutputTextLogprobs,
    #[doc = "`reasoning.encrypted_content`"]
    #[serde(rename = "reasoning.encrypted_content")]
    ReasoningEncryptedContent,
}
#[allow(clippy::module_inception)]
pub mod input_audio {
    #[doc = "The type of the input item. Always `input_audio`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio");
    #[doc = "The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Format {
        #[doc = "`mp3`"]
        #[serde(rename = "mp3")]
        Mp3,
        #[doc = "`wav`"]
        #[serde(rename = "wav")]
        Wav,
    }
}
#[doc = "An audio input to the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputAudio {
    #[doc = "Base64-encoded audio data.\n"]
    pub data: String,
    #[doc = "The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n"]
    pub format: crate::__types::input_audio::Format,
}
impl<'de> serde::Deserialize<'de> for InputAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputAudio {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::input_audio::Type,
            #[serde(rename = "data")]
            data: String,
            #[serde(rename = "format")]
            format: crate::__types::input_audio::Format,
        }
        let InputAudio { data, format, .. } = InputAudio::deserialize(deserializer)?;
        Ok(Self { data, format })
    }
}
impl serde::Serialize for InputAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputAudio<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::input_audio::Type,
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "format")]
            format: &'a crate::__types::input_audio::Format,
        }
        let Self { data, format } = self;
        InputAudio {
            r#type: &Default::default(),
            data,
            format,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum InputContent {
    InputText(crate::__types::InputTextContent),
    InputImage(crate::__types::InputImageContent),
    InputFile(crate::__types::InputFileContent),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum InputItem {
    EasyInputMessage(crate::__types::EasyInputMessage),
    #[doc = "An item representing part of the context for the response to be \ngenerated by the model. Can contain text, images, and audio inputs,\nas well as previous assistant responses and tool call outputs.\n"]
    Item(crate::__types::Item),
    ItemReferenceParam(crate::__types::ItemReferenceParam),
}
#[allow(clippy::module_inception)]
pub mod input_message {
    #[doc = "The type of the message input. Always set to `message`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Type;
    impl_serde!(Type, "message");
    #[doc = "The role of the message input. One of `user`, `system`, or `developer`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`system`"]
        #[serde(rename = "system")]
        System,
        #[doc = "`developer`"]
        #[serde(rename = "developer")]
        Developer,
    }
    #[doc = "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct InputMessage {
    #[doc = "The type of the message input. Always set to `message`.\n"]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::input_message::Type>,
    #[doc = "The role of the message input. One of `user`, `system`, or `developer`.\n"]
    #[serde(rename = "role")]
    pub role: crate::__types::input_message::Role,
    #[doc = "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status: Option<crate::__types::input_message::Status>,
    #[serde(rename = "content")]
    pub content: crate::__types::InputMessageContentList,
}
#[doc = "A list of one or many input items to the model, containing different content \ntypes.\n"]
pub type InputMessageContentList = Vec<crate::__types::InputContent>;
#[allow(clippy::module_inception)]
pub mod input_message_resource {
    #[doc = "The type of the message input. Always set to `message`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Type;
    impl_serde!(Type, "message");
    #[doc = "The role of the message input. One of `user`, `system`, or `developer`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`system`"]
        #[serde(rename = "system")]
        System,
        #[doc = "`developer`"]
        #[serde(rename = "developer")]
        Developer,
    }
    #[doc = "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct InputMessageResource {
    #[doc = "The type of the message input. Always set to `message`.\n"]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::input_message_resource::Type>,
    #[doc = "The role of the message input. One of `user`, `system`, or `developer`.\n"]
    #[serde(rename = "role")]
    pub role: crate::__types::input_message_resource::Role,
    #[doc = "The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status: Option<crate::__types::input_message_resource::Status>,
    #[serde(rename = "content")]
    pub content: crate::__types::InputMessageContentList,
    #[doc = "The unique ID of the message input.\n"]
    #[serde(rename = "id")]
    pub id: String,
}
#[allow(clippy::module_inception)]
pub mod invite {
    #[doc = "The object type, which is always `organization.invite`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.invite");
    #[doc = "`owner` or `reader`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`owner`"]
        #[serde(rename = "owner")]
        Owner,
        #[doc = "`reader`"]
        #[serde(rename = "reader")]
        Reader,
    }
    #[doc = "`accepted`,`expired`, or `pending`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`accepted`"]
        #[serde(rename = "accepted")]
        Accepted,
        #[doc = "`expired`"]
        #[serde(rename = "expired")]
        Expired,
        #[doc = "`pending`"]
        #[serde(rename = "pending")]
        Pending,
    }
    #[allow(clippy::module_inception)]
    pub mod projects {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "Project membership role"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Role {
                #[doc = "`member`"]
                #[serde(rename = "member")]
                Member,
                #[doc = "`owner`"]
                #[serde(rename = "owner")]
                Owner,
            }
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "Project's public ID"]
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub id: Option<String>,
            #[doc = "Project membership role"]
            #[serde(rename = "role")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub role: Option<crate::__types::invite::projects::item::Role>,
        }
    }
}
#[doc = "Represents an individual `invite` to the organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Invite {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The email address of the individual to whom the invite was sent"]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    pub role: crate::__types::invite::Role,
    #[doc = "`accepted`,`expired`, or `pending`"]
    pub status: crate::__types::invite::Status,
    #[doc = "The Unix timestamp (in seconds) of when the invite was sent."]
    pub invited_at: i64,
    #[doc = "The Unix timestamp (in seconds) of when the invite expires."]
    pub expires_at: i64,
    #[doc = "The Unix timestamp (in seconds) of when the invite was accepted."]
    #[builder(default)]
    pub accepted_at: Option<i64>,
    #[doc = "The projects that were granted membership upon acceptance of the invite."]
    #[builder(default)]
    pub projects: Option<Vec<crate::__types::invite::projects::Item>>,
}
impl<'de> serde::Deserialize<'de> for Invite {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Invite {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::invite::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "email")]
            email: String,
            #[serde(rename = "role")]
            role: crate::__types::invite::Role,
            #[serde(rename = "status")]
            status: crate::__types::invite::Status,
            #[serde(rename = "invited_at")]
            invited_at: i64,
            #[serde(rename = "expires_at")]
            expires_at: i64,
            #[serde(rename = "accepted_at")]
            accepted_at: Option<i64>,
            #[serde(rename = "projects")]
            projects: Option<Vec<crate::__types::invite::projects::Item>>,
        }
        let Invite {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
            ..
        } = Invite::deserialize(deserializer)?;
        Ok(Self {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        })
    }
}
impl serde::Serialize for Invite {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Invite<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::invite::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a crate::__types::invite::Role,
            #[serde(rename = "status")]
            status: &'a crate::__types::invite::Status,
            #[serde(rename = "invited_at")]
            invited_at: &'a i64,
            #[serde(rename = "expires_at")]
            expires_at: &'a i64,
            #[serde(rename = "accepted_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            accepted_at: &'a Option<i64>,
            #[serde(rename = "projects")]
            #[serde(skip_serializing_if = "Option::is_none")]
            projects: &'a Option<Vec<crate::__types::invite::projects::Item>>,
        }
        let Self {
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        } = self;
        Invite {
            object: &Default::default(),
            id,
            email,
            role,
            status,
            invited_at,
            expires_at,
            accepted_at,
            projects,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod invite_delete_response {
    #[doc = "The object type, which is always `organization.invite.deleted`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.invite.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for InviteDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InviteDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::invite_delete_response::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
        }
        let InviteDeleteResponse { id, deleted, .. } =
            InviteDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for InviteDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InviteDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::invite_delete_response::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        InviteDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod invite_list_response {
    #[doc = "The object type, which is always `list`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InviteListResponse {
    pub data: Vec<crate::__types::Invite>,
    #[doc = "The first `invite_id` in the retrieved `list`"]
    #[builder(default)]
    pub first_id: Option<String>,
    #[doc = "The last `invite_id` in the retrieved `list`"]
    #[builder(default)]
    pub last_id: Option<String>,
    #[doc = "The `has_more` property is used for pagination to indicate there are additional results."]
    #[builder(default)]
    pub has_more: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for InviteListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InviteListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::invite_list_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::Invite>,
            #[serde(rename = "first_id")]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            has_more: Option<bool>,
        }
        let InviteListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = InviteListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for InviteListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InviteListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::invite_list_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::Invite>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            #[serde(skip_serializing_if = "Option::is_none")]
            has_more: &'a Option<bool>,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        InviteListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod invite_request {
    #[doc = "`owner` or `reader`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`reader`"]
        #[serde(rename = "reader")]
        Reader,
        #[doc = "`owner`"]
        #[serde(rename = "owner")]
        Owner,
    }
    #[allow(clippy::module_inception)]
    pub mod projects {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "Project membership role"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Role {
                #[doc = "`member`"]
                #[serde(rename = "member")]
                Member,
                #[doc = "`owner`"]
                #[serde(rename = "owner")]
                Owner,
            }
        }
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "Project's public ID"]
            #[serde(rename = "id")]
            pub id: String,
            #[doc = "Project membership role"]
            #[serde(rename = "role")]
            pub role: crate::__types::invite_request::projects::item::Role,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct InviteRequest {
    #[doc = "Send an email to this address"]
    #[serde(rename = "email")]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    #[serde(rename = "role")]
    pub role: crate::__types::invite_request::Role,
    #[doc = "An array of projects to which membership is granted at the same time the org invite is accepted. If omitted, the user will be invited to the default project for compatibility with legacy behavior."]
    #[serde(rename = "projects")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub projects: Option<Vec<crate::__types::invite_request::projects::Item>>,
}
#[doc = "Content item used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum Item {
    InputMessage(crate::__types::InputMessage),
    OutputMessage(crate::__types::OutputMessage),
    FileSearchToolCall(crate::__types::FileSearchToolCall),
    ComputerToolCall(crate::__types::ComputerToolCall),
    ComputerCallOutputItemParam(crate::__types::ComputerCallOutputItemParam),
    WebSearchToolCall(crate::__types::WebSearchToolCall),
    FunctionToolCall(crate::__types::FunctionToolCall),
    FunctionCallOutputItemParam(crate::__types::FunctionCallOutputItemParam),
    ReasoningItem(crate::__types::ReasoningItem),
    ImageGenToolCall(crate::__types::ImageGenToolCall),
    CodeInterpreterToolCall(crate::__types::CodeInterpreterToolCall),
    LocalShellToolCall(crate::__types::LocalShellToolCall),
    LocalShellToolCallOutput(crate::__types::LocalShellToolCallOutput),
    McpListTools(crate::__types::McpListTools),
    McpApprovalRequest(crate::__types::McpApprovalRequest),
    McpApprovalResponse(crate::__types::McpApprovalResponse),
    McpToolCall(crate::__types::McpToolCall),
    CustomToolCallOutput(crate::__types::CustomToolCallOutput),
    CustomToolCall(crate::__types::CustomToolCall),
}
#[doc = "Content item used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ItemResource {
    InputMessageResource(crate::__types::InputMessageResource),
    OutputMessage(crate::__types::OutputMessage),
    FileSearchToolCall(crate::__types::FileSearchToolCall),
    ComputerToolCall(crate::__types::ComputerToolCall),
    ComputerToolCallOutputResource(crate::__types::ComputerToolCallOutputResource),
    WebSearchToolCall(crate::__types::WebSearchToolCall),
    FunctionToolCallResource(crate::__types::FunctionToolCallResource),
    FunctionToolCallOutputResource(crate::__types::FunctionToolCallOutputResource),
    ImageGenToolCall(crate::__types::ImageGenToolCall),
    CodeInterpreterToolCall(crate::__types::CodeInterpreterToolCall),
    LocalShellToolCall(crate::__types::LocalShellToolCall),
    LocalShellToolCallOutput(crate::__types::LocalShellToolCallOutput),
    McpListTools(crate::__types::McpListTools),
    McpApprovalRequest(crate::__types::McpApprovalRequest),
    McpApprovalResponseResource(crate::__types::McpApprovalResponseResource),
    McpToolCall(crate::__types::McpToolCall),
}
#[allow(clippy::module_inception)]
pub(crate) mod key_press {
    #[doc = "Specifies the event type. For a keypress action, this property is \nalways set to `keypress`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "keypress");
}
#[doc = "A collection of keypresses the model would like to perform.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct KeyPress {
    #[doc = "The combination of keys the model is requesting to be pressed. This is an\narray of strings, each representing a key.\n"]
    pub keys: Vec<String>,
}
impl<'de> serde::Deserialize<'de> for KeyPress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct KeyPress {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::key_press::Type,
            #[serde(rename = "keys")]
            keys: Vec<String>,
        }
        let KeyPress { keys, .. } = KeyPress::deserialize(deserializer)?;
        Ok(Self { keys })
    }
}
impl serde::Serialize for KeyPress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct KeyPress<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::key_press::Type,
            #[serde(rename = "keys")]
            keys: &'a Vec<String>,
        }
        let Self { keys } = self;
        KeyPress {
            r#type: &Default::default(),
            keys,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ListAssistantsResponse {
    #[serde(rename = "object")]
    pub object: String,
    #[serde(rename = "data")]
    pub data: Vec<crate::__types::AssistantObject>,
    #[serde(rename = "first_id")]
    pub first_id: String,
    #[serde(rename = "last_id")]
    pub last_id: String,
    #[serde(rename = "has_more")]
    pub has_more: bool,
}
#[allow(clippy::module_inception)]
pub(crate) mod list_audit_logs_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListAuditLogsResponse {
    pub data: Vec<crate::__types::AuditLog>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListAuditLogsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListAuditLogsResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::list_audit_logs_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::AuditLog>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ListAuditLogsResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListAuditLogsResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListAuditLogsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListAuditLogsResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::list_audit_logs_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::AuditLog>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListAuditLogsResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod list_batches_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListBatchesResponse {
    pub data: Vec<crate::__types::Batch>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListBatchesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListBatchesResponse {
            #[serde(rename = "data")]
            data: Vec<crate::__types::Batch>,
            #[serde(rename = "first_id")]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::list_batches_response::Object,
        }
        let ListBatchesResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListBatchesResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListBatchesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListBatchesResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::Batch>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a crate::__types::list_batches_response::Object,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListBatchesResponse {
            data,
            first_id,
            last_id,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod list_certificates_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListCertificatesResponse {
    pub data: Vec<crate::__types::Certificate>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListCertificatesResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListCertificatesResponse {
            #[serde(rename = "data")]
            data: Vec<crate::__types::Certificate>,
            #[serde(rename = "first_id")]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::list_certificates_response::Object,
        }
        let ListCertificatesResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListCertificatesResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListCertificatesResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListCertificatesResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::Certificate>,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a crate::__types::list_certificates_response::Object,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListCertificatesResponse {
            data,
            first_id,
            last_id,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ListFilesResponse {
    #[serde(rename = "object")]
    pub object: String,
    #[serde(rename = "data")]
    pub data: Vec<crate::__types::OpenAiFile>,
    #[serde(rename = "first_id")]
    pub first_id: String,
    #[serde(rename = "last_id")]
    pub last_id: String,
    #[serde(rename = "has_more")]
    pub has_more: bool,
}
#[allow(clippy::module_inception)]
pub(crate) mod list_fine_tuning_checkpoint_permission_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningCheckpointPermissionResponse {
    pub data: Vec<crate::__types::FineTuningCheckpointPermission>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningCheckpointPermissionResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListFineTuningCheckpointPermissionResponse {
            #[serde(rename = "data")]
            data: Vec<crate::__types::FineTuningCheckpointPermission>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::list_fine_tuning_checkpoint_permission_response::Object,
            #[serde(rename = "first_id")]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ListFineTuningCheckpointPermissionResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListFineTuningCheckpointPermissionResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListFineTuningCheckpointPermissionResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListFineTuningCheckpointPermissionResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::FineTuningCheckpointPermission>,
            #[serde(rename = "object")]
            object: &'a crate::__types::list_fine_tuning_checkpoint_permission_response::Object,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListFineTuningCheckpointPermissionResponse {
            data,
            object: &Default::default(),
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod list_fine_tuning_job_checkpoints_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningJobCheckpointsResponse {
    pub data: Vec<crate::__types::FineTuningJobCheckpoint>,
    #[builder(default)]
    pub first_id: Option<String>,
    #[builder(default)]
    pub last_id: Option<String>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningJobCheckpointsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListFineTuningJobCheckpointsResponse {
            #[serde(rename = "data")]
            data: Vec<crate::__types::FineTuningJobCheckpoint>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::list_fine_tuning_job_checkpoints_response::Object,
            #[serde(rename = "first_id")]
            first_id: Option<String>,
            #[serde(rename = "last_id")]
            last_id: Option<String>,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ListFineTuningJobCheckpointsResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ListFineTuningJobCheckpointsResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ListFineTuningJobCheckpointsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListFineTuningJobCheckpointsResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::FineTuningJobCheckpoint>,
            #[serde(rename = "object")]
            object: &'a crate::__types::list_fine_tuning_job_checkpoints_response::Object,
            #[serde(rename = "first_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            first_id: &'a Option<String>,
            #[serde(rename = "last_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_id: &'a Option<String>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ListFineTuningJobCheckpointsResponse {
            data,
            object: &Default::default(),
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod list_fine_tuning_job_events_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListFineTuningJobEventsResponse {
    pub data: Vec<crate::__types::FineTuningJobEvent>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListFineTuningJobEventsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListFineTuningJobEventsResponse {
            #[serde(rename = "data")]
            data: Vec<crate::__types::FineTuningJobEvent>,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::list_fine_tuning_job_events_response::Object,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ListFineTuningJobEventsResponse { data, has_more, .. } =
            ListFineTuningJobEventsResponse::deserialize(deserializer)?;
        Ok(Self { data, has_more })
    }
}
impl serde::Serialize for ListFineTuningJobEventsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListFineTuningJobEventsResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::FineTuningJobEvent>,
            #[serde(rename = "object")]
            object: &'a crate::__types::list_fine_tuning_job_events_response::Object,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self { data, has_more } = self;
        ListFineTuningJobEventsResponse {
            data,
            object: &Default::default(),
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ListMessagesResponse {
    #[serde(rename = "object")]
    pub object: String,
    #[serde(rename = "data")]
    pub data: Vec<crate::__types::MessageObject>,
    #[serde(rename = "first_id")]
    pub first_id: String,
    #[serde(rename = "last_id")]
    pub last_id: String,
    #[serde(rename = "has_more")]
    pub has_more: bool,
}
#[allow(clippy::module_inception)]
pub(crate) mod list_models_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListModelsResponse {
    pub data: Vec<crate::__types::Model>,
}
impl<'de> serde::Deserialize<'de> for ListModelsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListModelsResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::list_models_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::Model>,
        }
        let ListModelsResponse { data, .. } = ListModelsResponse::deserialize(deserializer)?;
        Ok(Self { data })
    }
}
impl serde::Serialize for ListModelsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListModelsResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::list_models_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::Model>,
        }
        let Self { data } = self;
        ListModelsResponse {
            object: &Default::default(),
            data,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod list_paginated_fine_tuning_jobs_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ListPaginatedFineTuningJobsResponse {
    pub data: Vec<crate::__types::FineTuningJob>,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ListPaginatedFineTuningJobsResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ListPaginatedFineTuningJobsResponse {
            #[serde(rename = "data")]
            data: Vec<crate::__types::FineTuningJob>,
            #[serde(rename = "has_more")]
            has_more: bool,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::list_paginated_fine_tuning_jobs_response::Object,
        }
        let ListPaginatedFineTuningJobsResponse { data, has_more, .. } =
            ListPaginatedFineTuningJobsResponse::deserialize(deserializer)?;
        Ok(Self { data, has_more })
    }
}
impl serde::Serialize for ListPaginatedFineTuningJobsResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ListPaginatedFineTuningJobsResponse<'a> {
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::FineTuningJob>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "object")]
            object: &'a crate::__types::list_paginated_fine_tuning_jobs_response::Object,
        }
        let Self { data, has_more } = self;
        ListPaginatedFineTuningJobsResponse {
            data,
            has_more,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ListRunStepsResponse {
    #[serde(rename = "object")]
    pub object: String,
    #[serde(rename = "data")]
    pub data: Vec<crate::__types::RunStepObject>,
    #[serde(rename = "first_id")]
    pub first_id: String,
    #[serde(rename = "last_id")]
    pub last_id: String,
    #[serde(rename = "has_more")]
    pub has_more: bool,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ListRunsResponse {
    #[serde(rename = "object")]
    pub object: String,
    #[serde(rename = "data")]
    pub data: Vec<crate::__types::RunObject>,
    #[serde(rename = "first_id")]
    pub first_id: String,
    #[serde(rename = "last_id")]
    pub last_id: String,
    #[serde(rename = "has_more")]
    pub has_more: bool,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ListVectorStoreFilesResponse {
    #[serde(rename = "object")]
    pub object: String,
    #[serde(rename = "data")]
    pub data: Vec<crate::__types::VectorStoreFileObject>,
    #[serde(rename = "first_id")]
    pub first_id: String,
    #[serde(rename = "last_id")]
    pub last_id: String,
    #[serde(rename = "has_more")]
    pub has_more: bool,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ListVectorStoresResponse {
    #[serde(rename = "object")]
    pub object: String,
    #[serde(rename = "data")]
    pub data: Vec<crate::__types::VectorStoreObject>,
    #[serde(rename = "first_id")]
    pub first_id: String,
    #[serde(rename = "last_id")]
    pub last_id: String,
    #[serde(rename = "has_more")]
    pub has_more: bool,
}
#[allow(clippy::module_inception)]
pub(crate) mod local_shell_exec_action {
    #[doc = "The type of the local shell action. Always `exec`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "exec");
}
#[doc = "Execute a shell command on the server.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LocalShellExecAction {
    #[doc = "The command to run.\n"]
    pub command: Vec<String>,
    #[doc = "Optional timeout in milliseconds for the command.\n"]
    #[builder(default)]
    pub timeout_ms: Option<i64>,
    #[doc = "Optional working directory to run the command in.\n"]
    #[builder(default)]
    pub working_directory: Option<String>,
    #[doc = "Environment variables to set for the command.\n"]
    pub env: indexmap::IndexMap<String, String>,
    #[doc = "Optional user to run the command as.\n"]
    #[builder(default)]
    pub user: Option<String>,
}
impl<'de> serde::Deserialize<'de> for LocalShellExecAction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LocalShellExecAction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::local_shell_exec_action::Type,
            #[serde(rename = "command")]
            command: Vec<String>,
            #[serde(rename = "timeout_ms")]
            timeout_ms: Option<i64>,
            #[serde(rename = "working_directory")]
            working_directory: Option<String>,
            #[serde(rename = "env")]
            env: indexmap::IndexMap<String, String>,
            #[serde(rename = "user")]
            user: Option<String>,
        }
        let LocalShellExecAction {
            command,
            timeout_ms,
            working_directory,
            env,
            user,
            ..
        } = LocalShellExecAction::deserialize(deserializer)?;
        Ok(Self {
            command,
            timeout_ms,
            working_directory,
            env,
            user,
        })
    }
}
impl serde::Serialize for LocalShellExecAction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LocalShellExecAction<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::local_shell_exec_action::Type,
            #[serde(rename = "command")]
            command: &'a Vec<String>,
            #[serde(rename = "timeout_ms")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timeout_ms: &'a Option<i64>,
            #[serde(rename = "working_directory")]
            #[serde(skip_serializing_if = "Option::is_none")]
            working_directory: &'a Option<String>,
            #[serde(rename = "env")]
            env: &'a indexmap::IndexMap<String, String>,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
        }
        let Self {
            command,
            timeout_ms,
            working_directory,
            env,
            user,
        } = self;
        LocalShellExecAction {
            r#type: &Default::default(),
            command,
            timeout_ms,
            working_directory,
            env,
            user,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod local_shell_tool {
    #[doc = "The type of the local shell tool. Always `local_shell`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "local_shell");
}
#[doc = "A tool that allows the model to execute shell commands in a local environment.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct LocalShellTool {}
impl<'de> serde::Deserialize<'de> for LocalShellTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LocalShellTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::local_shell_tool::Type,
        }
        let LocalShellTool { .. } = LocalShellTool::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for LocalShellTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LocalShellTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::local_shell_tool::Type,
        }
        let Self {} = self;
        LocalShellTool {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod local_shell_tool_call {
    #[doc = "The type of the local shell call. Always `local_shell_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "local_shell_call");
    #[doc = "The status of the local shell call.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "A tool call to run a command on the local shell.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LocalShellToolCall {
    #[doc = "The unique ID of the local shell call.\n"]
    pub id: String,
    #[doc = "The unique ID of the local shell tool call generated by the model.\n"]
    pub call_id: String,
    pub action: crate::__types::LocalShellExecAction,
    #[doc = "The status of the local shell call.\n"]
    pub status: crate::__types::local_shell_tool_call::Status,
}
impl<'de> serde::Deserialize<'de> for LocalShellToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LocalShellToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::local_shell_tool_call::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "action")]
            action: crate::__types::LocalShellExecAction,
            #[serde(rename = "status")]
            status: crate::__types::local_shell_tool_call::Status,
        }
        let LocalShellToolCall {
            id,
            call_id,
            action,
            status,
            ..
        } = LocalShellToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            action,
            status,
        })
    }
}
impl serde::Serialize for LocalShellToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LocalShellToolCall<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::local_shell_tool_call::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "action")]
            action: &'a crate::__types::LocalShellExecAction,
            #[serde(rename = "status")]
            status: &'a crate::__types::local_shell_tool_call::Status,
        }
        let Self {
            id,
            call_id,
            action,
            status,
        } = self;
        LocalShellToolCall {
            r#type: &Default::default(),
            id,
            call_id,
            action,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod local_shell_tool_call_output {
    #[doc = "The type of the local shell tool call output. Always `local_shell_call_output`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "local_shell_call_output");
    #[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "The output of a local shell tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct LocalShellToolCallOutput {
    #[doc = "The unique ID of the local shell tool call generated by the model.\n"]
    pub id: String,
    #[doc = "A JSON string of the output of the local shell tool call.\n"]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::local_shell_tool_call_output::Status>,
    pub call_id: serde_json::Value,
}
impl<'de> serde::Deserialize<'de> for LocalShellToolCallOutput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct LocalShellToolCallOutput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::local_shell_tool_call_output::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "output")]
            output: String,
            #[serde(rename = "status")]
            status: Option<crate::__types::local_shell_tool_call_output::Status>,
            #[serde(rename = "call_id")]
            call_id: serde_json::Value,
        }
        let LocalShellToolCallOutput {
            id,
            output,
            status,
            call_id,
            ..
        } = LocalShellToolCallOutput::deserialize(deserializer)?;
        Ok(Self {
            id,
            output,
            status,
            call_id,
        })
    }
}
impl serde::Serialize for LocalShellToolCallOutput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct LocalShellToolCallOutput<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::local_shell_tool_call_output::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::local_shell_tool_call_output::Status>,
            #[serde(rename = "call_id")]
            call_id: &'a serde_json::Value,
        }
        let Self {
            id,
            output,
            status,
            call_id,
        } = self;
        LocalShellToolCallOutput {
            r#type: &Default::default(),
            id,
            output,
            status,
            call_id,
        }
        .serialize(serializer)
    }
}
#[doc = "A log probability object.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct LogProbProperties {
    #[doc = "The token that was used to generate the log probability.\n"]
    #[serde(rename = "token")]
    pub token: String,
    #[doc = "The log probability of the token.\n"]
    #[serde(rename = "logprob")]
    pub logprob: serde_json::Number,
    #[doc = "The bytes that were used to generate the log probability.\n"]
    #[serde(rename = "bytes")]
    pub bytes: Vec<i64>,
}
#[allow(clippy::module_inception)]
pub(crate) mod mcp_approval_request {
    #[doc = "The type of the item. Always `mcp_approval_request`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "mcp_approval_request");
}
#[doc = "A request for human approval of a tool invocation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpApprovalRequest {
    #[doc = "The unique ID of the approval request.\n"]
    pub id: String,
    #[doc = "The label of the MCP server making the request.\n"]
    pub server_label: String,
    #[doc = "The name of the tool to run.\n"]
    pub name: String,
    #[doc = "A JSON string of arguments for the tool.\n"]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for McpApprovalRequest {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpApprovalRequest {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::mcp_approval_request::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "server_label")]
            server_label: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "arguments")]
            arguments: String,
        }
        let McpApprovalRequest {
            id,
            server_label,
            name,
            arguments,
            ..
        } = McpApprovalRequest::deserialize(deserializer)?;
        Ok(Self {
            id,
            server_label,
            name,
            arguments,
        })
    }
}
impl serde::Serialize for McpApprovalRequest {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpApprovalRequest<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::mcp_approval_request::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let Self {
            id,
            server_label,
            name,
            arguments,
        } = self;
        McpApprovalRequest {
            r#type: &Default::default(),
            id,
            server_label,
            name,
            arguments,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod mcp_approval_response {
    #[doc = "The type of the item. Always `mcp_approval_response`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "mcp_approval_response");
}
#[doc = "A response to an MCP approval request.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpApprovalResponse {
    #[doc = "The unique ID of the approval response\n"]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The ID of the approval request being answered.\n"]
    pub approval_request_id: String,
    #[doc = "Whether the request was approved.\n"]
    pub approve: bool,
    #[doc = "Optional reason for the decision.\n"]
    #[builder(default)]
    pub reason: Option<String>,
    pub request_id: serde_json::Value,
}
impl<'de> serde::Deserialize<'de> for McpApprovalResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpApprovalResponse {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::mcp_approval_response::Type,
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "approval_request_id")]
            approval_request_id: String,
            #[serde(rename = "approve")]
            approve: bool,
            #[serde(rename = "reason")]
            reason: Option<String>,
            #[serde(rename = "request_id")]
            request_id: serde_json::Value,
        }
        let McpApprovalResponse {
            id,
            approval_request_id,
            approve,
            reason,
            request_id,
            ..
        } = McpApprovalResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            approval_request_id,
            approve,
            reason,
            request_id,
        })
    }
}
impl serde::Serialize for McpApprovalResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpApprovalResponse<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::mcp_approval_response::Type,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "approval_request_id")]
            approval_request_id: &'a String,
            #[serde(rename = "approve")]
            approve: &'a bool,
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<String>,
            #[serde(rename = "request_id")]
            request_id: &'a serde_json::Value,
        }
        let Self {
            id,
            approval_request_id,
            approve,
            reason,
            request_id,
        } = self;
        McpApprovalResponse {
            r#type: &Default::default(),
            id,
            approval_request_id,
            approve,
            reason,
            request_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod mcp_approval_response_resource {
    #[doc = "The type of the item. Always `mcp_approval_response`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "mcp_approval_response");
}
#[doc = "A response to an MCP approval request.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpApprovalResponseResource {
    #[doc = "The unique ID of the approval response\n"]
    pub id: String,
    #[doc = "The ID of the approval request being answered.\n"]
    pub approval_request_id: String,
    #[doc = "Whether the request was approved.\n"]
    pub approve: bool,
    #[doc = "Optional reason for the decision.\n"]
    #[builder(default)]
    pub reason: Option<String>,
    pub request_id: serde_json::Value,
}
impl<'de> serde::Deserialize<'de> for McpApprovalResponseResource {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpApprovalResponseResource {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::mcp_approval_response_resource::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "approval_request_id")]
            approval_request_id: String,
            #[serde(rename = "approve")]
            approve: bool,
            #[serde(rename = "reason")]
            reason: Option<String>,
            #[serde(rename = "request_id")]
            request_id: serde_json::Value,
        }
        let McpApprovalResponseResource {
            id,
            approval_request_id,
            approve,
            reason,
            request_id,
            ..
        } = McpApprovalResponseResource::deserialize(deserializer)?;
        Ok(Self {
            id,
            approval_request_id,
            approve,
            reason,
            request_id,
        })
    }
}
impl serde::Serialize for McpApprovalResponseResource {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpApprovalResponseResource<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::mcp_approval_response_resource::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "approval_request_id")]
            approval_request_id: &'a String,
            #[serde(rename = "approve")]
            approve: &'a bool,
            #[serde(rename = "reason")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reason: &'a Option<String>,
            #[serde(rename = "request_id")]
            request_id: &'a serde_json::Value,
        }
        let Self {
            id,
            approval_request_id,
            approve,
            reason,
            request_id,
        } = self;
        McpApprovalResponseResource {
            r#type: &Default::default(),
            id,
            approval_request_id,
            approve,
            reason,
            request_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod mcp_list_tools {
    #[doc = "The type of the item. Always `mcp_list_tools`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "mcp_list_tools");
}
#[doc = "A list of tools available on an MCP server.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpListTools {
    #[doc = "The unique ID of the list.\n"]
    pub id: String,
    #[doc = "The label of the MCP server.\n"]
    pub server_label: String,
    #[doc = "The tools available on the server.\n"]
    pub tools: Vec<crate::__types::McpListToolsTool>,
    #[doc = "Error message if the server could not list tools.\n"]
    #[builder(default)]
    pub error: Option<String>,
}
impl<'de> serde::Deserialize<'de> for McpListTools {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpListTools {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::mcp_list_tools::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "server_label")]
            server_label: String,
            #[serde(rename = "tools")]
            tools: Vec<crate::__types::McpListToolsTool>,
            #[serde(rename = "error")]
            error: Option<String>,
        }
        let McpListTools {
            id,
            server_label,
            tools,
            error,
            ..
        } = McpListTools::deserialize(deserializer)?;
        Ok(Self {
            id,
            server_label,
            tools,
            error,
        })
    }
}
impl serde::Serialize for McpListTools {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpListTools<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::mcp_list_tools::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "tools")]
            tools: &'a Vec<crate::__types::McpListToolsTool>,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<String>,
        }
        let Self {
            id,
            server_label,
            tools,
            error,
        } = self;
        McpListTools {
            r#type: &Default::default(),
            id,
            server_label,
            tools,
            error,
        }
        .serialize(serializer)
    }
}
#[doc = "A tool available on an MCP server.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct McpListToolsTool {
    #[doc = "The name of the tool.\n"]
    #[serde(rename = "name")]
    pub name: String,
    #[doc = "The description of the tool.\n"]
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The JSON schema describing the tool's input.\n"]
    #[serde(rename = "input_schema")]
    pub input_schema: indexmap::IndexMap<String, serde_json::Value>,
    #[doc = "Additional annotations about the tool.\n"]
    #[serde(rename = "annotations")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub annotations: Option<indexmap::IndexMap<String, serde_json::Value>>,
}
#[allow(clippy::module_inception)]
pub mod mcp_tool {
    #[doc = "The type of the MCP tool. Always `mcp`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "mcp");
    #[allow(clippy::module_inception)]
    pub mod allowed_tools {
        #[doc = "A filter object to specify which tools are allowed.\n"]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Variant1 {
            #[doc = "List of allowed tool names."]
            #[serde(rename = "tool_names")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub tool_names: Option<Vec<String>>,
        }
    }
    #[doc = "List of allowed tool names or a filter object.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum AllowedTools {
        #[doc = "A string array of allowed tool names"]
        Array(Vec<String>),
        #[doc = "A filter object to specify which tools are allowed.\n"]
        Variant1(crate::__types::mcp_tool::allowed_tools::Variant1),
    }
    #[allow(clippy::module_inception)]
    pub mod require_approval {
        #[allow(clippy::module_inception)]
        pub mod variant0 {
            #[doc = "A list of tools that always require approval.\n"]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Always {
                #[doc = "List of tools that require approval."]
                #[serde(rename = "tool_names")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub tool_names: Option<Vec<String>>,
            }
            #[doc = "A list of tools that never require approval.\n"]
            #[derive(Clone, Debug, Default, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
            pub struct Never {
                #[doc = "List of tools that do not require approval."]
                #[serde(rename = "tool_names")]
                #[serde(skip_serializing_if = "Option::is_none")]
                #[builder(default)]
                pub tool_names: Option<Vec<String>>,
            }
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Variant0 {
            #[doc = "A list of tools that always require approval.\n"]
            #[serde(rename = "always")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub always: Option<crate::__types::mcp_tool::require_approval::variant0::Always>,
            #[doc = "A list of tools that never require approval.\n"]
            #[serde(rename = "never")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub never: Option<crate::__types::mcp_tool::require_approval::variant0::Never>,
        }
        #[doc = "always"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Always;
        impl_serde!(Always, "always");
        #[doc = "never"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Never;
        impl_serde!(Never, "never");
    }
    #[doc = "Specify which of the MCP server's tools require approval."]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum RequireApproval {
        Variant0(crate::__types::mcp_tool::require_approval::Variant0),
        #[doc = "always"]
        Always,
        #[doc = "never"]
        Never,
    }
    impl<'de> serde::Deserialize<'de> for RequireApproval {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum RequireApproval {
                Always(crate::__types::mcp_tool::require_approval::Always),
                Never(crate::__types::mcp_tool::require_approval::Never),
                Variant0(crate::__types::mcp_tool::require_approval::Variant0),
            }
            Ok(match RequireApproval::deserialize(deserializer)? {
                RequireApproval::Variant0(v) => Self::Variant0(v),
                RequireApproval::Always(_) => Self::Always,
                RequireApproval::Never(_) => Self::Never,
            })
        }
    }
    impl serde::Serialize for RequireApproval {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum RequireApproval<'a> {
                Variant0(&'a crate::__types::mcp_tool::require_approval::Variant0),
                Always(crate::__types::mcp_tool::require_approval::Always),
                Never(crate::__types::mcp_tool::require_approval::Never),
            }
            match self {
                Self::Variant0(v) => RequireApproval::Variant0(v),
                Self::Always => RequireApproval::Always(Default::default()),
                Self::Never => RequireApproval::Never(Default::default()),
            }
            .serialize(serializer)
        }
    }
}
#[doc = "Give the model access to additional tools via remote Model Context Protocol \n(MCP) servers. [Learn more about MCP](https://platform.openai.com/docs/guides/tools-remote-mcp).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpTool {
    #[doc = "A label for this MCP server, used to identify it in tool calls.\n"]
    pub server_label: String,
    #[doc = "The URL for the MCP server.\n"]
    pub server_url: String,
    #[doc = "Optional description of the MCP server, used to provide more context.\n"]
    #[builder(default)]
    pub server_description: Option<String>,
    #[doc = "Optional HTTP headers to send to the MCP server. Use for authentication\nor other purposes.\n"]
    #[builder(default)]
    pub headers: Option<indexmap::IndexMap<String, String>>,
    #[doc = "List of allowed tool names or a filter object.\n"]
    #[builder(default)]
    pub allowed_tools: Option<crate::__types::mcp_tool::AllowedTools>,
    #[doc = "Specify which of the MCP server's tools require approval."]
    #[builder(default)]
    pub require_approval: Option<crate::__types::mcp_tool::RequireApproval>,
}
impl<'de> serde::Deserialize<'de> for McpTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::mcp_tool::Type,
            #[serde(rename = "server_label")]
            server_label: String,
            #[serde(rename = "server_url")]
            server_url: String,
            #[serde(rename = "server_description")]
            server_description: Option<String>,
            #[serde(rename = "headers")]
            headers: Option<indexmap::IndexMap<String, String>>,
            #[serde(rename = "allowed_tools")]
            allowed_tools: Option<crate::__types::mcp_tool::AllowedTools>,
            #[serde(rename = "require_approval")]
            require_approval: Option<crate::__types::mcp_tool::RequireApproval>,
        }
        let McpTool {
            server_label,
            server_url,
            server_description,
            headers,
            allowed_tools,
            require_approval,
            ..
        } = McpTool::deserialize(deserializer)?;
        Ok(Self {
            server_label,
            server_url,
            server_description,
            headers,
            allowed_tools,
            require_approval,
        })
    }
}
impl serde::Serialize for McpTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::mcp_tool::Type,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "server_url")]
            server_url: &'a String,
            #[serde(rename = "server_description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            server_description: &'a Option<String>,
            #[serde(rename = "headers")]
            #[serde(skip_serializing_if = "Option::is_none")]
            headers: &'a Option<indexmap::IndexMap<String, String>>,
            #[serde(rename = "allowed_tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            allowed_tools: &'a Option<crate::__types::mcp_tool::AllowedTools>,
            #[serde(rename = "require_approval")]
            #[serde(skip_serializing_if = "Option::is_none")]
            require_approval: &'a Option<crate::__types::mcp_tool::RequireApproval>,
        }
        let Self {
            server_label,
            server_url,
            server_description,
            headers,
            allowed_tools,
            require_approval,
        } = self;
        McpTool {
            r#type: &Default::default(),
            server_label,
            server_url,
            server_description,
            headers,
            allowed_tools,
            require_approval,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod mcp_tool_call {
    #[doc = "The type of the item. Always `mcp_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "mcp_call");
}
#[doc = "An invocation of a tool on an MCP server.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct McpToolCall {
    #[doc = "The unique ID of the tool call.\n"]
    pub id: String,
    #[doc = "The label of the MCP server running the tool.\n"]
    pub server_label: String,
    #[doc = "The name of the tool that was run.\n"]
    pub name: String,
    #[doc = "A JSON string of the arguments passed to the tool.\n"]
    pub arguments: String,
    #[doc = "The output from the tool call.\n"]
    #[builder(default)]
    pub output: Option<String>,
    #[doc = "The error from the tool call, if any.\n"]
    #[builder(default)]
    pub error: Option<String>,
}
impl<'de> serde::Deserialize<'de> for McpToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct McpToolCall {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::mcp_tool_call::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "server_label")]
            server_label: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "arguments")]
            arguments: String,
            #[serde(rename = "output")]
            output: Option<String>,
            #[serde(rename = "error")]
            error: Option<String>,
        }
        let McpToolCall {
            id,
            server_label,
            name,
            arguments,
            output,
            error,
            ..
        } = McpToolCall::deserialize(deserializer)?;
        Ok(Self {
            id,
            server_label,
            name,
            arguments,
            output,
            error,
        })
    }
}
impl serde::Serialize for McpToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct McpToolCall<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::mcp_tool_call::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output: &'a Option<String>,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<String>,
        }
        let Self {
            id,
            server_label,
            name,
            arguments,
            output,
            error,
        } = self;
        McpToolCall {
            r#type: &Default::default(),
            id,
            server_label,
            name,
            arguments,
            output,
            error,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_content_image_file_object {
    #[doc = "Always `image_file`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_file");
    #[allow(clippy::module_inception)]
    pub mod image_file {
        #[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Detail {
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
            #[doc = "`low`"]
            #[serde(rename = "low")]
            Low,
            #[doc = "`high`"]
            #[serde(rename = "high")]
            High,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ImageFile {
        #[doc = "The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content."]
        #[serde(rename = "file_id")]
        pub file_id: String,
        #[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
        #[serde(rename = "detail")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub detail: Option<crate::__types::message_content_image_file_object::image_file::Detail>,
    }
}
#[doc = "References an image [File](https://platform.openai.com/docs/api-reference/files) in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageFileObject {
    pub image_file: crate::__types::message_content_image_file_object::ImageFile,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentImageFileObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_content_image_file_object::Type,
            #[serde(rename = "image_file")]
            image_file: crate::__types::message_content_image_file_object::ImageFile,
        }
        let MessageContentImageFileObject { image_file, .. } =
            MessageContentImageFileObject::deserialize(deserializer)?;
        Ok(Self { image_file })
    }
}
impl serde::Serialize for MessageContentImageFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentImageFileObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_content_image_file_object::Type,
            #[serde(rename = "image_file")]
            image_file: &'a crate::__types::message_content_image_file_object::ImageFile,
        }
        let Self { image_file } = self;
        MessageContentImageFileObject {
            r#type: &Default::default(),
            image_file,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_content_image_url_object {
    #[doc = "The type of the content part."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_url");
    #[allow(clippy::module_inception)]
    pub mod image_url {
        #[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Detail {
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
            #[doc = "`low`"]
            #[serde(rename = "low")]
            Low,
            #[doc = "`high`"]
            #[serde(rename = "high")]
            High,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ImageUrl {
        #[doc = "The external URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp."]
        #[serde(rename = "url")]
        pub url: String,
        #[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`. Default value is `auto`"]
        #[serde(rename = "detail")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub detail: Option<crate::__types::message_content_image_url_object::image_url::Detail>,
    }
}
#[doc = "References an image URL in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentImageUrlObject {
    pub image_url: crate::__types::message_content_image_url_object::ImageUrl,
}
impl<'de> serde::Deserialize<'de> for MessageContentImageUrlObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentImageUrlObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_content_image_url_object::Type,
            #[serde(rename = "image_url")]
            image_url: crate::__types::message_content_image_url_object::ImageUrl,
        }
        let MessageContentImageUrlObject { image_url, .. } =
            MessageContentImageUrlObject::deserialize(deserializer)?;
        Ok(Self { image_url })
    }
}
impl serde::Serialize for MessageContentImageUrlObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentImageUrlObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_content_image_url_object::Type,
            #[serde(rename = "image_url")]
            image_url: &'a crate::__types::message_content_image_url_object::ImageUrl,
        }
        let Self { image_url } = self;
        MessageContentImageUrlObject {
            r#type: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod message_content_refusal_object {
    #[doc = "Always `refusal`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "refusal");
}
#[doc = "The refusal content generated by the assistant."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentRefusalObject {
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for MessageContentRefusalObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentRefusalObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_content_refusal_object::Type,
            #[serde(rename = "refusal")]
            refusal: String,
        }
        let MessageContentRefusalObject { refusal, .. } =
            MessageContentRefusalObject::deserialize(deserializer)?;
        Ok(Self { refusal })
    }
}
impl serde::Serialize for MessageContentRefusalObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentRefusalObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_content_refusal_object::Type,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let Self { refusal } = self;
        MessageContentRefusalObject {
            r#type: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_content_text_annotations_file_citation_object {
    #[doc = "Always `file_citation`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_citation");
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FileCitation {
        #[doc = "The ID of the specific File the citation is from."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[doc = "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFileCitationObject {
    #[doc = "The text in the message content that needs to be replaced."]
    pub text: String,
    pub file_citation:
        crate::__types::message_content_text_annotations_file_citation_object::FileCitation,
    pub start_index: i64,
    pub end_index: i64,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFileCitationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextAnnotationsFileCitationObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_content_text_annotations_file_citation_object::Type,
            #[serde(rename = "text")]
            text: String,
            #[serde(rename = "file_citation")]
            file_citation:
                crate::__types::message_content_text_annotations_file_citation_object::FileCitation,
            #[serde(rename = "start_index")]
            start_index: i64,
            #[serde(rename = "end_index")]
            end_index: i64,
        }
        let MessageContentTextAnnotationsFileCitationObject {
            text,
            file_citation,
            start_index,
            end_index,
            ..
        } = MessageContentTextAnnotationsFileCitationObject::deserialize(deserializer)?;
        Ok(Self {
            text,
            file_citation,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFileCitationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextAnnotationsFileCitationObject < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: message_content_text_annotations_file_citation_object :: Type , # [serde (rename = "text")] text : & 'a String , # [serde (rename = "file_citation")] file_citation : & 'a crate :: __types :: message_content_text_annotations_file_citation_object :: FileCitation , # [serde (rename = "start_index")] start_index : & 'a i64 , # [serde (rename = "end_index")] end_index : & 'a i64 }
        let Self {
            text,
            file_citation,
            start_index,
            end_index,
        } = self;
        MessageContentTextAnnotationsFileCitationObject {
            r#type: &Default::default(),
            text,
            file_citation,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_content_text_annotations_file_path_object {
    #[doc = "Always `file_path`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_path");
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FilePath {
        #[doc = "The ID of the file that was generated."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[doc = "A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextAnnotationsFilePathObject {
    #[doc = "The text in the message content that needs to be replaced."]
    pub text: String,
    pub file_path: crate::__types::message_content_text_annotations_file_path_object::FilePath,
    pub start_index: i64,
    pub end_index: i64,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextAnnotationsFilePathObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextAnnotationsFilePathObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_content_text_annotations_file_path_object::Type,
            #[serde(rename = "text")]
            text: String,
            #[serde(rename = "file_path")]
            file_path: crate::__types::message_content_text_annotations_file_path_object::FilePath,
            #[serde(rename = "start_index")]
            start_index: i64,
            #[serde(rename = "end_index")]
            end_index: i64,
        }
        let MessageContentTextAnnotationsFilePathObject {
            text,
            file_path,
            start_index,
            end_index,
            ..
        } = MessageContentTextAnnotationsFilePathObject::deserialize(deserializer)?;
        Ok(Self {
            text,
            file_path,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageContentTextAnnotationsFilePathObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextAnnotationsFilePathObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_content_text_annotations_file_path_object::Type,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "file_path")]
            file_path:
                &'a crate::__types::message_content_text_annotations_file_path_object::FilePath,
            #[serde(rename = "start_index")]
            start_index: &'a i64,
            #[serde(rename = "end_index")]
            end_index: &'a i64,
        }
        let Self {
            text,
            file_path,
            start_index,
            end_index,
        } = self;
        MessageContentTextAnnotationsFilePathObject {
            r#type: &Default::default(),
            text,
            file_path,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_content_text_object {
    #[doc = "Always `text`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "text");
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Text {
        #[doc = "The data that makes up the text."]
        #[serde(rename = "value")]
        pub value: String,
        #[serde(rename = "annotations")]
        pub annotations: Vec<crate::__types::TextAnnotation>,
    }
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageContentTextObject {
    pub text: crate::__types::message_content_text_object::Text,
}
impl<'de> serde::Deserialize<'de> for MessageContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageContentTextObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_content_text_object::Type,
            #[serde(rename = "text")]
            text: crate::__types::message_content_text_object::Text,
        }
        let MessageContentTextObject { text, .. } =
            MessageContentTextObject::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for MessageContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageContentTextObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_content_text_object::Type,
            #[serde(rename = "text")]
            text: &'a crate::__types::message_content_text_object::Text,
        }
        let Self { text } = self;
        MessageContentTextObject {
            r#type: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_delta_content_image_file_object {
    #[doc = "Always `image_file`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_file");
    #[allow(clippy::module_inception)]
    pub mod image_file {
        #[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Detail {
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
            #[doc = "`low`"]
            #[serde(rename = "low")]
            Low,
            #[doc = "`high`"]
            #[serde(rename = "high")]
            High,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ImageFile {
        #[doc = "The [File](https://platform.openai.com/docs/api-reference/files) ID of the image in the message content. Set `purpose=\"vision\"` when uploading the File if you need to later display the file content."]
        #[serde(rename = "file_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_id: Option<String>,
        #[doc = "Specifies the detail level of the image if specified by the user. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
        #[serde(rename = "detail")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub detail:
            Option<crate::__types::message_delta_content_image_file_object::image_file::Detail>,
    }
}
#[doc = "References an image [File](https://platform.openai.com/docs/api-reference/files) in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageFileObject {
    #[doc = "The index of the content part in the message."]
    pub index: i64,
    #[builder(default)]
    pub image_file: Option<crate::__types::message_delta_content_image_file_object::ImageFile>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentImageFileObject {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_delta_content_image_file_object::Type,
            #[serde(rename = "image_file")]
            image_file: Option<crate::__types::message_delta_content_image_file_object::ImageFile>,
        }
        let MessageDeltaContentImageFileObject {
            index, image_file, ..
        } = MessageDeltaContentImageFileObject::deserialize(deserializer)?;
        Ok(Self { index, image_file })
    }
}
impl serde::Serialize for MessageDeltaContentImageFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentImageFileObject<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_delta_content_image_file_object::Type,
            #[serde(rename = "image_file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_file:
                &'a Option<crate::__types::message_delta_content_image_file_object::ImageFile>,
        }
        let Self { index, image_file } = self;
        MessageDeltaContentImageFileObject {
            index,
            r#type: &Default::default(),
            image_file,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_delta_content_image_url_object {
    #[doc = "Always `image_url`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_url");
    #[allow(clippy::module_inception)]
    pub mod image_url {
        #[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Detail {
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
            #[doc = "`low`"]
            #[serde(rename = "low")]
            Low,
            #[doc = "`high`"]
            #[serde(rename = "high")]
            High,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ImageUrl {
        #[doc = "The URL of the image, must be a supported image types: jpeg, jpg, png, gif, webp."]
        #[serde(rename = "url")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub url: Option<String>,
        #[doc = "Specifies the detail level of the image. `low` uses fewer tokens, you can opt in to high resolution using `high`."]
        #[serde(rename = "detail")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub detail:
            Option<crate::__types::message_delta_content_image_url_object::image_url::Detail>,
    }
}
#[doc = "References an image URL in the content of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentImageUrlObject {
    #[doc = "The index of the content part in the message."]
    pub index: i64,
    #[builder(default)]
    pub image_url: Option<crate::__types::message_delta_content_image_url_object::ImageUrl>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentImageUrlObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentImageUrlObject {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_delta_content_image_url_object::Type,
            #[serde(rename = "image_url")]
            image_url: Option<crate::__types::message_delta_content_image_url_object::ImageUrl>,
        }
        let MessageDeltaContentImageUrlObject {
            index, image_url, ..
        } = MessageDeltaContentImageUrlObject::deserialize(deserializer)?;
        Ok(Self { index, image_url })
    }
}
impl serde::Serialize for MessageDeltaContentImageUrlObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentImageUrlObject<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_delta_content_image_url_object::Type,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<crate::__types::message_delta_content_image_url_object::ImageUrl>,
        }
        let Self { index, image_url } = self;
        MessageDeltaContentImageUrlObject {
            index,
            r#type: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod message_delta_content_refusal_object {
    #[doc = "Always `refusal`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "refusal");
}
#[doc = "The refusal content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentRefusalObject {
    #[doc = "The index of the refusal part in the message."]
    pub index: i64,
    #[builder(default)]
    pub refusal: Option<String>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentRefusalObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentRefusalObject {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_delta_content_refusal_object::Type,
            #[serde(rename = "refusal")]
            refusal: Option<String>,
        }
        let MessageDeltaContentRefusalObject { index, refusal, .. } =
            MessageDeltaContentRefusalObject::deserialize(deserializer)?;
        Ok(Self { index, refusal })
    }
}
impl serde::Serialize for MessageDeltaContentRefusalObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentRefusalObject<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_delta_content_refusal_object::Type,
            #[serde(rename = "refusal")]
            #[serde(skip_serializing_if = "Option::is_none")]
            refusal: &'a Option<String>,
        }
        let Self { index, refusal } = self;
        MessageDeltaContentRefusalObject {
            index,
            r#type: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_delta_content_text_annotations_file_citation_object {
    #[doc = "Always `file_citation`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_citation");
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FileCitation {
        #[doc = "The ID of the specific File the citation is from."]
        #[serde(rename = "file_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_id: Option<String>,
        #[doc = "The specific quote in the file."]
        #[serde(rename = "quote")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub quote: Option<String>,
    }
}
#[doc = "A citation within the message that points to a specific quote from a specific File associated with the assistant or the message. Generated when the assistant uses the \"file_search\" tool to search files."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFileCitationObject {
    #[doc = "The index of the annotation in the text content part."]
    pub index: i64,
    #[doc = "The text in the message content that needs to be replaced."]
    #[builder(default)]
    pub text: Option<String>,
    #[builder(default)]
    pub file_citation: Option<
        crate::__types::message_delta_content_text_annotations_file_citation_object::FileCitation,
    >,
    #[builder(default)]
    pub start_index: Option<i64>,
    #[builder(default)]
    pub end_index: Option<i64>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextAnnotationsFileCitationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextAnnotationsFileCitationObject { # [serde (rename = "index")] index : i64 , # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: message_delta_content_text_annotations_file_citation_object :: Type , # [serde (rename = "text")] text : Option < String > , # [serde (rename = "file_citation")] file_citation : Option < crate :: __types :: message_delta_content_text_annotations_file_citation_object :: FileCitation > , # [serde (rename = "start_index")] start_index : Option < i64 > , # [serde (rename = "end_index")] end_index : Option < i64 > }
        let MessageDeltaContentTextAnnotationsFileCitationObject {
            index,
            text,
            file_citation,
            start_index,
            end_index,
            ..
        } = MessageDeltaContentTextAnnotationsFileCitationObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            text,
            file_citation,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFileCitationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextAnnotationsFileCitationObject < 'a > { # [serde (rename = "index")] index : & 'a i64 , # [serde (rename = "type")] r#type : & 'a crate :: __types :: message_delta_content_text_annotations_file_citation_object :: Type , # [serde (rename = "text")] # [serde (skip_serializing_if = "Option::is_none")] text : & 'a Option < String > , # [serde (rename = "file_citation")] # [serde (skip_serializing_if = "Option::is_none")] file_citation : & 'a Option < crate :: __types :: message_delta_content_text_annotations_file_citation_object :: FileCitation > , # [serde (rename = "start_index")] # [serde (skip_serializing_if = "Option::is_none")] start_index : & 'a Option < i64 > , # [serde (rename = "end_index")] # [serde (skip_serializing_if = "Option::is_none")] end_index : & 'a Option < i64 > }
        let Self {
            index,
            text,
            file_citation,
            start_index,
            end_index,
        } = self;
        MessageDeltaContentTextAnnotationsFileCitationObject {
            index,
            r#type: &Default::default(),
            text,
            file_citation,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_delta_content_text_annotations_file_path_object {
    #[doc = "Always `file_path`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_path");
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FilePath {
        #[doc = "The ID of the file that was generated."]
        #[serde(rename = "file_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_id: Option<String>,
    }
}
#[doc = "A URL for the file that's generated when the assistant used the `code_interpreter` tool to generate a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextAnnotationsFilePathObject {
    #[doc = "The index of the annotation in the text content part."]
    pub index: i64,
    #[doc = "The text in the message content that needs to be replaced."]
    #[builder(default)]
    pub text: Option<String>,
    #[builder(default)]
    pub file_path:
        Option<crate::__types::message_delta_content_text_annotations_file_path_object::FilePath>,
    #[builder(default)]
    pub start_index: Option<i64>,
    #[builder(default)]
    pub end_index: Option<i64>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextAnnotationsFilePathObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextAnnotationsFilePathObject {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_delta_content_text_annotations_file_path_object::Type,
            #[serde(rename = "text")]
            text: Option<String>,
            #[serde(rename = "file_path")]
            file_path: Option<
                crate::__types::message_delta_content_text_annotations_file_path_object::FilePath,
            >,
            #[serde(rename = "start_index")]
            start_index: Option<i64>,
            #[serde(rename = "end_index")]
            end_index: Option<i64>,
        }
        let MessageDeltaContentTextAnnotationsFilePathObject {
            index,
            text,
            file_path,
            start_index,
            end_index,
            ..
        } = MessageDeltaContentTextAnnotationsFilePathObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            text,
            file_path,
            start_index,
            end_index,
        })
    }
}
impl serde::Serialize for MessageDeltaContentTextAnnotationsFilePathObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextAnnotationsFilePathObject<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "type")]
            r#type:
                &'a crate::__types::message_delta_content_text_annotations_file_path_object::Type,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<String>,
            #[serde(rename = "file_path")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_path: &'a Option<
                crate::__types::message_delta_content_text_annotations_file_path_object::FilePath,
            >,
            #[serde(rename = "start_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            start_index: &'a Option<i64>,
            #[serde(rename = "end_index")]
            #[serde(skip_serializing_if = "Option::is_none")]
            end_index: &'a Option<i64>,
        }
        let Self {
            index,
            text,
            file_path,
            start_index,
            end_index,
        } = self;
        MessageDeltaContentTextAnnotationsFilePathObject {
            index,
            r#type: &Default::default(),
            text,
            file_path,
            start_index,
            end_index,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_delta_content_text_object {
    #[doc = "Always `text`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "text");
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Text {
        #[doc = "The data that makes up the text."]
        #[serde(rename = "value")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub value: Option<String>,
        #[serde(rename = "annotations")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub annotations: Option<Vec<crate::__types::TextAnnotationDelta>>,
    }
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaContentTextObject {
    #[doc = "The index of the content part in the message."]
    pub index: i64,
    #[builder(default)]
    pub text: Option<crate::__types::message_delta_content_text_object::Text>,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaContentTextObject {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_delta_content_text_object::Type,
            #[serde(rename = "text")]
            text: Option<crate::__types::message_delta_content_text_object::Text>,
        }
        let MessageDeltaContentTextObject { index, text, .. } =
            MessageDeltaContentTextObject::deserialize(deserializer)?;
        Ok(Self { index, text })
    }
}
impl serde::Serialize for MessageDeltaContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaContentTextObject<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_delta_content_text_object::Type,
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<crate::__types::message_delta_content_text_object::Text>,
        }
        let Self { index, text } = self;
        MessageDeltaContentTextObject {
            index,
            r#type: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_delta_object {
    #[doc = "The object type, which is always `thread.message.delta`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "thread.message.delta");
    #[allow(clippy::module_inception)]
    pub mod delta {
        #[doc = "The entity that produced the message. One of `user` or `assistant`."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Role {
            #[doc = "`user`"]
            #[serde(rename = "user")]
            User,
            #[doc = "`assistant`"]
            #[serde(rename = "assistant")]
            Assistant,
        }
    }
    #[doc = "The delta containing the fields that have changed on the Message."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Delta {
        #[doc = "The entity that produced the message. One of `user` or `assistant`."]
        #[serde(rename = "role")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub role: Option<crate::__types::message_delta_object::delta::Role>,
        #[doc = "The content of the message in array of text and/or images."]
        #[serde(rename = "content")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub content: Option<Vec<crate::__types::MessageContentDelta>>,
    }
}
#[doc = "Represents a message delta i.e. any changed fields on a message during streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageDeltaObject {
    #[doc = "The identifier of the message, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The delta containing the fields that have changed on the Message."]
    #[builder(default)]
    pub delta: crate::__types::message_delta_object::Delta,
}
impl<'de> serde::Deserialize<'de> for MessageDeltaObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageDeltaObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::message_delta_object::Object,
            #[serde(rename = "delta")]
            delta: crate::__types::message_delta_object::Delta,
        }
        let MessageDeltaObject { id, delta, .. } = MessageDeltaObject::deserialize(deserializer)?;
        Ok(Self { id, delta })
    }
}
impl serde::Serialize for MessageDeltaObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageDeltaObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::message_delta_object::Object,
            #[serde(rename = "delta")]
            delta: &'a crate::__types::message_delta_object::Delta,
        }
        let Self { id, delta } = self;
        MessageDeltaObject {
            id,
            object: &Default::default(),
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_object {
    #[doc = "The object type, which is always `thread.message`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "thread.message");
    #[doc = "The status of the message, which can be either `in_progress`, `incomplete`, or `completed`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
    }
    #[allow(clippy::module_inception)]
    pub mod incomplete_details {
        #[doc = "The reason the message is incomplete."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Reason {
            #[doc = "`content_filter`"]
            #[serde(rename = "content_filter")]
            ContentFilter,
            #[doc = "`max_tokens`"]
            #[serde(rename = "max_tokens")]
            MaxTokens,
            #[doc = "`run_cancelled`"]
            #[serde(rename = "run_cancelled")]
            RunCancelled,
            #[doc = "`run_expired`"]
            #[serde(rename = "run_expired")]
            RunExpired,
            #[doc = "`run_failed`"]
            #[serde(rename = "run_failed")]
            RunFailed,
        }
    }
    #[doc = "On an incomplete message, details about why the message is incomplete."]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct IncompleteDetails {
        #[doc = "The reason the message is incomplete."]
        #[serde(rename = "reason")]
        pub reason: crate::__types::message_object::incomplete_details::Reason,
    }
    #[doc = "The entity that produced the message. One of `user` or `assistant`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`assistant`"]
        #[serde(rename = "assistant")]
        Assistant,
    }
    #[allow(clippy::module_inception)]
    pub mod attachments {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[allow(clippy::module_inception)]
            pub mod tools {
                #[derive(Clone, Copy, Debug, PartialEq)]
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize, serde :: Serialize)]
                #[serde(untagged)]
                #[allow(clippy::large_enum_variant)]
                pub enum Item {
                    CodeInterpreter(crate::__types::AssistantToolsCode),
                    FileSearch(crate::__types::AssistantToolsFileSearchTypeOnly),
                }
            }
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The ID of the file to attach to the message."]
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_id: Option<String>,
            #[doc = "The tools to add this file to."]
            #[serde(rename = "tools")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub tools: Option<Vec<crate::__types::message_object::attachments::item::tools::Item>>,
        }
    }
}
#[doc = "Represents a message within a [thread](https://platform.openai.com/docs/api-reference/threads)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the message was created."]
    pub created_at: i64,
    #[doc = "The [thread](https://platform.openai.com/docs/api-reference/threads) ID that this message belongs to."]
    pub thread_id: String,
    #[doc = "The status of the message, which can be either `in_progress`, `incomplete`, or `completed`."]
    pub status: crate::__types::message_object::Status,
    #[doc = "On an incomplete message, details about why the message is incomplete."]
    #[builder(default)]
    pub incomplete_details: Option<crate::__types::message_object::IncompleteDetails>,
    #[doc = "The Unix timestamp (in seconds) for when the message was completed."]
    #[builder(default)]
    pub completed_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the message was marked as incomplete."]
    #[builder(default)]
    pub incomplete_at: Option<i64>,
    #[doc = "The entity that produced the message. One of `user` or `assistant`."]
    pub role: crate::__types::message_object::Role,
    #[doc = "The content of the message in array of text and/or images."]
    pub content: Vec<crate::__types::MessageContent>,
    #[doc = "If applicable, the ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) that authored this message."]
    #[builder(default)]
    pub assistant_id: Option<String>,
    #[doc = "The ID of the [run](https://platform.openai.com/docs/api-reference/runs) associated with the creation of this message. Value is `null` when messages are created manually using the create message or create thread endpoints."]
    #[builder(default)]
    pub run_id: Option<String>,
    #[doc = "A list of files attached to the message, and the tools they were added to."]
    #[builder(default)]
    pub attachments: Option<Vec<crate::__types::message_object::attachments::Item>>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
impl<'de> serde::Deserialize<'de> for MessageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::message_object::Object,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "thread_id")]
            thread_id: String,
            #[serde(rename = "status")]
            status: crate::__types::message_object::Status,
            #[serde(rename = "incomplete_details")]
            incomplete_details: Option<crate::__types::message_object::IncompleteDetails>,
            #[serde(rename = "completed_at")]
            completed_at: Option<i64>,
            #[serde(rename = "incomplete_at")]
            incomplete_at: Option<i64>,
            #[serde(rename = "role")]
            role: crate::__types::message_object::Role,
            #[serde(rename = "content")]
            content: Vec<crate::__types::MessageContent>,
            #[serde(rename = "assistant_id")]
            assistant_id: Option<String>,
            #[serde(rename = "run_id")]
            run_id: Option<String>,
            #[serde(rename = "attachments")]
            attachments: Option<Vec<crate::__types::message_object::attachments::Item>>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
        }
        let MessageObject {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
            ..
        } = MessageObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        })
    }
}
impl serde::Serialize for MessageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::message_object::Object,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "status")]
            status: &'a crate::__types::message_object::Status,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<crate::__types::message_object::IncompleteDetails>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<i64>,
            #[serde(rename = "incomplete_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_at: &'a Option<i64>,
            #[serde(rename = "role")]
            role: &'a crate::__types::message_object::Role,
            #[serde(rename = "content")]
            content: &'a Vec<crate::__types::MessageContent>,
            #[serde(rename = "assistant_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            assistant_id: &'a Option<String>,
            #[serde(rename = "run_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            run_id: &'a Option<String>,
            #[serde(rename = "attachments")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attachments: &'a Option<Vec<crate::__types::message_object::attachments::Item>>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
        }
        let Self {
            id,
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        } = self;
        MessageObject {
            id,
            object: &Default::default(),
            created_at,
            thread_id,
            status,
            incomplete_details,
            completed_at,
            incomplete_at,
            role,
            content,
            assistant_id,
            run_id,
            attachments,
            metadata,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod message_request_content_text_object {
    #[doc = "Always `text`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "text");
}
#[doc = "The text content that is part of a message."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct MessageRequestContentTextObject {
    #[doc = "Text content to be sent to the model"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for MessageRequestContentTextObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct MessageRequestContentTextObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::message_request_content_text_object::Type,
            #[serde(rename = "text")]
            text: String,
        }
        let MessageRequestContentTextObject { text, .. } =
            MessageRequestContentTextObject::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for MessageRequestContentTextObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct MessageRequestContentTextObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::message_request_content_text_object::Type,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        MessageRequestContentTextObject {
            r#type: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod message_stream_event {
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_message_created {
        #[doc = "thread.message.created"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.message.created");
    }
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is created."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadMessageCreated {
        pub data: crate::__types::MessageObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadMessageCreated {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadMessageCreated {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::message_stream_event::thread_message_created::Event,
                #[serde(rename = "data")]
                data: crate::__types::MessageObject,
            }
            let ThreadMessageCreated { data, .. } =
                ThreadMessageCreated::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadMessageCreated {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadMessageCreated<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::message_stream_event::thread_message_created::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::MessageObject,
            }
            let Self { data } = self;
            ThreadMessageCreated {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_message_in_progress {
        #[doc = "thread.message.in_progress"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.message.in_progress");
    }
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) moves to an `in_progress` state."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadMessageInProgress {
        pub data: crate::__types::MessageObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadMessageInProgress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadMessageInProgress {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::message_stream_event::thread_message_in_progress::Event,
                #[serde(rename = "data")]
                data: crate::__types::MessageObject,
            }
            let ThreadMessageInProgress { data, .. } =
                ThreadMessageInProgress::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadMessageInProgress {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadMessageInProgress<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::message_stream_event::thread_message_in_progress::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::MessageObject,
            }
            let Self { data } = self;
            ThreadMessageInProgress {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_message_delta {
        #[doc = "thread.message.delta"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.message.delta");
    }
    #[doc = "Occurs when parts of a [Message](https://platform.openai.com/docs/api-reference/messages/object) are being streamed."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadMessageDelta {
        pub data: crate::__types::MessageDeltaObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadMessageDelta {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadMessageDelta {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::message_stream_event::thread_message_delta::Event,
                #[serde(rename = "data")]
                data: crate::__types::MessageDeltaObject,
            }
            let ThreadMessageDelta { data, .. } = ThreadMessageDelta::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadMessageDelta {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadMessageDelta<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::message_stream_event::thread_message_delta::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::MessageDeltaObject,
            }
            let Self { data } = self;
            ThreadMessageDelta {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_message_completed {
        #[doc = "thread.message.completed"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.message.completed");
    }
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is completed."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadMessageCompleted {
        pub data: crate::__types::MessageObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadMessageCompleted {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadMessageCompleted {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::message_stream_event::thread_message_completed::Event,
                #[serde(rename = "data")]
                data: crate::__types::MessageObject,
            }
            let ThreadMessageCompleted { data, .. } =
                ThreadMessageCompleted::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadMessageCompleted {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadMessageCompleted<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::message_stream_event::thread_message_completed::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::MessageObject,
            }
            let Self { data } = self;
            ThreadMessageCompleted {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_message_incomplete {
        #[doc = "thread.message.incomplete"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.message.incomplete");
    }
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) ends before it is completed."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadMessageIncomplete {
        pub data: crate::__types::MessageObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadMessageIncomplete {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadMessageIncomplete {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::message_stream_event::thread_message_incomplete::Event,
                #[serde(rename = "data")]
                data: crate::__types::MessageObject,
            }
            let ThreadMessageIncomplete { data, .. } =
                ThreadMessageIncomplete::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadMessageIncomplete {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadMessageIncomplete<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::message_stream_event::thread_message_incomplete::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::MessageObject,
            }
            let Self { data } = self;
            ThreadMessageIncomplete {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum MessageStreamEvent {
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is created."]
    ThreadMessageCreated(crate::__types::message_stream_event::ThreadMessageCreated),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) moves to an `in_progress` state."]
    ThreadMessageInProgress(crate::__types::message_stream_event::ThreadMessageInProgress),
    #[doc = "Occurs when parts of a [Message](https://platform.openai.com/docs/api-reference/messages/object) are being streamed."]
    ThreadMessageDelta(crate::__types::message_stream_event::ThreadMessageDelta),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) is completed."]
    ThreadMessageCompleted(crate::__types::message_stream_event::ThreadMessageCompleted),
    #[doc = "Occurs when a [message](https://platform.openai.com/docs/api-reference/messages/object) ends before it is completed."]
    ThreadMessageIncomplete(crate::__types::message_stream_event::ThreadMessageIncomplete),
}
#[doc = "Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. \n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n"]
pub type Metadata = indexmap::IndexMap<String, String>;
#[allow(clippy::module_inception)]
pub(crate) mod model {
    #[doc = "The object type, which is always \"model\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "model");
}
#[doc = "Describes an OpenAI model offering that can be used with the API."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Model {
    #[doc = "The model identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) when the model was created."]
    pub created: i64,
    #[doc = "The organization that owns the model."]
    pub owned_by: String,
}
impl<'de> serde::Deserialize<'de> for Model {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Model {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "created")]
            created: i64,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::model::Object,
            #[serde(rename = "owned_by")]
            owned_by: String,
        }
        let Model {
            id,
            created,
            owned_by,
            ..
        } = Model::deserialize(deserializer)?;
        Ok(Self {
            id,
            created,
            owned_by,
        })
    }
}
impl serde::Serialize for Model {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Model<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created")]
            created: &'a i64,
            #[serde(rename = "object")]
            object: &'a crate::__types::model::Object,
            #[serde(rename = "owned_by")]
            owned_by: &'a String,
        }
        let Self {
            id,
            created,
            owned_by,
        } = self;
        Model {
            id,
            created,
            object: &Default::default(),
            owned_by,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIds {
    ModelIdsShared(crate::__types::ModelIdsShared),
    ModelIdsResponses(crate::__types::ModelIdsResponses),
}
#[allow(clippy::module_inception)]
pub(crate) mod model_ids_responses {
    #[doc = "o1-pro"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct O1Pro;
    impl_serde!(O1Pro, "o1-pro");
    #[doc = "o1-pro-2025-03-19"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct O1Pro2025_03_19;
    impl_serde!(O1Pro2025_03_19, "o1-pro-2025-03-19");
    #[doc = "o3-pro"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct O3Pro;
    impl_serde!(O3Pro, "o3-pro");
    #[doc = "o3-pro-2025-06-10"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct O3Pro2025_06_10;
    impl_serde!(O3Pro2025_06_10, "o3-pro-2025-06-10");
    #[doc = "o3-deep-research"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct O3DeepResearch;
    impl_serde!(O3DeepResearch, "o3-deep-research");
    #[doc = "o3-deep-research-2025-06-26"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct O3DeepResearch2025_06_26;
    impl_serde!(O3DeepResearch2025_06_26, "o3-deep-research-2025-06-26");
    #[doc = "o4-mini-deep-research"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct O4MiniDeepResearch;
    impl_serde!(O4MiniDeepResearch, "o4-mini-deep-research");
    #[doc = "o4-mini-deep-research-2025-06-26"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct O4MiniDeepResearch2025_06_26;
    impl_serde!(
        O4MiniDeepResearch2025_06_26,
        "o4-mini-deep-research-2025-06-26"
    );
    #[doc = "computer-use-preview"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct ComputerUsePreview;
    impl_serde!(ComputerUsePreview, "computer-use-preview");
    #[doc = "computer-use-preview-2025-03-11"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct ComputerUsePreview2025_03_11;
    impl_serde!(
        ComputerUsePreview2025_03_11,
        "computer-use-preview-2025-03-11"
    );
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIdsResponses {
    ModelIdsShared(crate::__types::ModelIdsShared),
    #[doc = "o1-pro"]
    O1Pro,
    #[doc = "o1-pro-2025-03-19"]
    O1Pro2025_03_19,
    #[doc = "o3-pro"]
    O3Pro,
    #[doc = "o3-pro-2025-06-10"]
    O3Pro2025_06_10,
    #[doc = "o3-deep-research"]
    O3DeepResearch,
    #[doc = "o3-deep-research-2025-06-26"]
    O3DeepResearch2025_06_26,
    #[doc = "o4-mini-deep-research"]
    O4MiniDeepResearch,
    #[doc = "o4-mini-deep-research-2025-06-26"]
    O4MiniDeepResearch2025_06_26,
    #[doc = "computer-use-preview"]
    ComputerUsePreview,
    #[doc = "computer-use-preview-2025-03-11"]
    ComputerUsePreview2025_03_11,
}
impl<'de> serde::Deserialize<'de> for ModelIdsResponses {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ModelIdsResponses {
            O1Pro(crate::__types::model_ids_responses::O1Pro),
            O1Pro2025_03_19(crate::__types::model_ids_responses::O1Pro2025_03_19),
            O3Pro(crate::__types::model_ids_responses::O3Pro),
            O3Pro2025_06_10(crate::__types::model_ids_responses::O3Pro2025_06_10),
            O3DeepResearch(crate::__types::model_ids_responses::O3DeepResearch),
            O3DeepResearch2025_06_26(crate::__types::model_ids_responses::O3DeepResearch2025_06_26),
            O4MiniDeepResearch(crate::__types::model_ids_responses::O4MiniDeepResearch),
            O4MiniDeepResearch2025_06_26(
                crate::__types::model_ids_responses::O4MiniDeepResearch2025_06_26,
            ),
            ComputerUsePreview(crate::__types::model_ids_responses::ComputerUsePreview),
            ComputerUsePreview2025_03_11(
                crate::__types::model_ids_responses::ComputerUsePreview2025_03_11,
            ),
            ModelIdsShared(crate::__types::ModelIdsShared),
        }
        Ok(match ModelIdsResponses::deserialize(deserializer)? {
            ModelIdsResponses::ModelIdsShared(v) => Self::ModelIdsShared(v),
            ModelIdsResponses::O1Pro(_) => Self::O1Pro,
            ModelIdsResponses::O1Pro2025_03_19(_) => Self::O1Pro2025_03_19,
            ModelIdsResponses::O3Pro(_) => Self::O3Pro,
            ModelIdsResponses::O3Pro2025_06_10(_) => Self::O3Pro2025_06_10,
            ModelIdsResponses::O3DeepResearch(_) => Self::O3DeepResearch,
            ModelIdsResponses::O3DeepResearch2025_06_26(_) => Self::O3DeepResearch2025_06_26,
            ModelIdsResponses::O4MiniDeepResearch(_) => Self::O4MiniDeepResearch,
            ModelIdsResponses::O4MiniDeepResearch2025_06_26(_) => {
                Self::O4MiniDeepResearch2025_06_26
            }
            ModelIdsResponses::ComputerUsePreview(_) => Self::ComputerUsePreview,
            ModelIdsResponses::ComputerUsePreview2025_03_11(_) => {
                Self::ComputerUsePreview2025_03_11
            }
        })
    }
}
impl serde::Serialize for ModelIdsResponses {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ModelIdsResponses<'a> {
            ModelIdsShared(&'a crate::__types::ModelIdsShared),
            O1Pro(crate::__types::model_ids_responses::O1Pro),
            O1Pro2025_03_19(crate::__types::model_ids_responses::O1Pro2025_03_19),
            O3Pro(crate::__types::model_ids_responses::O3Pro),
            O3Pro2025_06_10(crate::__types::model_ids_responses::O3Pro2025_06_10),
            O3DeepResearch(crate::__types::model_ids_responses::O3DeepResearch),
            O3DeepResearch2025_06_26(crate::__types::model_ids_responses::O3DeepResearch2025_06_26),
            O4MiniDeepResearch(crate::__types::model_ids_responses::O4MiniDeepResearch),
            O4MiniDeepResearch2025_06_26(
                crate::__types::model_ids_responses::O4MiniDeepResearch2025_06_26,
            ),
            ComputerUsePreview(crate::__types::model_ids_responses::ComputerUsePreview),
            ComputerUsePreview2025_03_11(
                crate::__types::model_ids_responses::ComputerUsePreview2025_03_11,
            ),
        }
        match self {
            Self::ModelIdsShared(v) => ModelIdsResponses::ModelIdsShared(v),
            Self::O1Pro => ModelIdsResponses::O1Pro(Default::default()),
            Self::O1Pro2025_03_19 => ModelIdsResponses::O1Pro2025_03_19(Default::default()),
            Self::O3Pro => ModelIdsResponses::O3Pro(Default::default()),
            Self::O3Pro2025_06_10 => ModelIdsResponses::O3Pro2025_06_10(Default::default()),
            Self::O3DeepResearch => ModelIdsResponses::O3DeepResearch(Default::default()),
            Self::O3DeepResearch2025_06_26 => {
                ModelIdsResponses::O3DeepResearch2025_06_26(Default::default())
            }
            Self::O4MiniDeepResearch => ModelIdsResponses::O4MiniDeepResearch(Default::default()),
            Self::O4MiniDeepResearch2025_06_26 => {
                ModelIdsResponses::O4MiniDeepResearch2025_06_26(Default::default())
            }
            Self::ComputerUsePreview => ModelIdsResponses::ComputerUsePreview(Default::default()),
            Self::ComputerUsePreview2025_03_11 => {
                ModelIdsResponses::ComputerUsePreview2025_03_11(Default::default())
            }
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum ModelIdsShared {
    Other(String),
    ChatModel(crate::__types::ChatModel),
}
impl<'de> serde::Deserialize<'de> for ModelIdsShared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum ModelIdsShared {
            ChatModel(crate::__types::ChatModel),
            Other(String),
        }
        Ok(match ModelIdsShared::deserialize(deserializer)? {
            ModelIdsShared::Other(v) => Self::Other(v),
            ModelIdsShared::ChatModel(v) => Self::ChatModel(v),
        })
    }
}
impl serde::Serialize for ModelIdsShared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum ModelIdsShared<'a> {
            Other(&'a String),
            ChatModel(&'a crate::__types::ChatModel),
        }
        match self {
            Self::Other(v) => ModelIdsShared::Other(v),
            Self::ChatModel(v) => ModelIdsShared::ChatModel(v),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod model_response_properties {
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Text {
        #[serde(rename = "verbosity")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub verbosity: Option<crate::__types::Verbosity>,
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ModelResponseProperties {
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<crate::__types::model_response_properties::Text>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"]
    #[serde(rename = "top_logprobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_logprobs: Option<i64>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users. \nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[serde(rename = "user")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user: Option<String>,
    #[doc = "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. \nThe IDs should be a string that uniquely identifies each user. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[serde(rename = "safety_identifier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub safety_identifier: Option<String>,
    #[doc = "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](https://platform.openai.com/docs/guides/prompt-caching).\n"]
    #[serde(rename = "prompt_cache_key")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt_cache_key: Option<String>,
    #[serde(rename = "service_tier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub service_tier: Option<crate::__types::ServiceTier>,
}
#[allow(clippy::module_inception)]
pub mod modify_assistant_request {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        AssistantSupportedModels(crate::__types::AssistantSupportedModels),
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                AssistantSupportedModels(crate::__types::AssistantSupportedModels),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::AssistantSupportedModels(v) => Self::AssistantSupportedModels(v),
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                AssistantSupportedModels(&'a crate::__types::AssistantSupportedModels),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::AssistantSupportedModels(v) => Model::AssistantSupportedModels(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod tool_resources {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct CodeInterpreter {
            #[doc = "Overrides the list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_ids: Option<Vec<String>>,
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct FileSearch {
            #[doc = "Overrides the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub vector_store_ids: Option<Vec<String>>,
        }
    }
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ToolResources {
        #[serde(rename = "code_interpreter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code_interpreter:
            Option<crate::__types::modify_assistant_request::tool_resources::CodeInterpreter>,
        #[serde(rename = "file_search")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_search:
            Option<crate::__types::modify_assistant_request::tool_resources::FileSearch>,
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ModifyAssistantRequest {
    #[doc = "ID of the model to use. You can use the [List models](https://platform.openai.com/docs/api-reference/models/list) API to see all of your available models, or see our [Model overview](https://platform.openai.com/docs/models) for descriptions of them.\n"]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::modify_assistant_request::Model>,
    #[serde(rename = "reasoning_effort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reasoning_effort: Option<crate::__types::ReasoningEffort>,
    #[doc = "The name of the assistant. The maximum length is 256 characters.\n"]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The description of the assistant. The maximum length is 512 characters.\n"]
    #[serde(rename = "description")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The system instructions that the assistant uses. The maximum length is 256,000 characters.\n"]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "A list of tool enabled on the assistant. There can be a maximum of 128 tools per assistant. Tools can be of types `code_interpreter`, `file_search`, or `function`.\n"]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::AssistantTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[serde(rename = "tool_resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_resources: Option<crate::__types::modify_assistant_request::ToolResources>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ModifyCertificateRequest {
    #[doc = "The updated name for the certificate"]
    #[serde(rename = "name")]
    pub name: String,
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ModifyMessageRequest {
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ModifyRunRequest {
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
#[allow(clippy::module_inception)]
pub mod modify_thread_request {
    #[allow(clippy::module_inception)]
    pub mod tool_resources {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct CodeInterpreter {
            #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_ids: Option<Vec<String>>,
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct FileSearch {
            #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub vector_store_ids: Option<Vec<String>>,
        }
    }
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ToolResources {
        #[serde(rename = "code_interpreter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code_interpreter:
            Option<crate::__types::modify_thread_request::tool_resources::CodeInterpreter>,
        #[serde(rename = "file_search")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_search: Option<crate::__types::modify_thread_request::tool_resources::FileSearch>,
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ModifyThreadRequest {
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[serde(rename = "tool_resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_resources: Option<crate::__types::modify_thread_request::ToolResources>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
#[allow(clippy::module_inception)]
pub(crate) mod r#move {
    #[doc = "Specifies the event type. For a move action, this property is \nalways set to `move`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "move");
}
#[doc = "A mouse move action.\n"]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Move {
    #[doc = "The x-coordinate to move to.\n"]
    pub x: i64,
    #[doc = "The y-coordinate to move to.\n"]
    pub y: i64,
}
impl<'de> serde::Deserialize<'de> for Move {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Move {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::r#move::Type,
            #[serde(rename = "x")]
            x: i64,
            #[serde(rename = "y")]
            y: i64,
        }
        let Move { x, y, .. } = Move::deserialize(deserializer)?;
        Ok(Self { x, y })
    }
}
impl serde::Serialize for Move {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Move<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::r#move::Type,
            #[serde(rename = "x")]
            x: &'a i64,
            #[serde(rename = "y")]
            y: &'a i64,
        }
        let Self { x, y } = self;
        Move {
            r#type: &Default::default(),
            x,
            y,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod open_ai_file {
    #[doc = "The object type, which is always `file`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "file");
    #[doc = "The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results`, `vision`, and `user_data`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Purpose {
        #[doc = "`assistants`"]
        #[serde(rename = "assistants")]
        Assistants,
        #[doc = "`assistants_output`"]
        #[serde(rename = "assistants_output")]
        AssistantsOutput,
        #[doc = "`batch`"]
        #[serde(rename = "batch")]
        Batch,
        #[doc = "`batch_output`"]
        #[serde(rename = "batch_output")]
        BatchOutput,
        #[doc = "`fine-tune`"]
        #[serde(rename = "fine-tune")]
        FineTune,
        #[doc = "`fine-tune-results`"]
        #[serde(rename = "fine-tune-results")]
        FineTuneResults,
        #[doc = "`vision`"]
        #[serde(rename = "vision")]
        Vision,
        #[doc = "`user_data`"]
        #[serde(rename = "user_data")]
        UserData,
    }
    #[doc = "Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`uploaded`"]
        #[serde(rename = "uploaded")]
        Uploaded,
        #[doc = "`processed`"]
        #[serde(rename = "processed")]
        Processed,
        #[doc = "`error`"]
        #[serde(rename = "error")]
        Error,
    }
}
#[doc = "The `File` object represents a document that has been uploaded to OpenAI."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OpenAiFile {
    #[doc = "The file identifier, which can be referenced in the API endpoints."]
    pub id: String,
    #[doc = "The size of the file, in bytes."]
    pub bytes: i64,
    #[doc = "The Unix timestamp (in seconds) for when the file was created."]
    pub created_at: i64,
    #[doc = "The Unix timestamp (in seconds) for when the file will expire."]
    #[builder(default)]
    pub expires_at: Option<i64>,
    #[doc = "The name of the file."]
    pub filename: String,
    #[doc = "The intended purpose of the file. Supported values are `assistants`, `assistants_output`, `batch`, `batch_output`, `fine-tune`, `fine-tune-results`, `vision`, and `user_data`."]
    pub purpose: crate::__types::open_ai_file::Purpose,
    #[doc = "Deprecated. The current status of the file, which can be either `uploaded`, `processed`, or `error`."]
    pub status: crate::__types::open_ai_file::Status,
    #[doc = "Deprecated. For details on why a fine-tuning training file failed validation, see the `error` field on `fine_tuning.job`."]
    #[builder(default)]
    pub status_details: Option<String>,
}
impl<'de> serde::Deserialize<'de> for OpenAiFile {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OpenAiFile {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "bytes")]
            bytes: i64,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "expires_at")]
            expires_at: Option<i64>,
            #[serde(rename = "filename")]
            filename: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::open_ai_file::Object,
            #[serde(rename = "purpose")]
            purpose: crate::__types::open_ai_file::Purpose,
            #[serde(rename = "status")]
            status: crate::__types::open_ai_file::Status,
            #[serde(rename = "status_details")]
            status_details: Option<String>,
        }
        let OpenAiFile {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
            ..
        } = OpenAiFile::deserialize(deserializer)?;
        Ok(Self {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
        })
    }
}
impl serde::Serialize for OpenAiFile {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OpenAiFile<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "bytes")]
            bytes: &'a i64,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<i64>,
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::open_ai_file::Object,
            #[serde(rename = "purpose")]
            purpose: &'a crate::__types::open_ai_file::Purpose,
            #[serde(rename = "status")]
            status: &'a crate::__types::open_ai_file::Status,
            #[serde(rename = "status_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status_details: &'a Option<String>,
        }
        let Self {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            purpose,
            status,
            status_details,
        } = self;
        OpenAiFile {
            id,
            bytes,
            created_at,
            expires_at,
            filename,
            object: &Default::default(),
            purpose,
            status,
            status_details,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod other_chunking_strategy_response_param {
    #[doc = "Always `other`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "other");
}
#[doc = "This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API."]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct OtherChunkingStrategyResponseParam {}
impl<'de> serde::Deserialize<'de> for OtherChunkingStrategyResponseParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OtherChunkingStrategyResponseParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::other_chunking_strategy_response_param::Type,
        }
        let OtherChunkingStrategyResponseParam { .. } =
            OtherChunkingStrategyResponseParam::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for OtherChunkingStrategyResponseParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OtherChunkingStrategyResponseParam<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::other_chunking_strategy_response_param::Type,
        }
        let Self {} = self;
        OtherChunkingStrategyResponseParam {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod output_audio {
    #[doc = "The type of the output audio. Always `output_audio`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "output_audio");
}
#[doc = "An audio output from the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputAudio {
    #[doc = "Base64-encoded audio data from the model.\n"]
    pub data: String,
    #[doc = "The transcript of the audio data from the model.\n"]
    pub transcript: String,
}
impl<'de> serde::Deserialize<'de> for OutputAudio {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OutputAudio {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::output_audio::Type,
            #[serde(rename = "data")]
            data: String,
            #[serde(rename = "transcript")]
            transcript: String,
        }
        let OutputAudio {
            data, transcript, ..
        } = OutputAudio::deserialize(deserializer)?;
        Ok(Self { data, transcript })
    }
}
impl serde::Serialize for OutputAudio {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OutputAudio<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::output_audio::Type,
            #[serde(rename = "data")]
            data: &'a String,
            #[serde(rename = "transcript")]
            transcript: &'a String,
        }
        let Self { data, transcript } = self;
        OutputAudio {
            r#type: &Default::default(),
            data,
            transcript,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum OutputContent {
    OutputText(crate::__types::OutputTextContent),
    Refusal(crate::__types::RefusalContent),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum OutputItem {
    Message(crate::__types::OutputMessage),
    FileSearchCall(crate::__types::FileSearchToolCall),
    FunctionCall(crate::__types::FunctionToolCall),
    WebSearchCall(crate::__types::WebSearchToolCall),
    ComputerCall(crate::__types::ComputerToolCall),
    Reasoning(crate::__types::ReasoningItem),
    ImageGenerationCall(crate::__types::ImageGenToolCall),
    CodeInterpreterCall(crate::__types::CodeInterpreterToolCall),
    LocalShellCall(crate::__types::LocalShellToolCall),
    McpCall(crate::__types::McpToolCall),
    McpListTools(crate::__types::McpListTools),
    McpApprovalRequest(crate::__types::McpApprovalRequest),
    CustomToolCall(crate::__types::CustomToolCall),
}
#[allow(clippy::module_inception)]
pub mod output_message {
    #[doc = "The type of the output message. Always `message`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "message");
    #[doc = "The role of the output message. Always `assistant`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "assistant");
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "An output message from the model.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputMessage {
    #[doc = "The unique ID of the output message.\n"]
    pub id: String,
    #[doc = "The content of the output message.\n"]
    pub content: Vec<crate::__types::OutputContent>,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n"]
    pub status: crate::__types::output_message::Status,
}
impl<'de> serde::Deserialize<'de> for OutputMessage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OutputMessage {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::output_message::Type,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::output_message::Role,
            #[serde(rename = "content")]
            content: Vec<crate::__types::OutputContent>,
            #[serde(rename = "status")]
            status: crate::__types::output_message::Status,
        }
        let OutputMessage {
            id,
            content,
            status,
            ..
        } = OutputMessage::deserialize(deserializer)?;
        Ok(Self {
            id,
            content,
            status,
        })
    }
}
impl serde::Serialize for OutputMessage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OutputMessage<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::output_message::Type,
            #[serde(rename = "role")]
            role: &'a crate::__types::output_message::Role,
            #[serde(rename = "content")]
            content: &'a Vec<crate::__types::OutputContent>,
            #[serde(rename = "status")]
            status: &'a crate::__types::output_message::Status,
        }
        let Self {
            id,
            content,
            status,
        } = self;
        OutputMessage {
            id,
            r#type: &Default::default(),
            role: &Default::default(),
            content,
            status,
        }
        .serialize(serializer)
    }
}
#[doc = "Whether to enable [parallel function calling](https://platform.openai.com/docs/guides/function-calling#configuring-parallel-function-calling) during tool use."]
pub type ParallelToolCalls = bool;
#[doc = "The number of partial images to generate. This parameter is used for\nstreaming responses that return partial images. Value must be between 0 and 3.\nWhen set to 0, the response will be a single image sent in one streaming event.\n\nNote that the final image may be sent before the full number of partial images \nare generated if the full image is generated more quickly.\n"]
pub type PartialImages = i64;
#[allow(clippy::module_inception)]
pub mod prediction_content {
    #[doc = "The type of the predicted content you want to provide. This type is\ncurrently always `content`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "content");
    #[doc = "The content that should be matched when generating a model response.\nIf generated tokens would match this content, the entire model response\ncan be returned much more quickly.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Content {
        #[doc = "The content used for a Predicted Output. This is often the\ntext of a file you are regenerating with minor changes.\n"]
        String(String),
        #[doc = "An array of content parts with a defined type. Supported options differ based on the [model](https://platform.openai.com/docs/models) being used to generate the response. Can contain text inputs."]
        Array(Vec<crate::__types::ChatCompletionRequestMessageContentPartText>),
    }
}
#[doc = "Static predicted output content, such as the content of a text file that is\nbeing regenerated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct PredictionContent {
    #[doc = "The content that should be matched when generating a model response.\nIf generated tokens would match this content, the entire model response\ncan be returned much more quickly.\n"]
    pub content: crate::__types::prediction_content::Content,
}
impl<'de> serde::Deserialize<'de> for PredictionContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct PredictionContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::prediction_content::Type,
            #[serde(rename = "content")]
            content: crate::__types::prediction_content::Content,
        }
        let PredictionContent { content, .. } = PredictionContent::deserialize(deserializer)?;
        Ok(Self { content })
    }
}
impl serde::Serialize for PredictionContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct PredictionContent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::prediction_content::Type,
            #[serde(rename = "content")]
            content: &'a crate::__types::prediction_content::Content,
        }
        let Self { content } = self;
        PredictionContent {
            r#type: &Default::default(),
            content,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod project {
    #[doc = "The object type, which is always `organization.project`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project");
    #[doc = "`active` or `archived`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`active`"]
        #[serde(rename = "active")]
        Active,
        #[doc = "`archived`"]
        #[serde(rename = "archived")]
        Archived,
    }
}
#[doc = "Represents an individual project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Project {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the project. This appears in reporting."]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the project was created."]
    pub created_at: i64,
    #[doc = "The Unix timestamp (in seconds) of when the project was archived or `null`."]
    #[builder(default)]
    pub archived_at: Option<i64>,
    #[doc = "`active` or `archived`"]
    pub status: crate::__types::project::Status,
}
impl<'de> serde::Deserialize<'de> for Project {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Project {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project::Object,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "archived_at")]
            archived_at: Option<i64>,
            #[serde(rename = "status")]
            status: crate::__types::project::Status,
        }
        let Project {
            id,
            name,
            created_at,
            archived_at,
            status,
            ..
        } = Project::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            created_at,
            archived_at,
            status,
        })
    }
}
impl serde::Serialize for Project {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Project<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::project::Object,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "archived_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            archived_at: &'a Option<i64>,
            #[serde(rename = "status")]
            status: &'a crate::__types::project::Status,
        }
        let Self {
            id,
            name,
            created_at,
            archived_at,
            status,
        } = self;
        Project {
            id,
            object: &Default::default(),
            name,
            created_at,
            archived_at,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod project_api_key {
    #[doc = "The object type, which is always `organization.project.api_key`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project.api_key");
    #[allow(clippy::module_inception)]
    pub mod owner {
        #[doc = "`user` or `service_account`"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Type {
            #[doc = "`user`"]
            #[serde(rename = "user")]
            User,
            #[doc = "`service_account`"]
            #[serde(rename = "service_account")]
            ServiceAccount,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Owner {
        #[doc = "`user` or `service_account`"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<crate::__types::project_api_key::owner::Type>,
        #[serde(rename = "user")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub user: Option<crate::__types::ProjectUser>,
        #[serde(rename = "service_account")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub service_account: Option<crate::__types::ProjectServiceAccount>,
    }
}
#[doc = "Represents an individual API key in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKey {
    #[doc = "The redacted value of the API key"]
    pub redacted_value: String,
    #[doc = "The name of the API key"]
    pub name: String,
    #[doc = "The Unix timestamp (in seconds) of when the API key was created"]
    pub created_at: i64,
    #[doc = "The Unix timestamp (in seconds) of when the API key was last used."]
    pub last_used_at: i64,
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[builder(default)]
    pub owner: crate::__types::project_api_key::Owner,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectApiKey {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_api_key::Object,
            #[serde(rename = "redacted_value")]
            redacted_value: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "last_used_at")]
            last_used_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "owner")]
            owner: crate::__types::project_api_key::Owner,
        }
        let ProjectApiKey {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
            ..
        } = ProjectApiKey::deserialize(deserializer)?;
        Ok(Self {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        })
    }
}
impl serde::Serialize for ProjectApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectApiKey<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_api_key::Object,
            #[serde(rename = "redacted_value")]
            redacted_value: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "last_used_at")]
            last_used_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "owner")]
            owner: &'a crate::__types::project_api_key::Owner,
        }
        let Self {
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        } = self;
        ProjectApiKey {
            object: &Default::default(),
            redacted_value,
            name,
            created_at,
            last_used_at,
            id,
            owner,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod project_api_key_delete_response {
    #[doc = "organization.project.api_key.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project.api_key.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKeyDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectApiKeyDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_api_key_delete_response::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
        }
        let ProjectApiKeyDeleteResponse { id, deleted, .. } =
            ProjectApiKeyDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for ProjectApiKeyDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectApiKeyDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_api_key_delete_response::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        ProjectApiKeyDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod project_api_key_list_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectApiKeyListResponse {
    pub data: Vec<crate::__types::ProjectApiKey>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectApiKeyListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectApiKeyListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_api_key_list_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::ProjectApiKey>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ProjectApiKeyListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectApiKeyListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectApiKeyListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectApiKeyListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_api_key_list_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::ProjectApiKey>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectApiKeyListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ProjectCreateRequest {
    #[doc = "The friendly name of the project, this name appears in reports."]
    #[serde(rename = "name")]
    pub name: String,
}
#[allow(clippy::module_inception)]
pub(crate) mod project_list_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectListResponse {
    pub data: Vec<crate::__types::Project>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_list_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::Project>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ProjectListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_list_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::Project>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod project_rate_limit {
    #[doc = "The object type, which is always `project.rate_limit`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "project.rate_limit");
}
#[doc = "Represents a project rate limit config."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimit {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The model this rate limit applies to."]
    pub model: String,
    #[doc = "The maximum requests per minute."]
    pub max_requests_per_1_minute: i64,
    #[doc = "The maximum tokens per minute."]
    pub max_tokens_per_1_minute: i64,
    #[doc = "The maximum images per minute. Only present for relevant models."]
    #[builder(default)]
    pub max_images_per_1_minute: Option<i64>,
    #[doc = "The maximum audio megabytes per minute. Only present for relevant models."]
    #[builder(default)]
    pub max_audio_megabytes_per_1_minute: Option<i64>,
    #[doc = "The maximum requests per day. Only present for relevant models."]
    #[builder(default)]
    pub max_requests_per_1_day: Option<i64>,
    #[doc = "The maximum batch input tokens per day. Only present for relevant models."]
    #[builder(default)]
    pub batch_1_day_max_input_tokens: Option<i64>,
}
impl<'de> serde::Deserialize<'de> for ProjectRateLimit {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectRateLimit {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_rate_limit::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "max_requests_per_1_minute")]
            max_requests_per_1_minute: i64,
            #[serde(rename = "max_tokens_per_1_minute")]
            max_tokens_per_1_minute: i64,
            #[serde(rename = "max_images_per_1_minute")]
            max_images_per_1_minute: Option<i64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            max_audio_megabytes_per_1_minute: Option<i64>,
            #[serde(rename = "max_requests_per_1_day")]
            max_requests_per_1_day: Option<i64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            batch_1_day_max_input_tokens: Option<i64>,
        }
        let ProjectRateLimit {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
            ..
        } = ProjectRateLimit::deserialize(deserializer)?;
        Ok(Self {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        })
    }
}
impl serde::Serialize for ProjectRateLimit {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectRateLimit<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_rate_limit::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "max_requests_per_1_minute")]
            max_requests_per_1_minute: &'a i64,
            #[serde(rename = "max_tokens_per_1_minute")]
            max_tokens_per_1_minute: &'a i64,
            #[serde(rename = "max_images_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_images_per_1_minute: &'a Option<i64>,
            #[serde(rename = "max_audio_megabytes_per_1_minute")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_audio_megabytes_per_1_minute: &'a Option<i64>,
            #[serde(rename = "max_requests_per_1_day")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_requests_per_1_day: &'a Option<i64>,
            #[serde(rename = "batch_1_day_max_input_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch_1_day_max_input_tokens: &'a Option<i64>,
        }
        let Self {
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        } = self;
        ProjectRateLimit {
            object: &Default::default(),
            id,
            model,
            max_requests_per_1_minute,
            max_tokens_per_1_minute,
            max_images_per_1_minute,
            max_audio_megabytes_per_1_minute,
            max_requests_per_1_day,
            batch_1_day_max_input_tokens,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod project_rate_limit_list_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimitListResponse {
    pub data: Vec<crate::__types::ProjectRateLimit>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectRateLimitListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectRateLimitListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_rate_limit_list_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::ProjectRateLimit>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ProjectRateLimitListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectRateLimitListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectRateLimitListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectRateLimitListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_rate_limit_list_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::ProjectRateLimit>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectRateLimitListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Copy, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ProjectRateLimitUpdateRequest {
    #[doc = "The maximum requests per minute."]
    #[serde(rename = "max_requests_per_1_minute")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_requests_per_1_minute: Option<i64>,
    #[doc = "The maximum tokens per minute."]
    #[serde(rename = "max_tokens_per_1_minute")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_tokens_per_1_minute: Option<i64>,
    #[doc = "The maximum images per minute. Only relevant for certain models."]
    #[serde(rename = "max_images_per_1_minute")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_images_per_1_minute: Option<i64>,
    #[doc = "The maximum audio megabytes per minute. Only relevant for certain models."]
    #[serde(rename = "max_audio_megabytes_per_1_minute")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_audio_megabytes_per_1_minute: Option<i64>,
    #[doc = "The maximum requests per day. Only relevant for certain models."]
    #[serde(rename = "max_requests_per_1_day")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_requests_per_1_day: Option<i64>,
    #[doc = "The maximum batch input tokens per day. Only relevant for certain models."]
    #[serde(rename = "batch_1_day_max_input_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub batch_1_day_max_input_tokens: Option<i64>,
}
#[allow(clippy::module_inception)]
pub mod project_service_account {
    #[doc = "The object type, which is always `organization.project.service_account`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project.service_account");
    #[doc = "`owner` or `member`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`owner`"]
        #[serde(rename = "owner")]
        Owner,
        #[doc = "`member`"]
        #[serde(rename = "member")]
        Member,
    }
}
#[doc = "Represents an individual service account in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccount {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the service account"]
    pub name: String,
    #[doc = "`owner` or `member`"]
    pub role: crate::__types::project_service_account::Role,
    #[doc = "The Unix timestamp (in seconds) of when the service account was created"]
    pub created_at: i64,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccount {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccount {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_service_account::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "role")]
            role: crate::__types::project_service_account::Role,
            #[serde(rename = "created_at")]
            created_at: i64,
        }
        let ProjectServiceAccount {
            id,
            name,
            role,
            created_at,
            ..
        } = ProjectServiceAccount::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            role,
            created_at,
        })
    }
}
impl serde::Serialize for ProjectServiceAccount {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccount<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_service_account::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "role")]
            role: &'a crate::__types::project_service_account::Role,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
        }
        let Self {
            id,
            name,
            role,
            created_at,
        } = self;
        ProjectServiceAccount {
            object: &Default::default(),
            id,
            name,
            role,
            created_at,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod project_service_account_api_key {
    #[doc = "The object type, which is always `organization.project.service_account.api_key`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project.service_account.api_key");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountApiKey {
    pub value: String,
    pub name: String,
    pub created_at: i64,
    pub id: String,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountApiKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountApiKey {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_service_account_api_key::Object,
            #[serde(rename = "value")]
            value: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
        }
        let ProjectServiceAccountApiKey {
            value,
            name,
            created_at,
            id,
            ..
        } = ProjectServiceAccountApiKey::deserialize(deserializer)?;
        Ok(Self {
            value,
            name,
            created_at,
            id,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountApiKey {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountApiKey<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_service_account_api_key::Object,
            #[serde(rename = "value")]
            value: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
        }
        let Self {
            value,
            name,
            created_at,
            id,
        } = self;
        ProjectServiceAccountApiKey {
            object: &Default::default(),
            value,
            name,
            created_at,
            id,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountCreateRequest {
    #[doc = "The name of the service account being created."]
    #[serde(rename = "name")]
    pub name: String,
}
#[allow(clippy::module_inception)]
pub(crate) mod project_service_account_create_response {
    #[doc = "organization.project.service_account"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project.service_account");
    #[doc = "Service accounts can only have one role of type `member`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Role;
    impl_serde!(Role, "member");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountCreateResponse {
    pub id: String,
    pub name: String,
    pub created_at: i64,
    pub api_key: crate::__types::ProjectServiceAccountApiKey,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountCreateResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountCreateResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_service_account_create_response::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "role")]
            #[allow(dead_code)]
            role: crate::__types::project_service_account_create_response::Role,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "api_key")]
            api_key: crate::__types::ProjectServiceAccountApiKey,
        }
        let ProjectServiceAccountCreateResponse {
            id,
            name,
            created_at,
            api_key,
            ..
        } = ProjectServiceAccountCreateResponse::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            created_at,
            api_key,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountCreateResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountCreateResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_service_account_create_response::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "role")]
            role: &'a crate::__types::project_service_account_create_response::Role,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "api_key")]
            api_key: &'a crate::__types::ProjectServiceAccountApiKey,
        }
        let Self {
            id,
            name,
            created_at,
            api_key,
        } = self;
        ProjectServiceAccountCreateResponse {
            object: &Default::default(),
            id,
            name,
            role: &Default::default(),
            created_at,
            api_key,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod project_service_account_delete_response {
    #[doc = "organization.project.service_account.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project.service_account.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_service_account_delete_response::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
        }
        let ProjectServiceAccountDeleteResponse { id, deleted, .. } =
            ProjectServiceAccountDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for ProjectServiceAccountDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_service_account_delete_response::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        ProjectServiceAccountDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod project_service_account_list_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectServiceAccountListResponse {
    pub data: Vec<crate::__types::ProjectServiceAccount>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectServiceAccountListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectServiceAccountListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_service_account_list_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::ProjectServiceAccount>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let ProjectServiceAccountListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = ProjectServiceAccountListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for ProjectServiceAccountListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectServiceAccountListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_service_account_list_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::ProjectServiceAccount>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        ProjectServiceAccountListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ProjectUpdateRequest {
    #[doc = "The updated name of the project, this name appears in reports."]
    #[serde(rename = "name")]
    pub name: String,
}
#[allow(clippy::module_inception)]
pub mod project_user {
    #[doc = "The object type, which is always `organization.project.user`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project.user");
    #[doc = "`owner` or `member`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`owner`"]
        #[serde(rename = "owner")]
        Owner,
        #[doc = "`member`"]
        #[serde(rename = "member")]
        Member,
    }
}
#[doc = "Represents an individual user in a project."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUser {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the user"]
    pub name: String,
    #[doc = "The email address of the user"]
    pub email: String,
    #[doc = "`owner` or `member`"]
    pub role: crate::__types::project_user::Role,
    #[doc = "The Unix timestamp (in seconds) of when the project was added."]
    pub added_at: i64,
}
impl<'de> serde::Deserialize<'de> for ProjectUser {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectUser {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_user::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "email")]
            email: String,
            #[serde(rename = "role")]
            role: crate::__types::project_user::Role,
            #[serde(rename = "added_at")]
            added_at: i64,
        }
        let ProjectUser {
            id,
            name,
            email,
            role,
            added_at,
            ..
        } = ProjectUser::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            email,
            role,
            added_at,
        })
    }
}
impl serde::Serialize for ProjectUser {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectUser<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_user::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a crate::__types::project_user::Role,
            #[serde(rename = "added_at")]
            added_at: &'a i64,
        }
        let Self {
            id,
            name,
            email,
            role,
            added_at,
        } = self;
        ProjectUser {
            object: &Default::default(),
            id,
            name,
            email,
            role,
            added_at,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod project_user_create_request {
    #[doc = "`owner` or `member`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`owner`"]
        #[serde(rename = "owner")]
        Owner,
        #[doc = "`member`"]
        #[serde(rename = "member")]
        Member,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ProjectUserCreateRequest {
    #[doc = "The ID of the user."]
    #[serde(rename = "user_id")]
    pub user_id: String,
    #[doc = "`owner` or `member`"]
    #[serde(rename = "role")]
    pub role: crate::__types::project_user_create_request::Role,
}
#[allow(clippy::module_inception)]
pub(crate) mod project_user_delete_response {
    #[doc = "organization.project.user.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.project.user.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ProjectUserDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for ProjectUserDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ProjectUserDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::project_user_delete_response::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
        }
        let ProjectUserDeleteResponse { id, deleted, .. } =
            ProjectUserDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for ProjectUserDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ProjectUserDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::project_user_delete_response::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        ProjectUserDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ProjectUserListResponse {
    #[serde(rename = "object")]
    pub object: String,
    #[serde(rename = "data")]
    pub data: Vec<crate::__types::ProjectUser>,
    #[serde(rename = "first_id")]
    pub first_id: String,
    #[serde(rename = "last_id")]
    pub last_id: String,
    #[serde(rename = "has_more")]
    pub has_more: bool,
}
#[allow(clippy::module_inception)]
pub mod project_user_update_request {
    #[doc = "`owner` or `member`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`owner`"]
        #[serde(rename = "owner")]
        Owner,
        #[doc = "`member`"]
        #[serde(rename = "member")]
        Member,
    }
}
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ProjectUserUpdateRequest {
    #[doc = "`owner` or `member`"]
    #[serde(rename = "role")]
    pub role: crate::__types::project_user_update_request::Role,
}
#[doc = "Reference to a prompt template and its variables. \n[Learn more](https://platform.openai.com/docs/guides/text?api-mode=responses#reusable-prompts).\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct Prompt {
    #[doc = "The unique identifier of the prompt template to use."]
    #[serde(rename = "id")]
    pub id: String,
    #[doc = "Optional version of the prompt template."]
    #[serde(rename = "version")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub version: Option<String>,
    #[serde(rename = "variables")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub variables: Option<crate::__types::ResponsePromptVariables>,
}
#[doc = "A realtime client event.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeClientEvent {
    ConversationItemCreate(crate::__types::RealtimeClientEventConversationItemCreate),
    ConversationItemDelete(crate::__types::RealtimeClientEventConversationItemDelete),
    ConversationItemRetrieve(crate::__types::RealtimeClientEventConversationItemRetrieve),
    ConversationItemTruncate(crate::__types::RealtimeClientEventConversationItemTruncate),
    InputAudioBufferAppend(crate::__types::RealtimeClientEventInputAudioBufferAppend),
    InputAudioBufferClear(crate::__types::RealtimeClientEventInputAudioBufferClear),
    OutputAudioBufferClear(crate::__types::RealtimeClientEventOutputAudioBufferClear),
    InputAudioBufferCommit(crate::__types::RealtimeClientEventInputAudioBufferCommit),
    ResponseCancel(crate::__types::RealtimeClientEventResponseCancel),
    ResponseCreate(crate::__types::RealtimeClientEventResponseCreate),
    SessionUpdate(crate::__types::RealtimeClientEventSessionUpdate),
    TranscriptionSessionUpdate(crate::__types::RealtimeClientEventTranscriptionSessionUpdate),
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_conversation_item_create {
    #[doc = "The event type, must be `conversation.item.create`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.create");
}
#[doc = "Add a new Item to the Conversation's context, including messages, function \ncalls, and function call responses. This event can be used both to populate a \n\"history\" of the conversation and to add new items mid-stream, but has the \ncurrent limitation that it cannot populate assistant audio messages.\n\nIf successful, the server will respond with a `conversation.item.created` \nevent, otherwise an `error` event will be sent.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemCreate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the preceding item after which the new item will be inserted. \nIf not set, the new item will be appended to the end of the conversation.\nIf set to `root`, the new item will be added to the beginning of the conversation.\nIf set to an existing ID, it allows an item to be inserted mid-conversation. If the\nID cannot be found, an error will be returned and the item will not be added.\n"]
    #[builder(default)]
    pub previous_item_id: Option<String>,
    #[builder(default)]
    pub item: crate::__types::RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemCreate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventConversationItemCreate {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_conversation_item_create::Type,
            #[serde(rename = "previous_item_id")]
            previous_item_id: Option<String>,
            #[serde(rename = "item")]
            item: crate::__types::RealtimeConversationItem,
        }
        let RealtimeClientEventConversationItemCreate {
            event_id,
            previous_item_id,
            item,
            ..
        } = RealtimeClientEventConversationItemCreate::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            previous_item_id,
            item,
        })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemCreate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventConversationItemCreate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_conversation_item_create::Type,
            #[serde(rename = "previous_item_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            previous_item_id: &'a Option<String>,
            #[serde(rename = "item")]
            item: &'a crate::__types::RealtimeConversationItem,
        }
        let Self {
            event_id,
            previous_item_id,
            item,
        } = self;
        RealtimeClientEventConversationItemCreate {
            event_id,
            r#type: &Default::default(),
            previous_item_id,
            item,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_conversation_item_delete {
    #[doc = "The event type, must be `conversation.item.delete`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.delete");
}
#[doc = "Send this event when you want to remove any item from the conversation \nhistory. The server will respond with a `conversation.item.deleted` event, \nunless the item does not exist in the conversation history, in which case the \nserver will respond with an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemDelete {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the item to delete."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemDelete {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventConversationItemDelete {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_conversation_item_delete::Type,
            #[serde(rename = "item_id")]
            item_id: String,
        }
        let RealtimeClientEventConversationItemDelete {
            event_id, item_id, ..
        } = RealtimeClientEventConversationItemDelete::deserialize(deserializer)?;
        Ok(Self { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemDelete {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventConversationItemDelete<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_conversation_item_delete::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self { event_id, item_id } = self;
        RealtimeClientEventConversationItemDelete {
            event_id,
            r#type: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_conversation_item_retrieve {
    #[doc = "The event type, must be `conversation.item.retrieve`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.retrieve");
}
#[doc = "Send this event when you want to retrieve the server's representation of a specific item in the conversation history. This is useful, for example, to inspect user audio after noise cancellation and VAD.\nThe server will respond with a `conversation.item.retrieved` event, \nunless the item does not exist in the conversation history, in which case the \nserver will respond with an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemRetrieve {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the item to retrieve."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemRetrieve {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventConversationItemRetrieve {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_conversation_item_retrieve::Type,
            #[serde(rename = "item_id")]
            item_id: String,
        }
        let RealtimeClientEventConversationItemRetrieve {
            event_id, item_id, ..
        } = RealtimeClientEventConversationItemRetrieve::deserialize(deserializer)?;
        Ok(Self { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemRetrieve {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventConversationItemRetrieve<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_conversation_item_retrieve::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self { event_id, item_id } = self;
        RealtimeClientEventConversationItemRetrieve {
            event_id,
            r#type: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_conversation_item_truncate {
    #[doc = "The event type, must be `conversation.item.truncate`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.truncate");
}
#[doc = "Send this event to truncate a previous assistant messages audio. The server \nwill produce audio faster than realtime, so this event is useful when the user \ninterrupts to truncate audio that has already been sent to the client but not \nyet played. This will synchronize the server's understanding of the audio with \nthe client's playback.\n\nTruncating audio will delete the server-side text transcript to ensure there \nis not text in the context that hasn't been heard by the user.\n\nIf successful, the server will respond with a `conversation.item.truncated` \nevent. \n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventConversationItemTruncate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "The ID of the assistant message item to truncate. Only assistant message \nitems can be truncated.\n"]
    pub item_id: String,
    #[doc = "The index of the content part to truncate. Set this to 0."]
    pub content_index: i64,
    #[doc = "Inclusive duration up to which audio is truncated, in milliseconds. If \nthe audio_end_ms is greater than the actual audio duration, the server \nwill respond with an error.\n"]
    pub audio_end_ms: i64,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventConversationItemTruncate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventConversationItemTruncate {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_conversation_item_truncate::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: i64,
        }
        let RealtimeClientEventConversationItemTruncate {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
            ..
        } = RealtimeClientEventConversationItemTruncate::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        })
    }
}
impl serde::Serialize for RealtimeClientEventConversationItemTruncate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventConversationItemTruncate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_conversation_item_truncate::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a i64,
        }
        let Self {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        } = self;
        RealtimeClientEventConversationItemTruncate {
            event_id,
            r#type: &Default::default(),
            item_id,
            content_index,
            audio_end_ms,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_input_audio_buffer_append {
    #[doc = "The event type, must be `input_audio_buffer.append`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio_buffer.append");
}
#[doc = "Send this event to append audio bytes to the input audio buffer. The audio \nbuffer is temporary storage you can write to and later commit. In Server VAD \nmode, the audio buffer is used to detect speech and the server will decide \nwhen to commit. When Server VAD is disabled, you must commit the audio buffer\nmanually.\n\nThe client may choose how much audio to place in each event up to a maximum \nof 15 MiB, for example streaming smaller chunks from the client may allow the \nVAD to be more responsive. Unlike made other client events, the server will \nnot send a confirmation response to this event.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferAppend {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "Base64-encoded audio bytes. This must be in the format specified by the \n`input_audio_format` field in the session configuration.\n"]
    pub audio: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferAppend {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventInputAudioBufferAppend {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_input_audio_buffer_append::Type,
            #[serde(rename = "audio")]
            audio: String,
        }
        let RealtimeClientEventInputAudioBufferAppend {
            event_id, audio, ..
        } = RealtimeClientEventInputAudioBufferAppend::deserialize(deserializer)?;
        Ok(Self { event_id, audio })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferAppend {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventInputAudioBufferAppend<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_input_audio_buffer_append::Type,
            #[serde(rename = "audio")]
            audio: &'a String,
        }
        let Self { event_id, audio } = self;
        RealtimeClientEventInputAudioBufferAppend {
            event_id,
            r#type: &Default::default(),
            audio,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_input_audio_buffer_clear {
    #[doc = "The event type, must be `input_audio_buffer.clear`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio_buffer.clear");
}
#[doc = "Send this event to clear the audio bytes in the buffer. The server will \nrespond with an `input_audio_buffer.cleared` event.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferClear {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferClear {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventInputAudioBufferClear {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_input_audio_buffer_clear::Type,
        }
        let RealtimeClientEventInputAudioBufferClear { event_id, .. } =
            RealtimeClientEventInputAudioBufferClear::deserialize(deserializer)?;
        Ok(Self { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferClear {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventInputAudioBufferClear<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_input_audio_buffer_clear::Type,
        }
        let Self { event_id } = self;
        RealtimeClientEventInputAudioBufferClear {
            event_id,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_input_audio_buffer_commit {
    #[doc = "The event type, must be `input_audio_buffer.commit`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio_buffer.commit");
}
#[doc = "Send this event to commit the user input audio buffer, which will create a \nnew user message item in the conversation. This event will produce an error \nif the input audio buffer is empty. When in Server VAD mode, the client does \nnot need to send this event, the server will commit the audio buffer \nautomatically.\n\nCommitting the input audio buffer will trigger input audio transcription \n(if enabled in session configuration), but it will not create a response \nfrom the model. The server will respond with an `input_audio_buffer.committed` \nevent.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventInputAudioBufferCommit {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventInputAudioBufferCommit {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventInputAudioBufferCommit {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_input_audio_buffer_commit::Type,
        }
        let RealtimeClientEventInputAudioBufferCommit { event_id, .. } =
            RealtimeClientEventInputAudioBufferCommit::deserialize(deserializer)?;
        Ok(Self { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventInputAudioBufferCommit {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventInputAudioBufferCommit<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_input_audio_buffer_commit::Type,
        }
        let Self { event_id } = self;
        RealtimeClientEventInputAudioBufferCommit {
            event_id,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_output_audio_buffer_clear {
    #[doc = "The event type, must be `output_audio_buffer.clear`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "output_audio_buffer.clear");
}
#[doc = "**WebRTC Only:** Emit to cut off the current audio response. This will trigger the server to\nstop generating audio and emit a `output_audio_buffer.cleared` event. This \nevent should be preceded by a `response.cancel` client event to stop the \ngeneration of the current response.\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventOutputAudioBufferClear {
    #[doc = "The unique ID of the client event used for error handling."]
    #[builder(default)]
    pub event_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventOutputAudioBufferClear {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventOutputAudioBufferClear {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_output_audio_buffer_clear::Type,
        }
        let RealtimeClientEventOutputAudioBufferClear { event_id, .. } =
            RealtimeClientEventOutputAudioBufferClear::deserialize(deserializer)?;
        Ok(Self { event_id })
    }
}
impl serde::Serialize for RealtimeClientEventOutputAudioBufferClear {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventOutputAudioBufferClear<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_output_audio_buffer_clear::Type,
        }
        let Self { event_id } = self;
        RealtimeClientEventOutputAudioBufferClear {
            event_id,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_response_cancel {
    #[doc = "The event type, must be `response.cancel`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.cancel");
}
#[doc = "Send this event to cancel an in-progress response. The server will respond \nwith a `response.done` event with a status of `response.status=cancelled`. If \nthere is no response to cancel, the server will respond with an error.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventResponseCancel {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[doc = "A specific response ID to cancel - if not provided, will cancel an \nin-progress response in the default conversation.\n"]
    #[builder(default)]
    pub response_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventResponseCancel {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventResponseCancel {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_response_cancel::Type,
            #[serde(rename = "response_id")]
            response_id: Option<String>,
        }
        let RealtimeClientEventResponseCancel {
            event_id,
            response_id,
            ..
        } = RealtimeClientEventResponseCancel::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeClientEventResponseCancel {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventResponseCancel<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_response_cancel::Type,
            #[serde(rename = "response_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_id: &'a Option<String>,
        }
        let Self {
            event_id,
            response_id,
        } = self;
        RealtimeClientEventResponseCancel {
            event_id,
            r#type: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_response_create {
    #[doc = "The event type, must be `response.create`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.create");
}
#[doc = "This event instructs the server to create a Response, which means triggering \nmodel inference. When in Server VAD mode, the server will create Responses \nautomatically.\n\nA Response will include at least one Item, and may have two, in which case \nthe second will be a function call. These Items will be appended to the \nconversation history.\n\nThe server will respond with a `response.created` event, events for Items \nand content created, and finally a `response.done` event to indicate the \nResponse is complete.\n\nThe `response.create` event includes inference configuration like \n`instructions`, and `temperature`. These fields will override the Session's \nconfiguration for this Response only.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventResponseCreate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub response: Option<crate::__types::RealtimeResponseCreateParams>,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventResponseCreate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventResponseCreate {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_response_create::Type,
            #[serde(rename = "response")]
            response: Option<crate::__types::RealtimeResponseCreateParams>,
        }
        let RealtimeClientEventResponseCreate {
            event_id, response, ..
        } = RealtimeClientEventResponseCreate::deserialize(deserializer)?;
        Ok(Self { event_id, response })
    }
}
impl serde::Serialize for RealtimeClientEventResponseCreate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventResponseCreate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_response_create::Type,
            #[serde(rename = "response")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response: &'a Option<crate::__types::RealtimeResponseCreateParams>,
        }
        let Self { event_id, response } = self;
        RealtimeClientEventResponseCreate {
            event_id,
            r#type: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_session_update {
    #[doc = "The event type, must be `session.update`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "session.update");
}
#[doc = "Send this event to update the sessions default configuration.\nThe client may send this event at any time to update any field,\nexcept for `voice`. However, note that once a session has been\ninitialized with a particular `model`, it cant be changed to\nanother model using `session.update`.\n\nWhen the server receives a `session.update`, it will respond\nwith a `session.updated` event showing the full, effective configuration.\nOnly the fields that are present are updated. To clear a field like\n`instructions`, pass an empty string.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventSessionUpdate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub session: crate::__types::RealtimeSessionCreateRequest,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventSessionUpdate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventSessionUpdate {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_session_update::Type,
            #[serde(rename = "session")]
            session: crate::__types::RealtimeSessionCreateRequest,
        }
        let RealtimeClientEventSessionUpdate {
            event_id, session, ..
        } = RealtimeClientEventSessionUpdate::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeClientEventSessionUpdate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventSessionUpdate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_session_update::Type,
            #[serde(rename = "session")]
            session: &'a crate::__types::RealtimeSessionCreateRequest,
        }
        let Self { event_id, session } = self;
        RealtimeClientEventSessionUpdate {
            event_id,
            r#type: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_client_event_transcription_session_update {
    #[doc = "The event type, must be `transcription_session.update`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "transcription_session.update");
}
#[doc = "Send this event to update a transcription session.\n"]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeClientEventTranscriptionSessionUpdate {
    #[doc = "Optional client-generated ID used to identify this event."]
    #[builder(default)]
    pub event_id: Option<String>,
    #[builder(default)]
    pub session: crate::__types::RealtimeTranscriptionSessionCreateRequest,
}
impl<'de> serde::Deserialize<'de> for RealtimeClientEventTranscriptionSessionUpdate {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeClientEventTranscriptionSessionUpdate {
            #[serde(rename = "event_id")]
            event_id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_client_event_transcription_session_update::Type,
            #[serde(rename = "session")]
            session: crate::__types::RealtimeTranscriptionSessionCreateRequest,
        }
        let RealtimeClientEventTranscriptionSessionUpdate {
            event_id, session, ..
        } = RealtimeClientEventTranscriptionSessionUpdate::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeClientEventTranscriptionSessionUpdate {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeClientEventTranscriptionSessionUpdate<'a> {
            #[serde(rename = "event_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            event_id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_client_event_transcription_session_update::Type,
            #[serde(rename = "session")]
            session: &'a crate::__types::RealtimeTranscriptionSessionCreateRequest,
        }
        let Self { event_id, session } = self;
        RealtimeClientEventTranscriptionSessionUpdate {
            event_id,
            r#type: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod realtime_conversation_item {
    #[doc = "The type of the item (`message`, `function_call`, `function_call_output`).\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`message`"]
        #[serde(rename = "message")]
        Message,
        #[doc = "`function_call`"]
        #[serde(rename = "function_call")]
        FunctionCall,
        #[doc = "`function_call_output`"]
        #[serde(rename = "function_call_output")]
        FunctionCallOutput,
    }
    #[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "realtime.item");
    #[doc = "The status of the item (`completed`, `incomplete`, `in_progress`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
    }
    #[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`assistant`"]
        #[serde(rename = "assistant")]
        Assistant,
        #[doc = "`system`"]
        #[serde(rename = "system")]
        System,
    }
}
#[doc = "The item to add to the conversation."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItem {
    #[doc = "The unique ID of the item, this can be generated by the client to help \nmanage server-side context, but is not required because the server will \ngenerate one if not provided.\n"]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the item (`message`, `function_call`, `function_call_output`).\n"]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::realtime_conversation_item::Type>,
    #[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
    #[serde(rename = "object")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<crate::__types::realtime_conversation_item::Object>,
    #[doc = "The status of the item (`completed`, `incomplete`, `in_progress`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status: Option<crate::__types::realtime_conversation_item::Status>,
    #[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
    #[serde(rename = "role")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub role: Option<crate::__types::realtime_conversation_item::Role>,
    #[doc = "The content of the message, applicable for `message` items. \n- Message items of role `system` support only `input_text` content\n- Message items of role `user` support `input_text` and `input_audio` \n  content\n- Message items of role `assistant` support `text` content.\n"]
    #[serde(rename = "content")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub content: Option<Vec<crate::__types::RealtimeConversationItemContent>>,
    #[doc = "The ID of the function call (for `function_call` and \n`function_call_output` items). If passed on a `function_call_output` \nitem, the server will check that a `function_call` item with the same \nID exists in the conversation history.\n"]
    #[serde(rename = "call_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub call_id: Option<String>,
    #[doc = "The name of the function being called (for `function_call` items).\n"]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments of the function call (for `function_call` items).\n"]
    #[serde(rename = "arguments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The output of the function call (for `function_call_output` items).\n"]
    #[serde(rename = "output")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod realtime_conversation_item_with_reference {
    #[doc = "The type of the item (`message`, `function_call`, `function_call_output`, `item_reference`).\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`message`"]
        #[serde(rename = "message")]
        Message,
        #[doc = "`function_call`"]
        #[serde(rename = "function_call")]
        FunctionCall,
        #[doc = "`function_call_output`"]
        #[serde(rename = "function_call_output")]
        FunctionCallOutput,
        #[doc = "`item_reference`"]
        #[serde(rename = "item_reference")]
        ItemReference,
    }
    #[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "realtime.item");
    #[doc = "The status of the item (`completed`, `incomplete`, `in_progress`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
    }
    #[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`user`"]
        #[serde(rename = "user")]
        User,
        #[doc = "`assistant`"]
        #[serde(rename = "assistant")]
        Assistant,
        #[doc = "`system`"]
        #[serde(rename = "system")]
        System,
    }
    #[allow(clippy::module_inception)]
    pub mod content {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`).\n"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Type {
                #[doc = "`input_text`"]
                #[serde(rename = "input_text")]
                InputText,
                #[doc = "`input_audio`"]
                #[serde(rename = "input_audio")]
                InputAudio,
                #[doc = "`item_reference`"]
                #[serde(rename = "item_reference")]
                ItemReference,
                #[doc = "`text`"]
                #[serde(rename = "text")]
                Text,
            }
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`).\n"]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub r#type: Option<
                crate::__types::realtime_conversation_item_with_reference::content::item::Type,
            >,
            #[doc = "The text content, used for `input_text` and `text` content types.\n"]
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub text: Option<String>,
            #[doc = "ID of a previous conversation item to reference (for `item_reference`\ncontent types in `response.create` events). These can reference both\nclient and server created items.\n"]
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub id: Option<String>,
            #[doc = "Base64-encoded audio bytes, used for `input_audio` content type.\n"]
            #[serde(rename = "audio")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub audio: Option<String>,
            #[doc = "The transcript of the audio, used for `input_audio` content type.\n"]
            #[serde(rename = "transcript")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub transcript: Option<String>,
        }
    }
}
#[doc = "The item to add to the conversation."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItemWithReference {
    #[doc = "For an item of type (`message` | `function_call` | `function_call_output`)\nthis field allows the client to assign the unique ID of the item. It is\nnot required because the server will generate one if not provided.\n\nFor an item of type `item_reference`, this field is required and is a\nreference to any item that has previously existed in the conversation.\n"]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The type of the item (`message`, `function_call`, `function_call_output`, `item_reference`).\n"]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::realtime_conversation_item_with_reference::Type>,
    #[doc = "Identifier for the API object being returned - always `realtime.item`.\n"]
    #[serde(rename = "object")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<crate::__types::realtime_conversation_item_with_reference::Object>,
    #[doc = "The status of the item (`completed`, `incomplete`, `in_progress`). These have no effect \non the conversation, but are accepted for consistency with the \n`conversation.item.created` event.\n"]
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status: Option<crate::__types::realtime_conversation_item_with_reference::Status>,
    #[doc = "The role of the message sender (`user`, `assistant`, `system`), only \napplicable for `message` items.\n"]
    #[serde(rename = "role")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub role: Option<crate::__types::realtime_conversation_item_with_reference::Role>,
    #[doc = "The content of the message, applicable for `message` items. \n- Message items of role `system` support only `input_text` content\n- Message items of role `user` support `input_text` and `input_audio` \n  content\n- Message items of role `assistant` support `text` content.\n"]
    #[serde(rename = "content")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub content:
        Option<Vec<crate::__types::realtime_conversation_item_with_reference::content::Item>>,
    #[doc = "The ID of the function call (for `function_call` and \n`function_call_output` items). If passed on a `function_call_output` \nitem, the server will check that a `function_call` item with the same \nID exists in the conversation history.\n"]
    #[serde(rename = "call_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub call_id: Option<String>,
    #[doc = "The name of the function being called (for `function_call` items).\n"]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The arguments of the function call (for `function_call` items).\n"]
    #[serde(rename = "arguments")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub arguments: Option<String>,
    #[doc = "The output of the function call (for `function_call_output` items).\n"]
    #[serde(rename = "output")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod realtime_response {
    #[doc = "The object type, must be `realtime.response`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "realtime.response");
    #[doc = "The final status of the response (`completed`, `cancelled`, `failed`, or \n`incomplete`, `in_progress`).\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`cancelled`"]
        #[serde(rename = "cancelled")]
        Cancelled,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
    }
    #[allow(clippy::module_inception)]
    pub mod status_details {
        #[doc = "The type of error that caused the response to fail, corresponding \nwith the `status` field (`completed`, `cancelled`, `incomplete`, \n`failed`).\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Type {
            #[doc = "`completed`"]
            #[serde(rename = "completed")]
            Completed,
            #[doc = "`cancelled`"]
            #[serde(rename = "cancelled")]
            Cancelled,
            #[doc = "`incomplete`"]
            #[serde(rename = "incomplete")]
            Incomplete,
            #[doc = "`failed`"]
            #[serde(rename = "failed")]
            Failed,
        }
        #[doc = "The reason the Response did not complete. For a `cancelled` Response, \none of `turn_detected` (the server VAD detected a new start of speech) \nor `client_cancelled` (the client sent a cancel event). For an \n`incomplete` Response, one of `max_output_tokens` or `content_filter` \n(the server-side safety filter activated and cut off the response).\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Reason {
            #[doc = "`turn_detected`"]
            #[serde(rename = "turn_detected")]
            TurnDetected,
            #[doc = "`client_cancelled`"]
            #[serde(rename = "client_cancelled")]
            ClientCancelled,
            #[doc = "`max_output_tokens`"]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
            #[doc = "`content_filter`"]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
        #[doc = "A description of the error that caused the response to fail, \npopulated when the `status` is `failed`.\n"]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Error {
            #[doc = "The type of error."]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub r#type: Option<String>,
            #[doc = "Error code, if any."]
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub code: Option<String>,
        }
    }
    #[doc = "Additional details about the status."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct StatusDetails {
        #[doc = "The type of error that caused the response to fail, corresponding \nwith the `status` field (`completed`, `cancelled`, `incomplete`, \n`failed`).\n"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<crate::__types::realtime_response::status_details::Type>,
        #[doc = "The reason the Response did not complete. For a `cancelled` Response, \none of `turn_detected` (the server VAD detected a new start of speech) \nor `client_cancelled` (the client sent a cancel event). For an \n`incomplete` Response, one of `max_output_tokens` or `content_filter` \n(the server-side safety filter activated and cut off the response).\n"]
        #[serde(rename = "reason")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub reason: Option<crate::__types::realtime_response::status_details::Reason>,
        #[doc = "A description of the error that caused the response to fail, \npopulated when the `status` is `failed`.\n"]
        #[serde(rename = "error")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub error: Option<crate::__types::realtime_response::status_details::Error>,
    }
    #[allow(clippy::module_inception)]
    pub mod usage {
        #[doc = "Details about the input tokens used in the Response."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct InputTokenDetails {
            #[doc = "The number of cached tokens used in the Response."]
            #[serde(rename = "cached_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub cached_tokens: Option<i64>,
            #[doc = "The number of text tokens used in the Response."]
            #[serde(rename = "text_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub text_tokens: Option<i64>,
            #[doc = "The number of audio tokens used in the Response."]
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub audio_tokens: Option<i64>,
        }
        #[doc = "Details about the output tokens used in the Response."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct OutputTokenDetails {
            #[doc = "The number of text tokens used in the Response."]
            #[serde(rename = "text_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub text_tokens: Option<i64>,
            #[doc = "The number of audio tokens used in the Response."]
            #[serde(rename = "audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub audio_tokens: Option<i64>,
        }
    }
    #[doc = "Usage statistics for the Response, this will correspond to billing. A \nRealtime API session will maintain a conversation context and append new \nItems to the Conversation, thus output from previous turns (text and \naudio tokens) will become the input for later turns.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Usage {
        #[doc = "The total number of tokens in the Response including input and output \ntext and audio tokens.\n"]
        #[serde(rename = "total_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub total_tokens: Option<i64>,
        #[doc = "The number of input tokens used in the Response, including text and \naudio tokens.\n"]
        #[serde(rename = "input_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub input_tokens: Option<i64>,
        #[doc = "The number of output tokens sent in the Response, including text and \naudio tokens.\n"]
        #[serde(rename = "output_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub output_tokens: Option<i64>,
        #[doc = "Details about the input tokens used in the Response."]
        #[serde(rename = "input_token_details")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub input_token_details:
            Option<crate::__types::realtime_response::usage::InputTokenDetails>,
        #[doc = "Details about the output tokens used in the Response."]
        #[serde(rename = "output_token_details")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub output_token_details:
            Option<crate::__types::realtime_response::usage::OutputTokenDetails>,
    }
    #[allow(clippy::module_inception)]
    pub mod modalities {
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Item {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputAudioFormat {
        #[doc = "`pcm16`"]
        #[serde(rename = "pcm16")]
        Pcm16,
        #[doc = "`g711_ulaw`"]
        #[serde(rename = "g711_ulaw")]
        G711Ulaw,
        #[doc = "`g711_alaw`"]
        #[serde(rename = "g711_alaw")]
        G711Alaw,
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod max_output_tokens {
        #[doc = "inf"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Inf;
        impl_serde!(Inf, "inf");
    }
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls, that was used in this response.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum MaxOutputTokens {
        Integer(i64),
        #[doc = "inf"]
        Inf,
    }
    impl<'de> serde::Deserialize<'de> for MaxOutputTokens {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum MaxOutputTokens {
                Inf(crate::__types::realtime_response::max_output_tokens::Inf),
                Integer(i64),
            }
            Ok(match MaxOutputTokens::deserialize(deserializer)? {
                MaxOutputTokens::Integer(v) => Self::Integer(v),
                MaxOutputTokens::Inf(_) => Self::Inf,
            })
        }
    }
    impl serde::Serialize for MaxOutputTokens {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum MaxOutputTokens<'a> {
                Integer(&'a i64),
                Inf(crate::__types::realtime_response::max_output_tokens::Inf),
            }
            match self {
                Self::Integer(v) => MaxOutputTokens::Integer(v),
                Self::Inf => MaxOutputTokens::Inf(Default::default()),
            }
            .serialize(serializer)
        }
    }
}
#[doc = "The response resource."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeResponse {
    #[doc = "The unique ID of the response."]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The object type, must be `realtime.response`."]
    #[serde(rename = "object")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub object: Option<crate::__types::realtime_response::Object>,
    #[doc = "The final status of the response (`completed`, `cancelled`, `failed`, or \n`incomplete`, `in_progress`).\n"]
    #[serde(rename = "status")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status: Option<crate::__types::realtime_response::Status>,
    #[doc = "Additional details about the status."]
    #[serde(rename = "status_details")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub status_details: Option<crate::__types::realtime_response::StatusDetails>,
    #[doc = "The list of output items generated by the response."]
    #[serde(rename = "output")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output: Option<Vec<crate::__types::RealtimeConversationItem>>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "Usage statistics for the Response, this will correspond to billing. A \nRealtime API session will maintain a conversation context and append new \nItems to the Conversation, thus output from previous turns (text and \naudio tokens) will become the input for later turns.\n"]
    #[serde(rename = "usage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub usage: Option<crate::__types::realtime_response::Usage>,
    #[doc = "Which conversation the response is added to, determined by the `conversation`\nfield in the `response.create` event. If `auto`, the response will be added to\nthe default conversation and the value of `conversation_id` will be an id like\n`conv_1234`. If `none`, the response will not be added to any conversation and\nthe value of `conversation_id` will be `null`. If responses are being triggered\nby server VAD, the response will be added to the default conversation, thus\nthe `conversation_id` will be an id like `conv_1234`.\n"]
    #[serde(rename = "conversation_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conversation_id: Option<String>,
    #[doc = "The voice the model used to respond.\nCurrent voice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, and `verse`.\n"]
    #[serde(rename = "voice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub voice: Option<crate::__types::VoiceIdsShared>,
    #[doc = "The set of modalities the model used to respond. If there are multiple modalities,\nthe model will pick one, for example if `modalities` is `[\"text\", \"audio\"]`, the model\ncould be responding in either text or audio.\n"]
    #[serde(rename = "modalities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub modalities: Option<Vec<crate::__types::realtime_response::modalities::Item>>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[serde(rename = "output_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_audio_format: Option<crate::__types::realtime_response::OutputAudioFormat>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls, that was used in this response.\n"]
    #[serde(rename = "max_output_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_output_tokens: Option<crate::__types::realtime_response::MaxOutputTokens>,
}
#[allow(clippy::module_inception)]
pub mod realtime_response_create_params {
    #[allow(clippy::module_inception)]
    pub mod modalities {
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Item {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputAudioFormat {
        #[doc = "`pcm16`"]
        #[serde(rename = "pcm16")]
        Pcm16,
        #[doc = "`g711_ulaw`"]
        #[serde(rename = "g711_ulaw")]
        G711Ulaw,
        #[doc = "`g711_alaw`"]
        #[serde(rename = "g711_alaw")]
        G711Alaw,
    }
    #[allow(clippy::module_inception)]
    pub mod tools {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The type of the tool, i.e. `function`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub struct Type;
            impl_serde!(Type, "function");
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The type of the tool, i.e. `function`."]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub r#type: Option<crate::__types::realtime_response_create_params::tools::item::Type>,
            #[doc = "The name of the function."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub name: Option<String>,
            #[doc = "The description of the function, including guidance on when and how \nto call it, and guidance about what to tell the user when calling \n(if anything).\n"]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub description: Option<String>,
            #[doc = "Parameters of the function in JSON Schema."]
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub parameters: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod max_response_output_tokens {
        #[doc = "inf"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Inf;
        impl_serde!(Inf, "inf");
    }
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum MaxResponseOutputTokens {
        Integer(i64),
        #[doc = "inf"]
        Inf,
    }
    impl<'de> serde::Deserialize<'de> for MaxResponseOutputTokens {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum MaxResponseOutputTokens {
                Inf (crate :: __types :: realtime_response_create_params :: max_response_output_tokens :: Inf) , Integer (i64) }
            Ok(match MaxResponseOutputTokens::deserialize(deserializer)? {
                MaxResponseOutputTokens::Integer(v) => Self::Integer(v),
                MaxResponseOutputTokens::Inf(_) => Self::Inf,
            })
        }
    }
    impl serde::Serialize for MaxResponseOutputTokens {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum MaxResponseOutputTokens<'a> {
                Integer (& 'a i64) , Inf (crate :: __types :: realtime_response_create_params :: max_response_output_tokens :: Inf) }
            match self {
                Self::Integer(v) => MaxResponseOutputTokens::Integer(v),
                Self::Inf => MaxResponseOutputTokens::Inf(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod conversation {
        #[doc = "auto"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
        #[doc = "none"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct None;
        impl_serde!(None, "none");
    }
    #[doc = "Controls which conversation the response is added to. Currently supports\n`auto` and `none`, with `auto` as the default value. The `auto` value\nmeans that the contents of the response will be added to the default\nconversation. Set this to `none` to create an out-of-band response which \nwill not add items to default conversation.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Conversation {
        Other(String),
        #[doc = "auto"]
        Auto,
        #[doc = "none"]
        None,
    }
    impl<'de> serde::Deserialize<'de> for Conversation {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Conversation {
                Auto(crate::__types::realtime_response_create_params::conversation::Auto),
                None(crate::__types::realtime_response_create_params::conversation::None),
                Other(String),
            }
            Ok(match Conversation::deserialize(deserializer)? {
                Conversation::Other(v) => Self::Other(v),
                Conversation::Auto(_) => Self::Auto,
                Conversation::None(_) => Self::None,
            })
        }
    }
    impl serde::Serialize for Conversation {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Conversation<'a> {
                Other(&'a String),
                Auto(crate::__types::realtime_response_create_params::conversation::Auto),
                None(crate::__types::realtime_response_create_params::conversation::None),
            }
            match self {
                Self::Other(v) => Conversation::Other(v),
                Self::Auto => Conversation::Auto(Default::default()),
                Self::None => Conversation::None(Default::default()),
            }
            .serialize(serializer)
        }
    }
}
#[doc = "Create a new Realtime response with these parameters"]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeResponseCreateParams {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[serde(rename = "modalities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub modalities: Option<Vec<crate::__types::realtime_response_create_params::modalities::Item>>,
    #[doc = "The default system instructions (i.e. system message) prepended to model \ncalls. This field allows the client to guide the model on desired \nresponses. The model can be instructed on response content and format, \n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good \nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion \ninto your voice\", \"laugh frequently\"). The instructions are not guaranteed \nto be followed by the model, but they provide guidance to the model on the \ndesired behavior.\n\nNote that the server sets default instructions which will be used if this \nfield is not set and are visible in the `session.created` event at the \nstart of the session.\n"]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the \nsession once the model has responded with audio at least once. Current \nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, and `verse`.\n"]
    #[serde(rename = "voice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub voice: Option<crate::__types::VoiceIdsShared>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[serde(rename = "output_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_audio_format:
        Option<crate::__types::realtime_response_create_params::OutputAudioFormat>,
    #[doc = "Tools (functions) available to the model."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::realtime_response_create_params::tools::Item>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or \nspecify a function, like `{\"type\": \"function\", \"function\": {\"name\": \"my_function\"}}`.\n"]
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[serde(rename = "max_response_output_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_response_output_tokens:
        Option<crate::__types::realtime_response_create_params::MaxResponseOutputTokens>,
    #[doc = "Controls which conversation the response is added to. Currently supports\n`auto` and `none`, with `auto` as the default value. The `auto` value\nmeans that the contents of the response will be added to the default\nconversation. Set this to `none` to create an out-of-band response which \nwill not add items to default conversation.\n"]
    #[serde(rename = "conversation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub conversation: Option<crate::__types::realtime_response_create_params::Conversation>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "Input items to include in the prompt for the model. Using this field\ncreates a new context for this Response instead of using the default\nconversation. An empty array `[]` will clear the context for this Response.\nNote that this can include references to items from the default conversation.\n"]
    #[serde(rename = "input")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input: Option<Vec<crate::__types::RealtimeConversationItemWithReference>>,
}
#[doc = "A realtime server event.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum RealtimeServerEvent {
    ConversationCreated(crate::__types::RealtimeServerEventConversationCreated),
    ConversationItemCreated(crate::__types::RealtimeServerEventConversationItemCreated),
    ConversationItemDeleted(crate::__types::RealtimeServerEventConversationItemDeleted),
    ConversationItemInputAudioTranscriptionCompleted(
        crate::__types::RealtimeServerEventConversationItemInputAudioTranscriptionCompleted,
    ),
    ConversationItemInputAudioTranscriptionDelta(
        crate::__types::RealtimeServerEventConversationItemInputAudioTranscriptionDelta,
    ),
    ConversationItemInputAudioTranscriptionFailed(
        crate::__types::RealtimeServerEventConversationItemInputAudioTranscriptionFailed,
    ),
    ConversationItemRetrieved(crate::__types::RealtimeServerEventConversationItemRetrieved),
    ConversationItemTruncated(crate::__types::RealtimeServerEventConversationItemTruncated),
    Error(crate::__types::RealtimeServerEventError),
    InputAudioBufferCleared(crate::__types::RealtimeServerEventInputAudioBufferCleared),
    InputAudioBufferCommitted(crate::__types::RealtimeServerEventInputAudioBufferCommitted),
    InputAudioBufferSpeechStarted(crate::__types::RealtimeServerEventInputAudioBufferSpeechStarted),
    InputAudioBufferSpeechStopped(crate::__types::RealtimeServerEventInputAudioBufferSpeechStopped),
    RateLimitsUpdated(crate::__types::RealtimeServerEventRateLimitsUpdated),
    ResponseAudioDelta(crate::__types::RealtimeServerEventResponseAudioDelta),
    ResponseAudioDone(crate::__types::RealtimeServerEventResponseAudioDone),
    ResponseAudioTranscriptDelta(crate::__types::RealtimeServerEventResponseAudioTranscriptDelta),
    ResponseAudioTranscriptDone(crate::__types::RealtimeServerEventResponseAudioTranscriptDone),
    ResponseContentPartAdded(crate::__types::RealtimeServerEventResponseContentPartAdded),
    ResponseContentPartDone(crate::__types::RealtimeServerEventResponseContentPartDone),
    ResponseCreated(crate::__types::RealtimeServerEventResponseCreated),
    ResponseDone(crate::__types::RealtimeServerEventResponseDone),
    ResponseFunctionCallArgumentsDelta(
        crate::__types::RealtimeServerEventResponseFunctionCallArgumentsDelta,
    ),
    ResponseFunctionCallArgumentsDone(
        crate::__types::RealtimeServerEventResponseFunctionCallArgumentsDone,
    ),
    ResponseOutputItemAdded(crate::__types::RealtimeServerEventResponseOutputItemAdded),
    ResponseOutputItemDone(crate::__types::RealtimeServerEventResponseOutputItemDone),
    ResponseTextDelta(crate::__types::RealtimeServerEventResponseTextDelta),
    ResponseTextDone(crate::__types::RealtimeServerEventResponseTextDone),
    SessionCreated(crate::__types::RealtimeServerEventSessionCreated),
    SessionUpdated(crate::__types::RealtimeServerEventSessionUpdated),
    TranscriptionSessionUpdated(crate::__types::RealtimeServerEventTranscriptionSessionUpdated),
    OutputAudioBufferStarted(crate::__types::RealtimeServerEventOutputAudioBufferStarted),
    OutputAudioBufferStopped(crate::__types::RealtimeServerEventOutputAudioBufferStopped),
    OutputAudioBufferCleared(crate::__types::RealtimeServerEventOutputAudioBufferCleared),
}
#[allow(clippy::module_inception)]
pub mod realtime_server_event_conversation_created {
    #[doc = "The event type, must be `conversation.created`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.created");
    #[allow(clippy::module_inception)]
    pub mod conversation {
        #[doc = "The object type, must be `realtime.conversation`."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub struct Object;
        impl_serde!(Object, "realtime.conversation");
    }
    #[doc = "The conversation resource."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Conversation {
        #[doc = "The unique ID of the conversation."]
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[doc = "The object type, must be `realtime.conversation`."]
        #[serde(rename = "object")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub object: Option<
            crate::__types::realtime_server_event_conversation_created::conversation::Object,
        >,
    }
}
#[doc = "Returned when a conversation is created. Emitted right after session creation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The conversation resource."]
    #[builder(default)]
    pub conversation: crate::__types::realtime_server_event_conversation_created::Conversation,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationCreated {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_conversation_created::Type,
            #[serde(rename = "conversation")]
            conversation: crate::__types::realtime_server_event_conversation_created::Conversation,
        }
        let RealtimeServerEventConversationCreated {
            event_id,
            conversation,
            ..
        } = RealtimeServerEventConversationCreated::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            conversation,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationCreated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_conversation_created::Type,
            #[serde(rename = "conversation")]
            conversation:
                &'a crate::__types::realtime_server_event_conversation_created::Conversation,
        }
        let Self {
            event_id,
            conversation,
        } = self;
        RealtimeServerEventConversationCreated {
            event_id,
            r#type: &Default::default(),
            conversation,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_conversation_item_created {
    #[doc = "The event type, must be `conversation.item.created`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.created");
}
#[doc = "Returned when a conversation item is created. There are several scenarios that produce this event:\n  - The server is generating a Response, which if successful will produce \n    either one or two Items, which will be of type `message` \n    (role `assistant`) or type `function_call`.\n  - The input audio buffer has been committed, either by the client or the \n    server (in `server_vad` mode). The server will take the content of the \n    input audio buffer and add it to a new user message Item.\n  - The client has sent a `conversation.item.create` event to add a new Item \n    to the Conversation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the preceding item in the Conversation context, allows the \nclient to understand the order of the conversation. Can be `null` if the \nitem has no predecessor.\n"]
    #[builder(default)]
    pub previous_item_id: Option<String>,
    #[builder(default)]
    pub item: crate::__types::RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemCreated {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_conversation_item_created::Type,
            #[serde(rename = "previous_item_id")]
            previous_item_id: Option<String>,
            #[serde(rename = "item")]
            item: crate::__types::RealtimeConversationItem,
        }
        let RealtimeServerEventConversationItemCreated {
            event_id,
            previous_item_id,
            item,
            ..
        } = RealtimeServerEventConversationItemCreated::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            previous_item_id,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemCreated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_conversation_item_created::Type,
            #[serde(rename = "previous_item_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            previous_item_id: &'a Option<String>,
            #[serde(rename = "item")]
            item: &'a crate::__types::RealtimeConversationItem,
        }
        let Self {
            event_id,
            previous_item_id,
            item,
        } = self;
        RealtimeServerEventConversationItemCreated {
            event_id,
            r#type: &Default::default(),
            previous_item_id,
            item,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_conversation_item_deleted {
    #[doc = "The event type, must be `conversation.item.deleted`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.deleted");
}
#[doc = "Returned when an item in the conversation is deleted by the client with a \n`conversation.item.delete` event. This event is used to synchronize the \nserver's understanding of the conversation history with the client's view.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemDeleted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the item that was deleted."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemDeleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemDeleted {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_conversation_item_deleted::Type,
            #[serde(rename = "item_id")]
            item_id: String,
        }
        let RealtimeServerEventConversationItemDeleted {
            event_id, item_id, ..
        } = RealtimeServerEventConversationItemDeleted::deserialize(deserializer)?;
        Ok(Self { event_id, item_id })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemDeleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemDeleted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_conversation_item_deleted::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self { event_id, item_id } = self;
        RealtimeServerEventConversationItemDeleted {
            event_id,
            r#type: &Default::default(),
            item_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod realtime_server_event_conversation_item_input_audio_transcription_completed {
    #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.completed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(
        Type,
        "conversation.item.input_audio_transcription.completed"
    );
    #[doc = "Usage statistics for the transcription."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Usage {
        Tokens(crate::__types::TranscriptTextUsageTokens),
        Duration(crate::__types::TranscriptTextUsageDuration),
    }
}
#[doc = "This event is the output of audio transcription for user audio written to the\nuser audio buffer. Transcription begins when the input audio buffer is\ncommitted by the client or server (in `server_vad` mode). Transcription runs\nasynchronously with Response creation, so this event may come before or after\nthe Response events.\n\nRealtime API models accept audio natively, and thus input transcription is a\nseparate process run on a separate ASR (Automatic Speech Recognition) model.\nThe transcript may diverge somewhat from the model's interpretation, and\nshould be treated as a rough guide.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionCompleted { # [doc = "The unique ID of the server event."] pub event_id : String , # [doc = "The ID of the user message item containing the audio."] pub item_id : String , # [doc = "The index of the content part containing the audio."] pub content_index : i64 , # [doc = "The transcribed text."] pub transcript : String , # [doc = "The log probabilities of the transcription."] # [builder (default)] pub logprobs : Option < Vec < crate :: __types :: LogProbProperties > > , # [doc = "Usage statistics for the transcription."] pub usage : crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_completed :: Usage }
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionCompleted { # [serde (rename = "event_id")] event_id : String , # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_completed :: Type , # [serde (rename = "item_id")] item_id : String , # [serde (rename = "content_index")] content_index : i64 , # [serde (rename = "transcript")] transcript : String , # [serde (rename = "logprobs")] logprobs : Option < Vec < crate :: __types :: LogProbProperties > > , # [serde (rename = "usage")] usage : crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_completed :: Usage }
        let RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
            event_id,
            item_id,
            content_index,
            transcript,
            logprobs,
            usage,
            ..
        } = RealtimeServerEventConversationItemInputAudioTranscriptionCompleted::deserialize(
            deserializer,
        )?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            transcript,
            logprobs,
            usage,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionCompleted < 'a > { # [serde (rename = "event_id")] event_id : & 'a String , # [serde (rename = "type")] r#type : & 'a crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_completed :: Type , # [serde (rename = "item_id")] item_id : & 'a String , # [serde (rename = "content_index")] content_index : & 'a i64 , # [serde (rename = "transcript")] transcript : & 'a String , # [serde (rename = "logprobs")] # [serde (skip_serializing_if = "Option::is_none")] logprobs : & 'a Option < Vec < crate :: __types :: LogProbProperties > > , # [serde (rename = "usage")] usage : & 'a crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_completed :: Usage }
        let Self {
            event_id,
            item_id,
            content_index,
            transcript,
            logprobs,
            usage,
        } = self;
        RealtimeServerEventConversationItemInputAudioTranscriptionCompleted {
            event_id,
            r#type: &Default::default(),
            item_id,
            content_index,
            transcript,
            logprobs,
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_conversation_item_input_audio_transcription_delta {
    #[doc = "The event type, must be `conversation.item.input_audio_transcription.delta`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.input_audio_transcription.delta");
}
#[doc = "Returned when the text value of an input audio transcription content part is updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the content part in the item's content array."]
    #[builder(default)]
    pub content_index: Option<i64>,
    #[doc = "The text delta."]
    #[builder(default)]
    pub delta: Option<String>,
    #[doc = "The log probabilities of the transcription."]
    #[builder(default)]
    pub logprobs: Option<Vec<crate::__types::LogProbProperties>>,
}
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionDelta
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionDelta { # [serde (rename = "event_id")] event_id : String , # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_delta :: Type , # [serde (rename = "item_id")] item_id : String , # [serde (rename = "content_index")] content_index : Option < i64 > , # [serde (rename = "delta")] delta : Option < String > , # [serde (rename = "logprobs")] logprobs : Option < Vec < crate :: __types :: LogProbProperties > > }
        let RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
            event_id,
            item_id,
            content_index,
            delta,
            logprobs,
            ..
        } = RealtimeServerEventConversationItemInputAudioTranscriptionDelta::deserialize(
            deserializer,
        )?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            delta,
            logprobs,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionDelta < 'a > { # [serde (rename = "event_id")] event_id : & 'a String , # [serde (rename = "type")] r#type : & 'a crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_delta :: Type , # [serde (rename = "item_id")] item_id : & 'a String , # [serde (rename = "content_index")] # [serde (skip_serializing_if = "Option::is_none")] content_index : & 'a Option < i64 > , # [serde (rename = "delta")] # [serde (skip_serializing_if = "Option::is_none")] delta : & 'a Option < String > , # [serde (rename = "logprobs")] # [serde (skip_serializing_if = "Option::is_none")] logprobs : & 'a Option < Vec < crate :: __types :: LogProbProperties > > }
        let Self {
            event_id,
            item_id,
            content_index,
            delta,
            logprobs,
        } = self;
        RealtimeServerEventConversationItemInputAudioTranscriptionDelta {
            event_id,
            r#type: &Default::default(),
            item_id,
            content_index,
            delta,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod realtime_server_event_conversation_item_input_audio_transcription_failed {
    #[doc = "The event type, must be\n`conversation.item.input_audio_transcription.failed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.input_audio_transcription.failed");
    #[doc = "Details of the transcription error."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Error {
        #[doc = "The type of error."]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<String>,
        #[doc = "Error code, if any."]
        #[serde(rename = "code")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code: Option<String>,
        #[doc = "A human-readable error message."]
        #[serde(rename = "message")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub message: Option<String>,
        #[doc = "Parameter related to the error, if any."]
        #[serde(rename = "param")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub param: Option<String>,
    }
}
#[doc = "Returned when input audio transcription is configured, and a transcription \nrequest for a user message failed. These events are separate from other \n`error` events so that the client can identify the related Item.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed { # [doc = "The unique ID of the server event."] pub event_id : String , # [doc = "The ID of the user message item."] pub item_id : String , # [doc = "The index of the content part containing the audio."] pub content_index : i64 , # [doc = "Details of the transcription error."] # [builder (default)] pub error : crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_failed :: Error }
impl<'de> serde::Deserialize<'de>
    for RealtimeServerEventConversationItemInputAudioTranscriptionFailed
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed { # [serde (rename = "event_id")] event_id : String , # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_failed :: Type , # [serde (rename = "item_id")] item_id : String , # [serde (rename = "content_index")] content_index : i64 , # [serde (rename = "error")] error : crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_failed :: Error }
        let RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
            event_id,
            item_id,
            content_index,
            error,
            ..
        } = RealtimeServerEventConversationItemInputAudioTranscriptionFailed::deserialize(
            deserializer,
        )?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            error,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemInputAudioTranscriptionFailed < 'a > { # [serde (rename = "event_id")] event_id : & 'a String , # [serde (rename = "type")] r#type : & 'a crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_failed :: Type , # [serde (rename = "item_id")] item_id : & 'a String , # [serde (rename = "content_index")] content_index : & 'a i64 , # [serde (rename = "error")] error : & 'a crate :: __types :: realtime_server_event_conversation_item_input_audio_transcription_failed :: Error }
        let Self {
            event_id,
            item_id,
            content_index,
            error,
        } = self;
        RealtimeServerEventConversationItemInputAudioTranscriptionFailed {
            event_id,
            r#type: &Default::default(),
            item_id,
            content_index,
            error,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_conversation_item_retrieved {
    #[doc = "The event type, must be `conversation.item.retrieved`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.retrieved");
}
#[doc = "Returned when a conversation item is retrieved with `conversation.item.retrieve`.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemRetrieved {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub item: crate::__types::RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemRetrieved {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemRetrieved {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_conversation_item_retrieved::Type,
            #[serde(rename = "item")]
            item: crate::__types::RealtimeConversationItem,
        }
        let RealtimeServerEventConversationItemRetrieved { event_id, item, .. } =
            RealtimeServerEventConversationItemRetrieved::deserialize(deserializer)?;
        Ok(Self { event_id, item })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemRetrieved {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemRetrieved<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_conversation_item_retrieved::Type,
            #[serde(rename = "item")]
            item: &'a crate::__types::RealtimeConversationItem,
        }
        let Self { event_id, item } = self;
        RealtimeServerEventConversationItemRetrieved {
            event_id,
            r#type: &Default::default(),
            item,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_conversation_item_truncated {
    #[doc = "The event type, must be `conversation.item.truncated`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "conversation.item.truncated");
}
#[doc = "Returned when an earlier assistant audio message item is truncated by the \nclient with a `conversation.item.truncate` event. This event is used to \nsynchronize the server's understanding of the audio with the client's playback.\n\nThis action will truncate the audio and remove the server-side text transcript \nto ensure there is no text in the context that hasn't been heard by the user.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventConversationItemTruncated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the assistant message item that was truncated."]
    pub item_id: String,
    #[doc = "The index of the content part that was truncated."]
    pub content_index: i64,
    #[doc = "The duration up to which the audio was truncated, in milliseconds.\n"]
    pub audio_end_ms: i64,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventConversationItemTruncated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventConversationItemTruncated {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_conversation_item_truncated::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: i64,
        }
        let RealtimeServerEventConversationItemTruncated {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
            ..
        } = RealtimeServerEventConversationItemTruncated::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        })
    }
}
impl serde::Serialize for RealtimeServerEventConversationItemTruncated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventConversationItemTruncated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_conversation_item_truncated::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a i64,
        }
        let Self {
            event_id,
            item_id,
            content_index,
            audio_end_ms,
        } = self;
        RealtimeServerEventConversationItemTruncated {
            event_id,
            r#type: &Default::default(),
            item_id,
            content_index,
            audio_end_ms,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod realtime_server_event_error {
    #[doc = "The event type, must be `error`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "error");
    #[doc = "Details of the error."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Error {
        #[doc = "The type of error (e.g., \"invalid_request_error\", \"server_error\").\n"]
        #[serde(rename = "type")]
        pub r#type: String,
        #[doc = "Error code, if any."]
        #[serde(rename = "code")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code: Option<String>,
        #[doc = "A human-readable error message."]
        #[serde(rename = "message")]
        pub message: String,
        #[doc = "Parameter related to the error, if any."]
        #[serde(rename = "param")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub param: Option<String>,
        #[doc = "The event_id of the client event that caused the error, if applicable.\n"]
        #[serde(rename = "event_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub event_id: Option<String>,
    }
}
#[doc = "Returned when an error occurs, which could be a client problem or a server \nproblem. Most errors are recoverable and the session will stay open, we \nrecommend to implementors to monitor and log error messages by default.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventError {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Details of the error."]
    pub error: crate::__types::realtime_server_event_error::Error,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventError {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventError {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_error::Type,
            #[serde(rename = "error")]
            error: crate::__types::realtime_server_event_error::Error,
        }
        let RealtimeServerEventError {
            event_id, error, ..
        } = RealtimeServerEventError::deserialize(deserializer)?;
        Ok(Self { event_id, error })
    }
}
impl serde::Serialize for RealtimeServerEventError {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventError<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_error::Type,
            #[serde(rename = "error")]
            error: &'a crate::__types::realtime_server_event_error::Error,
        }
        let Self { event_id, error } = self;
        RealtimeServerEventError {
            event_id,
            r#type: &Default::default(),
            error,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_input_audio_buffer_cleared {
    #[doc = "The event type, must be `input_audio_buffer.cleared`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio_buffer.cleared");
}
#[doc = "Returned when the input audio buffer is cleared by the client with a \n`input_audio_buffer.clear` event.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferCleared {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferCleared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventInputAudioBufferCleared {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_input_audio_buffer_cleared::Type,
        }
        let RealtimeServerEventInputAudioBufferCleared { event_id, .. } =
            RealtimeServerEventInputAudioBufferCleared::deserialize(deserializer)?;
        Ok(Self { event_id })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferCleared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventInputAudioBufferCleared<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_input_audio_buffer_cleared::Type,
        }
        let Self { event_id } = self;
        RealtimeServerEventInputAudioBufferCleared {
            event_id,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_input_audio_buffer_committed {
    #[doc = "The event type, must be `input_audio_buffer.committed`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio_buffer.committed");
}
#[doc = "Returned when an input audio buffer is committed, either by the client or \nautomatically in server VAD mode. The `item_id` property is the ID of the user\nmessage item that will be created, thus a `conversation.item.created` event \nwill also be sent to the client.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferCommitted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the preceding item after which the new item will be inserted.\nCan be `null` if the item has no predecessor.\n"]
    #[builder(default)]
    pub previous_item_id: Option<String>,
    #[doc = "The ID of the user message item that will be created."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferCommitted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventInputAudioBufferCommitted {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_input_audio_buffer_committed::Type,
            #[serde(rename = "previous_item_id")]
            previous_item_id: Option<String>,
            #[serde(rename = "item_id")]
            item_id: String,
        }
        let RealtimeServerEventInputAudioBufferCommitted {
            event_id,
            previous_item_id,
            item_id,
            ..
        } = RealtimeServerEventInputAudioBufferCommitted::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            previous_item_id,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferCommitted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventInputAudioBufferCommitted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_input_audio_buffer_committed::Type,
            #[serde(rename = "previous_item_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            previous_item_id: &'a Option<String>,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            event_id,
            previous_item_id,
            item_id,
        } = self;
        RealtimeServerEventInputAudioBufferCommitted {
            event_id,
            r#type: &Default::default(),
            previous_item_id,
            item_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_input_audio_buffer_speech_started {
    #[doc = "The event type, must be `input_audio_buffer.speech_started`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio_buffer.speech_started");
}
#[doc = "Sent by the server when in `server_vad` mode to indicate that speech has been \ndetected in the audio buffer. This can happen any time audio is added to the \nbuffer (unless speech is already detected). The client may want to use this \nevent to interrupt audio playback or provide visual feedback to the user. \n\nThe client should expect to receive a `input_audio_buffer.speech_stopped` event \nwhen speech stops. The `item_id` property is the ID of the user message item \nthat will be created when speech stops and will also be included in the \n`input_audio_buffer.speech_stopped` event (unless the client manually commits \nthe audio buffer during VAD activation).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferSpeechStarted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Milliseconds from the start of all audio written to the buffer during the \nsession when speech was first detected. This will correspond to the \nbeginning of audio sent to the model, and thus includes the \n`prefix_padding_ms` configured in the Session.\n"]
    pub audio_start_ms: i64,
    #[doc = "The ID of the user message item that will be created when speech stops.\n"]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferSpeechStarted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventInputAudioBufferSpeechStarted {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_input_audio_buffer_speech_started::Type,
            #[serde(rename = "audio_start_ms")]
            audio_start_ms: i64,
            #[serde(rename = "item_id")]
            item_id: String,
        }
        let RealtimeServerEventInputAudioBufferSpeechStarted {
            event_id,
            audio_start_ms,
            item_id,
            ..
        } = RealtimeServerEventInputAudioBufferSpeechStarted::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            audio_start_ms,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferSpeechStarted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventInputAudioBufferSpeechStarted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type:
                &'a crate::__types::realtime_server_event_input_audio_buffer_speech_started::Type,
            #[serde(rename = "audio_start_ms")]
            audio_start_ms: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            event_id,
            audio_start_ms,
            item_id,
        } = self;
        RealtimeServerEventInputAudioBufferSpeechStarted {
            event_id,
            r#type: &Default::default(),
            audio_start_ms,
            item_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_input_audio_buffer_speech_stopped {
    #[doc = "The event type, must be `input_audio_buffer.speech_stopped`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_audio_buffer.speech_stopped");
}
#[doc = "Returned in `server_vad` mode when the server detects the end of speech in \nthe audio buffer. The server will also send an `conversation.item.created` \nevent with the user message item that is created from the audio buffer.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventInputAudioBufferSpeechStopped {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "Milliseconds since the session started when speech stopped. This will \ncorrespond to the end of audio sent to the model, and thus includes the \n`min_silence_duration_ms` configured in the Session.\n"]
    pub audio_end_ms: i64,
    #[doc = "The ID of the user message item that will be created."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventInputAudioBufferSpeechStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventInputAudioBufferSpeechStopped {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_input_audio_buffer_speech_stopped::Type,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: i64,
            #[serde(rename = "item_id")]
            item_id: String,
        }
        let RealtimeServerEventInputAudioBufferSpeechStopped {
            event_id,
            audio_end_ms,
            item_id,
            ..
        } = RealtimeServerEventInputAudioBufferSpeechStopped::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            audio_end_ms,
            item_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventInputAudioBufferSpeechStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventInputAudioBufferSpeechStopped<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type:
                &'a crate::__types::realtime_server_event_input_audio_buffer_speech_stopped::Type,
            #[serde(rename = "audio_end_ms")]
            audio_end_ms: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            event_id,
            audio_end_ms,
            item_id,
        } = self;
        RealtimeServerEventInputAudioBufferSpeechStopped {
            event_id,
            r#type: &Default::default(),
            audio_end_ms,
            item_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_output_audio_buffer_cleared {
    #[doc = "The event type, must be `output_audio_buffer.cleared`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "output_audio_buffer.cleared");
}
#[doc = "**WebRTC Only:** Emitted when the output audio buffer is cleared. This happens either in VAD\nmode when the user has interrupted (`input_audio_buffer.speech_started`),\nor when the client has emitted the `output_audio_buffer.clear` event to manually\ncut off the current audio response.\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferCleared {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferCleared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventOutputAudioBufferCleared {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_output_audio_buffer_cleared::Type,
            #[serde(rename = "response_id")]
            response_id: String,
        }
        let RealtimeServerEventOutputAudioBufferCleared {
            event_id,
            response_id,
            ..
        } = RealtimeServerEventOutputAudioBufferCleared::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferCleared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventOutputAudioBufferCleared<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_output_audio_buffer_cleared::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let Self {
            event_id,
            response_id,
        } = self;
        RealtimeServerEventOutputAudioBufferCleared {
            event_id,
            r#type: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_output_audio_buffer_started {
    #[doc = "The event type, must be `output_audio_buffer.started`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "output_audio_buffer.started");
}
#[doc = "**WebRTC Only:** Emitted when the server begins streaming audio to the client. This event is\nemitted after an audio content part has been added (`response.content_part.added`)\nto the response.\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferStarted {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferStarted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventOutputAudioBufferStarted {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_output_audio_buffer_started::Type,
            #[serde(rename = "response_id")]
            response_id: String,
        }
        let RealtimeServerEventOutputAudioBufferStarted {
            event_id,
            response_id,
            ..
        } = RealtimeServerEventOutputAudioBufferStarted::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferStarted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventOutputAudioBufferStarted<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_output_audio_buffer_started::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let Self {
            event_id,
            response_id,
        } = self;
        RealtimeServerEventOutputAudioBufferStarted {
            event_id,
            r#type: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_output_audio_buffer_stopped {
    #[doc = "The event type, must be `output_audio_buffer.stopped`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "output_audio_buffer.stopped");
}
#[doc = "**WebRTC Only:** Emitted when the output audio buffer has been completely drained on the server,\nand no more audio is forthcoming. This event is emitted after the full response\ndata has been sent to the client (`response.done`).\n[Learn more](https://platform.openai.com/docs/guides/realtime-conversations#client-and-server-events-for-audio-in-webrtc).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventOutputAudioBufferStopped {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The unique ID of the response that produced the audio."]
    pub response_id: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventOutputAudioBufferStopped {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventOutputAudioBufferStopped {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_output_audio_buffer_stopped::Type,
            #[serde(rename = "response_id")]
            response_id: String,
        }
        let RealtimeServerEventOutputAudioBufferStopped {
            event_id,
            response_id,
            ..
        } = RealtimeServerEventOutputAudioBufferStopped::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
        })
    }
}
impl serde::Serialize for RealtimeServerEventOutputAudioBufferStopped {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventOutputAudioBufferStopped<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_output_audio_buffer_stopped::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
        }
        let Self {
            event_id,
            response_id,
        } = self;
        RealtimeServerEventOutputAudioBufferStopped {
            event_id,
            r#type: &Default::default(),
            response_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod realtime_server_event_rate_limits_updated {
    #[doc = "The event type, must be `rate_limits.updated`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "rate_limits.updated");
    #[allow(clippy::module_inception)]
    pub mod rate_limits {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The name of the rate limit (`requests`, `tokens`).\n"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Name {
                #[doc = "`requests`"]
                #[serde(rename = "requests")]
                Requests,
                #[doc = "`tokens`"]
                #[serde(rename = "tokens")]
                Tokens,
            }
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The name of the rate limit (`requests`, `tokens`).\n"]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub name: Option<
                crate::__types::realtime_server_event_rate_limits_updated::rate_limits::item::Name,
            >,
            #[doc = "The maximum allowed value for the rate limit."]
            #[serde(rename = "limit")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub limit: Option<i64>,
            #[doc = "The remaining value before the limit is reached."]
            #[serde(rename = "remaining")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub remaining: Option<i64>,
            #[doc = "Seconds until the rate limit resets."]
            #[serde(rename = "reset_seconds")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub reset_seconds: Option<serde_json::Number>,
        }
    }
}
#[doc = "Emitted at the beginning of a Response to indicate the updated rate limits. \nWhen a Response is created some tokens will be \"reserved\" for the output \ntokens, the rate limits shown here reflect that reservation, which is then \nadjusted accordingly once the Response is completed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventRateLimitsUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "List of rate limit information."]
    pub rate_limits:
        Vec<crate::__types::realtime_server_event_rate_limits_updated::rate_limits::Item>,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventRateLimitsUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventRateLimitsUpdated {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_rate_limits_updated::Type,
            #[serde(rename = "rate_limits")]
            rate_limits:
                Vec<crate::__types::realtime_server_event_rate_limits_updated::rate_limits::Item>,
        }
        let RealtimeServerEventRateLimitsUpdated {
            event_id,
            rate_limits,
            ..
        } = RealtimeServerEventRateLimitsUpdated::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            rate_limits,
        })
    }
}
impl serde::Serialize for RealtimeServerEventRateLimitsUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventRateLimitsUpdated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_rate_limits_updated::Type,
            #[serde(rename = "rate_limits")]
            rate_limits: &'a Vec<
                crate::__types::realtime_server_event_rate_limits_updated::rate_limits::Item,
            >,
        }
        let Self {
            event_id,
            rate_limits,
        } = self;
        RealtimeServerEventRateLimitsUpdated {
            event_id,
            r#type: &Default::default(),
            rate_limits,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_audio_delta {
    #[doc = "The event type, must be `response.audio.delta`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.audio.delta");
}
#[doc = "Returned when the model-generated audio is updated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: i64,
    #[doc = "Base64-encoded audio data delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseAudioDelta {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_audio_delta::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "delta")]
            delta: String,
        }
        let RealtimeServerEventResponseAudioDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = RealtimeServerEventResponseAudioDelta::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseAudioDelta<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_audio_delta::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        RealtimeServerEventResponseAudioDelta {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_audio_done {
    #[doc = "The event type, must be `response.audio.done`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.audio.done");
}
#[doc = "Returned when the model-generated audio is done. Also emitted when a Response\nis interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: i64,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseAudioDone {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_audio_done::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
        }
        let RealtimeServerEventResponseAudioDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            ..
        } = RealtimeServerEventResponseAudioDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseAudioDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_audio_done::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
        } = self;
        RealtimeServerEventResponseAudioDone {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_audio_transcript_delta {
    #[doc = "The event type, must be `response.audio_transcript.delta`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.audio_transcript.delta");
}
#[doc = "Returned when the model-generated transcription of audio output is updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioTranscriptDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: i64,
    #[doc = "The transcript delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioTranscriptDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseAudioTranscriptDelta {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_audio_transcript_delta::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "delta")]
            delta: String,
        }
        let RealtimeServerEventResponseAudioTranscriptDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = RealtimeServerEventResponseAudioTranscriptDelta::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioTranscriptDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseAudioTranscriptDelta<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_audio_transcript_delta::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        RealtimeServerEventResponseAudioTranscriptDelta {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_audio_transcript_done {
    #[doc = "The event type, must be `response.audio_transcript.done`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.audio_transcript.done");
}
#[doc = "Returned when the model-generated transcription of audio output is done\nstreaming. Also emitted when a Response is interrupted, incomplete, or\ncancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseAudioTranscriptDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: i64,
    #[doc = "The final transcript of the audio."]
    pub transcript: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseAudioTranscriptDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseAudioTranscriptDone {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_audio_transcript_done::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "transcript")]
            transcript: String,
        }
        let RealtimeServerEventResponseAudioTranscriptDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
            ..
        } = RealtimeServerEventResponseAudioTranscriptDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseAudioTranscriptDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseAudioTranscriptDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_audio_transcript_done::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "transcript")]
            transcript: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        } = self;
        RealtimeServerEventResponseAudioTranscriptDone {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            transcript,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod realtime_server_event_response_content_part_added {
    #[doc = "The event type, must be `response.content_part.added`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.content_part.added");
    #[allow(clippy::module_inception)]
    pub mod part {
        #[doc = "The content type (\"text\", \"audio\")."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Type {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[doc = "The content part that was added."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Part {
        #[doc = "The content type (\"text\", \"audio\")."]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type:
            Option<crate::__types::realtime_server_event_response_content_part_added::part::Type>,
        #[doc = "The text content (if type is \"text\")."]
        #[serde(rename = "text")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub text: Option<String>,
        #[doc = "Base64-encoded audio data (if type is \"audio\")."]
        #[serde(rename = "audio")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub audio: Option<String>,
        #[doc = "The transcript of the audio (if type is \"audio\")."]
        #[serde(rename = "transcript")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub transcript: Option<String>,
    }
}
#[doc = "Returned when a new content part is added to an assistant message item during\nresponse generation.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartAdded {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item to which the content part was added."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: i64,
    #[doc = "The content part that was added."]
    #[builder(default)]
    pub part: crate::__types::realtime_server_event_response_content_part_added::Part,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartAdded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseContentPartAdded {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_content_part_added::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "part")]
            part: crate::__types::realtime_server_event_response_content_part_added::Part,
        }
        let RealtimeServerEventResponseContentPartAdded {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
            ..
        } = RealtimeServerEventResponseContentPartAdded::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartAdded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseContentPartAdded<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_content_part_added::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "part")]
            part: &'a crate::__types::realtime_server_event_response_content_part_added::Part,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        } = self;
        RealtimeServerEventResponseContentPartAdded {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod realtime_server_event_response_content_part_done {
    #[doc = "The event type, must be `response.content_part.done`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.content_part.done");
    #[allow(clippy::module_inception)]
    pub mod part {
        #[doc = "The content type (\"text\", \"audio\")."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Type {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[doc = "The content part that is done."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Part {
        #[doc = "The content type (\"text\", \"audio\")."]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type:
            Option<crate::__types::realtime_server_event_response_content_part_done::part::Type>,
        #[doc = "The text content (if type is \"text\")."]
        #[serde(rename = "text")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub text: Option<String>,
        #[doc = "Base64-encoded audio data (if type is \"audio\")."]
        #[serde(rename = "audio")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub audio: Option<String>,
        #[doc = "The transcript of the audio (if type is \"audio\")."]
        #[serde(rename = "transcript")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub transcript: Option<String>,
    }
}
#[doc = "Returned when a content part is done streaming in an assistant message item.\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseContentPartDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: i64,
    #[doc = "The content part that is done."]
    #[builder(default)]
    pub part: crate::__types::realtime_server_event_response_content_part_done::Part,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseContentPartDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseContentPartDone {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_content_part_done::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "part")]
            part: crate::__types::realtime_server_event_response_content_part_done::Part,
        }
        let RealtimeServerEventResponseContentPartDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
            ..
        } = RealtimeServerEventResponseContentPartDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseContentPartDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseContentPartDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_content_part_done::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "part")]
            part: &'a crate::__types::realtime_server_event_response_content_part_done::Part,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        } = self;
        RealtimeServerEventResponseContentPartDone {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            part,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_created {
    #[doc = "The event type, must be `response.created`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.created");
}
#[doc = "Returned when a new Response is created. The first event of response creation,\nwhere the response is in an initial state of `in_progress`.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub response: crate::__types::RealtimeResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseCreated {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_created::Type,
            #[serde(rename = "response")]
            response: crate::__types::RealtimeResponse,
        }
        let RealtimeServerEventResponseCreated {
            event_id, response, ..
        } = RealtimeServerEventResponseCreated::deserialize(deserializer)?;
        Ok(Self { event_id, response })
    }
}
impl serde::Serialize for RealtimeServerEventResponseCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseCreated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_created::Type,
            #[serde(rename = "response")]
            response: &'a crate::__types::RealtimeResponse,
        }
        let Self { event_id, response } = self;
        RealtimeServerEventResponseCreated {
            event_id,
            r#type: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_done {
    #[doc = "The event type, must be `response.done`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.done");
}
#[doc = "Returned when a Response is done streaming. Always emitted, no matter the \nfinal state. The Response object included in the `response.done` event will \ninclude all output Items in the Response but will omit the raw audio data.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub response: crate::__types::RealtimeResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseDone {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_done::Type,
            #[serde(rename = "response")]
            response: crate::__types::RealtimeResponse,
        }
        let RealtimeServerEventResponseDone {
            event_id, response, ..
        } = RealtimeServerEventResponseDone::deserialize(deserializer)?;
        Ok(Self { event_id, response })
    }
}
impl serde::Serialize for RealtimeServerEventResponseDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_done::Type,
            #[serde(rename = "response")]
            response: &'a crate::__types::RealtimeResponse,
        }
        let Self { event_id, response } = self;
        RealtimeServerEventResponseDone {
            event_id,
            r#type: &Default::default(),
            response,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_function_call_arguments_delta {
    #[doc = "The event type, must be `response.function_call_arguments.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.function_call_arguments.delta");
}
#[doc = "Returned when the model-generated function call arguments are updated.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseFunctionCallArgumentsDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the function call item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The ID of the function call."]
    pub call_id: String,
    #[doc = "The arguments delta as a JSON string."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseFunctionCallArgumentsDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseFunctionCallArgumentsDelta {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type:
                crate::__types::realtime_server_event_response_function_call_arguments_delta::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "delta")]
            delta: String,
        }
        let RealtimeServerEventResponseFunctionCallArgumentsDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
            ..
        } = RealtimeServerEventResponseFunctionCallArgumentsDelta::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseFunctionCallArgumentsDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseFunctionCallArgumentsDelta < 'a > { # [serde (rename = "event_id")] event_id : & 'a String , # [serde (rename = "type")] r#type : & 'a crate :: __types :: realtime_server_event_response_function_call_arguments_delta :: Type , # [serde (rename = "response_id")] response_id : & 'a String , # [serde (rename = "item_id")] item_id : & 'a String , # [serde (rename = "output_index")] output_index : & 'a i64 , # [serde (rename = "call_id")] call_id : & 'a String , # [serde (rename = "delta")] delta : & 'a String }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        } = self;
        RealtimeServerEventResponseFunctionCallArgumentsDelta {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            call_id,
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_function_call_arguments_done {
    #[doc = "The event type, must be `response.function_call_arguments.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.function_call_arguments.done");
}
#[doc = "Returned when the model-generated function call arguments are done streaming.\nAlso emitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseFunctionCallArgumentsDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the function call item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The ID of the function call."]
    pub call_id: String,
    #[doc = "The final arguments as a JSON string."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseFunctionCallArgumentsDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseFunctionCallArgumentsDone {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type:
                crate::__types::realtime_server_event_response_function_call_arguments_done::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "arguments")]
            arguments: String,
        }
        let RealtimeServerEventResponseFunctionCallArgumentsDone {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
            ..
        } = RealtimeServerEventResponseFunctionCallArgumentsDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseFunctionCallArgumentsDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseFunctionCallArgumentsDone < 'a > { # [serde (rename = "event_id")] event_id : & 'a String , # [serde (rename = "type")] r#type : & 'a crate :: __types :: realtime_server_event_response_function_call_arguments_done :: Type , # [serde (rename = "response_id")] response_id : & 'a String , # [serde (rename = "item_id")] item_id : & 'a String , # [serde (rename = "output_index")] output_index : & 'a i64 , # [serde (rename = "call_id")] call_id : & 'a String , # [serde (rename = "arguments")] arguments : & 'a String }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        } = self;
        RealtimeServerEventResponseFunctionCallArgumentsDone {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            call_id,
            arguments,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_output_item_added {
    #[doc = "The event type, must be `response.output_item.added`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.output_item.added");
}
#[doc = "Returned when a new Item is created during Response generation."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseOutputItemAdded {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the Response to which the item belongs."]
    pub response_id: String,
    #[doc = "The index of the output item in the Response."]
    pub output_index: i64,
    #[builder(default)]
    pub item: crate::__types::RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseOutputItemAdded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseOutputItemAdded {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_output_item_added::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item")]
            item: crate::__types::RealtimeConversationItem,
        }
        let RealtimeServerEventResponseOutputItemAdded {
            event_id,
            response_id,
            output_index,
            item,
            ..
        } = RealtimeServerEventResponseOutputItemAdded::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            output_index,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseOutputItemAdded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseOutputItemAdded<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_output_item_added::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item")]
            item: &'a crate::__types::RealtimeConversationItem,
        }
        let Self {
            event_id,
            response_id,
            output_index,
            item,
        } = self;
        RealtimeServerEventResponseOutputItemAdded {
            event_id,
            r#type: &Default::default(),
            response_id,
            output_index,
            item,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_output_item_done {
    #[doc = "The event type, must be `response.output_item.done`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.output_item.done");
}
#[doc = "Returned when an Item is done streaming. Also emitted when a Response is \ninterrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseOutputItemDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the Response to which the item belongs."]
    pub response_id: String,
    #[doc = "The index of the output item in the Response."]
    pub output_index: i64,
    #[builder(default)]
    pub item: crate::__types::RealtimeConversationItem,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseOutputItemDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseOutputItemDone {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_output_item_done::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item")]
            item: crate::__types::RealtimeConversationItem,
        }
        let RealtimeServerEventResponseOutputItemDone {
            event_id,
            response_id,
            output_index,
            item,
            ..
        } = RealtimeServerEventResponseOutputItemDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            output_index,
            item,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseOutputItemDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseOutputItemDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_output_item_done::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item")]
            item: &'a crate::__types::RealtimeConversationItem,
        }
        let Self {
            event_id,
            response_id,
            output_index,
            item,
        } = self;
        RealtimeServerEventResponseOutputItemDone {
            event_id,
            r#type: &Default::default(),
            response_id,
            output_index,
            item,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_text_delta {
    #[doc = "The event type, must be `response.text.delta`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.text.delta");
}
#[doc = "Returned when the text value of a \"text\" content part is updated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseTextDelta {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: i64,
    #[doc = "The text delta."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseTextDelta {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseTextDelta {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_text_delta::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "delta")]
            delta: String,
        }
        let RealtimeServerEventResponseTextDelta {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
            ..
        } = RealtimeServerEventResponseTextDelta::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseTextDelta {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseTextDelta<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_text_delta::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        } = self;
        RealtimeServerEventResponseTextDelta {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_response_text_done {
    #[doc = "The event type, must be `response.text.done`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.text.done");
}
#[doc = "Returned when the text value of a \"text\" content part is done streaming. Also\nemitted when a Response is interrupted, incomplete, or cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventResponseTextDone {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[doc = "The ID of the response."]
    pub response_id: String,
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item in the response."]
    pub output_index: i64,
    #[doc = "The index of the content part in the item's content array."]
    pub content_index: i64,
    #[doc = "The final text content."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventResponseTextDone {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventResponseTextDone {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_response_text_done::Type,
            #[serde(rename = "response_id")]
            response_id: String,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "text")]
            text: String,
        }
        let RealtimeServerEventResponseTextDone {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
            ..
        } = RealtimeServerEventResponseTextDone::deserialize(deserializer)?;
        Ok(Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        })
    }
}
impl serde::Serialize for RealtimeServerEventResponseTextDone {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventResponseTextDone<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_response_text_done::Type,
            #[serde(rename = "response_id")]
            response_id: &'a String,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self {
            event_id,
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        } = self;
        RealtimeServerEventResponseTextDone {
            event_id,
            r#type: &Default::default(),
            response_id,
            item_id,
            output_index,
            content_index,
            text,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_session_created {
    #[doc = "The event type, must be `session.created`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "session.created");
}
#[doc = "Returned when a Session is created. Emitted automatically when a new \nconnection is established as the first server event. This event will contain \nthe default Session configuration.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventSessionCreated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub session: crate::__types::RealtimeSession,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventSessionCreated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventSessionCreated {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_session_created::Type,
            #[serde(rename = "session")]
            session: crate::__types::RealtimeSession,
        }
        let RealtimeServerEventSessionCreated {
            event_id, session, ..
        } = RealtimeServerEventSessionCreated::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventSessionCreated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventSessionCreated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_session_created::Type,
            #[serde(rename = "session")]
            session: &'a crate::__types::RealtimeSession,
        }
        let Self { event_id, session } = self;
        RealtimeServerEventSessionCreated {
            event_id,
            r#type: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_session_updated {
    #[doc = "The event type, must be `session.updated`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "session.updated");
}
#[doc = "Returned when a session is updated with a `session.update` event, unless \nthere is an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventSessionUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    #[builder(default)]
    pub session: crate::__types::RealtimeSession,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventSessionUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventSessionUpdated {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_session_updated::Type,
            #[serde(rename = "session")]
            session: crate::__types::RealtimeSession,
        }
        let RealtimeServerEventSessionUpdated {
            event_id, session, ..
        } = RealtimeServerEventSessionUpdated::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventSessionUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventSessionUpdated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_session_updated::Type,
            #[serde(rename = "session")]
            session: &'a crate::__types::RealtimeSession,
        }
        let Self { event_id, session } = self;
        RealtimeServerEventSessionUpdated {
            event_id,
            r#type: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod realtime_server_event_transcription_session_updated {
    #[doc = "The event type, must be `transcription_session.updated`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "transcription_session.updated");
}
#[doc = "Returned when a transcription session is updated with a `transcription_session.update` event, unless \nthere is an error.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RealtimeServerEventTranscriptionSessionUpdated {
    #[doc = "The unique ID of the server event."]
    pub event_id: String,
    pub session: crate::__types::RealtimeTranscriptionSessionCreateResponse,
}
impl<'de> serde::Deserialize<'de> for RealtimeServerEventTranscriptionSessionUpdated {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RealtimeServerEventTranscriptionSessionUpdated {
            #[serde(rename = "event_id")]
            event_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::realtime_server_event_transcription_session_updated::Type,
            #[serde(rename = "session")]
            session: crate::__types::RealtimeTranscriptionSessionCreateResponse,
        }
        let RealtimeServerEventTranscriptionSessionUpdated {
            event_id, session, ..
        } = RealtimeServerEventTranscriptionSessionUpdated::deserialize(deserializer)?;
        Ok(Self { event_id, session })
    }
}
impl serde::Serialize for RealtimeServerEventTranscriptionSessionUpdated {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RealtimeServerEventTranscriptionSessionUpdated<'a> {
            #[serde(rename = "event_id")]
            event_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::realtime_server_event_transcription_session_updated::Type,
            #[serde(rename = "session")]
            session: &'a crate::__types::RealtimeTranscriptionSessionCreateResponse,
        }
        let Self { event_id, session } = self;
        RealtimeServerEventTranscriptionSessionUpdated {
            event_id,
            r#type: &Default::default(),
            session,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod realtime_session {
    #[allow(clippy::module_inception)]
    pub mod modalities {
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Item {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[doc = "The Realtime model used for this session.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Model {
        #[doc = "`gpt-4o-realtime-preview`"]
        #[serde(rename = "gpt-4o-realtime-preview")]
        Gpt4oRealtimePreview,
        #[doc = "`gpt-4o-realtime-preview-2024-10-01`"]
        #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
        Gpt4oRealtimePreview2024_10_01,
        #[doc = "`gpt-4o-realtime-preview-2024-12-17`"]
        #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
        Gpt4oRealtimePreview2024_12_17,
        #[doc = "`gpt-4o-realtime-preview-2025-06-03`"]
        #[serde(rename = "gpt-4o-realtime-preview-2025-06-03")]
        Gpt4oRealtimePreview2025_06_03,
        #[doc = "`gpt-4o-mini-realtime-preview`"]
        #[serde(rename = "gpt-4o-mini-realtime-preview")]
        Gpt4oMiniRealtimePreview,
        #[doc = "`gpt-4o-mini-realtime-preview-2024-12-17`"]
        #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
        Gpt4oMiniRealtimePreview2024_12_17,
    }
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum InputAudioFormat {
        #[doc = "`pcm16`"]
        #[default]
        #[serde(rename = "pcm16")]
        Pcm16,
        #[doc = "`g711_ulaw`"]
        #[serde(rename = "g711_ulaw")]
        G711Ulaw,
        #[doc = "`g711_alaw`"]
        #[serde(rename = "g711_alaw")]
        G711Alaw,
    }
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputAudioFormat {
        #[doc = "`pcm16`"]
        #[default]
        #[serde(rename = "pcm16")]
        Pcm16,
        #[doc = "`g711_ulaw`"]
        #[serde(rename = "g711_ulaw")]
        G711Ulaw,
        #[doc = "`g711_alaw`"]
        #[serde(rename = "g711_alaw")]
        G711Alaw,
    }
    #[doc = "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudioTranscription {
        #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
        #[serde(rename = "model")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub model: Option<String>,
        #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
        #[serde(rename = "language")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub language: Option<String>,
        #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](https://platform.openai.com/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"]
        #[serde(rename = "prompt")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub prompt: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod turn_detection {
        #[doc = "Type of turn detection.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Type {
            #[doc = "`server_vad`"]
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
            #[doc = "`semantic_vad`"]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Eagerness {
            #[doc = "`low`"]
            #[serde(rename = "low")]
            Low,
            #[doc = "`medium`"]
            #[serde(rename = "medium")]
            Medium,
            #[doc = "`high`"]
            #[serde(rename = "high")]
            High,
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
    }
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjunction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct TurnDetection {
        #[doc = "Type of turn detection.\n"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<crate::__types::realtime_session::turn_detection::Type>,
        #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
        #[serde(rename = "eagerness")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub eagerness: Option<crate::__types::realtime_session::turn_detection::Eagerness>,
        #[doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"]
        #[serde(rename = "threshold")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub threshold: Option<serde_json::Number>,
        #[doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"]
        #[serde(rename = "prefix_padding_ms")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub prefix_padding_ms: Option<i64>,
        #[doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"]
        #[serde(rename = "silence_duration_ms")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub silence_duration_ms: Option<i64>,
        #[doc = "Whether or not to automatically generate a response when a VAD stop event occurs.\n"]
        #[serde(rename = "create_response")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub create_response: Option<bool>,
        #[doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs.\n"]
        #[serde(rename = "interrupt_response")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub interrupt_response: Option<bool>,
    }
    #[allow(clippy::module_inception)]
    pub mod input_audio_noise_reduction {
        #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Type {
            #[doc = "`near_field`"]
            #[serde(rename = "near_field")]
            NearField,
            #[doc = "`far_field`"]
            #[serde(rename = "far_field")]
            FarField,
        }
    }
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudioNoiseReduction {
        #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<crate::__types::realtime_session::input_audio_noise_reduction::Type>,
    }
    #[allow(clippy::module_inception)]
    pub mod tracing {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
        #[doc = "Granular configuration for tracing.\n"]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Variant1 {
            #[doc = "The name of the workflow to attach to this trace. This is used to\nname the trace in the traces dashboard.\n"]
            #[serde(rename = "workflow_name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub workflow_name: Option<String>,
            #[doc = "The group id to attach to this trace to enable filtering and\ngrouping in the traces dashboard.\n"]
            #[serde(rename = "group_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub group_id: Option<String>,
            #[doc = "The arbitrary metadata to attach to this trace to enable\nfiltering in the traces dashboard.\n"]
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
    }
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Tracing {
        #[doc = "auto"]
        Auto,
        #[doc = "Granular configuration for tracing.\n"]
        Variant1(crate::__types::realtime_session::tracing::Variant1),
    }
    impl<'de> serde::Deserialize<'de> for Tracing {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Tracing {
                Auto(crate::__types::realtime_session::tracing::Auto),
                Variant1(crate::__types::realtime_session::tracing::Variant1),
            }
            Ok(match Tracing::deserialize(deserializer)? {
                Tracing::Auto(_) => Self::Auto,
                Tracing::Variant1(v) => Self::Variant1(v),
            })
        }
    }
    impl serde::Serialize for Tracing {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Tracing<'a> {
                Auto(crate::__types::realtime_session::tracing::Auto),
                Variant1(&'a crate::__types::realtime_session::tracing::Variant1),
            }
            match self {
                Self::Auto => Tracing::Auto(Default::default()),
                Self::Variant1(v) => Tracing::Variant1(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod tools {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The type of the tool, i.e. `function`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub struct Type;
            impl_serde!(Type, "function");
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The type of the tool, i.e. `function`."]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub r#type: Option<crate::__types::realtime_session::tools::item::Type>,
            #[doc = "The name of the function."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub name: Option<String>,
            #[doc = "The description of the function, including guidance on when and how\nto call it, and guidance about what to tell the user when calling\n(if anything).\n"]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub description: Option<String>,
            #[doc = "Parameters of the function in JSON Schema."]
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub parameters: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod max_response_output_tokens {
        #[doc = "inf"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Inf;
        impl_serde!(Inf, "inf");
    }
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum MaxResponseOutputTokens {
        Integer(i64),
        #[doc = "inf"]
        Inf,
    }
    impl<'de> serde::Deserialize<'de> for MaxResponseOutputTokens {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum MaxResponseOutputTokens {
                Inf(crate::__types::realtime_session::max_response_output_tokens::Inf),
                Integer(i64),
            }
            Ok(match MaxResponseOutputTokens::deserialize(deserializer)? {
                MaxResponseOutputTokens::Integer(v) => Self::Integer(v),
                MaxResponseOutputTokens::Inf(_) => Self::Inf,
            })
        }
    }
    impl serde::Serialize for MaxResponseOutputTokens {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum MaxResponseOutputTokens<'a> {
                Integer(&'a i64),
                Inf(crate::__types::realtime_session::max_response_output_tokens::Inf),
            }
            match self {
                Self::Integer(v) => MaxResponseOutputTokens::Integer(v),
                Self::Inf => MaxResponseOutputTokens::Inf(Default::default()),
            }
            .serialize(serializer)
        }
    }
}
#[doc = "Realtime session object configuration."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeSession {
    #[doc = "Unique identifier for the session that looks like `sess_1234567890abcdef`.\n"]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[serde(rename = "modalities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub modalities: Option<Vec<crate::__types::realtime_session::modalities::Item>>,
    #[doc = "The Realtime model used for this session.\n"]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::realtime_session::Model>,
    #[doc = "The default system instructions (i.e. system message) prepended to model\ncalls. This field allows the client to guide the model on desired\nresponses. The model can be instructed on response content and format,\n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good\nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion\ninto your voice\", \"laugh frequently\"). The instructions are not\nguaranteed to be followed by the model, but they provide guidance to the\nmodel on the desired behavior.\n\n\nNote that the server sets default instructions which will be used if this\nfield is not set and are visible in the `session.created` event at the\nstart of the session.\n"]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the\nsession once the model has responded with audio at least once. Current\nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, and `verse`.\n"]
    #[serde(rename = "voice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub voice: Option<crate::__types::VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
    #[serde(rename = "input_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_format: Option<crate::__types::realtime_session::InputAudioFormat>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
    #[serde(rename = "output_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_audio_format: Option<crate::__types::realtime_session::OutputAudioFormat>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[serde(rename = "input_audio_transcription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_transcription:
        Option<crate::__types::realtime_session::InputAudioTranscription>,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjunction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[serde(rename = "turn_detection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub turn_detection: Option<crate::__types::realtime_session::TurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[serde(rename = "input_audio_noise_reduction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_noise_reduction:
        Option<crate::__types::realtime_session::InputAudioNoiseReduction>,
    #[doc = "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\nin between model turns, not while a response is in progress.\n"]
    #[serde(rename = "speed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub speed: Option<serde_json::Number>,
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"]
    #[serde(rename = "tracing")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tracing: Option<crate::__types::realtime_session::Tracing>,
    #[doc = "Tools (functions) available to the model."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::realtime_session::tools::Item>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or\nspecify a function.\n"]
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. For audio models a temperature of 0.8 is highly recommended for best performance.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[serde(rename = "max_response_output_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_response_output_tokens:
        Option<crate::__types::realtime_session::MaxResponseOutputTokens>,
}
#[allow(clippy::module_inception)]
pub mod realtime_session_create_request {
    #[allow(clippy::module_inception)]
    pub mod modalities {
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Item {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[doc = "The Realtime model used for this session.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Model {
        #[doc = "`gpt-4o-realtime-preview`"]
        #[serde(rename = "gpt-4o-realtime-preview")]
        Gpt4oRealtimePreview,
        #[doc = "`gpt-4o-realtime-preview-2024-10-01`"]
        #[serde(rename = "gpt-4o-realtime-preview-2024-10-01")]
        Gpt4oRealtimePreview2024_10_01,
        #[doc = "`gpt-4o-realtime-preview-2024-12-17`"]
        #[serde(rename = "gpt-4o-realtime-preview-2024-12-17")]
        Gpt4oRealtimePreview2024_12_17,
        #[doc = "`gpt-4o-realtime-preview-2025-06-03`"]
        #[serde(rename = "gpt-4o-realtime-preview-2025-06-03")]
        Gpt4oRealtimePreview2025_06_03,
        #[doc = "`gpt-4o-mini-realtime-preview`"]
        #[serde(rename = "gpt-4o-mini-realtime-preview")]
        Gpt4oMiniRealtimePreview,
        #[doc = "`gpt-4o-mini-realtime-preview-2024-12-17`"]
        #[serde(rename = "gpt-4o-mini-realtime-preview-2024-12-17")]
        Gpt4oMiniRealtimePreview2024_12_17,
    }
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum InputAudioFormat {
        #[doc = "`pcm16`"]
        #[default]
        #[serde(rename = "pcm16")]
        Pcm16,
        #[doc = "`g711_ulaw`"]
        #[serde(rename = "g711_ulaw")]
        G711Ulaw,
        #[doc = "`g711_alaw`"]
        #[serde(rename = "g711_alaw")]
        G711Alaw,
    }
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum OutputAudioFormat {
        #[doc = "`pcm16`"]
        #[default]
        #[serde(rename = "pcm16")]
        Pcm16,
        #[doc = "`g711_ulaw`"]
        #[serde(rename = "g711_ulaw")]
        G711Ulaw,
        #[doc = "`g711_alaw`"]
        #[serde(rename = "g711_alaw")]
        G711Alaw,
    }
    #[doc = "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudioTranscription {
        #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
        #[serde(rename = "model")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub model: Option<String>,
        #[doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"]
        #[serde(rename = "language")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub language: Option<String>,
        #[doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](https://platform.openai.com/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"]
        #[serde(rename = "prompt")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub prompt: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod turn_detection {
        #[doc = "Type of turn detection.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Type {
            #[doc = "`server_vad`"]
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
            #[doc = "`semantic_vad`"]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Eagerness {
            #[doc = "`low`"]
            #[serde(rename = "low")]
            Low,
            #[doc = "`medium`"]
            #[serde(rename = "medium")]
            Medium,
            #[doc = "`high`"]
            #[serde(rename = "high")]
            High,
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
    }
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjunction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct TurnDetection {
        #[doc = "Type of turn detection.\n"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<crate::__types::realtime_session_create_request::turn_detection::Type>,
        #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
        #[serde(rename = "eagerness")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub eagerness:
            Option<crate::__types::realtime_session_create_request::turn_detection::Eagerness>,
        #[doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"]
        #[serde(rename = "threshold")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub threshold: Option<serde_json::Number>,
        #[doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"]
        #[serde(rename = "prefix_padding_ms")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub prefix_padding_ms: Option<i64>,
        #[doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"]
        #[serde(rename = "silence_duration_ms")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub silence_duration_ms: Option<i64>,
        #[doc = "Whether or not to automatically generate a response when a VAD stop event occurs.\n"]
        #[serde(rename = "create_response")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub create_response: Option<bool>,
        #[doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs.\n"]
        #[serde(rename = "interrupt_response")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub interrupt_response: Option<bool>,
    }
    #[allow(clippy::module_inception)]
    pub mod input_audio_noise_reduction {
        #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Type {
            #[doc = "`near_field`"]
            #[serde(rename = "near_field")]
            NearField,
            #[doc = "`far_field`"]
            #[serde(rename = "far_field")]
            FarField,
        }
    }
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudioNoiseReduction {
        #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<
            crate::__types::realtime_session_create_request::input_audio_noise_reduction::Type,
        >,
    }
    #[allow(clippy::module_inception)]
    pub mod tracing {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
        #[doc = "Granular configuration for tracing.\n"]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Variant1 {
            #[doc = "The name of the workflow to attach to this trace. This is used to\nname the trace in the traces dashboard.\n"]
            #[serde(rename = "workflow_name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub workflow_name: Option<String>,
            #[doc = "The group id to attach to this trace to enable filtering and\ngrouping in the traces dashboard.\n"]
            #[serde(rename = "group_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub group_id: Option<String>,
            #[doc = "The arbitrary metadata to attach to this trace to enable\nfiltering in the traces dashboard.\n"]
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
    }
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Tracing {
        #[doc = "auto"]
        Auto,
        #[doc = "Granular configuration for tracing.\n"]
        Variant1(crate::__types::realtime_session_create_request::tracing::Variant1),
    }
    impl<'de> serde::Deserialize<'de> for Tracing {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Tracing {
                Auto(crate::__types::realtime_session_create_request::tracing::Auto),
                Variant1(crate::__types::realtime_session_create_request::tracing::Variant1),
            }
            Ok(match Tracing::deserialize(deserializer)? {
                Tracing::Auto(_) => Self::Auto,
                Tracing::Variant1(v) => Self::Variant1(v),
            })
        }
    }
    impl serde::Serialize for Tracing {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Tracing<'a> {
                Auto(crate::__types::realtime_session_create_request::tracing::Auto),
                Variant1(&'a crate::__types::realtime_session_create_request::tracing::Variant1),
            }
            match self {
                Self::Auto => Tracing::Auto(Default::default()),
                Self::Variant1(v) => Tracing::Variant1(v),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod tools {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The type of the tool, i.e. `function`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub struct Type;
            impl_serde!(Type, "function");
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The type of the tool, i.e. `function`."]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub r#type: Option<crate::__types::realtime_session_create_request::tools::item::Type>,
            #[doc = "The name of the function."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub name: Option<String>,
            #[doc = "The description of the function, including guidance on when and how\nto call it, and guidance about what to tell the user when calling\n(if anything).\n"]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub description: Option<String>,
            #[doc = "Parameters of the function in JSON Schema."]
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub parameters: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod max_response_output_tokens {
        #[doc = "inf"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Inf;
        impl_serde!(Inf, "inf");
    }
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum MaxResponseOutputTokens {
        Integer(i64),
        #[doc = "inf"]
        Inf,
    }
    impl<'de> serde::Deserialize<'de> for MaxResponseOutputTokens {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum MaxResponseOutputTokens {
                Inf (crate :: __types :: realtime_session_create_request :: max_response_output_tokens :: Inf) , Integer (i64) }
            Ok(match MaxResponseOutputTokens::deserialize(deserializer)? {
                MaxResponseOutputTokens::Integer(v) => Self::Integer(v),
                MaxResponseOutputTokens::Inf(_) => Self::Inf,
            })
        }
    }
    impl serde::Serialize for MaxResponseOutputTokens {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum MaxResponseOutputTokens<'a> {
                Integer (& 'a i64) , Inf (crate :: __types :: realtime_session_create_request :: max_response_output_tokens :: Inf) }
            match self {
                Self::Integer(v) => MaxResponseOutputTokens::Integer(v),
                Self::Inf => MaxResponseOutputTokens::Inf(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod client_secret {
        #[allow(clippy::module_inception)]
        pub mod expires_after {
            #[doc = "The anchor point for the ephemeral token expiration. Only `created_at` is currently supported.\n"]
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Anchor {
                #[doc = "`created_at`"]
                #[serde(rename = "created_at")]
                CreatedAt,
            }
        }
        #[doc = "Configuration for the ephemeral token expiration.\n"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct ExpiresAfter { # [doc = "The anchor point for the ephemeral token expiration. Only `created_at` is currently supported.\n"] # [serde (rename = "anchor")] pub anchor : crate :: __types :: realtime_session_create_request :: client_secret :: expires_after :: Anchor , # [doc = "The number of seconds from the anchor point to the expiration. Select a value between `10` and `7200`.\n"] # [serde (rename = "seconds")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub seconds : Option < i64 > }
    }
    #[doc = "Configuration options for the generated client secret.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ClientSecret {
        #[doc = "Configuration for the ephemeral token expiration.\n"]
        #[serde(rename = "expires_after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub expires_after:
            Option<crate::__types::realtime_session_create_request::client_secret::ExpiresAfter>,
    }
}
#[doc = "Realtime session object configuration."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateRequest {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[serde(rename = "modalities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub modalities: Option<Vec<crate::__types::realtime_session_create_request::modalities::Item>>,
    #[doc = "The Realtime model used for this session.\n"]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::realtime_session_create_request::Model>,
    #[doc = "The default system instructions (i.e. system message) prepended to model calls. This field allows the client to guide the model on desired responses. The model can be instructed on response content and format, (e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good responses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion into your voice\", \"laugh frequently\"). The instructions are not guaranteed to be followed by the model, but they provide guidance to the model on the desired behavior.\n\nNote that the server sets default instructions which will be used if this field is not set and are visible in the `session.created` event at the start of the session.\n"]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the\nsession once the model has responded with audio at least once. Current\nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, and `verse`.\n"]
    #[serde(rename = "voice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub voice: Option<crate::__types::VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
    #[serde(rename = "input_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_format:
        Option<crate::__types::realtime_session_create_request::InputAudioFormat>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, output audio is sampled at a rate of 24kHz.\n"]
    #[serde(rename = "output_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_audio_format:
        Option<crate::__types::realtime_session_create_request::OutputAudioFormat>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be set to `null` to turn off once on. Input audio transcription is not native to the model, since the model consumes audio directly. Transcription runs asynchronously through [the /audio/transcriptions endpoint](https://platform.openai.com/docs/api-reference/audio/createTranscription) and should be treated as guidance of input audio content rather than precisely what the model heard. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[serde(rename = "input_audio_transcription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_transcription:
        Option<crate::__types::realtime_session_create_request::InputAudioTranscription>,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjunction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[serde(rename = "turn_detection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub turn_detection: Option<crate::__types::realtime_session_create_request::TurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[serde(rename = "input_audio_noise_reduction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_noise_reduction:
        Option<crate::__types::realtime_session_create_request::InputAudioNoiseReduction>,
    #[doc = "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\nin between model turns, not while a response is in progress.\n"]
    #[serde(rename = "speed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub speed: Option<serde_json::Number>,
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"]
    #[serde(rename = "tracing")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tracing: Option<crate::__types::realtime_session_create_request::Tracing>,
    #[doc = "Tools (functions) available to the model."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::realtime_session_create_request::tools::Item>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or\nspecify a function.\n"]
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. For audio models a temperature of 0.8 is highly recommended for best performance.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[serde(rename = "max_response_output_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_response_output_tokens:
        Option<crate::__types::realtime_session_create_request::MaxResponseOutputTokens>,
    #[doc = "Configuration options for the generated client secret.\n"]
    #[serde(rename = "client_secret")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub client_secret: Option<crate::__types::realtime_session_create_request::ClientSecret>,
}
#[allow(clippy::module_inception)]
pub mod realtime_session_create_response {
    #[doc = "Ephemeral key returned by the API."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ClientSecret {
        #[doc = "Ephemeral key usable in client environments to authenticate connections\nto the Realtime API. Use this in client-side environments rather than\na standard API token, which should only be used server-side.\n"]
        #[serde(rename = "value")]
        pub value: String,
        #[doc = "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"]
        #[serde(rename = "expires_at")]
        pub expires_at: i64,
    }
    #[allow(clippy::module_inception)]
    pub mod modalities {
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Item {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[doc = "Configuration for input audio transcription, defaults to off and can be\nset to `null` to turn off once on. Input audio transcription is not native\nto the model, since the model consumes audio directly. Transcription runs\nasynchronously and should be treated as rough guidance\nrather than the representation understood by the model.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudioTranscription {
        #[doc = "The model to use for transcription.\n"]
        #[serde(rename = "model")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub model: Option<String>,
    }
    #[allow(clippy::module_inception)]
    pub mod tracing {
        #[doc = "Default tracing mode for the session.\n"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Auto;
        impl_serde!(Auto, "auto");
        #[doc = "Granular configuration for tracing.\n"]
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Variant1 {
            #[doc = "The name of the workflow to attach to this trace. This is used to\nname the trace in the traces dashboard.\n"]
            #[serde(rename = "workflow_name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub workflow_name: Option<String>,
            #[doc = "The group id to attach to this trace to enable filtering and\ngrouping in the traces dashboard.\n"]
            #[serde(rename = "group_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub group_id: Option<String>,
            #[doc = "The arbitrary metadata to attach to this trace to enable\nfiltering in the traces dashboard.\n"]
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub metadata: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
    }
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Tracing {
        #[doc = "auto"]
        Auto,
        #[doc = "Granular configuration for tracing.\n"]
        Variant1(crate::__types::realtime_session_create_response::tracing::Variant1),
    }
    impl<'de> serde::Deserialize<'de> for Tracing {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Tracing {
                Auto(crate::__types::realtime_session_create_response::tracing::Auto),
                Variant1(crate::__types::realtime_session_create_response::tracing::Variant1),
            }
            Ok(match Tracing::deserialize(deserializer)? {
                Tracing::Auto(_) => Self::Auto,
                Tracing::Variant1(v) => Self::Variant1(v),
            })
        }
    }
    impl serde::Serialize for Tracing {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Tracing<'a> {
                Auto(crate::__types::realtime_session_create_response::tracing::Auto),
                Variant1(&'a crate::__types::realtime_session_create_response::tracing::Variant1),
            }
            match self {
                Self::Auto => Tracing::Auto(Default::default()),
                Self::Variant1(v) => Tracing::Variant1(v),
            }
            .serialize(serializer)
        }
    }
    #[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server\nVAD means that the model will detect the start and end of speech based on\naudio volume and respond at the end of user speech.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct TurnDetection {
        #[doc = "Type of turn detection, only `server_vad` is currently supported.\n"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<String>,
        #[doc = "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"]
        #[serde(rename = "threshold")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub threshold: Option<serde_json::Number>,
        #[doc = "Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"]
        #[serde(rename = "prefix_padding_ms")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub prefix_padding_ms: Option<i64>,
        #[doc = "Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"]
        #[serde(rename = "silence_duration_ms")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub silence_duration_ms: Option<i64>,
    }
    #[allow(clippy::module_inception)]
    pub mod tools {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The type of the tool, i.e. `function`."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub struct Type;
            impl_serde!(Type, "function");
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The type of the tool, i.e. `function`."]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub r#type: Option<crate::__types::realtime_session_create_response::tools::item::Type>,
            #[doc = "The name of the function."]
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub name: Option<String>,
            #[doc = "The description of the function, including guidance on when and how\nto call it, and guidance about what to tell the user when calling\n(if anything).\n"]
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub description: Option<String>,
            #[doc = "Parameters of the function in JSON Schema."]
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub parameters: Option<indexmap::IndexMap<String, serde_json::Value>>,
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod max_response_output_tokens {
        #[doc = "inf"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Inf;
        impl_serde!(Inf, "inf");
    }
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum MaxResponseOutputTokens {
        Integer(i64),
        #[doc = "inf"]
        Inf,
    }
    impl<'de> serde::Deserialize<'de> for MaxResponseOutputTokens {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum MaxResponseOutputTokens {
                Inf (crate :: __types :: realtime_session_create_response :: max_response_output_tokens :: Inf) , Integer (i64) }
            Ok(match MaxResponseOutputTokens::deserialize(deserializer)? {
                MaxResponseOutputTokens::Integer(v) => Self::Integer(v),
                MaxResponseOutputTokens::Inf(_) => Self::Inf,
            })
        }
    }
    impl serde::Serialize for MaxResponseOutputTokens {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum MaxResponseOutputTokens<'a> {
                Integer (& 'a i64) , Inf (crate :: __types :: realtime_session_create_response :: max_response_output_tokens :: Inf) }
            match self {
                Self::Integer(v) => MaxResponseOutputTokens::Integer(v),
                Self::Inf => MaxResponseOutputTokens::Inf(Default::default()),
            }
            .serialize(serializer)
        }
    }
}
#[doc = "A new Realtime session configuration, with an ephemeral key. Default TTL\nfor keys is one minute.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeSessionCreateResponse {
    #[doc = "Ephemeral key returned by the API."]
    #[serde(rename = "client_secret")]
    pub client_secret: crate::__types::realtime_session_create_response::ClientSecret,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[serde(rename = "modalities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub modalities: Option<Vec<crate::__types::realtime_session_create_response::modalities::Item>>,
    #[doc = "The default system instructions (i.e. system message) prepended to model\ncalls. This field allows the client to guide the model on desired\nresponses. The model can be instructed on response content and format,\n(e.g. \"be extremely succinct\", \"act friendly\", \"here are examples of good\nresponses\") and on audio behavior (e.g. \"talk quickly\", \"inject emotion\ninto your voice\", \"laugh frequently\"). The instructions are not guaranteed\nto be followed by the model, but they provide guidance to the model on the\ndesired behavior.\n\nNote that the server sets default instructions which will be used if this\nfield is not set and are visible in the `session.created` event at the\nstart of the session.\n"]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "The voice the model uses to respond. Voice cannot be changed during the\nsession once the model has responded with audio at least once. Current\nvoice options are `alloy`, `ash`, `ballad`, `coral`, `echo`, `sage`,\n`shimmer`, and `verse`.\n"]
    #[serde(rename = "voice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub voice: Option<crate::__types::VoiceIdsShared>,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[serde(rename = "input_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_format: Option<String>,
    #[doc = "The format of output audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[serde(rename = "output_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub output_audio_format: Option<String>,
    #[doc = "Configuration for input audio transcription, defaults to off and can be\nset to `null` to turn off once on. Input audio transcription is not native\nto the model, since the model consumes audio directly. Transcription runs\nasynchronously and should be treated as rough guidance\nrather than the representation understood by the model.\n"]
    #[serde(rename = "input_audio_transcription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_transcription:
        Option<crate::__types::realtime_session_create_response::InputAudioTranscription>,
    #[doc = "The speed of the model's spoken response. 1.0 is the default speed. 0.25 is\nthe minimum speed. 1.5 is the maximum speed. This value can only be changed\nin between model turns, not while a response is in progress.\n"]
    #[serde(rename = "speed")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub speed: Option<serde_json::Number>,
    #[doc = "Configuration options for tracing. Set to null to disable tracing. Once\ntracing is enabled for a session, the configuration cannot be modified.\n\n`auto` will create a trace for the session with default values for the\nworkflow name, group id, and metadata.\n"]
    #[serde(rename = "tracing")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tracing: Option<crate::__types::realtime_session_create_response::Tracing>,
    #[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server\nVAD means that the model will detect the start and end of speech based on\naudio volume and respond at the end of user speech.\n"]
    #[serde(rename = "turn_detection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub turn_detection: Option<crate::__types::realtime_session_create_response::TurnDetection>,
    #[doc = "Tools (functions) available to the model."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::realtime_session_create_response::tools::Item>>,
    #[doc = "How the model chooses tools. Options are `auto`, `none`, `required`, or\nspecify a function.\n"]
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<String>,
    #[doc = "Sampling temperature for the model, limited to [0.6, 1.2]. Defaults to 0.8.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "Maximum number of output tokens for a single assistant response,\ninclusive of tool calls. Provide an integer between 1 and 4096 to\nlimit output tokens, or `inf` for the maximum available tokens for a\ngiven model. Defaults to `inf`.\n"]
    #[serde(rename = "max_response_output_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_response_output_tokens:
        Option<crate::__types::realtime_session_create_response::MaxResponseOutputTokens>,
}
#[allow(clippy::module_inception)]
pub mod realtime_transcription_session_create_request {
    #[allow(clippy::module_inception)]
    pub mod modalities {
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Item {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum InputAudioFormat {
        #[doc = "`pcm16`"]
        #[default]
        #[serde(rename = "pcm16")]
        Pcm16,
        #[doc = "`g711_ulaw`"]
        #[serde(rename = "g711_ulaw")]
        G711Ulaw,
        #[doc = "`g711_alaw`"]
        #[serde(rename = "g711_alaw")]
        G711Alaw,
    }
    #[allow(clippy::module_inception)]
    pub mod input_audio_transcription {
        #[doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Model {
            #[doc = "`gpt-4o-transcribe`"]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
            #[doc = "`gpt-4o-mini-transcribe`"]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
            #[doc = "`whisper-1`"]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
    }
    #[doc = "Configuration for input audio transcription. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudioTranscription { # [doc = "The model to use for transcription, current options are `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, and `whisper-1`.\n"] # [serde (rename = "model")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub model : Option < crate :: __types :: realtime_transcription_session_create_request :: input_audio_transcription :: Model > , # [doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"] # [serde (rename = "language")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub language : Option < String > , # [doc = "An optional text to guide the model's style or continue a previous audio\nsegment.\nFor `whisper-1`, the [prompt is a list of keywords](https://platform.openai.com/docs/guides/speech-to-text#prompting).\nFor `gpt-4o-transcribe` models, the prompt is a free text string, for example \"expect words related to technology\".\n"] # [serde (rename = "prompt")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub prompt : Option < String > }
    #[allow(clippy::module_inception)]
    pub mod turn_detection {
        #[doc = "Type of turn detection.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Type {
            #[doc = "`server_vad`"]
            #[default]
            #[serde(rename = "server_vad")]
            ServerVad,
            #[doc = "`semantic_vad`"]
            #[serde(rename = "semantic_vad")]
            SemanticVad,
        }
        #[doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Eagerness {
            #[doc = "`low`"]
            #[serde(rename = "low")]
            Low,
            #[doc = "`medium`"]
            #[serde(rename = "medium")]
            Medium,
            #[doc = "`high`"]
            #[serde(rename = "high")]
            High,
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
        }
    }
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjunction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct TurnDetection { # [doc = "Type of turn detection.\n"] # [serde (rename = "type")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub r#type : Option < crate :: __types :: realtime_transcription_session_create_request :: turn_detection :: Type > , # [doc = "Used only for `semantic_vad` mode. The eagerness of the model to respond. `low` will wait longer for the user to continue speaking, `high` will respond more quickly. `auto` is the default and is equivalent to `medium`.\n"] # [serde (rename = "eagerness")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub eagerness : Option < crate :: __types :: realtime_transcription_session_create_request :: turn_detection :: Eagerness > , # [doc = "Used only for `server_vad` mode. Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A\nhigher threshold will require louder audio to activate the model, and\nthus might perform better in noisy environments.\n"] # [serde (rename = "threshold")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub threshold : Option < serde_json :: Number > , # [doc = "Used only for `server_vad` mode. Amount of audio to include before the VAD detected speech (in\nmilliseconds). Defaults to 300ms.\n"] # [serde (rename = "prefix_padding_ms")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub prefix_padding_ms : Option < i64 > , # [doc = "Used only for `server_vad` mode. Duration of silence to detect speech stop (in milliseconds). Defaults\nto 500ms. With shorter values the model will respond more quickly,\nbut may jump in on short pauses from the user.\n"] # [serde (rename = "silence_duration_ms")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub silence_duration_ms : Option < i64 > , # [doc = "Whether or not to automatically generate a response when a VAD stop event occurs. Not available for transcription sessions.\n"] # [serde (rename = "create_response")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub create_response : Option < bool > , # [doc = "Whether or not to automatically interrupt any ongoing response with output to the default\nconversation (i.e. `conversation` of `auto`) when a VAD start event occurs. Not available for transcription sessions.\n"] # [serde (rename = "interrupt_response")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub interrupt_response : Option < bool > }
    #[allow(clippy::module_inception)]
    pub mod input_audio_noise_reduction {
        #[doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Type {
            #[doc = "`near_field`"]
            #[serde(rename = "near_field")]
            NearField,
            #[doc = "`far_field`"]
            #[serde(rename = "far_field")]
            FarField,
        }
    }
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudioNoiseReduction { # [doc = "Type of noise reduction. `near_field` is for close-talking microphones such as headphones, `far_field` is for far-field microphones such as laptop or conference room microphones.\n"] # [serde (rename = "type")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub r#type : Option < crate :: __types :: realtime_transcription_session_create_request :: input_audio_noise_reduction :: Type > }
    #[allow(clippy::module_inception)]
    pub mod client_secret {
        #[allow(clippy::module_inception)]
        pub mod expires_at {
            #[doc = "The anchor point for the ephemeral token expiration. Only `created_at` is currently supported.\n"]
            #[derive(
                Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
            )]
            pub enum Anchor {
                #[doc = "`created_at`"]
                #[default]
                #[serde(rename = "created_at")]
                CreatedAt,
            }
        }
        #[doc = "Configuration for the ephemeral token expiration.\n"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct ExpiresAt { # [doc = "The anchor point for the ephemeral token expiration. Only `created_at` is currently supported.\n"] # [serde (rename = "anchor")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub anchor : Option < crate :: __types :: realtime_transcription_session_create_request :: client_secret :: expires_at :: Anchor > , # [doc = "The number of seconds from the anchor point to the expiration. Select a value between `10` and `7200`.\n"] # [serde (rename = "seconds")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub seconds : Option < i64 > }
    }
    #[doc = "Configuration options for the generated client secret.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ClientSecret {
        #[doc = "Configuration for the ephemeral token expiration.\n"]
        #[serde(rename = "expires_at")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub expires_at: Option<
            crate::__types::realtime_transcription_session_create_request::client_secret::ExpiresAt,
        >,
    }
}
#[doc = "Realtime transcription session object configuration."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateRequest {
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[serde(rename = "modalities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub modalities: Option<
        Vec<crate::__types::realtime_transcription_session_create_request::modalities::Item>,
    >,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\nFor `pcm16`, input audio must be 16-bit PCM at a 24kHz sample rate,\nsingle channel (mono), and little-endian byte order.\n"]
    #[serde(rename = "input_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_format:
        Option<crate::__types::realtime_transcription_session_create_request::InputAudioFormat>,
    #[doc = "Configuration for input audio transcription. The client can optionally set the language and prompt for transcription, these offer additional guidance to the transcription service.\n"]
    #[serde(rename = "input_audio_transcription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_transcription: Option<
        crate::__types::realtime_transcription_session_create_request::InputAudioTranscription,
    >,
    #[doc = "Configuration for turn detection, ether Server VAD or Semantic VAD. This can be set to `null` to turn off, in which case the client must manually trigger model response.\nServer VAD means that the model will detect the start and end of speech based on audio volume and respond at the end of user speech.\nSemantic VAD is more advanced and uses a turn detection model (in conjunction with VAD) to semantically estimate whether the user has finished speaking, then dynamically sets a timeout based on this probability. For example, if user audio trails off with \"uhhm\", the model will score a low probability of turn end and wait longer for the user to continue speaking. This can be useful for more natural conversations, but may have a higher latency.\n"]
    #[serde(rename = "turn_detection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub turn_detection:
        Option<crate::__types::realtime_transcription_session_create_request::TurnDetection>,
    #[doc = "Configuration for input audio noise reduction. This can be set to `null` to turn off.\nNoise reduction filters audio added to the input audio buffer before it is sent to VAD and the model.\nFiltering the audio can improve VAD and turn detection accuracy (reducing false positives) and model performance by improving perception of the input audio.\n"]
    #[serde(rename = "input_audio_noise_reduction")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_noise_reduction: Option<
        crate::__types::realtime_transcription_session_create_request::InputAudioNoiseReduction,
    >,
    #[doc = "The set of items to include in the transcription. Current available items are:\n- `item.input_audio_transcription.logprobs`\n"]
    #[serde(rename = "include")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub include: Option<Vec<String>>,
    #[doc = "Configuration options for the generated client secret.\n"]
    #[serde(rename = "client_secret")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub client_secret:
        Option<crate::__types::realtime_transcription_session_create_request::ClientSecret>,
}
#[allow(clippy::module_inception)]
pub mod realtime_transcription_session_create_response {
    #[doc = "Ephemeral key returned by the API. Only present when the session is\ncreated on the server via REST API.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ClientSecret {
        #[doc = "Ephemeral key usable in client environments to authenticate connections\nto the Realtime API. Use this in client-side environments rather than\na standard API token, which should only be used server-side.\n"]
        #[serde(rename = "value")]
        pub value: String,
        #[doc = "Timestamp for when the token expires. Currently, all tokens expire\nafter one minute.\n"]
        #[serde(rename = "expires_at")]
        pub expires_at: i64,
    }
    #[allow(clippy::module_inception)]
    pub mod modalities {
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Item {
            #[doc = "`text`"]
            #[serde(rename = "text")]
            Text,
            #[doc = "`audio`"]
            #[serde(rename = "audio")]
            Audio,
        }
    }
    #[allow(clippy::module_inception)]
    pub mod input_audio_transcription {
        #[doc = "The model to use for transcription. Can be `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, or `whisper-1`.\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Model {
            #[doc = "`gpt-4o-transcribe`"]
            #[serde(rename = "gpt-4o-transcribe")]
            Gpt4oTranscribe,
            #[doc = "`gpt-4o-mini-transcribe`"]
            #[serde(rename = "gpt-4o-mini-transcribe")]
            Gpt4oMiniTranscribe,
            #[doc = "`whisper-1`"]
            #[serde(rename = "whisper-1")]
            Whisper1,
        }
    }
    #[doc = "Configuration of the transcription model.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputAudioTranscription { # [doc = "The model to use for transcription. Can be `gpt-4o-transcribe`, `gpt-4o-mini-transcribe`, or `whisper-1`.\n"] # [serde (rename = "model")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub model : Option < crate :: __types :: realtime_transcription_session_create_response :: input_audio_transcription :: Model > , # [doc = "The language of the input audio. Supplying the input language in\n[ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) (e.g. `en`) format\nwill improve accuracy and latency.\n"] # [serde (rename = "language")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub language : Option < String > , # [doc = "An optional text to guide the model's style or continue a previous audio\nsegment. The [prompt](https://platform.openai.com/docs/guides/speech-to-text#prompting) should match\nthe audio language.\n"] # [serde (rename = "prompt")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub prompt : Option < String > }
    #[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct TurnDetection {
        #[doc = "Type of turn detection, only `server_vad` is currently supported.\n"]
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub r#type: Option<String>,
        #[doc = "Activation threshold for VAD (0.0 to 1.0), this defaults to 0.5. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
        #[serde(rename = "threshold")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub threshold: Option<serde_json::Number>,
        #[doc = "Amount of audio to include before the VAD detected speech (in \nmilliseconds). Defaults to 300ms.\n"]
        #[serde(rename = "prefix_padding_ms")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub prefix_padding_ms: Option<i64>,
        #[doc = "Duration of silence to detect speech stop (in milliseconds). Defaults \nto 500ms. With shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
        #[serde(rename = "silence_duration_ms")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub silence_duration_ms: Option<i64>,
    }
}
#[doc = "A new Realtime transcription session configuration.\n\nWhen a session is created on the server via REST API, the session object\nalso contains an ephemeral key. Default TTL for keys is 10 minutes. This \nproperty is not present when a session is updated via the WebSocket API.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeTranscriptionSessionCreateResponse {
    #[doc = "Ephemeral key returned by the API. Only present when the session is\ncreated on the server via REST API.\n"]
    #[serde(rename = "client_secret")]
    pub client_secret: crate::__types::realtime_transcription_session_create_response::ClientSecret,
    #[doc = "The set of modalities the model can respond with. To disable audio,\nset this to [\"text\"].\n"]
    #[serde(rename = "modalities")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub modalities: Option<
        Vec<crate::__types::realtime_transcription_session_create_response::modalities::Item>,
    >,
    #[doc = "The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`.\n"]
    #[serde(rename = "input_audio_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_format: Option<String>,
    #[doc = "Configuration of the transcription model.\n"]
    #[serde(rename = "input_audio_transcription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub input_audio_transcription: Option<
        crate::__types::realtime_transcription_session_create_response::InputAudioTranscription,
    >,
    #[doc = "Configuration for turn detection. Can be set to `null` to turn off. Server \nVAD means that the model will detect the start and end of speech based on \naudio volume and respond at the end of user speech.\n"]
    #[serde(rename = "turn_detection")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub turn_detection:
        Option<crate::__types::realtime_transcription_session_create_response::TurnDetection>,
}
#[allow(clippy::module_inception)]
pub mod reasoning {
    #[doc = "A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Summary {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`concise`"]
        #[serde(rename = "concise")]
        Concise,
        #[doc = "`detailed`"]
        #[serde(rename = "detailed")]
        Detailed,
    }
    #[doc = "**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum GenerateSummary {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`concise`"]
        #[serde(rename = "concise")]
        Concise,
        #[doc = "`detailed`"]
        #[serde(rename = "detailed")]
        Detailed,
    }
}
#[doc = "**gpt-5 and o-series models only**\n\nConfiguration options for\n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct Reasoning {
    #[serde(rename = "effort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub effort: Option<crate::__types::ReasoningEffort>,
    #[doc = "A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
    #[serde(rename = "summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub summary: Option<crate::__types::reasoning::Summary>,
    #[doc = "**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model's reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n"]
    #[serde(rename = "generate_summary")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub generate_summary: Option<crate::__types::reasoning::GenerateSummary>,
}
#[doc = "Constrains effort on reasoning for \n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\nCurrently supported values are `minimal`, `low`, `medium`, and `high`. Reducing\nreasoning effort can result in faster responses and fewer tokens used\non reasoning in a response.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum ReasoningEffort {
    #[doc = "`minimal`"]
    #[serde(rename = "minimal")]
    Minimal,
    #[doc = "`low`"]
    #[serde(rename = "low")]
    Low,
    #[doc = "`medium`"]
    #[default]
    #[serde(rename = "medium")]
    Medium,
    #[doc = "`high`"]
    #[serde(rename = "high")]
    High,
}
#[allow(clippy::module_inception)]
pub mod reasoning_item {
    #[doc = "The type of the object. Always `reasoning`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "reasoning");
    #[allow(clippy::module_inception)]
    pub mod summary {
        #[allow(clippy::module_inception)]
        pub(crate) mod item {
            #[doc = "The type of the object. Always `summary_text`.\n"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "summary_text");
        }
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "A summary of the reasoning output from the model so far.\n"]
            pub text: String,
        }
        impl<'de> serde::Deserialize<'de> for Item {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct Item {
                    #[serde(rename = "type")]
                    #[allow(dead_code)]
                    r#type: crate::__types::reasoning_item::summary::item::Type,
                    #[serde(rename = "text")]
                    text: String,
                }
                let Item { text, .. } = Item::deserialize(deserializer)?;
                Ok(Self { text })
            }
        }
        impl serde::Serialize for Item {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct Item<'a> {
                    #[serde(rename = "type")]
                    r#type: &'a crate::__types::reasoning_item::summary::item::Type,
                    #[serde(rename = "text")]
                    text: &'a String,
                }
                let Self { text } = self;
                Item {
                    r#type: &Default::default(),
                    text,
                }
                .serialize(serializer)
            }
        }
    }
    #[allow(clippy::module_inception)]
    pub mod content {
        #[allow(clippy::module_inception)]
        pub(crate) mod item {
            #[doc = "The type of the object. Always `reasoning_text`.\n"]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub(crate) struct Type;
            impl_serde!(Type, "reasoning_text");
        }
        #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "Reasoning text output from the model.\n"]
            pub text: String,
        }
        impl<'de> serde::Deserialize<'de> for Item {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Deserialize)]
                struct Item {
                    #[serde(rename = "type")]
                    #[allow(dead_code)]
                    r#type: crate::__types::reasoning_item::content::item::Type,
                    #[serde(rename = "text")]
                    text: String,
                }
                let Item { text, .. } = Item::deserialize(deserializer)?;
                Ok(Self { text })
            }
        }
        impl serde::Serialize for Item {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                #[serde_with::serde_as]
                #[derive(serde :: Serialize)]
                struct Item<'a> {
                    #[serde(rename = "type")]
                    r#type: &'a crate::__types::reasoning_item::content::item::Type,
                    #[serde(rename = "text")]
                    text: &'a String,
                }
                let Self { text } = self;
                Item {
                    r#type: &Default::default(),
                    text,
                }
                .serialize(serializer)
            }
        }
    }
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "A description of the chain of thought used by a reasoning model while generating\na response. Be sure to include these items in your `input` to the Responses API\nfor subsequent turns of a conversation if you are manually \n[managing context](https://platform.openai.com/docs/guides/conversation-state).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ReasoningItem {
    #[doc = "The unique identifier of the reasoning content.\n"]
    pub id: String,
    #[doc = "The encrypted content of the reasoning item - populated when a response is\ngenerated with `reasoning.encrypted_content` in the `include` parameter.\n"]
    #[builder(default)]
    pub encrypted_content: Option<String>,
    #[doc = "Reasoning summary content.\n"]
    pub summary: Vec<crate::__types::reasoning_item::summary::Item>,
    #[doc = "Reasoning text content.\n"]
    #[builder(default)]
    pub content: Option<Vec<crate::__types::reasoning_item::content::Item>>,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::reasoning_item::Status>,
}
impl<'de> serde::Deserialize<'de> for ReasoningItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ReasoningItem {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::reasoning_item::Type,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "encrypted_content")]
            encrypted_content: Option<String>,
            #[serde(rename = "summary")]
            summary: Vec<crate::__types::reasoning_item::summary::Item>,
            #[serde(rename = "content")]
            content: Option<Vec<crate::__types::reasoning_item::content::Item>>,
            #[serde(rename = "status")]
            status: Option<crate::__types::reasoning_item::Status>,
        }
        let ReasoningItem {
            id,
            encrypted_content,
            summary,
            content,
            status,
            ..
        } = ReasoningItem::deserialize(deserializer)?;
        Ok(Self {
            id,
            encrypted_content,
            summary,
            content,
            status,
        })
    }
}
impl serde::Serialize for ReasoningItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ReasoningItem<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::reasoning_item::Type,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "encrypted_content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            encrypted_content: &'a Option<String>,
            #[serde(rename = "summary")]
            summary: &'a Vec<crate::__types::reasoning_item::summary::Item>,
            #[serde(rename = "content")]
            #[serde(skip_serializing_if = "Option::is_none")]
            content: &'a Option<Vec<crate::__types::reasoning_item::content::Item>>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::reasoning_item::Status>,
        }
        let Self {
            id,
            encrypted_content,
            summary,
            content,
            status,
        } = self;
        ReasoningItem {
            r#type: &Default::default(),
            id,
            encrypted_content,
            summary,
            content,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod response {
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Text {
        #[serde(rename = "format")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub format: Option<crate::__types::TextResponseFormatConfiguration>,
        #[serde(rename = "verbosity")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub verbosity: Option<crate::__types::Verbosity>,
    }
    #[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum ToolChoice {
        ToolChoiceOptions(crate::__types::ToolChoiceOptions),
        ToolChoiceAllowed(crate::__types::ToolChoiceAllowed),
        ToolChoiceTypes(crate::__types::ToolChoiceTypes),
        ToolChoiceFunction(crate::__types::ToolChoiceFunction),
        ToolChoiceMcp(crate::__types::ToolChoiceMcp),
        ToolChoiceCustom(crate::__types::ToolChoiceCustom),
    }
    impl<'de> serde::Deserialize<'de> for ToolChoice {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum ToolChoice {
                ToolChoiceOptions(crate::__types::ToolChoiceOptions),
                ToolChoiceAllowed(crate::__types::ToolChoiceAllowed),
                ToolChoiceTypes(crate::__types::ToolChoiceTypes),
                ToolChoiceFunction(crate::__types::ToolChoiceFunction),
                ToolChoiceMcp(crate::__types::ToolChoiceMcp),
                ToolChoiceCustom(crate::__types::ToolChoiceCustom),
            }
            Ok(match ToolChoice::deserialize(deserializer)? {
                ToolChoice::ToolChoiceOptions(v) => Self::ToolChoiceOptions(v),
                ToolChoice::ToolChoiceAllowed(v) => Self::ToolChoiceAllowed(v),
                ToolChoice::ToolChoiceTypes(v) => Self::ToolChoiceTypes(v),
                ToolChoice::ToolChoiceFunction(v) => Self::ToolChoiceFunction(v),
                ToolChoice::ToolChoiceMcp(v) => Self::ToolChoiceMcp(v),
                ToolChoice::ToolChoiceCustom(v) => Self::ToolChoiceCustom(v),
            })
        }
    }
    impl serde::Serialize for ToolChoice {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum ToolChoice<'a> {
                ToolChoiceOptions(&'a crate::__types::ToolChoiceOptions),
                ToolChoiceAllowed(&'a crate::__types::ToolChoiceAllowed),
                ToolChoiceTypes(&'a crate::__types::ToolChoiceTypes),
                ToolChoiceFunction(&'a crate::__types::ToolChoiceFunction),
                ToolChoiceMcp(&'a crate::__types::ToolChoiceMcp),
                ToolChoiceCustom(&'a crate::__types::ToolChoiceCustom),
            }
            match self {
                Self::ToolChoiceOptions(v) => ToolChoice::ToolChoiceOptions(v),
                Self::ToolChoiceAllowed(v) => ToolChoice::ToolChoiceAllowed(v),
                Self::ToolChoiceTypes(v) => ToolChoice::ToolChoiceTypes(v),
                Self::ToolChoiceFunction(v) => ToolChoice::ToolChoiceFunction(v),
                Self::ToolChoiceMcp(v) => ToolChoice::ToolChoiceMcp(v),
                Self::ToolChoiceCustom(v) => ToolChoice::ToolChoiceCustom(v),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping input items in the\n  middle of the conversation.\n- `disabled` (default): If a model response will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Truncation {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`disabled`"]
        #[default]
        #[serde(rename = "disabled")]
        Disabled,
    }
    #[doc = "The object type of this resource - always set to `response`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "response");
    #[doc = "The status of the response generation. One of `completed`, `failed`, \n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`cancelled`"]
        #[serde(rename = "cancelled")]
        Cancelled,
        #[doc = "`queued`"]
        #[serde(rename = "queued")]
        Queued,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
    #[allow(clippy::module_inception)]
    pub mod incomplete_details {
        #[doc = "The reason why the response is incomplete."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Reason {
            #[doc = "`max_output_tokens`"]
            #[serde(rename = "max_output_tokens")]
            MaxOutputTokens,
            #[doc = "`content_filter`"]
            #[serde(rename = "content_filter")]
            ContentFilter,
        }
    }
    #[doc = "Details about why the response is incomplete.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct IncompleteDetails {
        #[doc = "The reason why the response is incomplete."]
        #[serde(rename = "reason")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub reason: Option<crate::__types::response::incomplete_details::Reason>,
    }
    #[doc = "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Instructions {
        #[doc = "A text input to the model, equivalent to a text input with the \n`developer` role.\n"]
        String(String),
        #[doc = "A list of one or many input items to the model, containing \ndifferent content types.\n"]
        Array(Vec<crate::__types::InputItem>),
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Response {
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
    #[builder(default)]
    pub text: Option<crate::__types::response::Text>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "An integer between 0 and 20 specifying the number of most likely tokens to\nreturn at each token position, each with an associated log probability.\n"]
    #[builder(default)]
    pub top_logprobs: Option<i64>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\nWe generally recommend altering this or `top_p` but not both.\n"]
    pub temperature: serde_json::Number,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling,\nwhere the model considers the results of the tokens with top_p probability\nmass. So 0.1 means only the tokens comprising the top 10% probability mass\nare considered.\n\nWe generally recommend altering this or `temperature` but not both.\n"]
    pub top_p: serde_json::Number,
    #[doc = "This field is being replaced by `safety_identifier` and `prompt_cache_key`. Use `prompt_cache_key` instead to maintain caching optimizations.\nA stable identifier for your end-users. \nUsed to boost cache hit rates by better bucketing similar requests and  to help OpenAI detect and prevent abuse. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[builder(default)]
    pub user: Option<String>,
    #[doc = "A stable identifier used to help detect users of your application that may be violating OpenAI's usage policies. \nThe IDs should be a string that uniquely identifies each user. We recommend hashing their username or email address, in order to avoid sending us any identifying information. [Learn more](https://platform.openai.com/docs/guides/safety-best-practices#safety-identifiers).\n"]
    #[builder(default)]
    pub safety_identifier: Option<String>,
    #[doc = "Used by OpenAI to cache responses for similar requests to optimize your cache hit rates. Replaces the `user` field. [Learn more](https://platform.openai.com/docs/guides/prompt-caching).\n"]
    #[builder(default)]
    pub prompt_cache_key: Option<String>,
    #[builder(default)]
    pub service_tier: Option<crate::__types::ServiceTier>,
    #[doc = "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](https://platform.openai.com/docs/guides/conversation-state).\n"]
    #[builder(default)]
    pub previous_response_id: Option<String>,
    #[doc = "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\nto browse and compare available models.\n"]
    pub model: crate::__types::ModelIdsResponses,
    #[builder(default)]
    pub reasoning: Option<crate::__types::Reasoning>,
    #[doc = "Whether to run the model response in the background.\n[Learn more](https://platform.openai.com/docs/guides/background).\n"]
    #[builder(default)]
    pub background: Option<bool>,
    #[doc = "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\n"]
    #[builder(default)]
    pub max_output_tokens: Option<i64>,
    #[doc = "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"]
    #[builder(default)]
    pub max_tool_calls: Option<i64>,
    #[doc = "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nThe two categories of tools you can provide the model are:\n\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](https://platform.openai.com/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"]
    pub tools: Vec<crate::__types::Tool>,
    #[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
    pub tool_choice: crate::__types::response::ToolChoice,
    #[builder(default)]
    pub prompt: Option<crate::__types::Prompt>,
    #[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping input items in the\n  middle of the conversation.\n- `disabled` (default): If a model response will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"]
    #[builder(default)]
    pub truncation: Option<crate::__types::response::Truncation>,
    #[doc = "Unique identifier for this Response.\n"]
    pub id: String,
    #[doc = "The status of the response generation. One of `completed`, `failed`, \n`in_progress`, `cancelled`, `queued`, or `incomplete`.\n"]
    #[builder(default)]
    pub status: Option<crate::__types::response::Status>,
    #[doc = "Unix timestamp (in seconds) of when this Response was created.\n"]
    pub created_at: serde_json::Number,
    #[builder(default)]
    pub error: Option<crate::__types::ResponseError>,
    #[doc = "Details about why the response is incomplete.\n"]
    #[builder(default)]
    pub incomplete_details: Option<crate::__types::response::IncompleteDetails>,
    #[doc = "An array of content items generated by the model.\n\n- The length and order of items in the `output` array is dependent\n  on the model's response.\n- Rather than accessing the first item in the `output` array and \n  assuming it's an `assistant` message with the content generated by\n  the model, you might consider using the `output_text` property where\n  supported in SDKs.\n"]
    pub output: Vec<crate::__types::OutputItem>,
    #[doc = "A system (or developer) message inserted into the model's context.\n\nWhen using along with `previous_response_id`, the instructions from a previous\nresponse will not be carried over to the next response. This makes it simple\nto swap out system (or developer) messages in new responses.\n"]
    #[builder(default)]
    pub instructions: Option<crate::__types::response::Instructions>,
    #[doc = "SDK-only convenience property that contains the aggregated text output \nfrom all `output_text` items in the `output` array, if any are present. \nSupported in the Python and JavaScript SDKs.\n"]
    #[builder(default)]
    pub output_text: Option<String>,
    #[builder(default)]
    pub usage: Option<crate::__types::ResponseUsage>,
    #[doc = "Whether to allow the model to run tool calls in parallel.\n"]
    pub parallel_tool_calls: bool,
}
impl<'de> serde::Deserialize<'de> for Response {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Response {
            #[serde(rename = "text")]
            text: Option<crate::__types::response::Text>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
            #[serde(rename = "top_logprobs")]
            top_logprobs: Option<i64>,
            #[serde(rename = "temperature")]
            temperature: serde_json::Number,
            #[serde(rename = "top_p")]
            top_p: serde_json::Number,
            #[serde(rename = "user")]
            user: Option<String>,
            #[serde(rename = "safety_identifier")]
            safety_identifier: Option<String>,
            #[serde(rename = "prompt_cache_key")]
            prompt_cache_key: Option<String>,
            #[serde(rename = "service_tier")]
            service_tier: Option<crate::__types::ServiceTier>,
            #[serde(rename = "previous_response_id")]
            previous_response_id: Option<String>,
            #[serde(rename = "model")]
            model: crate::__types::ModelIdsResponses,
            #[serde(rename = "reasoning")]
            reasoning: Option<crate::__types::Reasoning>,
            #[serde(rename = "background")]
            background: Option<bool>,
            #[serde(rename = "max_output_tokens")]
            max_output_tokens: Option<i64>,
            #[serde(rename = "max_tool_calls")]
            max_tool_calls: Option<i64>,
            #[serde(rename = "tools")]
            tools: Vec<crate::__types::Tool>,
            #[serde(rename = "tool_choice")]
            tool_choice: crate::__types::response::ToolChoice,
            #[serde(rename = "prompt")]
            prompt: Option<crate::__types::Prompt>,
            #[serde(rename = "truncation")]
            truncation: Option<crate::__types::response::Truncation>,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::response::Object,
            #[serde(rename = "status")]
            status: Option<crate::__types::response::Status>,
            #[serde(rename = "created_at")]
            created_at: serde_json::Number,
            #[serde(rename = "error")]
            error: Option<crate::__types::ResponseError>,
            #[serde(rename = "incomplete_details")]
            incomplete_details: Option<crate::__types::response::IncompleteDetails>,
            #[serde(rename = "output")]
            output: Vec<crate::__types::OutputItem>,
            #[serde(rename = "instructions")]
            instructions: Option<crate::__types::response::Instructions>,
            #[serde(rename = "output_text")]
            output_text: Option<String>,
            #[serde(rename = "usage")]
            usage: Option<crate::__types::ResponseUsage>,
            #[serde(rename = "parallel_tool_calls")]
            parallel_tool_calls: bool,
        }
        let Response {
            text,
            metadata,
            top_logprobs,
            temperature,
            top_p,
            user,
            safety_identifier,
            prompt_cache_key,
            service_tier,
            previous_response_id,
            model,
            reasoning,
            background,
            max_output_tokens,
            max_tool_calls,
            tools,
            tool_choice,
            prompt,
            truncation,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            instructions,
            output_text,
            usage,
            parallel_tool_calls,
            ..
        } = Response::deserialize(deserializer)?;
        Ok(Self {
            text,
            metadata,
            top_logprobs,
            temperature,
            top_p,
            user,
            safety_identifier,
            prompt_cache_key,
            service_tier,
            previous_response_id,
            model,
            reasoning,
            background,
            max_output_tokens,
            max_tool_calls,
            tools,
            tool_choice,
            prompt,
            truncation,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            instructions,
            output_text,
            usage,
            parallel_tool_calls,
        })
    }
}
impl serde::Serialize for Response {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Response<'a> {
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            text: &'a Option<crate::__types::response::Text>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
            #[serde(rename = "top_logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_logprobs: &'a Option<i64>,
            #[serde(rename = "temperature")]
            temperature: &'a serde_json::Number,
            #[serde(rename = "top_p")]
            top_p: &'a serde_json::Number,
            #[serde(rename = "user")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user: &'a Option<String>,
            #[serde(rename = "safety_identifier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            safety_identifier: &'a Option<String>,
            #[serde(rename = "prompt_cache_key")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt_cache_key: &'a Option<String>,
            #[serde(rename = "service_tier")]
            #[serde(skip_serializing_if = "Option::is_none")]
            service_tier: &'a Option<crate::__types::ServiceTier>,
            #[serde(rename = "previous_response_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            previous_response_id: &'a Option<String>,
            #[serde(rename = "model")]
            model: &'a crate::__types::ModelIdsResponses,
            #[serde(rename = "reasoning")]
            #[serde(skip_serializing_if = "Option::is_none")]
            reasoning: &'a Option<crate::__types::Reasoning>,
            #[serde(rename = "background")]
            #[serde(skip_serializing_if = "Option::is_none")]
            background: &'a Option<bool>,
            #[serde(rename = "max_output_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_output_tokens: &'a Option<i64>,
            #[serde(rename = "max_tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_tool_calls: &'a Option<i64>,
            #[serde(rename = "tools")]
            tools: &'a Vec<crate::__types::Tool>,
            #[serde(rename = "tool_choice")]
            tool_choice: &'a crate::__types::response::ToolChoice,
            #[serde(rename = "prompt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            prompt: &'a Option<crate::__types::Prompt>,
            #[serde(rename = "truncation")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation: &'a Option<crate::__types::response::Truncation>,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::response::Object,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::response::Status>,
            #[serde(rename = "created_at")]
            created_at: &'a serde_json::Number,
            #[serde(rename = "error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            error: &'a Option<crate::__types::ResponseError>,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<crate::__types::response::IncompleteDetails>,
            #[serde(rename = "output")]
            output: &'a Vec<crate::__types::OutputItem>,
            #[serde(rename = "instructions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            instructions: &'a Option<crate::__types::response::Instructions>,
            #[serde(rename = "output_text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_text: &'a Option<String>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<crate::__types::ResponseUsage>,
            #[serde(rename = "parallel_tool_calls")]
            parallel_tool_calls: &'a bool,
        }
        let Self {
            text,
            metadata,
            top_logprobs,
            temperature,
            top_p,
            user,
            safety_identifier,
            prompt_cache_key,
            service_tier,
            previous_response_id,
            model,
            reasoning,
            background,
            max_output_tokens,
            max_tool_calls,
            tools,
            tool_choice,
            prompt,
            truncation,
            id,
            status,
            created_at,
            error,
            incomplete_details,
            output,
            instructions,
            output_text,
            usage,
            parallel_tool_calls,
        } = self;
        Response {
            text,
            metadata,
            top_logprobs,
            temperature,
            top_p,
            user,
            safety_identifier,
            prompt_cache_key,
            service_tier,
            previous_response_id,
            model,
            reasoning,
            background,
            max_output_tokens,
            max_tool_calls,
            tools,
            tool_choice,
            prompt,
            truncation,
            id,
            object: &Default::default(),
            status,
            created_at,
            error,
            incomplete_details,
            output,
            instructions,
            output_text,
            usage,
            parallel_tool_calls,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_audio_delta_event {
    #[doc = "The type of the event. Always `response.audio.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.audio.delta");
}
#[doc = "Emitted when there is a partial audio response."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseAudioDeltaEvent {
    #[doc = "A sequence number for this chunk of the stream response.\n"]
    pub sequence_number: i64,
    #[doc = "A chunk of Base64 encoded response audio bytes.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseAudioDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_audio_delta_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "delta")]
            delta: String,
        }
        let ResponseAudioDeltaEvent {
            sequence_number,
            delta,
            ..
        } = ResponseAudioDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            delta,
        })
    }
}
impl serde::Serialize for ResponseAudioDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseAudioDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_audio_delta_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            sequence_number,
            delta,
        } = self;
        ResponseAudioDeltaEvent {
            r#type: &Default::default(),
            sequence_number,
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_audio_done_event {
    #[doc = "The type of the event. Always `response.audio.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.audio.done");
}
#[doc = "Emitted when the audio response is complete."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseAudioDoneEvent {
    #[doc = "The sequence number of the delta.\n"]
    pub sequence_number: i64,
    pub response_id: serde_json::Value,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseAudioDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_audio_done_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "response_id")]
            response_id: serde_json::Value,
        }
        let ResponseAudioDoneEvent {
            sequence_number,
            response_id,
            ..
        } = ResponseAudioDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            response_id,
        })
    }
}
impl serde::Serialize for ResponseAudioDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseAudioDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_audio_done_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "response_id")]
            response_id: &'a serde_json::Value,
        }
        let Self {
            sequence_number,
            response_id,
        } = self;
        ResponseAudioDoneEvent {
            r#type: &Default::default(),
            sequence_number,
            response_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_audio_transcript_delta_event {
    #[doc = "The type of the event. Always `response.audio.transcript.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.audio.transcript.delta");
}
#[doc = "Emitted when there is a partial transcript of audio."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseAudioTranscriptDeltaEvent {
    #[doc = "The partial transcript of the audio response.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    pub response_id: serde_json::Value,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioTranscriptDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseAudioTranscriptDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_audio_transcript_delta_event::Type,
            #[serde(rename = "delta")]
            delta: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "response_id")]
            response_id: serde_json::Value,
        }
        let ResponseAudioTranscriptDeltaEvent {
            delta,
            sequence_number,
            response_id,
            ..
        } = ResponseAudioTranscriptDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            delta,
            sequence_number,
            response_id,
        })
    }
}
impl serde::Serialize for ResponseAudioTranscriptDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseAudioTranscriptDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_audio_transcript_delta_event::Type,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "response_id")]
            response_id: &'a serde_json::Value,
        }
        let Self {
            delta,
            sequence_number,
            response_id,
        } = self;
        ResponseAudioTranscriptDeltaEvent {
            r#type: &Default::default(),
            delta,
            sequence_number,
            response_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_audio_transcript_done_event {
    #[doc = "The type of the event. Always `response.audio.transcript.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.audio.transcript.done");
}
#[doc = "Emitted when the full audio transcript is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseAudioTranscriptDoneEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    pub response_id: serde_json::Value,
}
impl<'de> serde::Deserialize<'de> for ResponseAudioTranscriptDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseAudioTranscriptDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_audio_transcript_done_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "response_id")]
            response_id: serde_json::Value,
        }
        let ResponseAudioTranscriptDoneEvent {
            sequence_number,
            response_id,
            ..
        } = ResponseAudioTranscriptDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            response_id,
        })
    }
}
impl serde::Serialize for ResponseAudioTranscriptDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseAudioTranscriptDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_audio_transcript_done_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "response_id")]
            response_id: &'a serde_json::Value,
        }
        let Self {
            sequence_number,
            response_id,
        } = self;
        ResponseAudioTranscriptDoneEvent {
            r#type: &Default::default(),
            sequence_number,
            response_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_code_interpreter_call_code_delta_event {
    #[doc = "The type of the event. Always `response.code_interpreter_call_code.delta`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.code_interpreter_call_code.delta");
}
#[doc = "Emitted when a partial code snippet is streamed by the code interpreter."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCodeDeltaEvent {
    #[doc = "The index of the output item in the response for which the code is being streamed."]
    pub output_index: i64,
    #[doc = "The unique identifier of the code interpreter tool call item."]
    pub item_id: String,
    #[doc = "The partial code snippet being streamed by the code interpreter."]
    pub delta: String,
    #[doc = "The sequence number of this event, used to order streaming events."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCodeDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallCodeDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_code_interpreter_call_code_delta_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "delta")]
            delta: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseCodeInterpreterCallCodeDeltaEvent {
            output_index,
            item_id,
            delta,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallCodeDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCodeDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallCodeDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_code_interpreter_call_code_delta_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            delta,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallCodeDeltaEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_code_interpreter_call_code_done_event {
    #[doc = "The type of the event. Always `response.code_interpreter_call_code.done`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.code_interpreter_call_code.done");
}
#[doc = "Emitted when the code snippet is finalized by the code interpreter."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCodeDoneEvent {
    #[doc = "The index of the output item in the response for which the code is finalized."]
    pub output_index: i64,
    #[doc = "The unique identifier of the code interpreter tool call item."]
    pub item_id: String,
    #[doc = "The final code snippet output by the code interpreter."]
    pub code: String,
    #[doc = "The sequence number of this event, used to order streaming events."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCodeDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallCodeDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_code_interpreter_call_code_done_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "code")]
            code: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseCodeInterpreterCallCodeDoneEvent {
            output_index,
            item_id,
            code,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallCodeDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            code,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCodeDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallCodeDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_code_interpreter_call_code_done_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "code")]
            code: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            code,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallCodeDoneEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            code,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_code_interpreter_call_completed_event {
    #[doc = "The type of the event. Always `response.code_interpreter_call.completed`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.code_interpreter_call.completed");
}
#[doc = "Emitted when the code interpreter call is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallCompletedEvent {
    #[doc = "The index of the output item in the response for which the code interpreter call is completed."]
    pub output_index: i64,
    #[doc = "The unique identifier of the code interpreter tool call item."]
    pub item_id: String,
    #[doc = "The sequence number of this event, used to order streaming events."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_code_interpreter_call_completed_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseCodeInterpreterCallCompletedEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_code_interpreter_call_completed_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallCompletedEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_code_interpreter_call_in_progress_event {
    #[doc = "The type of the event. Always `response.code_interpreter_call.in_progress`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.code_interpreter_call.in_progress");
}
#[doc = "Emitted when a code interpreter call is in progress."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallInProgressEvent {
    #[doc = "The index of the output item in the response for which the code interpreter call is in progress."]
    pub output_index: i64,
    #[doc = "The unique identifier of the code interpreter tool call item."]
    pub item_id: String,
    #[doc = "The sequence number of this event, used to order streaming events."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_code_interpreter_call_in_progress_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseCodeInterpreterCallInProgressEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_code_interpreter_call_in_progress_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallInProgressEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_code_interpreter_call_interpreting_event {
    #[doc = "The type of the event. Always `response.code_interpreter_call.interpreting`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.code_interpreter_call.interpreting");
}
#[doc = "Emitted when the code interpreter is actively interpreting the code snippet."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCodeInterpreterCallInterpretingEvent {
    #[doc = "The index of the output item in the response for which the code interpreter is interpreting code."]
    pub output_index: i64,
    #[doc = "The unique identifier of the code interpreter tool call item."]
    pub item_id: String,
    #[doc = "The sequence number of this event, used to order streaming events."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseCodeInterpreterCallInterpretingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCodeInterpreterCallInterpretingEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_code_interpreter_call_interpreting_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseCodeInterpreterCallInterpretingEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseCodeInterpreterCallInterpretingEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCodeInterpreterCallInterpretingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCodeInterpreterCallInterpretingEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_code_interpreter_call_interpreting_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseCodeInterpreterCallInterpretingEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_completed_event {
    #[doc = "The type of the event. Always `response.completed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.completed");
}
#[doc = "Emitted when the model response is complete."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCompletedEvent {
    #[doc = "Properties of the completed response.\n"]
    pub response: crate::__types::Response,
    #[doc = "The sequence number for this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_completed_event::Type,
            #[serde(rename = "response")]
            response: crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseCompletedEvent {
            response,
            sequence_number,
            ..
        } = ResponseCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_completed_event::Type,
            #[serde(rename = "response")]
            response: &'a crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseCompletedEvent {
            r#type: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_content_part_added_event {
    #[doc = "The type of the event. Always `response.content_part.added`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.content_part.added");
}
#[doc = "Emitted when a new content part is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseContentPartAddedEvent {
    #[doc = "The ID of the output item that the content part was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the content part was added to.\n"]
    pub output_index: i64,
    #[doc = "The index of the content part that was added.\n"]
    pub content_index: i64,
    #[doc = "The content part that was added.\n"]
    pub part: crate::__types::OutputContent,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseContentPartAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseContentPartAddedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_content_part_added_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "part")]
            part: crate::__types::OutputContent,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseContentPartAddedEvent {
            item_id,
            output_index,
            content_index,
            part,
            sequence_number,
            ..
        } = ResponseContentPartAddedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            part,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseContentPartAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseContentPartAddedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_content_part_added_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "part")]
            part: &'a crate::__types::OutputContent,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            part,
            sequence_number,
        } = self;
        ResponseContentPartAddedEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            part,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_content_part_done_event {
    #[doc = "The type of the event. Always `response.content_part.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.content_part.done");
}
#[doc = "Emitted when a content part is done."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseContentPartDoneEvent {
    #[doc = "The ID of the output item that the content part was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the content part was added to.\n"]
    pub output_index: i64,
    #[doc = "The index of the content part that is done.\n"]
    pub content_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The content part that is done.\n"]
    pub part: crate::__types::OutputContent,
}
impl<'de> serde::Deserialize<'de> for ResponseContentPartDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseContentPartDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_content_part_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "part")]
            part: crate::__types::OutputContent,
        }
        let ResponseContentPartDoneEvent {
            item_id,
            output_index,
            content_index,
            sequence_number,
            part,
            ..
        } = ResponseContentPartDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            sequence_number,
            part,
        })
    }
}
impl serde::Serialize for ResponseContentPartDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseContentPartDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_content_part_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "part")]
            part: &'a crate::__types::OutputContent,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            sequence_number,
            part,
        } = self;
        ResponseContentPartDoneEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            sequence_number,
            part,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_created_event {
    #[doc = "The type of the event. Always `response.created`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.created");
}
#[doc = "An event that is emitted when a response is created.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCreatedEvent {
    #[doc = "The response that was created.\n"]
    pub response: crate::__types::Response,
    #[doc = "The sequence number for this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseCreatedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCreatedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_created_event::Type,
            #[serde(rename = "response")]
            response: crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseCreatedEvent {
            response,
            sequence_number,
            ..
        } = ResponseCreatedEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseCreatedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCreatedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_created_event::Type,
            #[serde(rename = "response")]
            response: &'a crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseCreatedEvent {
            r#type: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_custom_tool_call_input_delta_event {
    #[doc = "The event type identifier."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.custom_tool_call_input.delta");
}
#[doc = "Event representing a delta (partial update) to the input of a custom tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCustomToolCallInputDeltaEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The index of the output this delta applies to."]
    pub output_index: i64,
    #[doc = "Unique identifier for the API item associated with this event."]
    pub item_id: String,
    #[doc = "The incremental input data (delta) for the custom tool call."]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseCustomToolCallInputDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCustomToolCallInputDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_custom_tool_call_input_delta_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "delta")]
            delta: String,
        }
        let ResponseCustomToolCallInputDeltaEvent {
            sequence_number,
            output_index,
            item_id,
            delta,
            ..
        } = ResponseCustomToolCallInputDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            output_index,
            item_id,
            delta,
        })
    }
}
impl serde::Serialize for ResponseCustomToolCallInputDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCustomToolCallInputDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_custom_tool_call_input_delta_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            sequence_number,
            output_index,
            item_id,
            delta,
        } = self;
        ResponseCustomToolCallInputDeltaEvent {
            r#type: &Default::default(),
            sequence_number,
            output_index,
            item_id,
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_custom_tool_call_input_done_event {
    #[doc = "The event type identifier."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.custom_tool_call_input.done");
}
#[doc = "Event indicating that input for a custom tool call is complete.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseCustomToolCallInputDoneEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The index of the output this event applies to."]
    pub output_index: i64,
    #[doc = "Unique identifier for the API item associated with this event."]
    pub item_id: String,
    #[doc = "The complete input data for the custom tool call."]
    pub input: String,
}
impl<'de> serde::Deserialize<'de> for ResponseCustomToolCallInputDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseCustomToolCallInputDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_custom_tool_call_input_done_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "input")]
            input: String,
        }
        let ResponseCustomToolCallInputDoneEvent {
            sequence_number,
            output_index,
            item_id,
            input,
            ..
        } = ResponseCustomToolCallInputDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            output_index,
            item_id,
            input,
        })
    }
}
impl serde::Serialize for ResponseCustomToolCallInputDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseCustomToolCallInputDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_custom_tool_call_input_done_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "input")]
            input: &'a String,
        }
        let Self {
            sequence_number,
            output_index,
            item_id,
            input,
        } = self;
        ResponseCustomToolCallInputDoneEvent {
            r#type: &Default::default(),
            sequence_number,
            output_index,
            item_id,
            input,
        }
        .serialize(serializer)
    }
}
#[doc = "An error object returned when the model fails to generate a Response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ResponseError {
    #[serde(rename = "code")]
    pub code: crate::__types::ResponseErrorCode,
    #[doc = "A human-readable description of the error.\n"]
    #[serde(rename = "message")]
    pub message: String,
}
#[doc = "The error code for the response.\n"]
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum ResponseErrorCode {
    #[doc = "`server_error`"]
    #[serde(rename = "server_error")]
    ServerError,
    #[doc = "`rate_limit_exceeded`"]
    #[serde(rename = "rate_limit_exceeded")]
    RateLimitExceeded,
    #[doc = "`invalid_prompt`"]
    #[serde(rename = "invalid_prompt")]
    InvalidPrompt,
    #[doc = "`vector_store_timeout`"]
    #[serde(rename = "vector_store_timeout")]
    VectorStoreTimeout,
    #[doc = "`invalid_image`"]
    #[serde(rename = "invalid_image")]
    InvalidImage,
    #[doc = "`invalid_image_format`"]
    #[serde(rename = "invalid_image_format")]
    InvalidImageFormat,
    #[doc = "`invalid_base64_image`"]
    #[serde(rename = "invalid_base64_image")]
    InvalidBase64Image,
    #[doc = "`invalid_image_url`"]
    #[serde(rename = "invalid_image_url")]
    InvalidImageUrl,
    #[doc = "`image_too_large`"]
    #[serde(rename = "image_too_large")]
    ImageTooLarge,
    #[doc = "`image_too_small`"]
    #[serde(rename = "image_too_small")]
    ImageTooSmall,
    #[doc = "`image_parse_error`"]
    #[serde(rename = "image_parse_error")]
    ImageParseError,
    #[doc = "`image_content_policy_violation`"]
    #[serde(rename = "image_content_policy_violation")]
    ImageContentPolicyViolation,
    #[doc = "`invalid_image_mode`"]
    #[serde(rename = "invalid_image_mode")]
    InvalidImageMode,
    #[doc = "`image_file_too_large`"]
    #[serde(rename = "image_file_too_large")]
    ImageFileTooLarge,
    #[doc = "`unsupported_image_media_type`"]
    #[serde(rename = "unsupported_image_media_type")]
    UnsupportedImageMediaType,
    #[doc = "`empty_image_file`"]
    #[serde(rename = "empty_image_file")]
    EmptyImageFile,
    #[doc = "`failed_to_download_image`"]
    #[serde(rename = "failed_to_download_image")]
    FailedToDownloadImage,
    #[doc = "`image_file_not_found`"]
    #[serde(rename = "image_file_not_found")]
    ImageFileNotFound,
}
#[allow(clippy::module_inception)]
pub(crate) mod response_error_event {
    #[doc = "The type of the event. Always `error`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "error");
}
#[doc = "Emitted when an error occurs."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseErrorEvent {
    #[doc = "The error code.\n"]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "The error message.\n"]
    pub message: String,
    #[doc = "The error parameter.\n"]
    #[builder(default)]
    pub param: Option<String>,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseErrorEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseErrorEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_error_event::Type,
            #[serde(rename = "code")]
            code: Option<String>,
            #[serde(rename = "message")]
            message: String,
            #[serde(rename = "param")]
            param: Option<String>,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseErrorEvent {
            code,
            message,
            param,
            sequence_number,
            ..
        } = ResponseErrorEvent::deserialize(deserializer)?;
        Ok(Self {
            code,
            message,
            param,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseErrorEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseErrorEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_error_event::Type,
            #[serde(rename = "code")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code: &'a Option<String>,
            #[serde(rename = "message")]
            message: &'a String,
            #[serde(rename = "param")]
            #[serde(skip_serializing_if = "Option::is_none")]
            param: &'a Option<String>,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            code,
            message,
            param,
            sequence_number,
        } = self;
        ResponseErrorEvent {
            r#type: &Default::default(),
            code,
            message,
            param,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_failed_event {
    #[doc = "The type of the event. Always `response.failed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.failed");
}
#[doc = "An event that is emitted when a response fails.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFailedEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The response that failed.\n"]
    pub response: crate::__types::Response,
}
impl<'de> serde::Deserialize<'de> for ResponseFailedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFailedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_failed_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "response")]
            response: crate::__types::Response,
        }
        let ResponseFailedEvent {
            sequence_number,
            response,
            ..
        } = ResponseFailedEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            response,
        })
    }
}
impl serde::Serialize for ResponseFailedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFailedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_failed_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "response")]
            response: &'a crate::__types::Response,
        }
        let Self {
            sequence_number,
            response,
        } = self;
        ResponseFailedEvent {
            r#type: &Default::default(),
            sequence_number,
            response,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_file_search_call_completed_event {
    #[doc = "The type of the event. Always `response.file_search_call.completed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.file_search_call.completed");
}
#[doc = "Emitted when a file search call is completed (results found)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallCompletedEvent {
    #[doc = "The index of the output item that the file search call is initiated.\n"]
    pub output_index: i64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFileSearchCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_file_search_call_completed_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseFileSearchCallCompletedEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseFileSearchCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFileSearchCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_file_search_call_completed_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseFileSearchCallCompletedEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_file_search_call_in_progress_event {
    #[doc = "The type of the event. Always `response.file_search_call.in_progress`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.file_search_call.in_progress");
}
#[doc = "Emitted when a file search call is initiated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallInProgressEvent {
    #[doc = "The index of the output item that the file search call is initiated.\n"]
    pub output_index: i64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFileSearchCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_file_search_call_in_progress_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseFileSearchCallInProgressEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseFileSearchCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFileSearchCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_file_search_call_in_progress_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseFileSearchCallInProgressEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_file_search_call_searching_event {
    #[doc = "The type of the event. Always `response.file_search_call.searching`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.file_search_call.searching");
}
#[doc = "Emitted when a file search is currently searching."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFileSearchCallSearchingEvent {
    #[doc = "The index of the output item that the file search call is searching.\n"]
    pub output_index: i64,
    #[doc = "The ID of the output item that the file search call is initiated.\n"]
    pub item_id: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseFileSearchCallSearchingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFileSearchCallSearchingEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_file_search_call_searching_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseFileSearchCallSearchingEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseFileSearchCallSearchingEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseFileSearchCallSearchingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFileSearchCallSearchingEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_file_search_call_searching_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseFileSearchCallSearchingEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_format_json_object {
    #[doc = "The type of response format being defined. Always `json_object`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "json_object");
}
#[doc = "JSON object response format. An older method of generating JSON responses.\nUsing `json_schema` is recommended for models that support it. Note that the\nmodel will not generate JSON without a system or user message instructing it\nto do so.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatJsonObject {}
impl<'de> serde::Deserialize<'de> for ResponseFormatJsonObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatJsonObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_format_json_object::Type,
        }
        let ResponseFormatJsonObject { .. } = ResponseFormatJsonObject::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for ResponseFormatJsonObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatJsonObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_format_json_object::Type,
        }
        let Self {} = self;
        ResponseFormatJsonObject {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod response_format_json_schema {
    #[doc = "The type of response format being defined. Always `json_schema`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "json_schema");
    #[doc = "Structured Outputs configuration options, including a JSON Schema.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct JsonSchema {
        #[doc = "A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n"]
        #[serde(rename = "description")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub description: Option<String>,
        #[doc = "The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n"]
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "schema")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub schema: Option<crate::__types::ResponseFormatJsonSchemaSchema>,
        #[doc = "Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n"]
        #[serde(rename = "strict")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub strict: Option<bool>,
    }
}
#[doc = "JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatJsonSchema {
    #[doc = "Structured Outputs configuration options, including a JSON Schema.\n"]
    pub json_schema: crate::__types::response_format_json_schema::JsonSchema,
}
impl<'de> serde::Deserialize<'de> for ResponseFormatJsonSchema {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatJsonSchema {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_format_json_schema::Type,
            #[serde(rename = "json_schema")]
            json_schema: crate::__types::response_format_json_schema::JsonSchema,
        }
        let ResponseFormatJsonSchema { json_schema, .. } =
            ResponseFormatJsonSchema::deserialize(deserializer)?;
        Ok(Self { json_schema })
    }
}
impl serde::Serialize for ResponseFormatJsonSchema {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatJsonSchema<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_format_json_schema::Type,
            #[serde(rename = "json_schema")]
            json_schema: &'a crate::__types::response_format_json_schema::JsonSchema,
        }
        let Self { json_schema } = self;
        ResponseFormatJsonSchema {
            r#type: &Default::default(),
            json_schema,
        }
        .serialize(serializer)
    }
}
#[doc = "The schema for the response format, described as a JSON Schema object.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n"]
pub type ResponseFormatJsonSchemaSchema = indexmap::IndexMap<String, serde_json::Value>;
#[allow(clippy::module_inception)]
pub(crate) mod response_format_text {
    #[doc = "The type of response format being defined. Always `text`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "text");
}
#[doc = "Default response format. Used to generate text responses.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatText {}
impl<'de> serde::Deserialize<'de> for ResponseFormatText {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatText {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_format_text::Type,
        }
        let ResponseFormatText { .. } = ResponseFormatText::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for ResponseFormatText {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatText<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_format_text::Type,
        }
        let Self {} = self;
        ResponseFormatText {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_format_text_grammar {
    #[doc = "The type of response format being defined. Always `grammar`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "grammar");
}
#[doc = "A custom grammar for the model to follow when generating text.\nLearn more in the [custom grammars guide](https://platform.openai.com/docs/guides/custom-grammars).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatTextGrammar {
    #[doc = "The custom grammar for the model to follow."]
    pub grammar: String,
}
impl<'de> serde::Deserialize<'de> for ResponseFormatTextGrammar {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatTextGrammar {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_format_text_grammar::Type,
            #[serde(rename = "grammar")]
            grammar: String,
        }
        let ResponseFormatTextGrammar { grammar, .. } =
            ResponseFormatTextGrammar::deserialize(deserializer)?;
        Ok(Self { grammar })
    }
}
impl serde::Serialize for ResponseFormatTextGrammar {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatTextGrammar<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_format_text_grammar::Type,
            #[serde(rename = "grammar")]
            grammar: &'a String,
        }
        let Self { grammar } = self;
        ResponseFormatTextGrammar {
            r#type: &Default::default(),
            grammar,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_format_text_python {
    #[doc = "The type of response format being defined. Always `python`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "python");
}
#[doc = "Configure the model to generate valid Python code. See the\n[custom grammars guide](https://platform.openai.com/docs/guides/custom-grammars) for more details.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFormatTextPython {}
impl<'de> serde::Deserialize<'de> for ResponseFormatTextPython {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFormatTextPython {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_format_text_python::Type,
        }
        let ResponseFormatTextPython { .. } = ResponseFormatTextPython::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for ResponseFormatTextPython {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFormatTextPython<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_format_text_python::Type,
        }
        let Self {} = self;
        ResponseFormatTextPython {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_function_call_arguments_delta_event {
    #[doc = "The type of the event. Always `response.function_call_arguments.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.function_call_arguments.delta");
}
#[doc = "Emitted when there is a partial function-call arguments delta."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFunctionCallArgumentsDeltaEvent {
    #[doc = "The ID of the output item that the function-call arguments delta is added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the function-call arguments delta is added to.\n"]
    pub output_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The function-call arguments delta that is added.\n"]
    pub delta: String,
}
impl<'de> serde::Deserialize<'de> for ResponseFunctionCallArgumentsDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFunctionCallArgumentsDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_function_call_arguments_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "delta")]
            delta: String,
        }
        let ResponseFunctionCallArgumentsDeltaEvent {
            item_id,
            output_index,
            sequence_number,
            delta,
            ..
        } = ResponseFunctionCallArgumentsDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
            delta,
        })
    }
}
impl serde::Serialize for ResponseFunctionCallArgumentsDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFunctionCallArgumentsDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_function_call_arguments_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
            delta,
        } = self;
        ResponseFunctionCallArgumentsDeltaEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            sequence_number,
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_function_call_arguments_done_event {
    #[doc = "response.function_call_arguments.done"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.function_call_arguments.done");
}
#[doc = "Emitted when function-call arguments are finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseFunctionCallArgumentsDoneEvent {
    #[doc = "The ID of the item."]
    pub item_id: String,
    #[doc = "The index of the output item."]
    pub output_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The function-call arguments."]
    pub arguments: String,
}
impl<'de> serde::Deserialize<'de> for ResponseFunctionCallArgumentsDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseFunctionCallArgumentsDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_function_call_arguments_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "arguments")]
            arguments: String,
        }
        let ResponseFunctionCallArgumentsDoneEvent {
            item_id,
            output_index,
            sequence_number,
            arguments,
            ..
        } = ResponseFunctionCallArgumentsDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
            arguments,
        })
    }
}
impl serde::Serialize for ResponseFunctionCallArgumentsDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseFunctionCallArgumentsDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_function_call_arguments_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "arguments")]
            arguments: &'a String,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
            arguments,
        } = self;
        ResponseFunctionCallArgumentsDoneEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            sequence_number,
            arguments,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_image_gen_call_completed_event {
    #[doc = "The type of the event. Always 'response.image_generation_call.completed'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.image_generation_call.completed");
}
#[doc = "Emitted when an image generation tool call has completed and the final image is available.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseImageGenCallCompletedEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The unique identifier of the image generation item being processed."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseImageGenCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseImageGenCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_image_gen_call_completed_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "item_id")]
            item_id: String,
        }
        let ResponseImageGenCallCompletedEvent {
            output_index,
            sequence_number,
            item_id,
            ..
        } = ResponseImageGenCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            sequence_number,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseImageGenCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseImageGenCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_image_gen_call_completed_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            output_index,
            sequence_number,
            item_id,
        } = self;
        ResponseImageGenCallCompletedEvent {
            r#type: &Default::default(),
            output_index,
            sequence_number,
            item_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_image_gen_call_generating_event {
    #[doc = "The type of the event. Always 'response.image_generation_call.generating'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.image_generation_call.generating");
}
#[doc = "Emitted when an image generation tool call is actively generating an image (intermediate state).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseImageGenCallGeneratingEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: i64,
    #[doc = "The unique identifier of the image generation item being processed."]
    pub item_id: String,
    #[doc = "The sequence number of the image generation item being processed."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseImageGenCallGeneratingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseImageGenCallGeneratingEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_image_gen_call_generating_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseImageGenCallGeneratingEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseImageGenCallGeneratingEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseImageGenCallGeneratingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseImageGenCallGeneratingEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_image_gen_call_generating_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseImageGenCallGeneratingEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_image_gen_call_in_progress_event {
    #[doc = "The type of the event. Always 'response.image_generation_call.in_progress'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.image_generation_call.in_progress");
}
#[doc = "Emitted when an image generation tool call is in progress.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseImageGenCallInProgressEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: i64,
    #[doc = "The unique identifier of the image generation item being processed."]
    pub item_id: String,
    #[doc = "The sequence number of the image generation item being processed."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseImageGenCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseImageGenCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_image_gen_call_in_progress_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseImageGenCallInProgressEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseImageGenCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseImageGenCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseImageGenCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_image_gen_call_in_progress_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseImageGenCallInProgressEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_image_gen_call_partial_image_event {
    #[doc = "The type of the event. Always 'response.image_generation_call.partial_image'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.image_generation_call.partial_image");
}
#[doc = "Emitted when a partial image is available during image generation streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseImageGenCallPartialImageEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: i64,
    #[doc = "The unique identifier of the image generation item being processed."]
    pub item_id: String,
    #[doc = "The sequence number of the image generation item being processed."]
    pub sequence_number: i64,
    #[doc = "0-based index for the partial image (backend is 1-based, but this is 0-based for the user)."]
    pub partial_image_index: i64,
    #[doc = "Base64-encoded partial image data, suitable for rendering as an image."]
    pub partial_image_b64: String,
}
impl<'de> serde::Deserialize<'de> for ResponseImageGenCallPartialImageEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseImageGenCallPartialImageEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_image_gen_call_partial_image_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "partial_image_index")]
            partial_image_index: i64,
            #[serde(rename = "partial_image_b64")]
            partial_image_b64: String,
        }
        let ResponseImageGenCallPartialImageEvent {
            output_index,
            item_id,
            sequence_number,
            partial_image_index,
            partial_image_b64,
            ..
        } = ResponseImageGenCallPartialImageEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
            partial_image_index,
            partial_image_b64,
        })
    }
}
impl serde::Serialize for ResponseImageGenCallPartialImageEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseImageGenCallPartialImageEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_image_gen_call_partial_image_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "partial_image_index")]
            partial_image_index: &'a i64,
            #[serde(rename = "partial_image_b64")]
            partial_image_b64: &'a String,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
            partial_image_index,
            partial_image_b64,
        } = self;
        ResponseImageGenCallPartialImageEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
            partial_image_index,
            partial_image_b64,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_in_progress_event {
    #[doc = "The type of the event. Always `response.in_progress`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.in_progress");
}
#[doc = "Emitted when the response is in progress."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseInProgressEvent {
    #[doc = "The response that is in progress.\n"]
    pub response: crate::__types::Response,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_in_progress_event::Type,
            #[serde(rename = "response")]
            response: crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseInProgressEvent {
            response,
            sequence_number,
            ..
        } = ResponseInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseInProgressEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_in_progress_event::Type,
            #[serde(rename = "response")]
            response: &'a crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseInProgressEvent {
            r#type: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_incomplete_event {
    #[doc = "The type of the event. Always `response.incomplete`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.incomplete");
}
#[doc = "An event that is emitted when a response finishes as incomplete.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseIncompleteEvent {
    #[doc = "The response that was incomplete.\n"]
    pub response: crate::__types::Response,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseIncompleteEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseIncompleteEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_incomplete_event::Type,
            #[serde(rename = "response")]
            response: crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseIncompleteEvent {
            response,
            sequence_number,
            ..
        } = ResponseIncompleteEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseIncompleteEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseIncompleteEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_incomplete_event::Type,
            #[serde(rename = "response")]
            response: &'a crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseIncompleteEvent {
            r#type: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_item_list {
    #[doc = "The type of object returned, must be `list`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[doc = "A list of Response items."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseItemList {
    #[doc = "A list of items used to generate this response."]
    pub data: Vec<crate::__types::ItemResource>,
    #[doc = "Whether there are more items available."]
    pub has_more: bool,
    #[doc = "The ID of the first item in the list."]
    pub first_id: String,
    #[doc = "The ID of the last item in the list."]
    pub last_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseItemList {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseItemList {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::response_item_list::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::ItemResource>,
            #[serde(rename = "has_more")]
            has_more: bool,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
        }
        let ResponseItemList {
            data,
            has_more,
            first_id,
            last_id,
            ..
        } = ResponseItemList::deserialize(deserializer)?;
        Ok(Self {
            data,
            has_more,
            first_id,
            last_id,
        })
    }
}
impl serde::Serialize for ResponseItemList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseItemList<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::response_item_list::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::ItemResource>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
        }
        let Self {
            data,
            has_more,
            first_id,
            last_id,
        } = self;
        ResponseItemList {
            object: &Default::default(),
            data,
            has_more,
            first_id,
            last_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod response_log_prob {
    #[allow(clippy::module_inception)]
    pub mod top_logprobs {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "A possible text token."]
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub token: Option<String>,
            #[doc = "The log probability of this token."]
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub logprob: Option<serde_json::Number>,
        }
    }
}
#[doc = "A logprob is the logarithmic probability that the model assigns to producing \na particular token at a given position in the sequence. Less-negative (higher) \nlogprob values indicate greater model confidence in that token choice.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ResponseLogProb {
    #[doc = "A possible text token."]
    #[serde(rename = "token")]
    pub token: String,
    #[doc = "The log probability of this token.\n"]
    #[serde(rename = "logprob")]
    pub logprob: serde_json::Number,
    #[doc = "The log probability of the top 20 most likely tokens.\n"]
    #[serde(rename = "top_logprobs")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_logprobs: Option<Vec<crate::__types::response_log_prob::top_logprobs::Item>>,
}
#[allow(clippy::module_inception)]
pub(crate) mod response_mcp_call_arguments_delta_event {
    #[doc = "The type of the event. Always 'response.mcp_call_arguments.delta'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.mcp_call_arguments.delta");
}
#[doc = "Emitted when there is a delta (partial update) to the arguments of an MCP tool call.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallArgumentsDeltaEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: i64,
    #[doc = "The unique identifier of the MCP tool call item being processed."]
    pub item_id: String,
    #[doc = "A JSON string containing the partial update to the arguments for the MCP tool call.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallArgumentsDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallArgumentsDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_mcp_call_arguments_delta_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "delta")]
            delta: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseMcpCallArgumentsDeltaEvent {
            output_index,
            item_id,
            delta,
            sequence_number,
            ..
        } = ResponseMcpCallArgumentsDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpCallArgumentsDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallArgumentsDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_mcp_call_arguments_delta_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            delta,
            sequence_number,
        } = self;
        ResponseMcpCallArgumentsDeltaEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_mcp_call_arguments_done_event {
    #[doc = "The type of the event. Always 'response.mcp_call_arguments.done'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.mcp_call_arguments.done");
}
#[doc = "Emitted when the arguments for an MCP tool call are finalized.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallArgumentsDoneEvent {
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: i64,
    #[doc = "The unique identifier of the MCP tool call item being processed."]
    pub item_id: String,
    #[doc = "A JSON string containing the finalized arguments for the MCP tool call.\n"]
    pub arguments: String,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallArgumentsDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallArgumentsDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_mcp_call_arguments_done_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "arguments")]
            arguments: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseMcpCallArgumentsDoneEvent {
            output_index,
            item_id,
            arguments,
            sequence_number,
            ..
        } = ResponseMcpCallArgumentsDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            arguments,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpCallArgumentsDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallArgumentsDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_mcp_call_arguments_done_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "arguments")]
            arguments: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            arguments,
            sequence_number,
        } = self;
        ResponseMcpCallArgumentsDoneEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            arguments,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_mcp_call_completed_event {
    #[doc = "The type of the event. Always 'response.mcp_call.completed'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.mcp_call.completed");
}
#[doc = "Emitted when an MCP  tool call has completed successfully.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallCompletedEvent {
    #[doc = "The ID of the MCP tool call item that completed."]
    pub item_id: String,
    #[doc = "The index of the output item that completed."]
    pub output_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_mcp_call_completed_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseMcpCallCompletedEvent {
            item_id,
            output_index,
            sequence_number,
            ..
        } = ResponseMcpCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_mcp_call_completed_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
        } = self;
        ResponseMcpCallCompletedEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_mcp_call_failed_event {
    #[doc = "The type of the event. Always 'response.mcp_call.failed'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.mcp_call.failed");
}
#[doc = "Emitted when an MCP  tool call has failed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallFailedEvent {
    #[doc = "The ID of the MCP tool call item that failed."]
    pub item_id: String,
    #[doc = "The index of the output item that failed."]
    pub output_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallFailedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallFailedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_mcp_call_failed_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseMcpCallFailedEvent {
            item_id,
            output_index,
            sequence_number,
            ..
        } = ResponseMcpCallFailedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpCallFailedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallFailedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_mcp_call_failed_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
        } = self;
        ResponseMcpCallFailedEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_mcp_call_in_progress_event {
    #[doc = "The type of the event. Always 'response.mcp_call.in_progress'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.mcp_call.in_progress");
}
#[doc = "Emitted when an MCP  tool call is in progress.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpCallInProgressEvent {
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: i64,
    #[doc = "The unique identifier of the MCP tool call item being processed."]
    pub item_id: String,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_mcp_call_in_progress_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
        }
        let ResponseMcpCallInProgressEvent {
            sequence_number,
            output_index,
            item_id,
            ..
        } = ResponseMcpCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            sequence_number,
            output_index,
            item_id,
        })
    }
}
impl serde::Serialize for ResponseMcpCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_mcp_call_in_progress_event::Type,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
        }
        let Self {
            sequence_number,
            output_index,
            item_id,
        } = self;
        ResponseMcpCallInProgressEvent {
            r#type: &Default::default(),
            sequence_number,
            output_index,
            item_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_mcp_list_tools_completed_event {
    #[doc = "The type of the event. Always 'response.mcp_list_tools.completed'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.mcp_list_tools.completed");
}
#[doc = "Emitted when the list of available MCP tools has been successfully retrieved.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpListToolsCompletedEvent {
    #[doc = "The ID of the MCP tool call item that produced this output."]
    pub item_id: String,
    #[doc = "The index of the output item that was processed."]
    pub output_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpListToolsCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpListToolsCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_mcp_list_tools_completed_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseMcpListToolsCompletedEvent {
            item_id,
            output_index,
            sequence_number,
            ..
        } = ResponseMcpListToolsCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpListToolsCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpListToolsCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_mcp_list_tools_completed_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
        } = self;
        ResponseMcpListToolsCompletedEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_mcp_list_tools_failed_event {
    #[doc = "The type of the event. Always 'response.mcp_list_tools.failed'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.mcp_list_tools.failed");
}
#[doc = "Emitted when the attempt to list available MCP tools has failed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpListToolsFailedEvent {
    #[doc = "The ID of the MCP tool call item that failed."]
    pub item_id: String,
    #[doc = "The index of the output item that failed."]
    pub output_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpListToolsFailedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpListToolsFailedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_mcp_list_tools_failed_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseMcpListToolsFailedEvent {
            item_id,
            output_index,
            sequence_number,
            ..
        } = ResponseMcpListToolsFailedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpListToolsFailedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpListToolsFailedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_mcp_list_tools_failed_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
        } = self;
        ResponseMcpListToolsFailedEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_mcp_list_tools_in_progress_event {
    #[doc = "The type of the event. Always 'response.mcp_list_tools.in_progress'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.mcp_list_tools.in_progress");
}
#[doc = "Emitted when the system is in the process of retrieving the list of available MCP tools.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseMcpListToolsInProgressEvent {
    #[doc = "The ID of the MCP tool call item that is being processed."]
    pub item_id: String,
    #[doc = "The index of the output item that is being processed."]
    pub output_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseMcpListToolsInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseMcpListToolsInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_mcp_list_tools_in_progress_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseMcpListToolsInProgressEvent {
            item_id,
            output_index,
            sequence_number,
            ..
        } = ResponseMcpListToolsInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseMcpListToolsInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseMcpListToolsInProgressEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_mcp_list_tools_in_progress_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            sequence_number,
        } = self;
        ResponseMcpListToolsInProgressEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod response_modalities {
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Item {
        #[doc = "`text`"]
        #[serde(rename = "text")]
        Text,
        #[doc = "`audio`"]
        #[serde(rename = "audio")]
        Audio,
    }
}
#[doc = "Output types that you would like the model to generate.\nMost models are capable of generating text, which is the default:\n\n`[\"text\"]`\n\nThe `gpt-4o-audio-preview` model can also be used to \n[generate audio](https://platform.openai.com/docs/guides/audio). To request that this model generate \nboth text and audio responses, you can use:\n\n`[\"text\", \"audio\"]`\n"]
pub type ResponseModalities = Vec<crate::__types::response_modalities::Item>;
#[allow(clippy::module_inception)]
pub(crate) mod response_output_item_added_event {
    #[doc = "The type of the event. Always `response.output_item.added`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.output_item.added");
}
#[doc = "Emitted when a new output item is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseOutputItemAddedEvent {
    #[doc = "The index of the output item that was added.\n"]
    pub output_index: i64,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
    #[doc = "The output item that was added.\n"]
    pub item: crate::__types::OutputItem,
}
impl<'de> serde::Deserialize<'de> for ResponseOutputItemAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseOutputItemAddedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_output_item_added_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "item")]
            item: crate::__types::OutputItem,
        }
        let ResponseOutputItemAddedEvent {
            output_index,
            sequence_number,
            item,
            ..
        } = ResponseOutputItemAddedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            sequence_number,
            item,
        })
    }
}
impl serde::Serialize for ResponseOutputItemAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseOutputItemAddedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_output_item_added_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "item")]
            item: &'a crate::__types::OutputItem,
        }
        let Self {
            output_index,
            sequence_number,
            item,
        } = self;
        ResponseOutputItemAddedEvent {
            r#type: &Default::default(),
            output_index,
            sequence_number,
            item,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_output_item_done_event {
    #[doc = "The type of the event. Always `response.output_item.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.output_item.done");
}
#[doc = "Emitted when an output item is marked done."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseOutputItemDoneEvent {
    #[doc = "The index of the output item that was marked done.\n"]
    pub output_index: i64,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
    #[doc = "The output item that was marked done.\n"]
    pub item: crate::__types::OutputItem,
}
impl<'de> serde::Deserialize<'de> for ResponseOutputItemDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseOutputItemDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_output_item_done_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "item")]
            item: crate::__types::OutputItem,
        }
        let ResponseOutputItemDoneEvent {
            output_index,
            sequence_number,
            item,
            ..
        } = ResponseOutputItemDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            sequence_number,
            item,
        })
    }
}
impl serde::Serialize for ResponseOutputItemDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseOutputItemDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_output_item_done_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "item")]
            item: &'a crate::__types::OutputItem,
        }
        let Self {
            output_index,
            sequence_number,
            item,
        } = self;
        ResponseOutputItemDoneEvent {
            r#type: &Default::default(),
            output_index,
            sequence_number,
            item,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_output_text_annotation_added_event {
    #[doc = "The type of the event. Always 'response.output_text.annotation.added'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.output_text.annotation.added");
}
#[doc = "Emitted when an annotation is added to output text content.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseOutputTextAnnotationAddedEvent {
    #[doc = "The unique identifier of the item to which the annotation is being added."]
    pub item_id: String,
    #[doc = "The index of the output item in the response's output array."]
    pub output_index: i64,
    #[doc = "The index of the content part within the output item."]
    pub content_index: i64,
    #[doc = "The index of the annotation within the content part."]
    pub annotation_index: i64,
    #[doc = "The sequence number of this event."]
    pub sequence_number: i64,
    #[doc = "The annotation object being added. (See annotation schema for details.)"]
    pub annotation: indexmap::IndexMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for ResponseOutputTextAnnotationAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseOutputTextAnnotationAddedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_output_text_annotation_added_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "annotation_index")]
            annotation_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "annotation")]
            annotation: indexmap::IndexMap<String, serde_json::Value>,
        }
        let ResponseOutputTextAnnotationAddedEvent {
            item_id,
            output_index,
            content_index,
            annotation_index,
            sequence_number,
            annotation,
            ..
        } = ResponseOutputTextAnnotationAddedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            annotation_index,
            sequence_number,
            annotation,
        })
    }
}
impl serde::Serialize for ResponseOutputTextAnnotationAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseOutputTextAnnotationAddedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_output_text_annotation_added_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "annotation_index")]
            annotation_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "annotation")]
            annotation: &'a indexmap::IndexMap<String, serde_json::Value>,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            annotation_index,
            sequence_number,
            annotation,
        } = self;
        ResponseOutputTextAnnotationAddedEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            annotation_index,
            sequence_number,
            annotation,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod response_prompt_variables {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Item {
        Other(String),
        InputText(crate::__types::InputTextContent),
        InputImage(crate::__types::InputImageContent),
        InputFile(crate::__types::InputFileContent),
    }
}
#[doc = "Optional map of values to substitute in for variables in your\nprompt. The substitution values can either be strings, or other\nResponse input types like images or files.\n"]
pub type ResponsePromptVariables =
    indexmap::IndexMap<String, crate::__types::response_prompt_variables::Item>;
#[allow(clippy::module_inception)]
pub mod response_properties {
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Text {
        #[serde(rename = "format")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub format: Option<crate::__types::TextResponseFormatConfiguration>,
        #[serde(rename = "verbosity")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub verbosity: Option<crate::__types::Verbosity>,
    }
    #[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum ToolChoice {
        ToolChoiceOptions(crate::__types::ToolChoiceOptions),
        ToolChoiceAllowed(crate::__types::ToolChoiceAllowed),
        ToolChoiceTypes(crate::__types::ToolChoiceTypes),
        ToolChoiceFunction(crate::__types::ToolChoiceFunction),
        ToolChoiceMcp(crate::__types::ToolChoiceMcp),
        ToolChoiceCustom(crate::__types::ToolChoiceCustom),
    }
    impl<'de> serde::Deserialize<'de> for ToolChoice {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum ToolChoice {
                ToolChoiceOptions(crate::__types::ToolChoiceOptions),
                ToolChoiceAllowed(crate::__types::ToolChoiceAllowed),
                ToolChoiceTypes(crate::__types::ToolChoiceTypes),
                ToolChoiceFunction(crate::__types::ToolChoiceFunction),
                ToolChoiceMcp(crate::__types::ToolChoiceMcp),
                ToolChoiceCustom(crate::__types::ToolChoiceCustom),
            }
            Ok(match ToolChoice::deserialize(deserializer)? {
                ToolChoice::ToolChoiceOptions(v) => Self::ToolChoiceOptions(v),
                ToolChoice::ToolChoiceAllowed(v) => Self::ToolChoiceAllowed(v),
                ToolChoice::ToolChoiceTypes(v) => Self::ToolChoiceTypes(v),
                ToolChoice::ToolChoiceFunction(v) => Self::ToolChoiceFunction(v),
                ToolChoice::ToolChoiceMcp(v) => Self::ToolChoiceMcp(v),
                ToolChoice::ToolChoiceCustom(v) => Self::ToolChoiceCustom(v),
            })
        }
    }
    impl serde::Serialize for ToolChoice {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum ToolChoice<'a> {
                ToolChoiceOptions(&'a crate::__types::ToolChoiceOptions),
                ToolChoiceAllowed(&'a crate::__types::ToolChoiceAllowed),
                ToolChoiceTypes(&'a crate::__types::ToolChoiceTypes),
                ToolChoiceFunction(&'a crate::__types::ToolChoiceFunction),
                ToolChoiceMcp(&'a crate::__types::ToolChoiceMcp),
                ToolChoiceCustom(&'a crate::__types::ToolChoiceCustom),
            }
            match self {
                Self::ToolChoiceOptions(v) => ToolChoice::ToolChoiceOptions(v),
                Self::ToolChoiceAllowed(v) => ToolChoice::ToolChoiceAllowed(v),
                Self::ToolChoiceTypes(v) => ToolChoice::ToolChoiceTypes(v),
                Self::ToolChoiceFunction(v) => ToolChoice::ToolChoiceFunction(v),
                Self::ToolChoiceMcp(v) => ToolChoice::ToolChoiceMcp(v),
                Self::ToolChoiceCustom(v) => ToolChoice::ToolChoiceCustom(v),
            }
            .serialize(serializer)
        }
    }
    #[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping input items in the\n  middle of the conversation.\n- `disabled` (default): If a model response will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Truncation {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`disabled`"]
        #[default]
        #[serde(rename = "disabled")]
        Disabled,
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ResponseProperties {
    #[doc = "The unique ID of the previous response to the model. Use this to\ncreate multi-turn conversations. Learn more about\n[conversation state](https://platform.openai.com/docs/guides/conversation-state).\n"]
    #[serde(rename = "previous_response_id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub previous_response_id: Option<String>,
    #[doc = "Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI\noffers a wide range of models with different capabilities, performance\ncharacteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models)\nto browse and compare available models.\n"]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::ModelIdsResponses>,
    #[serde(rename = "reasoning")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reasoning: Option<crate::__types::Reasoning>,
    #[doc = "Whether to run the model response in the background.\n[Learn more](https://platform.openai.com/docs/guides/background).\n"]
    #[serde(rename = "background")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub background: Option<bool>,
    #[doc = "An upper bound for the number of tokens that can be generated for a response, including visible output tokens and [reasoning tokens](https://platform.openai.com/docs/guides/reasoning).\n"]
    #[serde(rename = "max_output_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_output_tokens: Option<i64>,
    #[doc = "The maximum number of total calls to built-in tools that can be processed in a response. This maximum number applies across all built-in tool calls, not per individual tool. Any further attempts to call a tool by the model will be ignored.\n"]
    #[serde(rename = "max_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_tool_calls: Option<i64>,
    #[doc = "Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n"]
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<crate::__types::response_properties::Text>,
    #[doc = "An array of tools the model may call while generating a response. You\ncan specify which tool to use by setting the `tool_choice` parameter.\n\nThe two categories of tools you can provide the model are:\n\n- **Built-in tools**: Tools that are provided by OpenAI that extend the\n  model's capabilities, like [web search](https://platform.openai.com/docs/guides/tools-web-search)\n  or [file search](https://platform.openai.com/docs/guides/tools-file-search). Learn more about\n  [built-in tools](https://platform.openai.com/docs/guides/tools).\n- **Function calls (custom tools)**: Functions that are defined by you,\n  enabling the model to call your own code with strongly typed arguments\n  and outputs. Learn more about\n  [function calling](https://platform.openai.com/docs/guides/function-calling). You can also use\n  custom tools to call your own code.\n"]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::Tool>>,
    #[doc = "How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n"]
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<crate::__types::response_properties::ToolChoice>,
    #[serde(rename = "prompt")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prompt: Option<crate::__types::Prompt>,
    #[doc = "The truncation strategy to use for the model response.\n- `auto`: If the context of this response and previous ones exceeds\n  the model's context window size, the model will truncate the\n  response to fit the context window by dropping input items in the\n  middle of the conversation.\n- `disabled` (default): If a model response will exceed the context window\n  size for a model, the request will fail with a 400 error.\n"]
    #[serde(rename = "truncation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub truncation: Option<crate::__types::response_properties::Truncation>,
}
#[allow(clippy::module_inception)]
pub(crate) mod response_queued_event {
    #[doc = "The type of the event. Always 'response.queued'."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.queued");
}
#[doc = "Emitted when a response is queued and waiting to be processed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseQueuedEvent {
    #[doc = "The full response object that is queued."]
    pub response: crate::__types::Response,
    #[doc = "The sequence number for this event."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseQueuedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseQueuedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_queued_event::Type,
            #[serde(rename = "response")]
            response: crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseQueuedEvent {
            response,
            sequence_number,
            ..
        } = ResponseQueuedEvent::deserialize(deserializer)?;
        Ok(Self {
            response,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseQueuedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseQueuedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_queued_event::Type,
            #[serde(rename = "response")]
            response: &'a crate::__types::Response,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            response,
            sequence_number,
        } = self;
        ResponseQueuedEvent {
            r#type: &Default::default(),
            response,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod response_reasoning_summary_part_added_event {
    #[doc = "The type of the event. Always `response.reasoning_summary_part.added`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.reasoning_summary_part.added");
    #[allow(clippy::module_inception)]
    pub(crate) mod part {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Type;
        impl_serde!(Type, "summary_text");
    }
    #[doc = "The summary part that was added.\n"]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct Part {
        #[doc = "The text of the summary part."]
        pub text: String,
    }
    impl<'de> serde::Deserialize<'de> for Part {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct Part {
                #[serde(rename = "type")]
                #[allow(dead_code)]
                r#type: crate::__types::response_reasoning_summary_part_added_event::part::Type,
                #[serde(rename = "text")]
                text: String,
            }
            let Part { text, .. } = Part::deserialize(deserializer)?;
            Ok(Self { text })
        }
    }
    impl serde::Serialize for Part {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct Part<'a> {
                #[serde(rename = "type")]
                r#type: &'a crate::__types::response_reasoning_summary_part_added_event::part::Type,
                #[serde(rename = "text")]
                text: &'a String,
            }
            let Self { text } = self;
            Part {
                r#type: &Default::default(),
                text,
            }
            .serialize(serializer)
        }
    }
}
#[doc = "Emitted when a new reasoning summary part is added."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartAddedEvent {
    #[doc = "The ID of the item this summary part is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary part is associated with.\n"]
    pub output_index: i64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: i64,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
    #[doc = "The summary part that was added.\n"]
    pub part: crate::__types::response_reasoning_summary_part_added_event::Part,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartAddedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryPartAddedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_reasoning_summary_part_added_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "summary_index")]
            summary_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "part")]
            part: crate::__types::response_reasoning_summary_part_added_event::Part,
        }
        let ResponseReasoningSummaryPartAddedEvent {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
            ..
        } = ResponseReasoningSummaryPartAddedEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartAddedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryPartAddedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_reasoning_summary_part_added_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "summary_index")]
            summary_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "part")]
            part: &'a crate::__types::response_reasoning_summary_part_added_event::Part,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        } = self;
        ResponseReasoningSummaryPartAddedEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod response_reasoning_summary_part_done_event {
    #[doc = "The type of the event. Always `response.reasoning_summary_part.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.reasoning_summary_part.done");
    #[allow(clippy::module_inception)]
    pub(crate) mod part {
        #[doc = "The type of the summary part. Always `summary_text`."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Type;
        impl_serde!(Type, "summary_text");
    }
    #[doc = "The completed summary part.\n"]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct Part {
        #[doc = "The text of the summary part."]
        pub text: String,
    }
    impl<'de> serde::Deserialize<'de> for Part {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct Part {
                #[serde(rename = "type")]
                #[allow(dead_code)]
                r#type: crate::__types::response_reasoning_summary_part_done_event::part::Type,
                #[serde(rename = "text")]
                text: String,
            }
            let Part { text, .. } = Part::deserialize(deserializer)?;
            Ok(Self { text })
        }
    }
    impl serde::Serialize for Part {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct Part<'a> {
                #[serde(rename = "type")]
                r#type: &'a crate::__types::response_reasoning_summary_part_done_event::part::Type,
                #[serde(rename = "text")]
                text: &'a String,
            }
            let Self { text } = self;
            Part {
                r#type: &Default::default(),
                text,
            }
            .serialize(serializer)
        }
    }
}
#[doc = "Emitted when a reasoning summary part is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryPartDoneEvent {
    #[doc = "The ID of the item this summary part is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary part is associated with.\n"]
    pub output_index: i64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: i64,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
    #[doc = "The completed summary part.\n"]
    pub part: crate::__types::response_reasoning_summary_part_done_event::Part,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryPartDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryPartDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_reasoning_summary_part_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "summary_index")]
            summary_index: i64,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "part")]
            part: crate::__types::response_reasoning_summary_part_done_event::Part,
        }
        let ResponseReasoningSummaryPartDoneEvent {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
            ..
        } = ResponseReasoningSummaryPartDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryPartDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryPartDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_reasoning_summary_part_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "summary_index")]
            summary_index: &'a i64,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "part")]
            part: &'a crate::__types::response_reasoning_summary_part_done_event::Part,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        } = self;
        ResponseReasoningSummaryPartDoneEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            summary_index,
            sequence_number,
            part,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_reasoning_summary_text_delta_event {
    #[doc = "The type of the event. Always `response.reasoning_summary_text.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.reasoning_summary_text.delta");
}
#[doc = "Emitted when a delta is added to a reasoning summary text."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryTextDeltaEvent {
    #[doc = "The ID of the item this summary text delta is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary text delta is associated with.\n"]
    pub output_index: i64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: i64,
    #[doc = "The text delta that was added to the summary.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryTextDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_reasoning_summary_text_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "summary_index")]
            summary_index: i64,
            #[serde(rename = "delta")]
            delta: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseReasoningSummaryTextDeltaEvent {
            item_id,
            output_index,
            summary_index,
            delta,
            sequence_number,
            ..
        } = ResponseReasoningSummaryTextDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryTextDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_reasoning_summary_text_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "summary_index")]
            summary_index: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            delta,
            sequence_number,
        } = self;
        ResponseReasoningSummaryTextDeltaEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            summary_index,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_reasoning_summary_text_done_event {
    #[doc = "The type of the event. Always `response.reasoning_summary_text.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.reasoning_summary_text.done");
}
#[doc = "Emitted when a reasoning summary text is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningSummaryTextDoneEvent {
    #[doc = "The ID of the item this summary text is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this summary text is associated with.\n"]
    pub output_index: i64,
    #[doc = "The index of the summary part within the reasoning summary.\n"]
    pub summary_index: i64,
    #[doc = "The full text of the completed reasoning summary.\n"]
    pub text: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningSummaryTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningSummaryTextDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_reasoning_summary_text_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "summary_index")]
            summary_index: i64,
            #[serde(rename = "text")]
            text: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseReasoningSummaryTextDoneEvent {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
            ..
        } = ResponseReasoningSummaryTextDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningSummaryTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningSummaryTextDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_reasoning_summary_text_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "summary_index")]
            summary_index: &'a i64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        } = self;
        ResponseReasoningSummaryTextDoneEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            summary_index,
            text,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_reasoning_text_delta_event {
    #[doc = "The type of the event. Always `response.reasoning_text.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.reasoning_text.delta");
}
#[doc = "Emitted when a delta is added to a reasoning text."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningTextDeltaEvent {
    #[doc = "The ID of the item this reasoning text delta is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this reasoning text delta is associated with.\n"]
    pub output_index: i64,
    #[doc = "The index of the reasoning content part this delta is associated with.\n"]
    pub content_index: i64,
    #[doc = "The text delta that was added to the reasoning content.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningTextDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_reasoning_text_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "delta")]
            delta: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseReasoningTextDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            ..
        } = ResponseReasoningTextDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningTextDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_reasoning_text_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        } = self;
        ResponseReasoningTextDeltaEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_reasoning_text_done_event {
    #[doc = "The type of the event. Always `response.reasoning_text.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.reasoning_text.done");
}
#[doc = "Emitted when a reasoning text is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseReasoningTextDoneEvent {
    #[doc = "The ID of the item this reasoning text is associated with.\n"]
    pub item_id: String,
    #[doc = "The index of the output item this reasoning text is associated with.\n"]
    pub output_index: i64,
    #[doc = "The index of the reasoning content part.\n"]
    pub content_index: i64,
    #[doc = "The full text of the completed reasoning content.\n"]
    pub text: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseReasoningTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseReasoningTextDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_reasoning_text_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "text")]
            text: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseReasoningTextDoneEvent {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
            ..
        } = ResponseReasoningTextDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseReasoningTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseReasoningTextDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_reasoning_text_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        } = self;
        ResponseReasoningTextDoneEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_refusal_delta_event {
    #[doc = "The type of the event. Always `response.refusal.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.refusal.delta");
}
#[doc = "Emitted when there is a partial refusal text."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseRefusalDeltaEvent {
    #[doc = "The ID of the output item that the refusal text is added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the refusal text is added to.\n"]
    pub output_index: i64,
    #[doc = "The index of the content part that the refusal text is added to.\n"]
    pub content_index: i64,
    #[doc = "The refusal text that is added.\n"]
    pub delta: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseRefusalDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseRefusalDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_refusal_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "delta")]
            delta: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseRefusalDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            ..
        } = ResponseRefusalDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseRefusalDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseRefusalDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_refusal_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        } = self;
        ResponseRefusalDeltaEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_refusal_done_event {
    #[doc = "The type of the event. Always `response.refusal.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.refusal.done");
}
#[doc = "Emitted when refusal text is finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseRefusalDoneEvent {
    #[doc = "The ID of the output item that the refusal text is finalized.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the refusal text is finalized.\n"]
    pub output_index: i64,
    #[doc = "The index of the content part that the refusal text is finalized.\n"]
    pub content_index: i64,
    #[doc = "The refusal text that is finalized.\n"]
    pub refusal: String,
    #[doc = "The sequence number of this event.\n"]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseRefusalDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseRefusalDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_refusal_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "refusal")]
            refusal: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseRefusalDoneEvent {
            item_id,
            output_index,
            content_index,
            refusal,
            sequence_number,
            ..
        } = ResponseRefusalDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            refusal,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseRefusalDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseRefusalDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_refusal_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "refusal")]
            refusal: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            refusal,
            sequence_number,
        } = self;
        ResponseRefusalDoneEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            refusal,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ResponseStreamEvent {
    ResponseAudioDelta(crate::__types::ResponseAudioDeltaEvent),
    ResponseAudioDone(crate::__types::ResponseAudioDoneEvent),
    ResponseAudioTranscriptDelta(crate::__types::ResponseAudioTranscriptDeltaEvent),
    ResponseAudioTranscriptDone(crate::__types::ResponseAudioTranscriptDoneEvent),
    ResponseCodeInterpreterCallCodeDelta(crate::__types::ResponseCodeInterpreterCallCodeDeltaEvent),
    ResponseCodeInterpreterCallCodeDone(crate::__types::ResponseCodeInterpreterCallCodeDoneEvent),
    ResponseCodeInterpreterCallCompleted(crate::__types::ResponseCodeInterpreterCallCompletedEvent),
    ResponseCodeInterpreterCallInProgress(
        crate::__types::ResponseCodeInterpreterCallInProgressEvent,
    ),
    ResponseCodeInterpreterCallInterpreting(
        crate::__types::ResponseCodeInterpreterCallInterpretingEvent,
    ),
    ResponseCompleted(crate::__types::ResponseCompletedEvent),
    ResponseContentPartAdded(crate::__types::ResponseContentPartAddedEvent),
    ResponseContentPartDone(crate::__types::ResponseContentPartDoneEvent),
    ResponseCreated(crate::__types::ResponseCreatedEvent),
    Error(crate::__types::ResponseErrorEvent),
    ResponseFileSearchCallCompleted(crate::__types::ResponseFileSearchCallCompletedEvent),
    ResponseFileSearchCallInProgress(crate::__types::ResponseFileSearchCallInProgressEvent),
    ResponseFileSearchCallSearching(crate::__types::ResponseFileSearchCallSearchingEvent),
    ResponseFunctionCallArgumentsDelta(crate::__types::ResponseFunctionCallArgumentsDeltaEvent),
    ResponseFunctionCallArgumentsDone(crate::__types::ResponseFunctionCallArgumentsDoneEvent),
    ResponseInProgress(crate::__types::ResponseInProgressEvent),
    ResponseFailed(crate::__types::ResponseFailedEvent),
    ResponseIncomplete(crate::__types::ResponseIncompleteEvent),
    ResponseOutputItemAdded(crate::__types::ResponseOutputItemAddedEvent),
    ResponseOutputItemDone(crate::__types::ResponseOutputItemDoneEvent),
    ResponseReasoningSummaryPartAdded(crate::__types::ResponseReasoningSummaryPartAddedEvent),
    ResponseReasoningSummaryPartDone(crate::__types::ResponseReasoningSummaryPartDoneEvent),
    ResponseReasoningSummaryTextDelta(crate::__types::ResponseReasoningSummaryTextDeltaEvent),
    ResponseReasoningSummaryTextDone(crate::__types::ResponseReasoningSummaryTextDoneEvent),
    ResponseReasoningTextDelta(crate::__types::ResponseReasoningTextDeltaEvent),
    ResponseReasoningTextDone(crate::__types::ResponseReasoningTextDoneEvent),
    ResponseRefusalDelta(crate::__types::ResponseRefusalDeltaEvent),
    ResponseRefusalDone(crate::__types::ResponseRefusalDoneEvent),
    ResponseOutputTextDelta(crate::__types::ResponseTextDeltaEvent),
    ResponseOutputTextDone(crate::__types::ResponseTextDoneEvent),
    ResponseWebSearchCallCompleted(crate::__types::ResponseWebSearchCallCompletedEvent),
    ResponseWebSearchCallInProgress(crate::__types::ResponseWebSearchCallInProgressEvent),
    ResponseWebSearchCallSearching(crate::__types::ResponseWebSearchCallSearchingEvent),
    ResponseImageGenerationCallCompleted(crate::__types::ResponseImageGenCallCompletedEvent),
    ResponseImageGenerationCallGenerating(crate::__types::ResponseImageGenCallGeneratingEvent),
    ResponseImageGenerationCallInProgress(crate::__types::ResponseImageGenCallInProgressEvent),
    ResponseImageGenerationCallPartialImage(crate::__types::ResponseImageGenCallPartialImageEvent),
    ResponseMcpCallArgumentsDelta(crate::__types::ResponseMcpCallArgumentsDeltaEvent),
    ResponseMcpCallArgumentsDone(crate::__types::ResponseMcpCallArgumentsDoneEvent),
    ResponseMcpCallCompleted(crate::__types::ResponseMcpCallCompletedEvent),
    ResponseMcpCallFailed(crate::__types::ResponseMcpCallFailedEvent),
    ResponseMcpCallInProgress(crate::__types::ResponseMcpCallInProgressEvent),
    ResponseMcpListToolsCompleted(crate::__types::ResponseMcpListToolsCompletedEvent),
    ResponseMcpListToolsFailed(crate::__types::ResponseMcpListToolsFailedEvent),
    ResponseMcpListToolsInProgress(crate::__types::ResponseMcpListToolsInProgressEvent),
    ResponseOutputTextAnnotationAdded(crate::__types::ResponseOutputTextAnnotationAddedEvent),
    ResponseQueued(crate::__types::ResponseQueuedEvent),
    ResponseCustomToolCallInputDelta(crate::__types::ResponseCustomToolCallInputDeltaEvent),
    ResponseCustomToolCallInputDone(crate::__types::ResponseCustomToolCallInputDoneEvent),
}
#[doc = "Options for streaming responses. Only set this when you set `stream: true`.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ResponseStreamOptions {
    #[doc = "When true, stream obfuscation will be enabled. Stream obfuscation adds\nrandom characters to an `obfuscation` field on streaming delta events to\nnormalize payload sizes as a mitigation to certain side-channel attacks.\nThese obfuscation fields are included by default, but add a small amount\nof overhead to the data stream. You can set `include_obfuscation` to\nfalse to optimize for bandwidth if you trust the network links between\nyour application and the OpenAI API.\n"]
    #[serde(rename = "include_obfuscation")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub include_obfuscation: Option<bool>,
}
#[allow(clippy::module_inception)]
pub(crate) mod response_text_delta_event {
    #[doc = "The type of the event. Always `response.output_text.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.output_text.delta");
}
#[doc = "Emitted when there is an additional text delta."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseTextDeltaEvent {
    #[doc = "The ID of the output item that the text delta was added to.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the text delta was added to.\n"]
    pub output_index: i64,
    #[doc = "The index of the content part that the text delta was added to.\n"]
    pub content_index: i64,
    #[doc = "The text delta that was added.\n"]
    pub delta: String,
    #[doc = "The sequence number for this event."]
    pub sequence_number: i64,
    #[doc = "The log probabilities of the tokens in the delta.\n"]
    pub logprobs: Vec<crate::__types::ResponseLogProb>,
}
impl<'de> serde::Deserialize<'de> for ResponseTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseTextDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_text_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "delta")]
            delta: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "logprobs")]
            logprobs: Vec<crate::__types::ResponseLogProb>,
        }
        let ResponseTextDeltaEvent {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            logprobs,
            ..
        } = ResponseTextDeltaEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            logprobs,
        })
    }
}
impl serde::Serialize for ResponseTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseTextDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_text_delta_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "logprobs")]
            logprobs: &'a Vec<crate::__types::ResponseLogProb>,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            logprobs,
        } = self;
        ResponseTextDeltaEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            delta,
            sequence_number,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_text_done_event {
    #[doc = "The type of the event. Always `response.output_text.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.output_text.done");
}
#[doc = "Emitted when text content is finalized."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseTextDoneEvent {
    #[doc = "The ID of the output item that the text content is finalized.\n"]
    pub item_id: String,
    #[doc = "The index of the output item that the text content is finalized.\n"]
    pub output_index: i64,
    #[doc = "The index of the content part that the text content is finalized.\n"]
    pub content_index: i64,
    #[doc = "The text content that is finalized.\n"]
    pub text: String,
    #[doc = "The sequence number for this event."]
    pub sequence_number: i64,
    #[doc = "The log probabilities of the tokens in the delta.\n"]
    pub logprobs: Vec<crate::__types::ResponseLogProb>,
}
impl<'de> serde::Deserialize<'de> for ResponseTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseTextDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_text_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "content_index")]
            content_index: i64,
            #[serde(rename = "text")]
            text: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
            #[serde(rename = "logprobs")]
            logprobs: Vec<crate::__types::ResponseLogProb>,
        }
        let ResponseTextDoneEvent {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
            logprobs,
            ..
        } = ResponseTextDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
            logprobs,
        })
    }
}
impl serde::Serialize for ResponseTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseTextDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_text_done_event::Type,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "content_index")]
            content_index: &'a i64,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
            #[serde(rename = "logprobs")]
            logprobs: &'a Vec<crate::__types::ResponseLogProb>,
        }
        let Self {
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
            logprobs,
        } = self;
        ResponseTextDoneEvent {
            r#type: &Default::default(),
            item_id,
            output_index,
            content_index,
            text,
            sequence_number,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod response_usage {
    #[doc = "A detailed breakdown of the input tokens."]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputTokensDetails {
        #[doc = "The number of tokens that were retrieved from the cache. \n[More on prompt caching](https://platform.openai.com/docs/guides/prompt-caching).\n"]
        #[serde(rename = "cached_tokens")]
        pub cached_tokens: i64,
    }
    #[doc = "A detailed breakdown of the output tokens."]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct OutputTokensDetails {
        #[doc = "The number of reasoning tokens."]
        #[serde(rename = "reasoning_tokens")]
        pub reasoning_tokens: i64,
    }
}
#[doc = "Represents token usage details including input tokens, output tokens,\na breakdown of output tokens, and the total tokens used.\n"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ResponseUsage {
    #[doc = "The number of input tokens."]
    #[serde(rename = "input_tokens")]
    pub input_tokens: i64,
    #[doc = "A detailed breakdown of the input tokens."]
    #[serde(rename = "input_tokens_details")]
    pub input_tokens_details: crate::__types::response_usage::InputTokensDetails,
    #[doc = "The number of output tokens."]
    #[serde(rename = "output_tokens")]
    pub output_tokens: i64,
    #[doc = "A detailed breakdown of the output tokens."]
    #[serde(rename = "output_tokens_details")]
    pub output_tokens_details: crate::__types::response_usage::OutputTokensDetails,
    #[doc = "The total number of tokens used."]
    #[serde(rename = "total_tokens")]
    pub total_tokens: i64,
}
#[allow(clippy::module_inception)]
pub(crate) mod response_web_search_call_completed_event {
    #[doc = "The type of the event. Always `response.web_search_call.completed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.web_search_call.completed");
}
#[doc = "Emitted when a web search call is completed."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallCompletedEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: i64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
    #[doc = "The sequence number of the web search call being processed."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallCompletedEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseWebSearchCallCompletedEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_web_search_call_completed_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseWebSearchCallCompletedEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseWebSearchCallCompletedEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallCompletedEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseWebSearchCallCompletedEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_web_search_call_completed_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseWebSearchCallCompletedEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_web_search_call_in_progress_event {
    #[doc = "The type of the event. Always `response.web_search_call.in_progress`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.web_search_call.in_progress");
}
#[doc = "Emitted when a web search call is initiated."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallInProgressEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: i64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
    #[doc = "The sequence number of the web search call being processed."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallInProgressEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseWebSearchCallInProgressEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_web_search_call_in_progress_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseWebSearchCallInProgressEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseWebSearchCallInProgressEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallInProgressEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseWebSearchCallInProgressEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_web_search_call_in_progress_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseWebSearchCallInProgressEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod response_web_search_call_searching_event {
    #[doc = "The type of the event. Always `response.web_search_call.searching`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.web_search_call.searching");
}
#[doc = "Emitted when a web search call is executing."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ResponseWebSearchCallSearchingEvent {
    #[doc = "The index of the output item that the web search call is associated with.\n"]
    pub output_index: i64,
    #[doc = "Unique ID for the output item associated with the web search call.\n"]
    pub item_id: String,
    #[doc = "The sequence number of the web search call being processed."]
    pub sequence_number: i64,
}
impl<'de> serde::Deserialize<'de> for ResponseWebSearchCallSearchingEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ResponseWebSearchCallSearchingEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::response_web_search_call_searching_event::Type,
            #[serde(rename = "output_index")]
            output_index: i64,
            #[serde(rename = "item_id")]
            item_id: String,
            #[serde(rename = "sequence_number")]
            sequence_number: i64,
        }
        let ResponseWebSearchCallSearchingEvent {
            output_index,
            item_id,
            sequence_number,
            ..
        } = ResponseWebSearchCallSearchingEvent::deserialize(deserializer)?;
        Ok(Self {
            output_index,
            item_id,
            sequence_number,
        })
    }
}
impl serde::Serialize for ResponseWebSearchCallSearchingEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ResponseWebSearchCallSearchingEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::response_web_search_call_searching_event::Type,
            #[serde(rename = "output_index")]
            output_index: &'a i64,
            #[serde(rename = "item_id")]
            item_id: &'a String,
            #[serde(rename = "sequence_number")]
            sequence_number: &'a i64,
        }
        let Self {
            output_index,
            item_id,
            sequence_number,
        } = self;
        ResponseWebSearchCallSearchingEvent {
            r#type: &Default::default(),
            output_index,
            item_id,
            sequence_number,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics related to the run. This value will be `null` if the run is not in a terminal state (i.e. `in_progress`, `queued`, etc.)."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RunCompletionUsage {
    #[doc = "Number of completion tokens used over the course of the run."]
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i64,
    #[doc = "Number of prompt tokens used over the course of the run."]
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i64,
    #[doc = "Total number of tokens used (prompt + completion)."]
    #[serde(rename = "total_tokens")]
    pub total_tokens: i64,
}
#[allow(clippy::module_inception)]
pub mod run_grader_request {
    #[doc = "The grader used for the fine-tuning job."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Grader {
        StringCheck(crate::__types::GraderStringCheck),
        TextSimilarity(crate::__types::GraderTextSimilarity),
        Python(crate::__types::GraderPython),
        ScoreModel(crate::__types::GraderScoreModel),
        Multi(crate::__types::GraderMulti),
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RunGraderRequest {
    #[doc = "The grader used for the fine-tuning job."]
    #[serde(rename = "grader")]
    pub grader: crate::__types::run_grader_request::Grader,
    #[doc = "The dataset item provided to the grader. This will be used to populate \nthe `item` namespace. See [the guide](https://platform.openai.com/docs/guides/graders) for more details. \n"]
    #[serde(rename = "item")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub item: Option<indexmap::IndexMap<String, serde_json::Value>>,
    #[doc = "The model sample to be evaluated. This value will be used to populate \nthe `sample` namespace. See [the guide](https://platform.openai.com/docs/guides/graders) for more details.\nThe `output_json` variable will be populated if the model sample is a \nvalid JSON string.\n \n"]
    #[serde(rename = "model_sample")]
    pub model_sample: String,
}
#[allow(clippy::module_inception)]
pub mod run_grader_response {
    #[allow(clippy::module_inception)]
    pub mod metadata {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Errors {
            #[serde(rename = "formula_parse_error")]
            pub formula_parse_error: bool,
            #[serde(rename = "sample_parse_error")]
            pub sample_parse_error: bool,
            #[serde(rename = "truncated_observation_error")]
            pub truncated_observation_error: bool,
            #[serde(rename = "unresponsive_reward_error")]
            pub unresponsive_reward_error: bool,
            #[serde(rename = "invalid_variable_error")]
            pub invalid_variable_error: bool,
            #[serde(rename = "other_error")]
            pub other_error: bool,
            #[serde(rename = "python_grader_server_error")]
            pub python_grader_server_error: bool,
            #[serde(rename = "python_grader_server_error_type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub python_grader_server_error_type: Option<String>,
            #[serde(rename = "python_grader_runtime_error")]
            pub python_grader_runtime_error: bool,
            #[serde(rename = "python_grader_runtime_error_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub python_grader_runtime_error_details: Option<String>,
            #[serde(rename = "model_grader_server_error")]
            pub model_grader_server_error: bool,
            #[serde(rename = "model_grader_refusal_error")]
            pub model_grader_refusal_error: bool,
            #[serde(rename = "model_grader_parse_error")]
            pub model_grader_parse_error: bool,
            #[serde(rename = "model_grader_server_error_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub model_grader_server_error_details: Option<String>,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Metadata {
        #[serde(rename = "name")]
        pub name: String,
        #[serde(rename = "type")]
        pub r#type: String,
        #[serde(rename = "errors")]
        pub errors: crate::__types::run_grader_response::metadata::Errors,
        #[serde(rename = "execution_time")]
        pub execution_time: serde_json::Number,
        #[serde(rename = "scores")]
        pub scores: indexmap::IndexMap<String, serde_json::Value>,
        #[serde(rename = "token_usage")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub token_usage: Option<i64>,
        #[serde(rename = "sampled_model_name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub sampled_model_name: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RunGraderResponse {
    #[serde(rename = "reward")]
    pub reward: serde_json::Number,
    #[serde(rename = "metadata")]
    pub metadata: crate::__types::run_grader_response::Metadata,
    #[serde(rename = "sub_rewards")]
    pub sub_rewards: indexmap::IndexMap<String, serde_json::Value>,
    #[serde(rename = "model_grader_token_usage_per_model")]
    pub model_grader_token_usage_per_model: indexmap::IndexMap<String, serde_json::Value>,
}
#[allow(clippy::module_inception)]
pub mod run_object {
    #[doc = "The object type, which is always `thread.run`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "thread.run");
    #[allow(clippy::module_inception)]
    pub mod required_action {
        #[doc = "For now, this is always `submit_tool_outputs`."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Type;
        impl_serde!(Type, "submit_tool_outputs");
        #[doc = "Details on the tool outputs needed for this run to continue."]
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct SubmitToolOutputs {
            #[doc = "A list of the relevant tool calls."]
            #[serde(rename = "tool_calls")]
            pub tool_calls: Vec<crate::__types::RunToolCallObject>,
        }
    }
    #[doc = "Details on the action required to continue the run. Will be `null` if no action is required."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct RequiredAction {
        #[doc = "Details on the tool outputs needed for this run to continue."]
        pub submit_tool_outputs: crate::__types::run_object::required_action::SubmitToolOutputs,
    }
    impl<'de> serde::Deserialize<'de> for RequiredAction {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct RequiredAction {
                #[serde(rename = "type")]
                #[allow(dead_code)]
                r#type: crate::__types::run_object::required_action::Type,
                #[serde(rename = "submit_tool_outputs")]
                submit_tool_outputs: crate::__types::run_object::required_action::SubmitToolOutputs,
            }
            let RequiredAction {
                submit_tool_outputs,
                ..
            } = RequiredAction::deserialize(deserializer)?;
            Ok(Self {
                submit_tool_outputs,
            })
        }
    }
    impl serde::Serialize for RequiredAction {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct RequiredAction<'a> {
                #[serde(rename = "type")]
                r#type: &'a crate::__types::run_object::required_action::Type,
                #[serde(rename = "submit_tool_outputs")]
                submit_tool_outputs:
                    &'a crate::__types::run_object::required_action::SubmitToolOutputs,
            }
            let Self {
                submit_tool_outputs,
            } = self;
            RequiredAction {
                r#type: &Default::default(),
                submit_tool_outputs,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod last_error {
        #[doc = "One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Code {
            #[doc = "`server_error`"]
            #[serde(rename = "server_error")]
            ServerError,
            #[doc = "`rate_limit_exceeded`"]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
            #[doc = "`invalid_prompt`"]
            #[serde(rename = "invalid_prompt")]
            InvalidPrompt,
        }
    }
    #[doc = "The last error associated with this run. Will be `null` if there are no errors."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct LastError {
        #[doc = "One of `server_error`, `rate_limit_exceeded`, or `invalid_prompt`."]
        #[serde(rename = "code")]
        pub code: crate::__types::run_object::last_error::Code,
        #[doc = "A human-readable description of the error."]
        #[serde(rename = "message")]
        pub message: String,
    }
    #[allow(clippy::module_inception)]
    pub mod incomplete_details {
        #[doc = "The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Reason {
            #[doc = "`max_completion_tokens`"]
            #[serde(rename = "max_completion_tokens")]
            MaxCompletionTokens,
            #[doc = "`max_prompt_tokens`"]
            #[serde(rename = "max_prompt_tokens")]
            MaxPromptTokens,
        }
    }
    #[doc = "Details on why the run is incomplete. Will be `null` if the run is not incomplete."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct IncompleteDetails {
        #[doc = "The reason why the run is incomplete. This will point to which specific token limit was reached over the course of the run."]
        #[serde(rename = "reason")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub reason: Option<crate::__types::run_object::incomplete_details::Reason>,
    }
}
#[doc = "Represents an execution run on a [thread](https://platform.openai.com/docs/api-reference/threads)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the run was created."]
    pub created_at: i64,
    #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was executed on as a part of this run."]
    pub thread_id: String,
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for execution of this run."]
    pub assistant_id: String,
    pub status: crate::__types::RunStatus,
    #[doc = "Details on the action required to continue the run. Will be `null` if no action is required."]
    #[builder(default)]
    pub required_action: Option<crate::__types::run_object::RequiredAction>,
    #[doc = "The last error associated with this run. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<crate::__types::run_object::LastError>,
    #[doc = "The Unix timestamp (in seconds) for when the run will expire."]
    #[builder(default)]
    pub expires_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was started."]
    #[builder(default)]
    pub started_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the run failed."]
    #[builder(default)]
    pub failed_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the run was completed."]
    #[builder(default)]
    pub completed_at: Option<i64>,
    #[doc = "Details on why the run is incomplete. Will be `null` if the run is not incomplete."]
    #[builder(default)]
    pub incomplete_details: Option<crate::__types::run_object::IncompleteDetails>,
    #[doc = "The model that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub model: String,
    #[doc = "The instructions that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub instructions: String,
    #[doc = "The list of tools that the [assistant](https://platform.openai.com/docs/api-reference/assistants) used for this run."]
    pub tools: Vec<crate::__types::AssistantTool>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[builder(default)]
    pub usage: Option<crate::__types::RunCompletionUsage>,
    #[doc = "The sampling temperature used for this run. If not set, defaults to 1."]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "The nucleus sampling value used for this run. If not set, defaults to 1."]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "The maximum number of prompt tokens specified to have been used over the course of the run.\n"]
    #[builder(default)]
    pub max_prompt_tokens: Option<i64>,
    #[doc = "The maximum number of completion tokens specified to have been used over the course of the run.\n"]
    #[builder(default)]
    pub max_completion_tokens: Option<i64>,
    #[builder(default)]
    pub truncation_strategy: Option<crate::__types::TruncationObject>,
    #[builder(default)]
    pub tool_choice: Option<crate::__types::AssistantsApiToolChoiceOption>,
    pub parallel_tool_calls: crate::__types::ParallelToolCalls,
    #[builder(default)]
    pub response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
}
impl<'de> serde::Deserialize<'de> for RunObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::run_object::Object,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "thread_id")]
            thread_id: String,
            #[serde(rename = "assistant_id")]
            assistant_id: String,
            #[serde(rename = "status")]
            status: crate::__types::RunStatus,
            #[serde(rename = "required_action")]
            required_action: Option<crate::__types::run_object::RequiredAction>,
            #[serde(rename = "last_error")]
            last_error: Option<crate::__types::run_object::LastError>,
            #[serde(rename = "expires_at")]
            expires_at: Option<i64>,
            #[serde(rename = "started_at")]
            started_at: Option<i64>,
            #[serde(rename = "cancelled_at")]
            cancelled_at: Option<i64>,
            #[serde(rename = "failed_at")]
            failed_at: Option<i64>,
            #[serde(rename = "completed_at")]
            completed_at: Option<i64>,
            #[serde(rename = "incomplete_details")]
            incomplete_details: Option<crate::__types::run_object::IncompleteDetails>,
            #[serde(rename = "model")]
            model: String,
            #[serde(rename = "instructions")]
            instructions: String,
            #[serde(rename = "tools")]
            tools: Vec<crate::__types::AssistantTool>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
            #[serde(rename = "usage")]
            usage: Option<crate::__types::RunCompletionUsage>,
            #[serde(rename = "temperature")]
            temperature: Option<serde_json::Number>,
            #[serde(rename = "top_p")]
            top_p: Option<serde_json::Number>,
            #[serde(rename = "max_prompt_tokens")]
            max_prompt_tokens: Option<i64>,
            #[serde(rename = "max_completion_tokens")]
            max_completion_tokens: Option<i64>,
            #[serde(rename = "truncation_strategy")]
            truncation_strategy: Option<crate::__types::TruncationObject>,
            #[serde(rename = "tool_choice")]
            tool_choice: Option<crate::__types::AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            parallel_tool_calls: crate::__types::ParallelToolCalls,
            #[serde(rename = "response_format")]
            response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
        }
        let RunObject {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
            ..
        } = RunObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        })
    }
}
impl serde::Serialize for RunObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::run_object::Object,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "status")]
            status: &'a crate::__types::RunStatus,
            #[serde(rename = "required_action")]
            #[serde(skip_serializing_if = "Option::is_none")]
            required_action: &'a Option<crate::__types::run_object::RequiredAction>,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<crate::__types::run_object::LastError>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<i64>,
            #[serde(rename = "started_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            started_at: &'a Option<i64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<i64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<i64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<i64>,
            #[serde(rename = "incomplete_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            incomplete_details: &'a Option<crate::__types::run_object::IncompleteDetails>,
            #[serde(rename = "model")]
            model: &'a String,
            #[serde(rename = "instructions")]
            instructions: &'a String,
            #[serde(rename = "tools")]
            tools: &'a Vec<crate::__types::AssistantTool>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<crate::__types::RunCompletionUsage>,
            #[serde(rename = "temperature")]
            #[serde(skip_serializing_if = "Option::is_none")]
            temperature: &'a Option<serde_json::Number>,
            #[serde(rename = "top_p")]
            #[serde(skip_serializing_if = "Option::is_none")]
            top_p: &'a Option<serde_json::Number>,
            #[serde(rename = "max_prompt_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_prompt_tokens: &'a Option<i64>,
            #[serde(rename = "max_completion_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_completion_tokens: &'a Option<i64>,
            #[serde(rename = "truncation_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            truncation_strategy: &'a Option<crate::__types::TruncationObject>,
            #[serde(rename = "tool_choice")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_choice: &'a Option<crate::__types::AssistantsApiToolChoiceOption>,
            #[serde(rename = "parallel_tool_calls")]
            parallel_tool_calls: &'a crate::__types::ParallelToolCalls,
            #[serde(rename = "response_format")]
            #[serde(skip_serializing_if = "Option::is_none")]
            response_format: &'a Option<crate::__types::AssistantsApiResponseFormatOption>,
        }
        let Self {
            id,
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        } = self;
        RunObject {
            id,
            object: &Default::default(),
            created_at,
            thread_id,
            assistant_id,
            status,
            required_action,
            last_error,
            expires_at,
            started_at,
            cancelled_at,
            failed_at,
            completed_at,
            incomplete_details,
            model,
            instructions,
            tools,
            metadata,
            usage,
            temperature,
            top_p,
            max_prompt_tokens,
            max_completion_tokens,
            truncation_strategy,
            tool_choice,
            parallel_tool_calls,
            response_format,
        }
        .serialize(serializer)
    }
}
#[doc = "Usage statistics related to the run step. This value will be `null` while the run step's status is `in_progress`."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RunStepCompletionUsage {
    #[doc = "Number of completion tokens used over the course of the run step."]
    #[serde(rename = "completion_tokens")]
    pub completion_tokens: i64,
    #[doc = "Number of prompt tokens used over the course of the run step."]
    #[serde(rename = "prompt_tokens")]
    pub prompt_tokens: i64,
    #[doc = "Total number of tokens used (prompt + completion)."]
    #[serde(rename = "total_tokens")]
    pub total_tokens: i64,
}
#[allow(clippy::module_inception)]
pub(crate) mod run_step_delta_object {
    #[doc = "The object type, which is always `thread.run.step.delta`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "thread.run.step.delta");
}
#[doc = "Represents a run step delta i.e. any changed fields on a run step during streaming.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaObject {
    #[doc = "The identifier of the run step, which can be referenced in API endpoints."]
    pub id: String,
    #[builder(default)]
    pub delta: crate::__types::RunStepDeltaObjectDelta,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::run_step_delta_object::Object,
            #[serde(rename = "delta")]
            delta: crate::__types::RunStepDeltaObjectDelta,
        }
        let RunStepDeltaObject { id, delta, .. } = RunStepDeltaObject::deserialize(deserializer)?;
        Ok(Self { id, delta })
    }
}
impl serde::Serialize for RunStepDeltaObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::run_step_delta_object::Object,
            #[serde(rename = "delta")]
            delta: &'a crate::__types::RunStepDeltaObjectDelta,
        }
        let Self { id, delta } = self;
        RunStepDeltaObject {
            id,
            object: &Default::default(),
            delta,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_delta_step_details_message_creation_object {
    #[doc = "Always `message_creation`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "message_creation");
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct MessageCreation {
        #[doc = "The ID of the message that was created by this run step."]
        #[serde(rename = "message_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub message_id: Option<String>,
    }
}
#[doc = "Details of the message creation by the run step."]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsMessageCreationObject {
    #[builder(default)]
    pub message_creation: Option<
        crate::__types::run_step_delta_step_details_message_creation_object::MessageCreation,
    >,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsMessageCreationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsMessageCreationObject { # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: run_step_delta_step_details_message_creation_object :: Type , # [serde (rename = "message_creation")] message_creation : Option < crate :: __types :: run_step_delta_step_details_message_creation_object :: MessageCreation > }
        let RunStepDeltaStepDetailsMessageCreationObject {
            message_creation, ..
        } = RunStepDeltaStepDetailsMessageCreationObject::deserialize(deserializer)?;
        Ok(Self { message_creation })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsMessageCreationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsMessageCreationObject < 'a > { # [serde (rename = "type")] r#type : & 'a crate :: __types :: run_step_delta_step_details_message_creation_object :: Type , # [serde (rename = "message_creation")] # [serde (skip_serializing_if = "Option::is_none")] message_creation : & 'a Option < crate :: __types :: run_step_delta_step_details_message_creation_object :: MessageCreation > }
        let Self { message_creation } = self;
        RunStepDeltaStepDetailsMessageCreationObject {
            r#type: &Default::default(),
            message_creation,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_delta_step_details_tool_calls_code_object {
    #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "code_interpreter");
    #[allow(clippy::module_inception)]
    pub mod code_interpreter {
        #[allow(clippy::module_inception)]
        pub mod outputs {
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::large_enum_variant)]
            pub enum Item {
                Logs(crate::__types::RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject),
                Image(crate::__types::RunStepDeltaStepDetailsToolCallsCodeOutputImageObject),
            }
        }
    }
    #[doc = "The Code Interpreter tool call definition."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CodeInterpreter { # [doc = "The input to the Code Interpreter tool call."] # [serde (rename = "input")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub input : Option < String > , # [doc = "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type."] # [serde (rename = "outputs")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub outputs : Option < Vec < crate :: __types :: run_step_delta_step_details_tool_calls_code_object :: code_interpreter :: outputs :: Item > > }
}
#[doc = "Details of the Code Interpreter tool call the run step was involved in."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: i64,
    #[doc = "The ID of the tool call."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The Code Interpreter tool call definition."]
    #[builder(default)]
    pub code_interpreter:
        Option<crate::__types::run_step_delta_step_details_tool_calls_code_object::CodeInterpreter>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeObject {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_delta_step_details_tool_calls_code_object::Type,
            #[serde(rename = "code_interpreter")]
            code_interpreter: Option<
                crate::__types::run_step_delta_step_details_tool_calls_code_object::CodeInterpreter,
            >,
        }
        let RunStepDeltaStepDetailsToolCallsCodeObject {
            index,
            id,
            code_interpreter,
            ..
        } = RunStepDeltaStepDetailsToolCallsCodeObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            id,
            code_interpreter,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeObject<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_delta_step_details_tool_calls_code_object::Type,
            #[serde(rename = "code_interpreter")]
            #[serde(skip_serializing_if = "Option::is_none")]
            code_interpreter: &'a Option<
                crate::__types::run_step_delta_step_details_tool_calls_code_object::CodeInterpreter,
            >,
        }
        let Self {
            index,
            id,
            code_interpreter,
        } = self;
        RunStepDeltaStepDetailsToolCallsCodeObject {
            index,
            id,
            r#type: &Default::default(),
            code_interpreter,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_delta_step_details_tool_calls_code_output_image_object {
    #[doc = "Always `image`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image");
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Image {
        #[doc = "The [file](https://platform.openai.com/docs/api-reference/files) ID of the image."]
        #[serde(rename = "file_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_id: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    #[doc = "The index of the output in the outputs array."]
    pub index: i64,
    #[builder(default)]
    pub image: Option<
        crate::__types::run_step_delta_step_details_tool_calls_code_output_image_object::Image,
    >,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject { # [serde (rename = "index")] index : i64 , # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: run_step_delta_step_details_tool_calls_code_output_image_object :: Type , # [serde (rename = "image")] image : Option < crate :: __types :: run_step_delta_step_details_tool_calls_code_output_image_object :: Image > }
        let RunStepDeltaStepDetailsToolCallsCodeOutputImageObject { index, image, .. } =
            RunStepDeltaStepDetailsToolCallsCodeOutputImageObject::deserialize(deserializer)?;
        Ok(Self { index, image })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputImageObject < 'a > { # [serde (rename = "index")] index : & 'a i64 , # [serde (rename = "type")] r#type : & 'a crate :: __types :: run_step_delta_step_details_tool_calls_code_output_image_object :: Type , # [serde (rename = "image")] # [serde (skip_serializing_if = "Option::is_none")] image : & 'a Option < crate :: __types :: run_step_delta_step_details_tool_calls_code_output_image_object :: Image > }
        let Self { index, image } = self;
        RunStepDeltaStepDetailsToolCallsCodeOutputImageObject {
            index,
            r#type: &Default::default(),
            image,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod run_step_delta_step_details_tool_calls_code_output_logs_object {
    #[doc = "Always `logs`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "logs");
}
#[doc = "Text output from the Code Interpreter tool call as part of a run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    #[doc = "The index of the output in the outputs array."]
    pub index: i64,
    #[doc = "The text output from the Code Interpreter tool call."]
    #[builder(default)]
    pub logs: Option<String>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject { # [serde (rename = "index")] index : i64 , # [serde (rename = "type")] # [allow (dead_code)] r#type : crate :: __types :: run_step_delta_step_details_tool_calls_code_output_logs_object :: Type , # [serde (rename = "logs")] logs : Option < String > }
        let RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject { index, logs, .. } =
            RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject::deserialize(deserializer)?;
        Ok(Self { index, logs })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject < 'a > { # [serde (rename = "index")] index : & 'a i64 , # [serde (rename = "type")] r#type : & 'a crate :: __types :: run_step_delta_step_details_tool_calls_code_output_logs_object :: Type , # [serde (rename = "logs")] # [serde (skip_serializing_if = "Option::is_none")] logs : & 'a Option < String > }
        let Self { index, logs } = self;
        RunStepDeltaStepDetailsToolCallsCodeOutputLogsObject {
            index,
            r#type: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod run_step_delta_step_details_tool_calls_file_search_object {
    #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_search");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsFileSearchObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: i64,
    #[doc = "The ID of the tool call object."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "For now, this is always going to be an empty object."]
    pub file_search: indexmap::IndexMap<String, serde_json::Value>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsFileSearchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsFileSearchObject {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_delta_step_details_tool_calls_file_search_object::Type,
            #[serde(rename = "file_search")]
            file_search: indexmap::IndexMap<String, serde_json::Value>,
        }
        let RunStepDeltaStepDetailsToolCallsFileSearchObject {
            index,
            id,
            file_search,
            ..
        } = RunStepDeltaStepDetailsToolCallsFileSearchObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            id,
            file_search,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsFileSearchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsFileSearchObject<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type:
                &'a crate::__types::run_step_delta_step_details_tool_calls_file_search_object::Type,
            #[serde(rename = "file_search")]
            file_search: &'a indexmap::IndexMap<String, serde_json::Value>,
        }
        let Self {
            index,
            id,
            file_search,
        } = self;
        RunStepDeltaStepDetailsToolCallsFileSearchObject {
            index,
            id,
            r#type: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_delta_step_details_tool_calls_function_object {
    #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
    #[doc = "The definition of the function that was called."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Function {
        #[doc = "The name of the function."]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
        #[doc = "The arguments passed to the function."]
        #[serde(rename = "arguments")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub arguments: Option<String>,
        #[doc = "The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet."]
        #[serde(rename = "output")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub output: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsFunctionObject {
    #[doc = "The index of the tool call in the tool calls array."]
    pub index: i64,
    #[doc = "The ID of the tool call object."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The definition of the function that was called."]
    #[builder(default)]
    pub function:
        Option<crate::__types::run_step_delta_step_details_tool_calls_function_object::Function>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsFunctionObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsFunctionObject {
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_delta_step_details_tool_calls_function_object::Type,
            #[serde(rename = "function")]
            function: Option<
                crate::__types::run_step_delta_step_details_tool_calls_function_object::Function,
            >,
        }
        let RunStepDeltaStepDetailsToolCallsFunctionObject {
            index,
            id,
            function,
            ..
        } = RunStepDeltaStepDetailsToolCallsFunctionObject::deserialize(deserializer)?;
        Ok(Self {
            index,
            id,
            function,
        })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsFunctionObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsFunctionObject<'a> {
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "type")]
            r#type:
                &'a crate::__types::run_step_delta_step_details_tool_calls_function_object::Type,
            #[serde(rename = "function")]
            #[serde(skip_serializing_if = "Option::is_none")]
            function: &'a Option<
                crate::__types::run_step_delta_step_details_tool_calls_function_object::Function,
            >,
        }
        let Self {
            index,
            id,
            function,
        } = self;
        RunStepDeltaStepDetailsToolCallsFunctionObject {
            index,
            id,
            r#type: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod run_step_delta_step_details_tool_calls_object {
    #[doc = "Always `tool_calls`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "tool_calls");
}
#[doc = "Details of the tool call."]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaStepDetailsToolCallsObject {
    #[doc = "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.\n"]
    #[builder(default)]
    pub tool_calls: Option<Vec<crate::__types::RunStepDeltaStepDetailsToolCall>>,
}
impl<'de> serde::Deserialize<'de> for RunStepDeltaStepDetailsToolCallsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDeltaStepDetailsToolCallsObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_delta_step_details_tool_calls_object::Type,
            #[serde(rename = "tool_calls")]
            tool_calls: Option<Vec<crate::__types::RunStepDeltaStepDetailsToolCall>>,
        }
        let RunStepDeltaStepDetailsToolCallsObject { tool_calls, .. } =
            RunStepDeltaStepDetailsToolCallsObject::deserialize(deserializer)?;
        Ok(Self { tool_calls })
    }
}
impl serde::Serialize for RunStepDeltaStepDetailsToolCallsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDeltaStepDetailsToolCallsObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_delta_step_details_tool_calls_object::Type,
            #[serde(rename = "tool_calls")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_calls: &'a Option<Vec<crate::__types::RunStepDeltaStepDetailsToolCall>>,
        }
        let Self { tool_calls } = self;
        RunStepDeltaStepDetailsToolCallsObject {
            r#type: &Default::default(),
            tool_calls,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_details_message_creation_object {
    #[doc = "Always `message_creation`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "message_creation");
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct MessageCreation {
        #[doc = "The ID of the message that was created by this run step."]
        #[serde(rename = "message_id")]
        pub message_id: String,
    }
}
#[doc = "Details of the message creation by the run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsMessageCreationObject {
    pub message_creation: crate::__types::run_step_details_message_creation_object::MessageCreation,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsMessageCreationObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsMessageCreationObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_details_message_creation_object::Type,
            #[serde(rename = "message_creation")]
            message_creation:
                crate::__types::run_step_details_message_creation_object::MessageCreation,
        }
        let RunStepDetailsMessageCreationObject {
            message_creation, ..
        } = RunStepDetailsMessageCreationObject::deserialize(deserializer)?;
        Ok(Self { message_creation })
    }
}
impl serde::Serialize for RunStepDetailsMessageCreationObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsMessageCreationObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_details_message_creation_object::Type,
            #[serde(rename = "message_creation")]
            message_creation:
                &'a crate::__types::run_step_details_message_creation_object::MessageCreation,
        }
        let Self { message_creation } = self;
        RunStepDetailsMessageCreationObject {
            r#type: &Default::default(),
            message_creation,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_details_tool_calls_code_object {
    #[doc = "The type of tool call. This is always going to be `code_interpreter` for this type of tool call."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "code_interpreter");
    #[allow(clippy::module_inception)]
    pub mod code_interpreter {
        #[allow(clippy::module_inception)]
        pub mod outputs {
            #[derive(Clone, Debug, PartialEq)]
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize, serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::large_enum_variant)]
            pub enum Item {
                Logs(crate::__types::RunStepDetailsToolCallsCodeOutputLogsObject),
                Image(crate::__types::RunStepDetailsToolCallsCodeOutputImageObject),
            }
        }
    }
    #[doc = "The Code Interpreter tool call definition."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct CodeInterpreter { # [doc = "The input to the Code Interpreter tool call."] # [serde (rename = "input")] pub input : String , # [doc = "The outputs from the Code Interpreter tool call. Code Interpreter can output one or more items, including text (`logs`) or images (`image`). Each of these are represented by a different object type."] # [serde (rename = "outputs")] pub outputs : Vec < crate :: __types :: run_step_details_tool_calls_code_object :: code_interpreter :: outputs :: Item > }
}
#[doc = "Details of the Code Interpreter tool call the run step was involved in."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeObject {
    #[doc = "The ID of the tool call."]
    pub id: String,
    #[doc = "The Code Interpreter tool call definition."]
    pub code_interpreter: crate::__types::run_step_details_tool_calls_code_object::CodeInterpreter,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsCodeObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_details_tool_calls_code_object::Type,
            #[serde(rename = "code_interpreter")]
            code_interpreter:
                crate::__types::run_step_details_tool_calls_code_object::CodeInterpreter,
        }
        let RunStepDetailsToolCallsCodeObject {
            id,
            code_interpreter,
            ..
        } = RunStepDetailsToolCallsCodeObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            code_interpreter,
        })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsCodeObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_details_tool_calls_code_object::Type,
            #[serde(rename = "code_interpreter")]
            code_interpreter:
                &'a crate::__types::run_step_details_tool_calls_code_object::CodeInterpreter,
        }
        let Self {
            id,
            code_interpreter,
        } = self;
        RunStepDetailsToolCallsCodeObject {
            id,
            r#type: &Default::default(),
            code_interpreter,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_details_tool_calls_code_output_image_object {
    #[doc = "Always `image`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image");
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Image {
        #[doc = "The [file](https://platform.openai.com/docs/api-reference/files) ID of the image."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeOutputImageObject {
    pub image: crate::__types::run_step_details_tool_calls_code_output_image_object::Image,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeOutputImageObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsCodeOutputImageObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_details_tool_calls_code_output_image_object::Type,
            #[serde(rename = "image")]
            image: crate::__types::run_step_details_tool_calls_code_output_image_object::Image,
        }
        let RunStepDetailsToolCallsCodeOutputImageObject { image, .. } =
            RunStepDetailsToolCallsCodeOutputImageObject::deserialize(deserializer)?;
        Ok(Self { image })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeOutputImageObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsCodeOutputImageObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_details_tool_calls_code_output_image_object::Type,
            #[serde(rename = "image")]
            image: &'a crate::__types::run_step_details_tool_calls_code_output_image_object::Image,
        }
        let Self { image } = self;
        RunStepDetailsToolCallsCodeOutputImageObject {
            r#type: &Default::default(),
            image,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod run_step_details_tool_calls_code_output_logs_object {
    #[doc = "Always `logs`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "logs");
}
#[doc = "Text output from the Code Interpreter tool call as part of a run step."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsCodeOutputLogsObject {
    #[doc = "The text output from the Code Interpreter tool call."]
    pub logs: String,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsCodeOutputLogsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsCodeOutputLogsObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_details_tool_calls_code_output_logs_object::Type,
            #[serde(rename = "logs")]
            logs: String,
        }
        let RunStepDetailsToolCallsCodeOutputLogsObject { logs, .. } =
            RunStepDetailsToolCallsCodeOutputLogsObject::deserialize(deserializer)?;
        Ok(Self { logs })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsCodeOutputLogsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsCodeOutputLogsObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_details_tool_calls_code_output_logs_object::Type,
            #[serde(rename = "logs")]
            logs: &'a String,
        }
        let Self { logs } = self;
        RunStepDetailsToolCallsCodeOutputLogsObject {
            r#type: &Default::default(),
            logs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_details_tool_calls_file_search_object {
    #[doc = "The type of tool call. This is always going to be `file_search` for this type of tool call."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_search");
    #[doc = "For now, this is always going to be an empty object."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FileSearch {
        #[serde(rename = "ranking_options")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub ranking_options:
            Option<crate::__types::RunStepDetailsToolCallsFileSearchRankingOptionsObject>,
        #[doc = "The results of the file search."]
        #[serde(rename = "results")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub results: Option<Vec<crate::__types::RunStepDetailsToolCallsFileSearchResultObject>>,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchObject {
    #[doc = "The ID of the tool call object."]
    pub id: String,
    #[doc = "For now, this is always going to be an empty object."]
    #[builder(default)]
    pub file_search: crate::__types::run_step_details_tool_calls_file_search_object::FileSearch,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFileSearchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFileSearchObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_details_tool_calls_file_search_object::Type,
            #[serde(rename = "file_search")]
            file_search: crate::__types::run_step_details_tool_calls_file_search_object::FileSearch,
        }
        let RunStepDetailsToolCallsFileSearchObject {
            id, file_search, ..
        } = RunStepDetailsToolCallsFileSearchObject::deserialize(deserializer)?;
        Ok(Self { id, file_search })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFileSearchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFileSearchObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_details_tool_calls_file_search_object::Type,
            #[serde(rename = "file_search")]
            file_search:
                &'a crate::__types::run_step_details_tool_calls_file_search_object::FileSearch,
        }
        let Self { id, file_search } = self;
        RunStepDetailsToolCallsFileSearchObject {
            id,
            r#type: &Default::default(),
            file_search,
        }
        .serialize(serializer)
    }
}
#[doc = "The ranking options for the file search."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchRankingOptionsObject {
    #[serde(rename = "ranker")]
    pub ranker: crate::__types::FileSearchRanker,
    #[doc = "The score threshold for the file search. All values must be a floating point number between 0 and 1."]
    #[serde(rename = "score_threshold")]
    pub score_threshold: serde_json::Number,
}
#[allow(clippy::module_inception)]
pub mod run_step_details_tool_calls_file_search_result_object {
    #[allow(clippy::module_inception)]
    pub mod content {
        #[allow(clippy::module_inception)]
        pub mod item {
            #[doc = "The type of the content."]
            #[derive(Clone, Copy, Debug, Default, PartialEq)]
            pub struct Type;
            impl_serde!(Type, "text");
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item { # [doc = "The type of the content."] # [serde (rename = "type")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub r#type : Option < crate :: __types :: run_step_details_tool_calls_file_search_result_object :: content :: item :: Type > , # [doc = "The text content of the file."] # [serde (rename = "text")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub text : Option < String > }
    }
}
#[doc = "A result instance of the file search."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFileSearchResultObject {
    #[doc = "The ID of the file that result was found in."]
    #[serde(rename = "file_id")]
    pub file_id: String,
    #[doc = "The name of the file that result was found in."]
    #[serde(rename = "file_name")]
    pub file_name: String,
    #[doc = "The score of the result. All values must be a floating point number between 0 and 1."]
    #[serde(rename = "score")]
    pub score: serde_json::Number,
    #[doc = "The content of the result that was found. The content is only included if requested via the include query parameter."]
    #[serde(rename = "content")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub content: Option<
        Vec<crate::__types::run_step_details_tool_calls_file_search_result_object::content::Item>,
    >,
}
#[allow(clippy::module_inception)]
pub mod run_step_details_tool_calls_function_object {
    #[doc = "The type of tool call. This is always going to be `function` for this type of tool call."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
    #[doc = "The definition of the function that was called."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Function {
        #[doc = "The name of the function."]
        #[serde(rename = "name")]
        pub name: String,
        #[doc = "The arguments passed to the function."]
        #[serde(rename = "arguments")]
        pub arguments: String,
        #[doc = "The output of the function. This will be `null` if the outputs have not been [submitted](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) yet."]
        #[serde(rename = "output")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub output: Option<String>,
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsFunctionObject {
    #[doc = "The ID of the tool call object."]
    pub id: String,
    #[doc = "The definition of the function that was called."]
    pub function: crate::__types::run_step_details_tool_calls_function_object::Function,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsFunctionObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsFunctionObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_details_tool_calls_function_object::Type,
            #[serde(rename = "function")]
            function: crate::__types::run_step_details_tool_calls_function_object::Function,
        }
        let RunStepDetailsToolCallsFunctionObject { id, function, .. } =
            RunStepDetailsToolCallsFunctionObject::deserialize(deserializer)?;
        Ok(Self { id, function })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsFunctionObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsFunctionObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_details_tool_calls_function_object::Type,
            #[serde(rename = "function")]
            function: &'a crate::__types::run_step_details_tool_calls_function_object::Function,
        }
        let Self { id, function } = self;
        RunStepDetailsToolCallsFunctionObject {
            id,
            r#type: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod run_step_details_tool_calls_object {
    #[doc = "Always `tool_calls`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "tool_calls");
}
#[doc = "Details of the tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepDetailsToolCallsObject {
    #[doc = "An array of tool calls the run step was involved in. These can be associated with one of three types of tools: `code_interpreter`, `file_search`, or `function`.\n"]
    pub tool_calls: Vec<crate::__types::RunStepDetailsToolCall>,
}
impl<'de> serde::Deserialize<'de> for RunStepDetailsToolCallsObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepDetailsToolCallsObject {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_step_details_tool_calls_object::Type,
            #[serde(rename = "tool_calls")]
            tool_calls: Vec<crate::__types::RunStepDetailsToolCall>,
        }
        let RunStepDetailsToolCallsObject { tool_calls, .. } =
            RunStepDetailsToolCallsObject::deserialize(deserializer)?;
        Ok(Self { tool_calls })
    }
}
impl serde::Serialize for RunStepDetailsToolCallsObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepDetailsToolCallsObject<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_details_tool_calls_object::Type,
            #[serde(rename = "tool_calls")]
            tool_calls: &'a Vec<crate::__types::RunStepDetailsToolCall>,
        }
        let Self { tool_calls } = self;
        RunStepDetailsToolCallsObject {
            r#type: &Default::default(),
            tool_calls,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_object {
    #[doc = "The object type, which is always `thread.run.step`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "thread.run.step");
    #[doc = "The type of run step, which can be either `message_creation` or `tool_calls`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`message_creation`"]
        #[serde(rename = "message_creation")]
        MessageCreation,
        #[doc = "`tool_calls`"]
        #[serde(rename = "tool_calls")]
        ToolCalls,
    }
    #[doc = "The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`cancelled`"]
        #[serde(rename = "cancelled")]
        Cancelled,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`expired`"]
        #[serde(rename = "expired")]
        Expired,
    }
    #[doc = "The details of the run step."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum StepDetails {
        MessageCreation(crate::__types::RunStepDetailsMessageCreationObject),
        ToolCalls(crate::__types::RunStepDetailsToolCallsObject),
    }
    #[allow(clippy::module_inception)]
    pub mod last_error {
        #[doc = "One of `server_error` or `rate_limit_exceeded`."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Code {
            #[doc = "`server_error`"]
            #[serde(rename = "server_error")]
            ServerError,
            #[doc = "`rate_limit_exceeded`"]
            #[serde(rename = "rate_limit_exceeded")]
            RateLimitExceeded,
        }
    }
    #[doc = "The last error associated with this run step. Will be `null` if there are no errors."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct LastError {
        #[doc = "One of `server_error` or `rate_limit_exceeded`."]
        #[serde(rename = "code")]
        pub code: crate::__types::run_step_object::last_error::Code,
        #[doc = "A human-readable description of the error."]
        #[serde(rename = "message")]
        pub message: String,
    }
}
#[doc = "Represents a step in execution of a run.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunStepObject {
    #[doc = "The identifier of the run step, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the run step was created."]
    pub created_at: i64,
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) associated with the run step."]
    pub assistant_id: String,
    #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run."]
    pub thread_id: String,
    #[doc = "The ID of the [run](https://platform.openai.com/docs/api-reference/runs) that this run step is a part of."]
    pub run_id: String,
    #[doc = "The type of run step, which can be either `message_creation` or `tool_calls`."]
    pub r#type: crate::__types::run_step_object::Type,
    #[doc = "The status of the run step, which can be either `in_progress`, `cancelled`, `failed`, `completed`, or `expired`."]
    pub status: crate::__types::run_step_object::Status,
    #[doc = "The details of the run step."]
    pub step_details: crate::__types::run_step_object::StepDetails,
    #[doc = "The last error associated with this run step. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<crate::__types::run_step_object::LastError>,
    #[doc = "The Unix timestamp (in seconds) for when the run step expired. A step is considered expired if the parent run is expired."]
    #[builder(default)]
    pub expired_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step was cancelled."]
    #[builder(default)]
    pub cancelled_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step failed."]
    #[builder(default)]
    pub failed_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the run step completed."]
    #[builder(default)]
    pub completed_at: Option<i64>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[builder(default)]
    pub usage: Option<crate::__types::RunStepCompletionUsage>,
}
impl<'de> serde::Deserialize<'de> for RunStepObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunStepObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::run_step_object::Object,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "assistant_id")]
            assistant_id: String,
            #[serde(rename = "thread_id")]
            thread_id: String,
            #[serde(rename = "run_id")]
            run_id: String,
            #[serde(rename = "type")]
            r#type: crate::__types::run_step_object::Type,
            #[serde(rename = "status")]
            status: crate::__types::run_step_object::Status,
            #[serde(rename = "step_details")]
            step_details: crate::__types::run_step_object::StepDetails,
            #[serde(rename = "last_error")]
            last_error: Option<crate::__types::run_step_object::LastError>,
            #[serde(rename = "expired_at")]
            expired_at: Option<i64>,
            #[serde(rename = "cancelled_at")]
            cancelled_at: Option<i64>,
            #[serde(rename = "failed_at")]
            failed_at: Option<i64>,
            #[serde(rename = "completed_at")]
            completed_at: Option<i64>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
            #[serde(rename = "usage")]
            usage: Option<crate::__types::RunStepCompletionUsage>,
        }
        let RunStepObject {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            r#type,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
            ..
        } = RunStepObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            r#type,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        })
    }
}
impl serde::Serialize for RunStepObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunStepObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::run_step_object::Object,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "assistant_id")]
            assistant_id: &'a String,
            #[serde(rename = "thread_id")]
            thread_id: &'a String,
            #[serde(rename = "run_id")]
            run_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_step_object::Type,
            #[serde(rename = "status")]
            status: &'a crate::__types::run_step_object::Status,
            #[serde(rename = "step_details")]
            step_details: &'a crate::__types::run_step_object::StepDetails,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<crate::__types::run_step_object::LastError>,
            #[serde(rename = "expired_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expired_at: &'a Option<i64>,
            #[serde(rename = "cancelled_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            cancelled_at: &'a Option<i64>,
            #[serde(rename = "failed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            failed_at: &'a Option<i64>,
            #[serde(rename = "completed_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            completed_at: &'a Option<i64>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<crate::__types::RunStepCompletionUsage>,
        }
        let Self {
            id,
            created_at,
            assistant_id,
            thread_id,
            run_id,
            r#type,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        } = self;
        RunStepObject {
            id,
            object: &Default::default(),
            created_at,
            assistant_id,
            thread_id,
            run_id,
            r#type,
            status,
            step_details,
            last_error,
            expired_at,
            cancelled_at,
            failed_at,
            completed_at,
            metadata,
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod run_step_stream_event {
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_step_created {
        #[doc = "thread.run.step.created"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.step.created");
    }
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is created."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunStepCreated {
        pub data: crate::__types::RunStepObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunStepCreated {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunStepCreated {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_step_stream_event::thread_run_step_created::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunStepObject,
            }
            let ThreadRunStepCreated { data, .. } =
                ThreadRunStepCreated::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunStepCreated {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunStepCreated<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_step_stream_event::thread_run_step_created::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunStepObject,
            }
            let Self { data } = self;
            ThreadRunStepCreated {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_step_in_progress {
        #[doc = "thread.run.step.in_progress"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.step.in_progress");
    }
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) moves to an `in_progress` state."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunStepInProgress {
        pub data: crate::__types::RunStepObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunStepInProgress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunStepInProgress {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_step_stream_event::thread_run_step_in_progress::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunStepObject,
            }
            let ThreadRunStepInProgress { data, .. } =
                ThreadRunStepInProgress::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunStepInProgress {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunStepInProgress<'a> {
                #[serde(rename = "event")]
                event:
                    &'a crate::__types::run_step_stream_event::thread_run_step_in_progress::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunStepObject,
            }
            let Self { data } = self;
            ThreadRunStepInProgress {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_step_delta {
        #[doc = "thread.run.step.delta"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.step.delta");
    }
    #[doc = "Occurs when parts of a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) are being streamed."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunStepDelta {
        pub data: crate::__types::RunStepDeltaObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunStepDelta {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunStepDelta {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_step_stream_event::thread_run_step_delta::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunStepDeltaObject,
            }
            let ThreadRunStepDelta { data, .. } = ThreadRunStepDelta::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunStepDelta {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunStepDelta<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_step_stream_event::thread_run_step_delta::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunStepDeltaObject,
            }
            let Self { data } = self;
            ThreadRunStepDelta {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_step_completed {
        #[doc = "thread.run.step.completed"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.step.completed");
    }
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is completed."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunStepCompleted {
        pub data: crate::__types::RunStepObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunStepCompleted {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunStepCompleted {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_step_stream_event::thread_run_step_completed::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunStepObject,
            }
            let ThreadRunStepCompleted { data, .. } =
                ThreadRunStepCompleted::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunStepCompleted {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunStepCompleted<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_step_stream_event::thread_run_step_completed::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunStepObject,
            }
            let Self { data } = self;
            ThreadRunStepCompleted {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_step_failed {
        #[doc = "thread.run.step.failed"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.step.failed");
    }
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) fails."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunStepFailed {
        pub data: crate::__types::RunStepObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunStepFailed {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunStepFailed {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_step_stream_event::thread_run_step_failed::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunStepObject,
            }
            let ThreadRunStepFailed { data, .. } = ThreadRunStepFailed::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunStepFailed {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunStepFailed<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_step_stream_event::thread_run_step_failed::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunStepObject,
            }
            let Self { data } = self;
            ThreadRunStepFailed {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_step_cancelled {
        #[doc = "thread.run.step.cancelled"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.step.cancelled");
    }
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is cancelled."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunStepCancelled {
        pub data: crate::__types::RunStepObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunStepCancelled {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunStepCancelled {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_step_stream_event::thread_run_step_cancelled::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunStepObject,
            }
            let ThreadRunStepCancelled { data, .. } =
                ThreadRunStepCancelled::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunStepCancelled {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunStepCancelled<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_step_stream_event::thread_run_step_cancelled::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunStepObject,
            }
            let Self { data } = self;
            ThreadRunStepCancelled {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_step_expired {
        #[doc = "thread.run.step.expired"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.step.expired");
    }
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) expires."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunStepExpired {
        pub data: crate::__types::RunStepObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunStepExpired {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunStepExpired {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_step_stream_event::thread_run_step_expired::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunStepObject,
            }
            let ThreadRunStepExpired { data, .. } =
                ThreadRunStepExpired::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunStepExpired {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunStepExpired<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_step_stream_event::thread_run_step_expired::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunStepObject,
            }
            let Self { data } = self;
            ThreadRunStepExpired {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepStreamEvent {
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is created."]
    ThreadRunStepCreated(crate::__types::run_step_stream_event::ThreadRunStepCreated),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) moves to an `in_progress` state."]
    ThreadRunStepInProgress(crate::__types::run_step_stream_event::ThreadRunStepInProgress),
    #[doc = "Occurs when parts of a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) are being streamed."]
    ThreadRunStepDelta(crate::__types::run_step_stream_event::ThreadRunStepDelta),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is completed."]
    ThreadRunStepCompleted(crate::__types::run_step_stream_event::ThreadRunStepCompleted),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) fails."]
    ThreadRunStepFailed(crate::__types::run_step_stream_event::ThreadRunStepFailed),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) is cancelled."]
    ThreadRunStepCancelled(crate::__types::run_step_stream_event::ThreadRunStepCancelled),
    #[doc = "Occurs when a [run step](https://platform.openai.com/docs/api-reference/run-steps/step-object) expires."]
    ThreadRunStepExpired(crate::__types::run_step_stream_event::ThreadRunStepExpired),
}
#[allow(clippy::module_inception)]
pub mod run_stream_event {
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_created {
        #[doc = "thread.run.created"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.created");
    }
    #[doc = "Occurs when a new [run](https://platform.openai.com/docs/api-reference/runs/object) is created."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunCreated {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunCreated {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunCreated {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_created::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunCreated { data, .. } = ThreadRunCreated::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunCreated {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunCreated<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_created::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunCreated {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_queued {
        #[doc = "thread.run.queued"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.queued");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `queued` status."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunQueued {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunQueued {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunQueued {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_queued::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunQueued { data, .. } = ThreadRunQueued::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunQueued {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunQueued<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_queued::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunQueued {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_in_progress {
        #[doc = "thread.run.in_progress"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.in_progress");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to an `in_progress` status."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunInProgress {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunInProgress {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunInProgress {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_in_progress::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunInProgress { data, .. } = ThreadRunInProgress::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunInProgress {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunInProgress<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_in_progress::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunInProgress {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_requires_action {
        #[doc = "thread.run.requires_action"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.requires_action");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `requires_action` status."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunRequiresAction {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunRequiresAction {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunRequiresAction {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_requires_action::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunRequiresAction { data, .. } =
                ThreadRunRequiresAction::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunRequiresAction {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunRequiresAction<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_requires_action::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunRequiresAction {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_completed {
        #[doc = "thread.run.completed"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.completed");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is completed."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunCompleted {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunCompleted {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunCompleted {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_completed::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunCompleted { data, .. } = ThreadRunCompleted::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunCompleted {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunCompleted<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_completed::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunCompleted {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_incomplete {
        #[doc = "thread.run.incomplete"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.incomplete");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) ends with status `incomplete`."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunIncomplete {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunIncomplete {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunIncomplete {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_incomplete::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunIncomplete { data, .. } = ThreadRunIncomplete::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunIncomplete {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunIncomplete<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_incomplete::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunIncomplete {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_failed {
        #[doc = "thread.run.failed"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.failed");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) fails."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunFailed {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunFailed {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunFailed {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_failed::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunFailed { data, .. } = ThreadRunFailed::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunFailed {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunFailed<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_failed::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunFailed {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_cancelling {
        #[doc = "thread.run.cancelling"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.cancelling");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `cancelling` status."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunCancelling {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunCancelling {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunCancelling {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_cancelling::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunCancelling { data, .. } = ThreadRunCancelling::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunCancelling {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunCancelling<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_cancelling::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunCancelling {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_cancelled {
        #[doc = "thread.run.cancelled"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.cancelled");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is cancelled."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunCancelled {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunCancelled {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunCancelled {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_cancelled::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunCancelled { data, .. } = ThreadRunCancelled::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunCancelled {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunCancelled<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_cancelled::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunCancelled {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_run_expired {
        #[doc = "thread.run.expired"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.run.expired");
    }
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) expires."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadRunExpired {
        pub data: crate::__types::RunObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadRunExpired {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadRunExpired {
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::run_stream_event::thread_run_expired::Event,
                #[serde(rename = "data")]
                data: crate::__types::RunObject,
            }
            let ThreadRunExpired { data, .. } = ThreadRunExpired::deserialize(deserializer)?;
            Ok(Self { data })
        }
    }
    impl serde::Serialize for ThreadRunExpired {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadRunExpired<'a> {
                #[serde(rename = "event")]
                event: &'a crate::__types::run_stream_event::thread_run_expired::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::RunObject,
            }
            let Self { data } = self;
            ThreadRunExpired {
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum RunStreamEvent {
    #[doc = "Occurs when a new [run](https://platform.openai.com/docs/api-reference/runs/object) is created."]
    ThreadRunCreated(crate::__types::run_stream_event::ThreadRunCreated),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `queued` status."]
    ThreadRunQueued(crate::__types::run_stream_event::ThreadRunQueued),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to an `in_progress` status."]
    ThreadRunInProgress(crate::__types::run_stream_event::ThreadRunInProgress),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `requires_action` status."]
    ThreadRunRequiresAction(crate::__types::run_stream_event::ThreadRunRequiresAction),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is completed."]
    ThreadRunCompleted(crate::__types::run_stream_event::ThreadRunCompleted),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) ends with status `incomplete`."]
    ThreadRunIncomplete(crate::__types::run_stream_event::ThreadRunIncomplete),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) fails."]
    ThreadRunFailed(crate::__types::run_stream_event::ThreadRunFailed),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) moves to a `cancelling` status."]
    ThreadRunCancelling(crate::__types::run_stream_event::ThreadRunCancelling),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) is cancelled."]
    ThreadRunCancelled(crate::__types::run_stream_event::ThreadRunCancelled),
    #[doc = "Occurs when a [run](https://platform.openai.com/docs/api-reference/runs/object) expires."]
    ThreadRunExpired(crate::__types::run_stream_event::ThreadRunExpired),
}
#[allow(clippy::module_inception)]
pub mod run_tool_call_object {
    #[doc = "The type of tool call the output is required for. For now, this is always `function`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
    #[doc = "The function definition."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Function {
        #[doc = "The name of the function."]
        #[serde(rename = "name")]
        pub name: String,
        #[doc = "The arguments that the model expects you to pass to the function."]
        #[serde(rename = "arguments")]
        pub arguments: String,
    }
}
#[doc = "Tool call objects"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RunToolCallObject {
    #[doc = "The ID of the tool call. This ID must be referenced when you submit the tool outputs in using the [Submit tool outputs to run](https://platform.openai.com/docs/api-reference/runs/submitToolOutputs) endpoint."]
    pub id: String,
    #[doc = "The function definition."]
    pub function: crate::__types::run_tool_call_object::Function,
}
impl<'de> serde::Deserialize<'de> for RunToolCallObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RunToolCallObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::run_tool_call_object::Type,
            #[serde(rename = "function")]
            function: crate::__types::run_tool_call_object::Function,
        }
        let RunToolCallObject { id, function, .. } = RunToolCallObject::deserialize(deserializer)?;
        Ok(Self { id, function })
    }
}
impl serde::Serialize for RunToolCallObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RunToolCallObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::run_tool_call_object::Type,
            #[serde(rename = "function")]
            function: &'a crate::__types::run_tool_call_object::Function,
        }
        let Self { id, function } = self;
        RunToolCallObject {
            id,
            r#type: &Default::default(),
            function,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod screenshot {
    #[doc = "Specifies the event type. For a screenshot action, this property is \nalways set to `screenshot`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "screenshot");
}
#[doc = "A screenshot action.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct Screenshot {}
impl<'de> serde::Deserialize<'de> for Screenshot {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Screenshot {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::screenshot::Type,
        }
        let Screenshot { .. } = Screenshot::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for Screenshot {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Screenshot<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::screenshot::Type,
        }
        let Self {} = self;
        Screenshot {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod scroll {
    #[doc = "Specifies the event type. For a scroll action, this property is \nalways set to `scroll`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "scroll");
}
#[doc = "A scroll action.\n"]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Scroll {
    #[doc = "The x-coordinate where the scroll occurred.\n"]
    pub x: i64,
    #[doc = "The y-coordinate where the scroll occurred.\n"]
    pub y: i64,
    #[doc = "The horizontal scroll distance.\n"]
    pub scroll_x: i64,
    #[doc = "The vertical scroll distance.\n"]
    pub scroll_y: i64,
}
impl<'de> serde::Deserialize<'de> for Scroll {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Scroll {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::scroll::Type,
            #[serde(rename = "x")]
            x: i64,
            #[serde(rename = "y")]
            y: i64,
            #[serde(rename = "scroll_x")]
            scroll_x: i64,
            #[serde(rename = "scroll_y")]
            scroll_y: i64,
        }
        let Scroll {
            x,
            y,
            scroll_x,
            scroll_y,
            ..
        } = Scroll::deserialize(deserializer)?;
        Ok(Self {
            x,
            y,
            scroll_x,
            scroll_y,
        })
    }
}
impl serde::Serialize for Scroll {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Scroll<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::scroll::Type,
            #[serde(rename = "x")]
            x: &'a i64,
            #[serde(rename = "y")]
            y: &'a i64,
            #[serde(rename = "scroll_x")]
            scroll_x: &'a i64,
            #[serde(rename = "scroll_y")]
            scroll_y: &'a i64,
        }
        let Self {
            x,
            y,
            scroll_x,
            scroll_y,
        } = self;
        Scroll {
            r#type: &Default::default(),
            x,
            y,
            scroll_x,
            scroll_y,
        }
        .serialize(serializer)
    }
}
#[doc = "Specifies the processing type used for serving the request.\n  - If set to 'auto', then the request will be processed with the service tier configured in the Project settings. Unless otherwise configured, the Project will use 'default'.\n  - If set to 'default', then the request will be processed with the standard pricing and performance for the selected model.\n  - If set to '[flex](https://platform.openai.com/docs/guides/flex-processing)' or '[priority](https://openai.com/api-priority-processing/)', then the request will be processed with the corresponding service tier.\n  - When not set, the default behavior is 'auto'.\n\n  When the `service_tier` parameter is set, the response body will include the `service_tier` value based on the processing mode actually used to serve the request. This response value may be different from the value set in the parameter.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum ServiceTier {
    #[doc = "`auto`"]
    #[default]
    #[serde(rename = "auto")]
    Auto,
    #[doc = "`default`"]
    #[serde(rename = "default")]
    Default,
    #[doc = "`flex`"]
    #[serde(rename = "flex")]
    Flex,
    #[doc = "`scale`"]
    #[serde(rename = "scale")]
    Scale,
    #[doc = "`priority`"]
    #[serde(rename = "priority")]
    Priority,
}
#[allow(clippy::module_inception)]
pub(crate) mod speech_audio_delta_event {
    #[doc = "The type of the event. Always `speech.audio.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "speech.audio.delta");
}
#[doc = "Emitted for each chunk of audio data generated during speech synthesis."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct SpeechAudioDeltaEvent {
    #[doc = "A chunk of Base64-encoded audio data.\n"]
    pub audio: String,
}
impl<'de> serde::Deserialize<'de> for SpeechAudioDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct SpeechAudioDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::speech_audio_delta_event::Type,
            #[serde(rename = "audio")]
            audio: String,
        }
        let SpeechAudioDeltaEvent { audio, .. } = SpeechAudioDeltaEvent::deserialize(deserializer)?;
        Ok(Self { audio })
    }
}
impl serde::Serialize for SpeechAudioDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct SpeechAudioDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::speech_audio_delta_event::Type,
            #[serde(rename = "audio")]
            audio: &'a String,
        }
        let Self { audio } = self;
        SpeechAudioDeltaEvent {
            r#type: &Default::default(),
            audio,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod speech_audio_done_event {
    #[doc = "The type of the event. Always `speech.audio.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "speech.audio.done");
    #[doc = "Token usage statistics for the request.\n"]
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Usage {
        #[doc = "Number of input tokens in the prompt."]
        #[serde(rename = "input_tokens")]
        pub input_tokens: i64,
        #[doc = "Number of output tokens generated."]
        #[serde(rename = "output_tokens")]
        pub output_tokens: i64,
        #[doc = "Total number of tokens used (input + output)."]
        #[serde(rename = "total_tokens")]
        pub total_tokens: i64,
    }
}
#[doc = "Emitted when the speech synthesis is complete and all audio has been streamed."]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct SpeechAudioDoneEvent {
    #[doc = "Token usage statistics for the request.\n"]
    pub usage: crate::__types::speech_audio_done_event::Usage,
}
impl<'de> serde::Deserialize<'de> for SpeechAudioDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct SpeechAudioDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::speech_audio_done_event::Type,
            #[serde(rename = "usage")]
            usage: crate::__types::speech_audio_done_event::Usage,
        }
        let SpeechAudioDoneEvent { usage, .. } = SpeechAudioDoneEvent::deserialize(deserializer)?;
        Ok(Self { usage })
    }
}
impl serde::Serialize for SpeechAudioDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct SpeechAudioDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::speech_audio_done_event::Type,
            #[serde(rename = "usage")]
            usage: &'a crate::__types::speech_audio_done_event::Usage,
        }
        let Self { usage } = self;
        SpeechAudioDoneEvent {
            r#type: &Default::default(),
            usage,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategy {
    #[doc = "The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`."]
    #[serde(rename = "max_chunk_size_tokens")]
    pub max_chunk_size_tokens: i64,
    #[doc = "The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n"]
    #[serde(rename = "chunk_overlap_tokens")]
    pub chunk_overlap_tokens: i64,
}
#[allow(clippy::module_inception)]
pub(crate) mod static_chunking_strategy_request_param {
    #[doc = "Always `static`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "static");
}
#[doc = "Customize your own chunking strategy by setting chunk size and chunk overlap."]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategyRequestParam {
    pub r#static: crate::__types::StaticChunkingStrategy,
}
impl<'de> serde::Deserialize<'de> for StaticChunkingStrategyRequestParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct StaticChunkingStrategyRequestParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::static_chunking_strategy_request_param::Type,
            #[serde(rename = "static")]
            r#static: crate::__types::StaticChunkingStrategy,
        }
        let StaticChunkingStrategyRequestParam { r#static, .. } =
            StaticChunkingStrategyRequestParam::deserialize(deserializer)?;
        Ok(Self { r#static })
    }
}
impl serde::Serialize for StaticChunkingStrategyRequestParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct StaticChunkingStrategyRequestParam<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::static_chunking_strategy_request_param::Type,
            #[serde(rename = "static")]
            r#static: &'a crate::__types::StaticChunkingStrategy,
        }
        let Self { r#static } = self;
        StaticChunkingStrategyRequestParam {
            r#type: &Default::default(),
            r#static,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod static_chunking_strategy_response_param {
    #[doc = "Always `static`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "static");
}
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct StaticChunkingStrategyResponseParam {
    pub r#static: crate::__types::StaticChunkingStrategy,
}
impl<'de> serde::Deserialize<'de> for StaticChunkingStrategyResponseParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct StaticChunkingStrategyResponseParam {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::static_chunking_strategy_response_param::Type,
            #[serde(rename = "static")]
            r#static: crate::__types::StaticChunkingStrategy,
        }
        let StaticChunkingStrategyResponseParam { r#static, .. } =
            StaticChunkingStrategyResponseParam::deserialize(deserializer)?;
        Ok(Self { r#static })
    }
}
impl serde::Serialize for StaticChunkingStrategyResponseParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct StaticChunkingStrategyResponseParam<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::static_chunking_strategy_response_param::Type,
            #[serde(rename = "static")]
            r#static: &'a crate::__types::StaticChunkingStrategy,
        }
        let Self { r#static } = self;
        StaticChunkingStrategyResponseParam {
            r#type: &Default::default(),
            r#static,
        }
        .serialize(serializer)
    }
}
#[doc = "Not supported with latest reasoning models `o3` and `o4-mini`.\n\nUp to 4 sequences where the API will stop generating further tokens. The\nreturned text will not contain the stop sequence.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum StopConfiguration {
    String(String),
    Array(Vec<String>),
}
#[allow(clippy::module_inception)]
pub mod submit_tool_outputs_run_request {
    #[allow(clippy::module_inception)]
    pub mod tool_outputs {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The ID of the tool call in the `required_action` object within the run object the output is being submitted for."]
            #[serde(rename = "tool_call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub tool_call_id: Option<String>,
            #[doc = "The output of the tool call to be submitted to continue the run."]
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub output: Option<String>,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct SubmitToolOutputsRunRequest {
    #[doc = "A list of tools for which the outputs are being submitted."]
    #[serde(rename = "tool_outputs")]
    pub tool_outputs: Vec<crate::__types::submit_tool_outputs_run_request::tool_outputs::Item>,
    #[doc = "If `true`, returns a stream of events that happen during the Run as server-sent events, terminating when the Run enters a terminal state with a `data: [DONE]` message.\n"]
    #[serde(rename = "stream")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub stream: Option<bool>,
}
#[doc = "An object specifying the format that the model must output.\n\nConfiguring `{ \"type\": \"json_schema\" }` enables Structured Outputs, \nwhich ensures the model will match your supplied JSON schema. Learn more in the \n[Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n\nThe default format is `{ \"type\": \"text\" }` with no additional options.\n\n**Not recommended for gpt-4o and newer models:**\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum TextResponseFormatConfiguration {
    Text(crate::__types::ResponseFormatText),
    JsonSchema(crate::__types::TextResponseFormatJsonSchema),
    JsonObject(crate::__types::ResponseFormatJsonObject),
}
#[allow(clippy::module_inception)]
pub(crate) mod text_response_format_json_schema {
    #[doc = "The type of response format being defined. Always `json_schema`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "json_schema");
}
#[doc = "JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs).\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TextResponseFormatJsonSchema {
    #[doc = "A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n"]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n"]
    pub name: String,
    pub schema: crate::__types::ResponseFormatJsonSchemaSchema,
    #[doc = "Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n"]
    #[builder(default)]
    pub strict: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for TextResponseFormatJsonSchema {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TextResponseFormatJsonSchema {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::text_response_format_json_schema::Type,
            #[serde(rename = "description")]
            description: Option<String>,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "schema")]
            schema: crate::__types::ResponseFormatJsonSchemaSchema,
            #[serde(rename = "strict")]
            strict: Option<bool>,
        }
        let TextResponseFormatJsonSchema {
            description,
            name,
            schema,
            strict,
            ..
        } = TextResponseFormatJsonSchema::deserialize(deserializer)?;
        Ok(Self {
            description,
            name,
            schema,
            strict,
        })
    }
}
impl serde::Serialize for TextResponseFormatJsonSchema {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TextResponseFormatJsonSchema<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::text_response_format_json_schema::Type,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "schema")]
            schema: &'a crate::__types::ResponseFormatJsonSchemaSchema,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let Self {
            description,
            name,
            schema,
            strict,
        } = self;
        TextResponseFormatJsonSchema {
            r#type: &Default::default(),
            description,
            name,
            schema,
            strict,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod thread_object {
    #[doc = "The object type, which is always `thread`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "thread");
    #[allow(clippy::module_inception)]
    pub mod tool_resources {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct CodeInterpreter {
            #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_ids: Option<Vec<String>>,
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct FileSearch {
            #[doc = "The [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this thread. There can be a maximum of 1 vector store attached to the thread.\n"]
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub vector_store_ids: Option<Vec<String>>,
        }
    }
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ToolResources {
        #[serde(rename = "code_interpreter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub code_interpreter:
            Option<crate::__types::thread_object::tool_resources::CodeInterpreter>,
        #[serde(rename = "file_search")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub file_search: Option<crate::__types::thread_object::tool_resources::FileSearch>,
    }
}
#[doc = "Represents a thread that contains [messages](https://platform.openai.com/docs/api-reference/messages)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ThreadObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the thread was created."]
    pub created_at: i64,
    #[doc = "A set of resources that are made available to the assistant's tools in this thread. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[builder(default)]
    pub tool_resources: Option<crate::__types::thread_object::ToolResources>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
impl<'de> serde::Deserialize<'de> for ThreadObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ThreadObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::thread_object::Object,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "tool_resources")]
            tool_resources: Option<crate::__types::thread_object::ToolResources>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
        }
        let ThreadObject {
            id,
            created_at,
            tool_resources,
            metadata,
            ..
        } = ThreadObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            tool_resources,
            metadata,
        })
    }
}
impl serde::Serialize for ThreadObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ThreadObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::thread_object::Object,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "tool_resources")]
            #[serde(skip_serializing_if = "Option::is_none")]
            tool_resources: &'a Option<crate::__types::thread_object::ToolResources>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
        }
        let Self {
            id,
            created_at,
            tool_resources,
            metadata,
        } = self;
        ThreadObject {
            id,
            object: &Default::default(),
            created_at,
            tool_resources,
            metadata,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod thread_stream_event {
    #[allow(clippy::module_inception)]
    pub(crate) mod thread_created {
        #[doc = "thread.created"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Event;
        impl_serde!(Event, "thread.created");
    }
    #[doc = "Occurs when a new [thread](https://platform.openai.com/docs/api-reference/threads/object) is created."]
    #[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
    pub struct ThreadCreated {
        #[doc = "Whether to enable input audio transcription."]
        #[builder(default)]
        pub enabled: Option<bool>,
        pub data: crate::__types::ThreadObject,
    }
    impl<'de> serde::Deserialize<'de> for ThreadCreated {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            struct ThreadCreated {
                #[serde(rename = "enabled")]
                enabled: Option<bool>,
                #[serde(rename = "event")]
                #[allow(dead_code)]
                event: crate::__types::thread_stream_event::thread_created::Event,
                #[serde(rename = "data")]
                data: crate::__types::ThreadObject,
            }
            let ThreadCreated { enabled, data, .. } = ThreadCreated::deserialize(deserializer)?;
            Ok(Self { enabled, data })
        }
    }
    impl serde::Serialize for ThreadCreated {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            struct ThreadCreated<'a> {
                #[serde(rename = "enabled")]
                #[serde(skip_serializing_if = "Option::is_none")]
                enabled: &'a Option<bool>,
                #[serde(rename = "event")]
                event: &'a crate::__types::thread_stream_event::thread_created::Event,
                #[serde(rename = "data")]
                data: &'a crate::__types::ThreadObject,
            }
            let Self { enabled, data } = self;
            ThreadCreated {
                enabled,
                event: &Default::default(),
                data,
            }
            .serialize(serializer)
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ThreadStreamEvent {
    #[doc = "Occurs when a new [thread](https://platform.openai.com/docs/api-reference/threads/object) is created."]
    ThreadCreated(crate::__types::thread_stream_event::ThreadCreated),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ToggleCertificatesRequest {
    #[serde(rename = "certificate_ids")]
    pub certificate_ids: Vec<String>,
}
#[doc = "A tool that can be used to generate a response.\n"]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum Tool {
    FunctionTool(crate::__types::FunctionTool),
    FileSearchTool(crate::__types::FileSearchTool),
    WebSearchPreviewTool(crate::__types::WebSearchPreviewTool),
    ComputerUsePreviewTool(crate::__types::ComputerUsePreviewTool),
    McpTool(crate::__types::McpTool),
    CodeInterpreterTool(crate::__types::CodeInterpreterTool),
    ImageGenTool(crate::__types::ImageGenTool),
    LocalShellTool(crate::__types::LocalShellTool),
    CustomTool(crate::__types::CustomTool),
}
#[allow(clippy::module_inception)]
pub mod tool_choice_allowed {
    #[doc = "Allowed tool configuration type. Always `allowed_tools`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "allowed_tools");
    #[doc = "Constrains the tools available to the model to a pre-defined set.\n\n`auto` allows the model to pick from among the allowed tools and generate a\nmessage.\n\n`required` requires the model to call one or more of the allowed tools.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Mode {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`required`"]
        #[serde(rename = "required")]
        Required,
    }
}
#[doc = "Constrains the tools available to the model to a pre-defined set.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ToolChoiceAllowed {
    #[doc = "Constrains the tools available to the model to a pre-defined set.\n\n`auto` allows the model to pick from among the allowed tools and generate a\nmessage.\n\n`required` requires the model to call one or more of the allowed tools.\n"]
    pub mode: crate::__types::tool_choice_allowed::Mode,
    #[doc = "A list of tool definitions that the model should be allowed to call.\n\nFor the Responses API, the list of tool definitions might look like:\n```json\n[\n  { \"type\": \"function\", \"name\": \"get_weather\" },\n  { \"type\": \"mcp\", \"server_label\": \"deepwiki\" },\n  { \"type\": \"image_generation\" }\n]\n```text\n"]
    pub tools: Vec<indexmap::IndexMap<String, serde_json::Value>>,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceAllowed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ToolChoiceAllowed {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::tool_choice_allowed::Type,
            #[serde(rename = "mode")]
            mode: crate::__types::tool_choice_allowed::Mode,
            #[serde(rename = "tools")]
            tools: Vec<indexmap::IndexMap<String, serde_json::Value>>,
        }
        let ToolChoiceAllowed { mode, tools, .. } = ToolChoiceAllowed::deserialize(deserializer)?;
        Ok(Self { mode, tools })
    }
}
impl serde::Serialize for ToolChoiceAllowed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ToolChoiceAllowed<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::tool_choice_allowed::Type,
            #[serde(rename = "mode")]
            mode: &'a crate::__types::tool_choice_allowed::Mode,
            #[serde(rename = "tools")]
            tools: &'a Vec<indexmap::IndexMap<String, serde_json::Value>>,
        }
        let Self { mode, tools } = self;
        ToolChoiceAllowed {
            r#type: &Default::default(),
            mode,
            tools,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod tool_choice_custom {
    #[doc = "For custom tool calling, the type is always `custom`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "custom");
}
#[doc = "Use this option to force the model to call a specific custom tool.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ToolChoiceCustom {
    #[doc = "The name of the custom tool to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceCustom {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ToolChoiceCustom {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::tool_choice_custom::Type,
            #[serde(rename = "name")]
            name: String,
        }
        let ToolChoiceCustom { name, .. } = ToolChoiceCustom::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ToolChoiceCustom {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ToolChoiceCustom<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::tool_choice_custom::Type,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ToolChoiceCustom {
            r#type: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod tool_choice_function {
    #[doc = "For function calling, the type is always `function`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
}
#[doc = "Use this option to force the model to call a specific function.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ToolChoiceFunction {
    #[doc = "The name of the function to call."]
    pub name: String,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceFunction {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ToolChoiceFunction {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::tool_choice_function::Type,
            #[serde(rename = "name")]
            name: String,
        }
        let ToolChoiceFunction { name, .. } = ToolChoiceFunction::deserialize(deserializer)?;
        Ok(Self { name })
    }
}
impl serde::Serialize for ToolChoiceFunction {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ToolChoiceFunction<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::tool_choice_function::Type,
            #[serde(rename = "name")]
            name: &'a String,
        }
        let Self { name } = self;
        ToolChoiceFunction {
            r#type: &Default::default(),
            name,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod tool_choice_mcp {
    #[doc = "For MCP tools, the type is always `mcp`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "mcp");
}
#[doc = "Use this option to force the model to call a specific tool on a remote MCP server.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ToolChoiceMcp {
    #[doc = "The label of the MCP server to use.\n"]
    pub server_label: String,
    #[doc = "The name of the tool to call on the server.\n"]
    #[builder(default)]
    pub name: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ToolChoiceMcp {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ToolChoiceMcp {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::tool_choice_mcp::Type,
            #[serde(rename = "server_label")]
            server_label: String,
            #[serde(rename = "name")]
            name: Option<String>,
        }
        let ToolChoiceMcp {
            server_label, name, ..
        } = ToolChoiceMcp::deserialize(deserializer)?;
        Ok(Self { server_label, name })
    }
}
impl serde::Serialize for ToolChoiceMcp {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ToolChoiceMcp<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::tool_choice_mcp::Type,
            #[serde(rename = "server_label")]
            server_label: &'a String,
            #[serde(rename = "name")]
            #[serde(skip_serializing_if = "Option::is_none")]
            name: &'a Option<String>,
        }
        let Self { server_label, name } = self;
        ToolChoiceMcp {
            r#type: &Default::default(),
            server_label,
            name,
        }
        .serialize(serializer)
    }
}
#[doc = "Controls which (if any) tool is called by the model.\n\n`none` means the model will not call any tool and instead generates a message.\n\n`auto` means the model can pick between generating a message or calling one or\nmore tools.\n\n`required` means the model must call one or more tools.\n"]
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum ToolChoiceOptions {
    #[doc = "`none`"]
    #[serde(rename = "none")]
    None,
    #[doc = "`auto`"]
    #[serde(rename = "auto")]
    Auto,
    #[doc = "`required`"]
    #[serde(rename = "required")]
    Required,
}
#[allow(clippy::module_inception)]
pub mod tool_choice_types {
    #[doc = "The type of hosted tool the model should to use. Learn more about\n[built-in tools](https://platform.openai.com/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n- `code_interpreter`\n- `image_generation`\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`file_search`"]
        #[serde(rename = "file_search")]
        FileSearch,
        #[doc = "`web_search_preview`"]
        #[serde(rename = "web_search_preview")]
        WebSearchPreview,
        #[doc = "`computer_use_preview`"]
        #[serde(rename = "computer_use_preview")]
        ComputerUsePreview,
        #[doc = "`web_search_preview_2025_03_11`"]
        #[serde(rename = "web_search_preview_2025_03_11")]
        WebSearchPreview2025_03_11,
        #[doc = "`image_generation`"]
        #[serde(rename = "image_generation")]
        ImageGeneration,
        #[doc = "`code_interpreter`"]
        #[serde(rename = "code_interpreter")]
        CodeInterpreter,
    }
}
#[doc = "Indicates that the model should use a built-in tool to generate a response.\n[Learn more about built-in tools](https://platform.openai.com/docs/guides/tools).\n"]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ToolChoiceTypes {
    #[doc = "The type of hosted tool the model should to use. Learn more about\n[built-in tools](https://platform.openai.com/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n- `code_interpreter`\n- `image_generation`\n"]
    #[serde(rename = "type")]
    pub r#type: crate::__types::tool_choice_types::Type,
}
#[allow(clippy::module_inception)]
pub mod transcript_text_delta_event {
    #[doc = "The type of the event. Always `transcript.text.delta`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "transcript.text.delta");
    #[allow(clippy::module_inception)]
    pub mod logprobs {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The token that was used to generate the log probability.\n"]
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub token: Option<String>,
            #[doc = "The log probability of the token.\n"]
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub logprob: Option<serde_json::Number>,
            #[doc = "The bytes that were used to generate the log probability.\n"]
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub bytes: Option<Vec<i64>>,
        }
    }
}
#[doc = "Emitted when there is an additional text delta. This is also the first event emitted when the transcription starts. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDeltaEvent {
    #[doc = "The text delta that was additionally transcribed.\n"]
    pub delta: String,
    #[doc = "The log probabilities of the delta. Only included if you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.\n"]
    #[builder(default)]
    pub logprobs: Option<Vec<crate::__types::transcript_text_delta_event::logprobs::Item>>,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDeltaEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptTextDeltaEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::transcript_text_delta_event::Type,
            #[serde(rename = "delta")]
            delta: String,
            #[serde(rename = "logprobs")]
            logprobs: Option<Vec<crate::__types::transcript_text_delta_event::logprobs::Item>>,
        }
        let TranscriptTextDeltaEvent {
            delta, logprobs, ..
        } = TranscriptTextDeltaEvent::deserialize(deserializer)?;
        Ok(Self { delta, logprobs })
    }
}
impl serde::Serialize for TranscriptTextDeltaEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptTextDeltaEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::transcript_text_delta_event::Type,
            #[serde(rename = "delta")]
            delta: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<crate::__types::transcript_text_delta_event::logprobs::Item>>,
        }
        let Self { delta, logprobs } = self;
        TranscriptTextDeltaEvent {
            r#type: &Default::default(),
            delta,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod transcript_text_done_event {
    #[doc = "The type of the event. Always `transcript.text.done`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "transcript.text.done");
    #[allow(clippy::module_inception)]
    pub mod logprobs {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The token that was used to generate the log probability.\n"]
            #[serde(rename = "token")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub token: Option<String>,
            #[doc = "The log probability of the token.\n"]
            #[serde(rename = "logprob")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub logprob: Option<serde_json::Number>,
            #[doc = "The bytes that were used to generate the log probability.\n"]
            #[serde(rename = "bytes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub bytes: Option<Vec<i64>>,
        }
    }
}
#[doc = "Emitted when the transcription is complete. Contains the complete transcription text. Only emitted when you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `Stream` parameter set to `true`."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptTextDoneEvent {
    #[doc = "The text that was transcribed.\n"]
    pub text: String,
    #[doc = "The log probabilities of the individual tokens in the transcription. Only included if you [create a transcription](https://platform.openai.com/docs/api-reference/audio/create-transcription) with the `include[]` parameter set to `logprobs`.\n"]
    #[builder(default)]
    pub logprobs: Option<Vec<crate::__types::transcript_text_done_event::logprobs::Item>>,
    #[builder(default)]
    pub usage: Option<crate::__types::TranscriptTextUsageTokens>,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextDoneEvent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptTextDoneEvent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::transcript_text_done_event::Type,
            #[serde(rename = "text")]
            text: String,
            #[serde(rename = "logprobs")]
            logprobs: Option<Vec<crate::__types::transcript_text_done_event::logprobs::Item>>,
            #[serde(rename = "usage")]
            usage: Option<crate::__types::TranscriptTextUsageTokens>,
        }
        let TranscriptTextDoneEvent {
            text,
            logprobs,
            usage,
            ..
        } = TranscriptTextDoneEvent::deserialize(deserializer)?;
        Ok(Self {
            text,
            logprobs,
            usage,
        })
    }
}
impl serde::Serialize for TranscriptTextDoneEvent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptTextDoneEvent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::transcript_text_done_event::Type,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<crate::__types::transcript_text_done_event::logprobs::Item>>,
            #[serde(rename = "usage")]
            #[serde(skip_serializing_if = "Option::is_none")]
            usage: &'a Option<crate::__types::TranscriptTextUsageTokens>,
        }
        let Self {
            text,
            logprobs,
            usage,
        } = self;
        TranscriptTextDoneEvent {
            r#type: &Default::default(),
            text,
            logprobs,
            usage,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod transcript_text_usage_duration {
    #[doc = "The type of the usage object. Always `duration` for this variant."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "duration");
}
#[doc = "Usage statistics for models billed by audio input duration."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptTextUsageDuration {
    #[doc = "Duration of the input audio in seconds."]
    pub seconds: serde_json::Number,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextUsageDuration {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptTextUsageDuration {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::transcript_text_usage_duration::Type,
            #[serde(rename = "seconds")]
            seconds: serde_json::Number,
        }
        let TranscriptTextUsageDuration { seconds, .. } =
            TranscriptTextUsageDuration::deserialize(deserializer)?;
        Ok(Self { seconds })
    }
}
impl serde::Serialize for TranscriptTextUsageDuration {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptTextUsageDuration<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::transcript_text_usage_duration::Type,
            #[serde(rename = "seconds")]
            seconds: &'a serde_json::Number,
        }
        let Self { seconds } = self;
        TranscriptTextUsageDuration {
            r#type: &Default::default(),
            seconds,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod transcript_text_usage_tokens {
    #[doc = "The type of the usage object. Always `tokens` for this variant."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "tokens");
    #[doc = "Details about the input tokens billed for this request."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct InputTokenDetails {
        #[doc = "Number of text tokens billed for this request."]
        #[serde(rename = "text_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub text_tokens: Option<i64>,
        #[doc = "Number of audio tokens billed for this request."]
        #[serde(rename = "audio_tokens")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub audio_tokens: Option<i64>,
    }
}
#[doc = "Usage statistics for models billed by token usage."]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct TranscriptTextUsageTokens {
    #[doc = "Number of input tokens billed for this request."]
    pub input_tokens: i64,
    #[doc = "Details about the input tokens billed for this request."]
    #[builder(default)]
    pub input_token_details:
        Option<crate::__types::transcript_text_usage_tokens::InputTokenDetails>,
    #[doc = "Number of output tokens generated."]
    pub output_tokens: i64,
    #[doc = "Total number of tokens used (input + output)."]
    pub total_tokens: i64,
}
impl<'de> serde::Deserialize<'de> for TranscriptTextUsageTokens {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct TranscriptTextUsageTokens {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::transcript_text_usage_tokens::Type,
            #[serde(rename = "input_tokens")]
            input_tokens: i64,
            #[serde(rename = "input_token_details")]
            input_token_details:
                Option<crate::__types::transcript_text_usage_tokens::InputTokenDetails>,
            #[serde(rename = "output_tokens")]
            output_tokens: i64,
            #[serde(rename = "total_tokens")]
            total_tokens: i64,
        }
        let TranscriptTextUsageTokens {
            input_tokens,
            input_token_details,
            output_tokens,
            total_tokens,
            ..
        } = TranscriptTextUsageTokens::deserialize(deserializer)?;
        Ok(Self {
            input_tokens,
            input_token_details,
            output_tokens,
            total_tokens,
        })
    }
}
impl serde::Serialize for TranscriptTextUsageTokens {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct TranscriptTextUsageTokens<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::transcript_text_usage_tokens::Type,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a i64,
            #[serde(rename = "input_token_details")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_token_details:
                &'a Option<crate::__types::transcript_text_usage_tokens::InputTokenDetails>,
            #[serde(rename = "output_tokens")]
            output_tokens: &'a i64,
            #[serde(rename = "total_tokens")]
            total_tokens: &'a i64,
        }
        let Self {
            input_tokens,
            input_token_details,
            output_tokens,
            total_tokens,
        } = self;
        TranscriptTextUsageTokens {
            r#type: &Default::default(),
            input_tokens,
            input_token_details,
            output_tokens,
            total_tokens,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod transcription_chunking_strategy {
    #[doc = "auto"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Auto;
    impl_serde!(Auto, "auto");
}
#[doc = "Controls how the audio is cut into chunks. When set to `\"auto\"`, the server first normalizes loudness and then uses voice activity detection (VAD) to choose boundaries. `server_vad` object can be provided to tweak VAD detection parameters manually. If unset, the audio is transcribed as a single block. "]
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum TranscriptionChunkingStrategy {
    #[doc = "auto"]
    Auto,
    VadConfig(crate::__types::VadConfig),
}
impl<'de> serde::Deserialize<'de> for TranscriptionChunkingStrategy {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum TranscriptionChunkingStrategy {
            Auto(crate::__types::transcription_chunking_strategy::Auto),
            VadConfig(crate::__types::VadConfig),
        }
        Ok(
            match TranscriptionChunkingStrategy::deserialize(deserializer)? {
                TranscriptionChunkingStrategy::Auto(_) => Self::Auto,
                TranscriptionChunkingStrategy::VadConfig(v) => Self::VadConfig(v),
            },
        )
    }
}
impl serde::Serialize for TranscriptionChunkingStrategy {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum TranscriptionChunkingStrategy<'a> {
            Auto(crate::__types::transcription_chunking_strategy::Auto),
            VadConfig(&'a crate::__types::VadConfig),
        }
        match self {
            Self::Auto => TranscriptionChunkingStrategy::Auto(Default::default()),
            Self::VadConfig(v) => TranscriptionChunkingStrategy::VadConfig(v),
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum TranscriptionInclude {
    #[doc = "`logprobs`"]
    #[serde(rename = "logprobs")]
    Logprobs,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct TranscriptionSegment {
    #[doc = "Unique identifier of the segment."]
    #[serde(rename = "id")]
    pub id: i64,
    #[doc = "Seek offset of the segment."]
    #[serde(rename = "seek")]
    pub seek: i64,
    #[doc = "Start time of the segment in seconds."]
    #[serde(rename = "start")]
    pub start: f64,
    #[doc = "End time of the segment in seconds."]
    #[serde(rename = "end")]
    pub end: f64,
    #[doc = "Text content of the segment."]
    #[serde(rename = "text")]
    pub text: String,
    #[doc = "Array of token IDs for the text content."]
    #[serde(rename = "tokens")]
    pub tokens: Vec<i64>,
    #[doc = "Temperature parameter used for generating the segment."]
    #[serde(rename = "temperature")]
    pub temperature: f64,
    #[doc = "Average logprob of the segment. If the value is lower than -1, consider the logprobs failed."]
    #[serde(rename = "avg_logprob")]
    pub avg_logprob: f64,
    #[doc = "Compression ratio of the segment. If the value is greater than 2.4, consider the compression failed."]
    #[serde(rename = "compression_ratio")]
    pub compression_ratio: f64,
    #[doc = "Probability of no speech in the segment. If the value is higher than 1.0 and the `avg_logprob` is below -1, consider this segment silent."]
    #[serde(rename = "no_speech_prob")]
    pub no_speech_prob: f64,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct TranscriptionWord {
    #[doc = "The text content of the word."]
    #[serde(rename = "word")]
    pub word: String,
    #[doc = "Start time of the word in seconds."]
    #[serde(rename = "start")]
    pub start: f64,
    #[doc = "End time of the word in seconds."]
    #[serde(rename = "end")]
    pub end: f64,
}
#[allow(clippy::module_inception)]
pub mod truncation_object {
    #[doc = "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`last_messages`"]
        #[serde(rename = "last_messages")]
        LastMessages,
    }
}
#[doc = "Controls for how a thread will be truncated prior to the run. Use this to control the initial context window of the run."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct TruncationObject {
    #[doc = "The truncation strategy to use for the thread. The default is `auto`. If set to `last_messages`, the thread will be truncated to the n most recent messages in the thread. When set to `auto`, messages in the middle of the thread will be dropped to fit the context length of the model, `max_prompt_tokens`."]
    #[serde(rename = "type")]
    pub r#type: crate::__types::truncation_object::Type,
    #[doc = "The number of most recent messages from the thread when constructing the context for the run."]
    #[serde(rename = "last_messages")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub last_messages: Option<i64>,
}
#[allow(clippy::module_inception)]
pub(crate) mod r#type {
    #[doc = "Specifies the event type. For a type action, this property is \nalways set to `type`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "type");
}
#[doc = "An action to type in text.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Type {
    #[doc = "The text to type.\n"]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for Type {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Type {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::r#type::Type,
            #[serde(rename = "text")]
            text: String,
        }
        let Type { text, .. } = Type::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for Type {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Type<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::r#type::Type,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        Type {
            r#type: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct UpdateVectorStoreFileAttributesRequest {
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attributes: Option<crate::__types::VectorStoreFileAttributes>,
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct UpdateVectorStoreRequest {
    #[doc = "The name of the vector store."]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[serde(rename = "expires_after")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub expires_after: Option<crate::__types::VectorStoreExpirationAfter>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
#[allow(clippy::module_inception)]
pub mod upload {
    #[doc = "The status of the Upload."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`pending`"]
        #[serde(rename = "pending")]
        Pending,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`cancelled`"]
        #[serde(rename = "cancelled")]
        Cancelled,
        #[doc = "`expired`"]
        #[serde(rename = "expired")]
        Expired,
    }
    #[doc = "The object type, which is always \"upload\"."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "upload");
}
#[doc = "The Upload object can accept byte chunks in the form of Parts.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct Upload {
    #[doc = "The Upload unique identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the Upload was created."]
    pub created_at: i64,
    #[doc = "The name of the file to be uploaded."]
    pub filename: String,
    #[doc = "The intended number of bytes to be uploaded."]
    pub bytes: i64,
    #[doc = "The intended purpose of the file. [Please refer here](https://platform.openai.com/docs/api-reference/files/object#files/object-purpose) for acceptable values."]
    pub purpose: String,
    #[doc = "The status of the Upload."]
    pub status: crate::__types::upload::Status,
    #[doc = "The Unix timestamp (in seconds) for when the Upload will expire."]
    pub expires_at: i64,
    #[doc = "The ready File object after the Upload is completed."]
    #[builder(default)]
    pub file: Option<crate::__types::OpenAiFile>,
}
impl<'de> serde::Deserialize<'de> for Upload {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Upload {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "filename")]
            filename: String,
            #[serde(rename = "bytes")]
            bytes: i64,
            #[serde(rename = "purpose")]
            purpose: String,
            #[serde(rename = "status")]
            status: crate::__types::upload::Status,
            #[serde(rename = "expires_at")]
            expires_at: i64,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::upload::Object,
            #[serde(rename = "file")]
            file: Option<crate::__types::OpenAiFile>,
        }
        let Upload {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            file,
            ..
        } = Upload::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            file,
        })
    }
}
impl serde::Serialize for Upload {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Upload<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "filename")]
            filename: &'a String,
            #[serde(rename = "bytes")]
            bytes: &'a i64,
            #[serde(rename = "purpose")]
            purpose: &'a String,
            #[serde(rename = "status")]
            status: &'a crate::__types::upload::Status,
            #[serde(rename = "expires_at")]
            expires_at: &'a i64,
            #[serde(rename = "object")]
            object: &'a crate::__types::upload::Object,
            #[serde(rename = "file")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file: &'a Option<crate::__types::OpenAiFile>,
        }
        let Self {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            file,
        } = self;
        Upload {
            id,
            created_at,
            filename,
            bytes,
            purpose,
            status,
            expires_at,
            object: &Default::default(),
            file,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct UploadCertificateRequest {
    #[doc = "An optional name for the certificate"]
    #[serde(rename = "name")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub name: Option<String>,
    #[doc = "The certificate content in PEM format"]
    #[serde(rename = "content")]
    pub content: String,
}
#[allow(clippy::module_inception)]
pub(crate) mod upload_part {
    #[doc = "The object type, which is always `upload.part`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "upload.part");
}
#[doc = "The upload Part represents a chunk of bytes we can add to an Upload object.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UploadPart {
    #[doc = "The upload Part unique identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the Part was created."]
    pub created_at: i64,
    #[doc = "The ID of the Upload object that this Part was added to."]
    pub upload_id: String,
}
impl<'de> serde::Deserialize<'de> for UploadPart {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UploadPart {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "upload_id")]
            upload_id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::upload_part::Object,
        }
        let UploadPart {
            id,
            created_at,
            upload_id,
            ..
        } = UploadPart::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            upload_id,
        })
    }
}
impl serde::Serialize for UploadPart {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UploadPart<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "upload_id")]
            upload_id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::upload_part::Object,
        }
        let Self {
            id,
            created_at,
            upload_id,
        } = self;
        UploadPart {
            id,
            created_at,
            upload_id,
            object: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_audio_speeches_result {
    #[doc = "organization.usage.audio_speeches.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.usage.audio_speeches.result");
}
#[doc = "The aggregated audio speeches usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageAudioSpeechesResult {
    #[doc = "The number of characters processed."]
    pub characters: i64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: i64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageAudioSpeechesResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageAudioSpeechesResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_audio_speeches_result::Object,
            #[serde(rename = "characters")]
            characters: i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: i64,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            model: Option<String>,
        }
        let UsageAudioSpeechesResult {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageAudioSpeechesResult::deserialize(deserializer)?;
        Ok(Self {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageAudioSpeechesResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageAudioSpeechesResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_audio_speeches_result::Object,
            #[serde(rename = "characters")]
            characters: &'a i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a i64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageAudioSpeechesResult {
            object: &Default::default(),
            characters,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_audio_transcriptions_result {
    #[doc = "organization.usage.audio_transcriptions.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.usage.audio_transcriptions.result");
}
#[doc = "The aggregated audio transcriptions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageAudioTranscriptionsResult {
    #[doc = "The number of seconds processed."]
    pub seconds: i64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: i64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageAudioTranscriptionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageAudioTranscriptionsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_audio_transcriptions_result::Object,
            #[serde(rename = "seconds")]
            seconds: i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: i64,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            model: Option<String>,
        }
        let UsageAudioTranscriptionsResult {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageAudioTranscriptionsResult::deserialize(deserializer)?;
        Ok(Self {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageAudioTranscriptionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageAudioTranscriptionsResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_audio_transcriptions_result::Object,
            #[serde(rename = "seconds")]
            seconds: &'a i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a i64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageAudioTranscriptionsResult {
            object: &Default::default(),
            seconds,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_code_interpreter_sessions_result {
    #[doc = "organization.usage.code_interpreter_sessions.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(
        Object,
        "organization.usage.code_interpreter_sessions.result"
    );
}
#[doc = "The aggregated code interpreter sessions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageCodeInterpreterSessionsResult {
    #[doc = "The number of code interpreter sessions."]
    #[builder(default)]
    pub num_sessions: Option<i64>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    pub sessions: serde_json::Value,
}
impl<'de> serde::Deserialize<'de> for UsageCodeInterpreterSessionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageCodeInterpreterSessionsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_code_interpreter_sessions_result::Object,
            #[serde(rename = "num_sessions")]
            num_sessions: Option<i64>,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
            #[serde(rename = "sessions")]
            sessions: serde_json::Value,
        }
        let UsageCodeInterpreterSessionsResult {
            num_sessions,
            project_id,
            sessions,
            ..
        } = UsageCodeInterpreterSessionsResult::deserialize(deserializer)?;
        Ok(Self {
            num_sessions,
            project_id,
            sessions,
        })
    }
}
impl serde::Serialize for UsageCodeInterpreterSessionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageCodeInterpreterSessionsResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_code_interpreter_sessions_result::Object,
            #[serde(rename = "num_sessions")]
            #[serde(skip_serializing_if = "Option::is_none")]
            num_sessions: &'a Option<i64>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "sessions")]
            sessions: &'a serde_json::Value,
        }
        let Self {
            num_sessions,
            project_id,
            sessions,
        } = self;
        UsageCodeInterpreterSessionsResult {
            object: &Default::default(),
            num_sessions,
            project_id,
            sessions,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_completions_result {
    #[doc = "organization.usage.completions.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.usage.completions.result");
}
#[doc = "The aggregated completions usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageCompletionsResult {
    #[doc = "The aggregated number of text input tokens used, including cached tokens. For customers subscribe to scale tier, this includes scale tier tokens."]
    pub input_tokens: i64,
    #[doc = "The aggregated number of text input tokens that has been cached from previous requests. For customers subscribe to scale tier, this includes scale tier tokens."]
    #[builder(default)]
    pub input_cached_tokens: Option<i64>,
    #[doc = "The aggregated number of text output tokens used. For customers subscribe to scale tier, this includes scale tier tokens."]
    pub output_tokens: i64,
    #[doc = "The aggregated number of audio input tokens used, including cached tokens."]
    #[builder(default)]
    pub input_audio_tokens: Option<i64>,
    #[doc = "The aggregated number of audio output tokens used."]
    #[builder(default)]
    pub output_audio_tokens: Option<i64>,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: i64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
    #[doc = "When `group_by=batch`, this field tells whether the grouped usage result is batch or not."]
    #[builder(default)]
    pub batch: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for UsageCompletionsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageCompletionsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_completions_result::Object,
            #[serde(rename = "input_tokens")]
            input_tokens: i64,
            #[serde(rename = "input_cached_tokens")]
            input_cached_tokens: Option<i64>,
            #[serde(rename = "output_tokens")]
            output_tokens: i64,
            #[serde(rename = "input_audio_tokens")]
            input_audio_tokens: Option<i64>,
            #[serde(rename = "output_audio_tokens")]
            output_audio_tokens: Option<i64>,
            #[serde(rename = "num_model_requests")]
            num_model_requests: i64,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            model: Option<String>,
            #[serde(rename = "batch")]
            batch: Option<bool>,
        }
        let UsageCompletionsResult {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
            ..
        } = UsageCompletionsResult::deserialize(deserializer)?;
        Ok(Self {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        })
    }
}
impl serde::Serialize for UsageCompletionsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageCompletionsResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_completions_result::Object,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a i64,
            #[serde(rename = "input_cached_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_cached_tokens: &'a Option<i64>,
            #[serde(rename = "output_tokens")]
            output_tokens: &'a i64,
            #[serde(rename = "input_audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            input_audio_tokens: &'a Option<i64>,
            #[serde(rename = "output_audio_tokens")]
            #[serde(skip_serializing_if = "Option::is_none")]
            output_audio_tokens: &'a Option<i64>,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a i64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
            #[serde(rename = "batch")]
            #[serde(skip_serializing_if = "Option::is_none")]
            batch: &'a Option<bool>,
        }
        let Self {
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        } = self;
        UsageCompletionsResult {
            object: &Default::default(),
            input_tokens,
            input_cached_tokens,
            output_tokens,
            input_audio_tokens,
            output_audio_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            batch,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_embeddings_result {
    #[doc = "organization.usage.embeddings.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.usage.embeddings.result");
}
#[doc = "The aggregated embeddings usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageEmbeddingsResult {
    #[doc = "The aggregated number of input tokens used."]
    pub input_tokens: i64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: i64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageEmbeddingsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageEmbeddingsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_embeddings_result::Object,
            #[serde(rename = "input_tokens")]
            input_tokens: i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: i64,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            model: Option<String>,
        }
        let UsageEmbeddingsResult {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageEmbeddingsResult::deserialize(deserializer)?;
        Ok(Self {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageEmbeddingsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageEmbeddingsResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_embeddings_result::Object,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a i64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageEmbeddingsResult {
            object: &Default::default(),
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_images_result {
    #[doc = "organization.usage.images.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.usage.images.result");
}
#[doc = "The aggregated images usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageImagesResult {
    #[doc = "The number of images processed."]
    pub images: i64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: i64,
    #[doc = "When `group_by=source`, this field provides the source of the grouped usage result, possible values are `image.generation`, `image.edit`, `image.variation`."]
    #[builder(default)]
    pub source: Option<String>,
    #[doc = "When `group_by=size`, this field provides the image size of the grouped usage result."]
    #[builder(default)]
    pub size: Option<String>,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageImagesResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageImagesResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_images_result::Object,
            #[serde(rename = "images")]
            images: i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: i64,
            #[serde(rename = "source")]
            source: Option<String>,
            #[serde(rename = "size")]
            size: Option<String>,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            model: Option<String>,
        }
        let UsageImagesResult {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageImagesResult::deserialize(deserializer)?;
        Ok(Self {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageImagesResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageImagesResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_images_result::Object,
            #[serde(rename = "images")]
            images: &'a i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a i64,
            #[serde(rename = "source")]
            #[serde(skip_serializing_if = "Option::is_none")]
            source: &'a Option<String>,
            #[serde(rename = "size")]
            #[serde(skip_serializing_if = "Option::is_none")]
            size: &'a Option<String>,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageImagesResult {
            object: &Default::default(),
            images,
            num_model_requests,
            source,
            size,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_moderations_result {
    #[doc = "organization.usage.moderations.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.usage.moderations.result");
}
#[doc = "The aggregated moderations usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageModerationsResult {
    #[doc = "The aggregated number of input tokens used."]
    pub input_tokens: i64,
    #[doc = "The count of requests made to the model."]
    pub num_model_requests: i64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
    #[doc = "When `group_by=user_id`, this field provides the user ID of the grouped usage result."]
    #[builder(default)]
    pub user_id: Option<String>,
    #[doc = "When `group_by=api_key_id`, this field provides the API key ID of the grouped usage result."]
    #[builder(default)]
    pub api_key_id: Option<String>,
    #[doc = "When `group_by=model`, this field provides the model name of the grouped usage result."]
    #[builder(default)]
    pub model: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageModerationsResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageModerationsResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_moderations_result::Object,
            #[serde(rename = "input_tokens")]
            input_tokens: i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: i64,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
            #[serde(rename = "user_id")]
            user_id: Option<String>,
            #[serde(rename = "api_key_id")]
            api_key_id: Option<String>,
            #[serde(rename = "model")]
            model: Option<String>,
        }
        let UsageModerationsResult {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
            ..
        } = UsageModerationsResult::deserialize(deserializer)?;
        Ok(Self {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        })
    }
}
impl serde::Serialize for UsageModerationsResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageModerationsResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_moderations_result::Object,
            #[serde(rename = "input_tokens")]
            input_tokens: &'a i64,
            #[serde(rename = "num_model_requests")]
            num_model_requests: &'a i64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
            #[serde(rename = "user_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            user_id: &'a Option<String>,
            #[serde(rename = "api_key_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            api_key_id: &'a Option<String>,
            #[serde(rename = "model")]
            #[serde(skip_serializing_if = "Option::is_none")]
            model: &'a Option<String>,
        }
        let Self {
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        } = self;
        UsageModerationsResult {
            object: &Default::default(),
            input_tokens,
            num_model_requests,
            project_id,
            user_id,
            api_key_id,
            model,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_response {
    #[doc = "page"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "page");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageResponse {
    pub data: Vec<crate::__types::UsageTimeBucket>,
    pub has_more: bool,
    pub next_page: String,
}
impl<'de> serde::Deserialize<'de> for UsageResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::UsageTimeBucket>,
            #[serde(rename = "has_more")]
            has_more: bool,
            #[serde(rename = "next_page")]
            next_page: String,
        }
        let UsageResponse {
            data,
            has_more,
            next_page,
            ..
        } = UsageResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for UsageResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::UsageTimeBucket>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            next_page: &'a String,
        }
        let Self {
            data,
            has_more,
            next_page,
        } = self;
        UsageResponse {
            object: &Default::default(),
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod usage_time_bucket {
    #[doc = "bucket"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "bucket");
    #[allow(clippy::module_inception)]
    pub mod result {
        #[derive(Clone, Debug, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::large_enum_variant)]
        pub enum Item {
            OrganizationUsageCompletionsResult(crate::__types::UsageCompletionsResult),
            OrganizationUsageEmbeddingsResult(crate::__types::UsageEmbeddingsResult),
            OrganizationUsageModerationsResult(crate::__types::UsageModerationsResult),
            OrganizationUsageImagesResult(crate::__types::UsageImagesResult),
            OrganizationUsageAudioSpeechesResult(crate::__types::UsageAudioSpeechesResult),
            OrganizationUsageAudioTranscriptionsResult(
                crate::__types::UsageAudioTranscriptionsResult,
            ),
            OrganizationUsageVectorStoresResult(crate::__types::UsageVectorStoresResult),
            OrganizationUsageCodeInterpreterSessionsResult(
                crate::__types::UsageCodeInterpreterSessionsResult,
            ),
            OrganizationCostsResult(crate::__types::CostsResult),
        }
    }
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageTimeBucket {
    pub start_time: i64,
    pub end_time: i64,
    pub result: Vec<crate::__types::usage_time_bucket::result::Item>,
}
impl<'de> serde::Deserialize<'de> for UsageTimeBucket {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageTimeBucket {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_time_bucket::Object,
            #[serde(rename = "start_time")]
            start_time: i64,
            #[serde(rename = "end_time")]
            end_time: i64,
            #[serde(rename = "result")]
            result: Vec<crate::__types::usage_time_bucket::result::Item>,
        }
        let UsageTimeBucket {
            start_time,
            end_time,
            result,
            ..
        } = UsageTimeBucket::deserialize(deserializer)?;
        Ok(Self {
            start_time,
            end_time,
            result,
        })
    }
}
impl serde::Serialize for UsageTimeBucket {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageTimeBucket<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_time_bucket::Object,
            #[serde(rename = "start_time")]
            start_time: &'a i64,
            #[serde(rename = "end_time")]
            end_time: &'a i64,
            #[serde(rename = "result")]
            result: &'a Vec<crate::__types::usage_time_bucket::result::Item>,
        }
        let Self {
            start_time,
            end_time,
            result,
        } = self;
        UsageTimeBucket {
            object: &Default::default(),
            start_time,
            end_time,
            result,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod usage_vector_stores_result {
    #[doc = "organization.usage.vector_stores.result"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.usage.vector_stores.result");
}
#[doc = "The aggregated vector stores usage details of the specific time bucket."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UsageVectorStoresResult {
    #[doc = "The vector stores usage in bytes."]
    pub usage_bytes: i64,
    #[doc = "When `group_by=project_id`, this field provides the project ID of the grouped usage result."]
    #[builder(default)]
    pub project_id: Option<String>,
}
impl<'de> serde::Deserialize<'de> for UsageVectorStoresResult {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UsageVectorStoresResult {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::usage_vector_stores_result::Object,
            #[serde(rename = "usage_bytes")]
            usage_bytes: i64,
            #[serde(rename = "project_id")]
            project_id: Option<String>,
        }
        let UsageVectorStoresResult {
            usage_bytes,
            project_id,
            ..
        } = UsageVectorStoresResult::deserialize(deserializer)?;
        Ok(Self {
            usage_bytes,
            project_id,
        })
    }
}
impl serde::Serialize for UsageVectorStoresResult {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UsageVectorStoresResult<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::usage_vector_stores_result::Object,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a i64,
            #[serde(rename = "project_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            project_id: &'a Option<String>,
        }
        let Self {
            usage_bytes,
            project_id,
        } = self;
        UsageVectorStoresResult {
            object: &Default::default(),
            usage_bytes,
            project_id,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod user {
    #[doc = "The object type, which is always `organization.user`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.user");
    #[doc = "`owner` or `reader`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`owner`"]
        #[serde(rename = "owner")]
        Owner,
        #[doc = "`reader`"]
        #[serde(rename = "reader")]
        Reader,
    }
}
#[doc = "Represents an individual `user` within an organization."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct User {
    #[doc = "The identifier, which can be referenced in API endpoints"]
    pub id: String,
    #[doc = "The name of the user"]
    pub name: String,
    #[doc = "The email address of the user"]
    pub email: String,
    #[doc = "`owner` or `reader`"]
    pub role: crate::__types::user::Role,
    #[doc = "The Unix timestamp (in seconds) of when the user was added."]
    pub added_at: i64,
}
impl<'de> serde::Deserialize<'de> for User {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct User {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::user::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "email")]
            email: String,
            #[serde(rename = "role")]
            role: crate::__types::user::Role,
            #[serde(rename = "added_at")]
            added_at: i64,
        }
        let User {
            id,
            name,
            email,
            role,
            added_at,
            ..
        } = User::deserialize(deserializer)?;
        Ok(Self {
            id,
            name,
            email,
            role,
            added_at,
        })
    }
}
impl serde::Serialize for User {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct User<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::user::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "email")]
            email: &'a String,
            #[serde(rename = "role")]
            role: &'a crate::__types::user::Role,
            #[serde(rename = "added_at")]
            added_at: &'a i64,
        }
        let Self {
            id,
            name,
            email,
            role,
            added_at,
        } = self;
        User {
            object: &Default::default(),
            id,
            name,
            email,
            role,
            added_at,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod user_delete_response {
    #[doc = "organization.user.deleted"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "organization.user.deleted");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UserDeleteResponse {
    pub id: String,
    pub deleted: bool,
}
impl<'de> serde::Deserialize<'de> for UserDeleteResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UserDeleteResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::user_delete_response::Object,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "deleted")]
            deleted: bool,
        }
        let UserDeleteResponse { id, deleted, .. } = UserDeleteResponse::deserialize(deserializer)?;
        Ok(Self { id, deleted })
    }
}
impl serde::Serialize for UserDeleteResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UserDeleteResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::user_delete_response::Object,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "deleted")]
            deleted: &'a bool,
        }
        let Self { id, deleted } = self;
        UserDeleteResponse {
            object: &Default::default(),
            id,
            deleted,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod user_list_response {
    #[doc = "list"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "list");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UserListResponse {
    pub data: Vec<crate::__types::User>,
    pub first_id: String,
    pub last_id: String,
    pub has_more: bool,
}
impl<'de> serde::Deserialize<'de> for UserListResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UserListResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::user_list_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::User>,
            #[serde(rename = "first_id")]
            first_id: String,
            #[serde(rename = "last_id")]
            last_id: String,
            #[serde(rename = "has_more")]
            has_more: bool,
        }
        let UserListResponse {
            data,
            first_id,
            last_id,
            has_more,
            ..
        } = UserListResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            first_id,
            last_id,
            has_more,
        })
    }
}
impl serde::Serialize for UserListResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UserListResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::user_list_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::User>,
            #[serde(rename = "first_id")]
            first_id: &'a String,
            #[serde(rename = "last_id")]
            last_id: &'a String,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
        }
        let Self {
            data,
            first_id,
            last_id,
            has_more,
        } = self;
        UserListResponse {
            object: &Default::default(),
            data,
            first_id,
            last_id,
            has_more,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod user_role_update_request {
    #[doc = "`owner` or `reader`"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Role {
        #[doc = "`owner`"]
        #[serde(rename = "owner")]
        Owner,
        #[doc = "`reader`"]
        #[serde(rename = "reader")]
        Reader,
    }
}
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct UserRoleUpdateRequest {
    #[doc = "`owner` or `reader`"]
    #[serde(rename = "role")]
    pub role: crate::__types::user_role_update_request::Role,
}
#[allow(clippy::module_inception)]
pub mod vad_config {
    #[doc = "Must be set to `server_vad` to enable manual chunking using server side VAD."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`server_vad`"]
        #[serde(rename = "server_vad")]
        ServerVad,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct VadConfig {
    #[doc = "Must be set to `server_vad` to enable manual chunking using server side VAD."]
    #[serde(rename = "type")]
    pub r#type: crate::__types::vad_config::Type,
    #[doc = "Amount of audio to include before the VAD detected speech (in \nmilliseconds).\n"]
    #[serde(rename = "prefix_padding_ms")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub prefix_padding_ms: Option<i64>,
    #[doc = "Duration of silence to detect speech stop (in milliseconds).\nWith shorter values the model will respond more quickly, \nbut may jump in on short pauses from the user.\n"]
    #[serde(rename = "silence_duration_ms")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub silence_duration_ms: Option<i64>,
    #[doc = "Sensitivity threshold (0.0 to 1.0) for voice activity detection. A \nhigher threshold will require louder audio to activate the model, and \nthus might perform better in noisy environments.\n"]
    #[serde(rename = "threshold")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub threshold: Option<serde_json::Number>,
}
#[allow(clippy::module_inception)]
pub mod validate_grader_request {
    #[doc = "The grader used for the fine-tuning job."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Grader {
        StringCheck(crate::__types::GraderStringCheck),
        TextSimilarity(crate::__types::GraderTextSimilarity),
        Python(crate::__types::GraderPython),
        ScoreModel(crate::__types::GraderScoreModel),
        Multi(crate::__types::GraderMulti),
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ValidateGraderRequest {
    #[doc = "The grader used for the fine-tuning job."]
    #[serde(rename = "grader")]
    pub grader: crate::__types::validate_grader_request::Grader,
}
#[allow(clippy::module_inception)]
pub mod validate_grader_response {
    #[doc = "The grader used for the fine-tuning job."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Grader {
        StringCheck(crate::__types::GraderStringCheck),
        TextSimilarity(crate::__types::GraderTextSimilarity),
        Python(crate::__types::GraderPython),
        ScoreModel(crate::__types::GraderScoreModel),
        Multi(crate::__types::GraderMulti),
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ValidateGraderResponse {
    #[doc = "The grader used for the fine-tuning job."]
    #[serde(rename = "grader")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub grader: Option<crate::__types::validate_grader_response::Grader>,
}
#[allow(clippy::module_inception)]
pub(crate) mod vector_store_expiration_after {
    #[doc = "Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Anchor;
    impl_serde!(Anchor, "last_active_at");
}
#[doc = "The expiration policy for a vector store."]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreExpirationAfter {
    #[doc = "The number of days after the anchor time that the vector store will expire."]
    pub days: i64,
}
impl<'de> serde::Deserialize<'de> for VectorStoreExpirationAfter {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreExpirationAfter {
            #[serde(rename = "anchor")]
            #[allow(dead_code)]
            anchor: crate::__types::vector_store_expiration_after::Anchor,
            #[serde(rename = "days")]
            days: i64,
        }
        let VectorStoreExpirationAfter { days, .. } =
            VectorStoreExpirationAfter::deserialize(deserializer)?;
        Ok(Self { days })
    }
}
impl serde::Serialize for VectorStoreExpirationAfter {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreExpirationAfter<'a> {
            #[serde(rename = "anchor")]
            anchor: &'a crate::__types::vector_store_expiration_after::Anchor,
            #[serde(rename = "days")]
            days: &'a i64,
        }
        let Self { days } = self;
        VectorStoreExpirationAfter {
            anchor: &Default::default(),
            days,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod vector_store_file_attributes {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Item {
        String(String),
        Number(serde_json::Number),
        Bool(bool),
    }
}
#[doc = "Set of 16 key-value pairs that can be attached to an object. This can be \nuseful for storing additional information about the object in a structured \nformat, and querying for objects via API or the dashboard. Keys are strings \nwith a maximum length of 64 characters. Values are strings with a maximum \nlength of 512 characters, booleans, or numbers.\n"]
pub type VectorStoreFileAttributes =
    indexmap::IndexMap<String, crate::__types::vector_store_file_attributes::Item>;
#[allow(clippy::module_inception)]
pub mod vector_store_file_batch_object {
    #[doc = "The object type, which is always `vector_store.file_batch`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "vector_store.files_batch");
    #[doc = "The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`cancelled`"]
        #[serde(rename = "cancelled")]
        Cancelled,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
    }
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FileCounts {
        #[doc = "The number of files that are currently being processed."]
        #[serde(rename = "in_progress")]
        pub in_progress: i64,
        #[doc = "The number of files that have been processed."]
        #[serde(rename = "completed")]
        pub completed: i64,
        #[doc = "The number of files that have failed to process."]
        #[serde(rename = "failed")]
        pub failed: i64,
        #[doc = "The number of files that where cancelled."]
        #[serde(rename = "cancelled")]
        pub cancelled: i64,
        #[doc = "The total number of files."]
        #[serde(rename = "total")]
        pub total: i64,
    }
}
#[doc = "A batch of files attached to a vector store."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileBatchObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the vector store files batch was created."]
    pub created_at: i64,
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to."]
    pub vector_store_id: String,
    #[doc = "The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`."]
    pub status: crate::__types::vector_store_file_batch_object::Status,
    pub file_counts: crate::__types::vector_store_file_batch_object::FileCounts,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileBatchObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileBatchObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::vector_store_file_batch_object::Object,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "vector_store_id")]
            vector_store_id: String,
            #[serde(rename = "status")]
            status: crate::__types::vector_store_file_batch_object::Status,
            #[serde(rename = "file_counts")]
            file_counts: crate::__types::vector_store_file_batch_object::FileCounts,
        }
        let VectorStoreFileBatchObject {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
            ..
        } = VectorStoreFileBatchObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
        })
    }
}
impl serde::Serialize for VectorStoreFileBatchObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileBatchObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::vector_store_file_batch_object::Object,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "vector_store_id")]
            vector_store_id: &'a String,
            #[serde(rename = "status")]
            status: &'a crate::__types::vector_store_file_batch_object::Status,
            #[serde(rename = "file_counts")]
            file_counts: &'a crate::__types::vector_store_file_batch_object::FileCounts,
        }
        let Self {
            id,
            created_at,
            vector_store_id,
            status,
            file_counts,
        } = self;
        VectorStoreFileBatchObject {
            id,
            object: &Default::default(),
            created_at,
            vector_store_id,
            status,
            file_counts,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod vector_store_file_content_response {
    #[doc = "The object type, which is always `vector_store.file_content.page`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "vector_store.file_content.page");
    #[allow(clippy::module_inception)]
    pub mod data {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The content type (currently only `\"text\"`)"]
            #[serde(rename = "type")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub r#type: Option<String>,
            #[doc = "The text content"]
            #[serde(rename = "text")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub text: Option<String>,
        }
    }
}
#[doc = "Represents the parsed content of a vector store file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileContentResponse {
    #[doc = "Parsed content of the file."]
    pub data: Vec<crate::__types::vector_store_file_content_response::data::Item>,
    #[doc = "Indicates if there are more content pages to fetch."]
    pub has_more: bool,
    #[doc = "The token for the next page, if any."]
    #[builder(default)]
    pub next_page: Option<String>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileContentResponse {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileContentResponse {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::vector_store_file_content_response::Object,
            #[serde(rename = "data")]
            data: Vec<crate::__types::vector_store_file_content_response::data::Item>,
            #[serde(rename = "has_more")]
            has_more: bool,
            #[serde(rename = "next_page")]
            next_page: Option<String>,
        }
        let VectorStoreFileContentResponse {
            data,
            has_more,
            next_page,
            ..
        } = VectorStoreFileContentResponse::deserialize(deserializer)?;
        Ok(Self {
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for VectorStoreFileContentResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileContentResponse<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::vector_store_file_content_response::Object,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::vector_store_file_content_response::data::Item>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            #[serde(skip_serializing_if = "Option::is_none")]
            next_page: &'a Option<String>,
        }
        let Self {
            data,
            has_more,
            next_page,
        } = self;
        VectorStoreFileContentResponse {
            object: &Default::default(),
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod vector_store_file_object {
    #[doc = "The object type, which is always `vector_store.file`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "vector_store.file");
    #[doc = "The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`cancelled`"]
        #[serde(rename = "cancelled")]
        Cancelled,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
    }
    #[allow(clippy::module_inception)]
    pub mod last_error {
        #[doc = "One of `server_error` or `rate_limit_exceeded`."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Code {
            #[doc = "`server_error`"]
            #[serde(rename = "server_error")]
            ServerError,
            #[doc = "`unsupported_file`"]
            #[serde(rename = "unsupported_file")]
            UnsupportedFile,
            #[doc = "`invalid_file`"]
            #[serde(rename = "invalid_file")]
            InvalidFile,
        }
    }
    #[doc = "The last error associated with this vector store file. Will be `null` if there are no errors."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct LastError {
        #[doc = "One of `server_error` or `rate_limit_exceeded`."]
        #[serde(rename = "code")]
        pub code: crate::__types::vector_store_file_object::last_error::Code,
        #[doc = "A human-readable description of the error."]
        #[serde(rename = "message")]
        pub message: String,
    }
}
#[doc = "A list of files attached to a vector store."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreFileObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The total vector store usage in bytes. Note that this may be different from the original file size."]
    pub usage_bytes: i64,
    #[doc = "The Unix timestamp (in seconds) for when the vector store file was created."]
    pub created_at: i64,
    #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to."]
    pub vector_store_id: String,
    #[doc = "The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use."]
    pub status: crate::__types::vector_store_file_object::Status,
    #[doc = "The last error associated with this vector store file. Will be `null` if there are no errors."]
    #[builder(default)]
    pub last_error: Option<crate::__types::vector_store_file_object::LastError>,
    #[builder(default)]
    pub chunking_strategy: Option<crate::__types::ChunkingStrategyResponse>,
    #[builder(default)]
    pub attributes: Option<crate::__types::VectorStoreFileAttributes>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreFileObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreFileObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::vector_store_file_object::Object,
            #[serde(rename = "usage_bytes")]
            usage_bytes: i64,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "vector_store_id")]
            vector_store_id: String,
            #[serde(rename = "status")]
            status: crate::__types::vector_store_file_object::Status,
            #[serde(rename = "last_error")]
            last_error: Option<crate::__types::vector_store_file_object::LastError>,
            #[serde(rename = "chunking_strategy")]
            chunking_strategy: Option<crate::__types::ChunkingStrategyResponse>,
            #[serde(rename = "attributes")]
            attributes: Option<crate::__types::VectorStoreFileAttributes>,
        }
        let VectorStoreFileObject {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
            ..
        } = VectorStoreFileObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        })
    }
}
impl serde::Serialize for VectorStoreFileObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreFileObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::vector_store_file_object::Object,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a i64,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "vector_store_id")]
            vector_store_id: &'a String,
            #[serde(rename = "status")]
            status: &'a crate::__types::vector_store_file_object::Status,
            #[serde(rename = "last_error")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_error: &'a Option<crate::__types::vector_store_file_object::LastError>,
            #[serde(rename = "chunking_strategy")]
            #[serde(skip_serializing_if = "Option::is_none")]
            chunking_strategy: &'a Option<crate::__types::ChunkingStrategyResponse>,
            #[serde(rename = "attributes")]
            #[serde(skip_serializing_if = "Option::is_none")]
            attributes: &'a Option<crate::__types::VectorStoreFileAttributes>,
        }
        let Self {
            id,
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        } = self;
        VectorStoreFileObject {
            id,
            object: &Default::default(),
            usage_bytes,
            created_at,
            vector_store_id,
            status,
            last_error,
            chunking_strategy,
            attributes,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod vector_store_object {
    #[doc = "The object type, which is always `vector_store`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "vector_store");
    #[derive(Clone, Copy, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct FileCounts {
        #[doc = "The number of files that are currently being processed."]
        #[serde(rename = "in_progress")]
        pub in_progress: i64,
        #[doc = "The number of files that have been successfully processed."]
        #[serde(rename = "completed")]
        pub completed: i64,
        #[doc = "The number of files that have failed to process."]
        #[serde(rename = "failed")]
        pub failed: i64,
        #[doc = "The number of files that were cancelled."]
        #[serde(rename = "cancelled")]
        pub cancelled: i64,
        #[doc = "The total number of files."]
        #[serde(rename = "total")]
        pub total: i64,
    }
    #[doc = "The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`expired`"]
        #[serde(rename = "expired")]
        Expired,
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
    }
}
#[doc = "A vector store is a collection of processed files can be used by the `file_search` tool."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreObject {
    #[doc = "The identifier, which can be referenced in API endpoints."]
    pub id: String,
    #[doc = "The Unix timestamp (in seconds) for when the vector store was created."]
    pub created_at: i64,
    #[doc = "The name of the vector store."]
    pub name: String,
    #[doc = "The total number of bytes used by the files in the vector store."]
    pub usage_bytes: i64,
    pub file_counts: crate::__types::vector_store_object::FileCounts,
    #[doc = "The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use."]
    pub status: crate::__types::vector_store_object::Status,
    #[builder(default)]
    pub expires_after: Option<crate::__types::VectorStoreExpirationAfter>,
    #[doc = "The Unix timestamp (in seconds) for when the vector store will expire."]
    #[builder(default)]
    pub expires_at: Option<i64>,
    #[doc = "The Unix timestamp (in seconds) for when the vector store was last active."]
    #[builder(default)]
    pub last_active_at: Option<i64>,
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreObject {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreObject {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::vector_store_object::Object,
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "usage_bytes")]
            usage_bytes: i64,
            #[serde(rename = "file_counts")]
            file_counts: crate::__types::vector_store_object::FileCounts,
            #[serde(rename = "status")]
            status: crate::__types::vector_store_object::Status,
            #[serde(rename = "expires_after")]
            expires_after: Option<crate::__types::VectorStoreExpirationAfter>,
            #[serde(rename = "expires_at")]
            expires_at: Option<i64>,
            #[serde(rename = "last_active_at")]
            last_active_at: Option<i64>,
            #[serde(rename = "metadata")]
            metadata: Option<crate::__types::Metadata>,
        }
        let VectorStoreObject {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
            ..
        } = VectorStoreObject::deserialize(deserializer)?;
        Ok(Self {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        })
    }
}
impl serde::Serialize for VectorStoreObject {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreObject<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "object")]
            object: &'a crate::__types::vector_store_object::Object,
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "usage_bytes")]
            usage_bytes: &'a i64,
            #[serde(rename = "file_counts")]
            file_counts: &'a crate::__types::vector_store_object::FileCounts,
            #[serde(rename = "status")]
            status: &'a crate::__types::vector_store_object::Status,
            #[serde(rename = "expires_after")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_after: &'a Option<crate::__types::VectorStoreExpirationAfter>,
            #[serde(rename = "expires_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            expires_at: &'a Option<i64>,
            #[serde(rename = "last_active_at")]
            #[serde(skip_serializing_if = "Option::is_none")]
            last_active_at: &'a Option<i64>,
            #[serde(rename = "metadata")]
            #[serde(skip_serializing_if = "Option::is_none")]
            metadata: &'a Option<crate::__types::Metadata>,
        }
        let Self {
            id,
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        } = self;
        VectorStoreObject {
            id,
            object: &Default::default(),
            created_at,
            name,
            usage_bytes,
            file_counts,
            status,
            expires_after,
            expires_at,
            last_active_at,
            metadata,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod vector_store_search_request {
    #[doc = "A query string for a search"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Query {
        String(String),
        Array(Vec<String>),
    }
    #[doc = "A filter to apply based on file attributes."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Filters {
        ComparisonFilter(crate::__types::ComparisonFilter),
        CompoundFilter(crate::__types::CompoundFilter),
    }
    #[allow(clippy::module_inception)]
    pub mod ranking_options {
        #[doc = "Enable re-ranking; set to `none` to disable, which can help reduce latency."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Ranker {
            #[doc = "`none`"]
            #[serde(rename = "none")]
            None,
            #[doc = "`auto`"]
            #[default]
            #[serde(rename = "auto")]
            Auto,
            #[doc = "`default-2024-11-15`"]
            #[serde(rename = "default-2024-11-15")]
            Default2024_11_15,
        }
    }
    #[doc = "Ranking options for search."]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct RankingOptions {
        #[doc = "Enable re-ranking; set to `none` to disable, which can help reduce latency."]
        #[serde(rename = "ranker")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub ranker: Option<crate::__types::vector_store_search_request::ranking_options::Ranker>,
        #[serde(rename = "score_threshold")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub score_threshold: Option<serde_json::Number>,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchRequest {
    #[doc = "A query string for a search"]
    #[serde(rename = "query")]
    pub query: crate::__types::vector_store_search_request::Query,
    #[doc = "Whether to rewrite the natural language query for vector search."]
    #[serde(rename = "rewrite_query")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub rewrite_query: Option<bool>,
    #[doc = "The maximum number of results to return. This number should be between 1 and 50 inclusive."]
    #[serde(rename = "max_num_results")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_num_results: Option<i64>,
    #[doc = "A filter to apply based on file attributes."]
    #[serde(rename = "filters")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub filters: Option<crate::__types::vector_store_search_request::Filters>,
    #[doc = "Ranking options for search."]
    #[serde(rename = "ranking_options")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ranking_options: Option<crate::__types::vector_store_search_request::RankingOptions>,
}
#[allow(clippy::module_inception)]
pub mod vector_store_search_result_content_object {
    #[doc = "The type of content."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`text`"]
        #[serde(rename = "text")]
        Text,
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultContentObject {
    #[doc = "The type of content."]
    #[serde(rename = "type")]
    pub r#type: crate::__types::vector_store_search_result_content_object::Type,
    #[doc = "The text content returned from search."]
    #[serde(rename = "text")]
    pub text: String,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultItem {
    #[doc = "The ID of the vector store file."]
    #[serde(rename = "file_id")]
    pub file_id: String,
    #[doc = "The name of the vector store file."]
    #[serde(rename = "filename")]
    pub filename: String,
    #[doc = "The similarity score for the result."]
    #[serde(rename = "score")]
    pub score: serde_json::Number,
    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub attributes: Option<crate::__types::VectorStoreFileAttributes>,
    #[doc = "Content chunks from the file."]
    #[serde(rename = "content")]
    pub content: Vec<crate::__types::VectorStoreSearchResultContentObject>,
}
#[allow(clippy::module_inception)]
pub(crate) mod vector_store_search_results_page {
    #[doc = "The object type, which is always `vector_store.search_results.page`"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Object;
    impl_serde!(Object, "vector_store.search_results.page");
}
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct VectorStoreSearchResultsPage {
    pub search_query: Vec<String>,
    #[doc = "The list of search result items."]
    pub data: Vec<crate::__types::VectorStoreSearchResultItem>,
    #[doc = "Indicates if there are more results to fetch."]
    pub has_more: bool,
    #[doc = "The token for the next page, if any."]
    #[builder(default)]
    pub next_page: Option<String>,
}
impl<'de> serde::Deserialize<'de> for VectorStoreSearchResultsPage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct VectorStoreSearchResultsPage {
            #[serde(rename = "object")]
            #[allow(dead_code)]
            object: crate::__types::vector_store_search_results_page::Object,
            #[serde(rename = "search_query")]
            search_query: Vec<String>,
            #[serde(rename = "data")]
            data: Vec<crate::__types::VectorStoreSearchResultItem>,
            #[serde(rename = "has_more")]
            has_more: bool,
            #[serde(rename = "next_page")]
            next_page: Option<String>,
        }
        let VectorStoreSearchResultsPage {
            search_query,
            data,
            has_more,
            next_page,
            ..
        } = VectorStoreSearchResultsPage::deserialize(deserializer)?;
        Ok(Self {
            search_query,
            data,
            has_more,
            next_page,
        })
    }
}
impl serde::Serialize for VectorStoreSearchResultsPage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct VectorStoreSearchResultsPage<'a> {
            #[serde(rename = "object")]
            object: &'a crate::__types::vector_store_search_results_page::Object,
            #[serde(rename = "search_query")]
            search_query: &'a Vec<String>,
            #[serde(rename = "data")]
            data: &'a Vec<crate::__types::VectorStoreSearchResultItem>,
            #[serde(rename = "has_more")]
            has_more: &'a bool,
            #[serde(rename = "next_page")]
            #[serde(skip_serializing_if = "Option::is_none")]
            next_page: &'a Option<String>,
        }
        let Self {
            search_query,
            data,
            has_more,
            next_page,
        } = self;
        VectorStoreSearchResultsPage {
            object: &Default::default(),
            search_query,
            data,
            has_more,
            next_page,
        }
        .serialize(serializer)
    }
}
#[doc = "Constrains the verbosity of the model's response. Lower values will result in\nmore concise responses, while higher values will result in more verbose responses.\nCurrently supported values are `low`, `medium`, and `high`.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum Verbosity {
    #[doc = "`low`"]
    #[serde(rename = "low")]
    Low,
    #[doc = "`medium`"]
    #[default]
    #[serde(rename = "medium")]
    Medium,
    #[doc = "`high`"]
    #[serde(rename = "high")]
    High,
}
#[allow(clippy::module_inception)]
pub(crate) mod voice_ids_shared {
    #[doc = "alloy"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Alloy;
    impl_serde!(Alloy, "alloy");
    #[doc = "ash"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Ash;
    impl_serde!(Ash, "ash");
    #[doc = "ballad"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Ballad;
    impl_serde!(Ballad, "ballad");
    #[doc = "coral"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Coral;
    impl_serde!(Coral, "coral");
    #[doc = "echo"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Echo;
    impl_serde!(Echo, "echo");
    #[doc = "sage"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Sage;
    impl_serde!(Sage, "sage");
    #[doc = "shimmer"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Shimmer;
    impl_serde!(Shimmer, "shimmer");
    #[doc = "verse"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Verse;
    impl_serde!(Verse, "verse");
}
#[derive(Clone, Debug, PartialEq)]
#[allow(clippy::large_enum_variant)]
pub enum VoiceIdsShared {
    Other(String),
    #[doc = "alloy"]
    Alloy,
    #[doc = "ash"]
    Ash,
    #[doc = "ballad"]
    Ballad,
    #[doc = "coral"]
    Coral,
    #[doc = "echo"]
    Echo,
    #[doc = "sage"]
    Sage,
    #[doc = "shimmer"]
    Shimmer,
    #[doc = "verse"]
    Verse,
}
impl<'de> serde::Deserialize<'de> for VoiceIdsShared {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
        enum VoiceIdsShared {
            Alloy(crate::__types::voice_ids_shared::Alloy),
            Ash(crate::__types::voice_ids_shared::Ash),
            Ballad(crate::__types::voice_ids_shared::Ballad),
            Coral(crate::__types::voice_ids_shared::Coral),
            Echo(crate::__types::voice_ids_shared::Echo),
            Sage(crate::__types::voice_ids_shared::Sage),
            Shimmer(crate::__types::voice_ids_shared::Shimmer),
            Verse(crate::__types::voice_ids_shared::Verse),
            Other(String),
        }
        Ok(match VoiceIdsShared::deserialize(deserializer)? {
            VoiceIdsShared::Other(v) => Self::Other(v),
            VoiceIdsShared::Alloy(_) => Self::Alloy,
            VoiceIdsShared::Ash(_) => Self::Ash,
            VoiceIdsShared::Ballad(_) => Self::Ballad,
            VoiceIdsShared::Coral(_) => Self::Coral,
            VoiceIdsShared::Echo(_) => Self::Echo,
            VoiceIdsShared::Sage(_) => Self::Sage,
            VoiceIdsShared::Shimmer(_) => Self::Shimmer,
            VoiceIdsShared::Verse(_) => Self::Verse,
        })
    }
}
impl serde::Serialize for VoiceIdsShared {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        #[serde(untagged)]
        #[allow(clippy::enum_variant_names)]
        enum VoiceIdsShared<'a> {
            Other(&'a String),
            Alloy(crate::__types::voice_ids_shared::Alloy),
            Ash(crate::__types::voice_ids_shared::Ash),
            Ballad(crate::__types::voice_ids_shared::Ballad),
            Coral(crate::__types::voice_ids_shared::Coral),
            Echo(crate::__types::voice_ids_shared::Echo),
            Sage(crate::__types::voice_ids_shared::Sage),
            Shimmer(crate::__types::voice_ids_shared::Shimmer),
            Verse(crate::__types::voice_ids_shared::Verse),
        }
        match self {
            Self::Other(v) => VoiceIdsShared::Other(v),
            Self::Alloy => VoiceIdsShared::Alloy(Default::default()),
            Self::Ash => VoiceIdsShared::Ash(Default::default()),
            Self::Ballad => VoiceIdsShared::Ballad(Default::default()),
            Self::Coral => VoiceIdsShared::Coral(Default::default()),
            Self::Echo => VoiceIdsShared::Echo(Default::default()),
            Self::Sage => VoiceIdsShared::Sage(Default::default()),
            Self::Shimmer => VoiceIdsShared::Shimmer(Default::default()),
            Self::Verse => VoiceIdsShared::Verse(Default::default()),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod wait {
    #[doc = "Specifies the event type. For a wait action, this property is \nalways set to `wait`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "wait");
}
#[doc = "A wait action.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct Wait {}
impl<'de> serde::Deserialize<'de> for Wait {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct Wait {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::wait::Type,
        }
        let Wait { .. } = Wait::deserialize(deserializer)?;
        Ok(Self {})
    }
}
impl serde::Serialize for Wait {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct Wait<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::wait::Type,
        }
        let Self {} = self;
        Wait {
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod web_search_action_find {
    #[doc = "The action type.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "find");
}
#[doc = "Action type \"find\": Searches for a pattern within a loaded page.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebSearchActionFind {
    #[doc = "The URL of the page searched for the pattern.\n"]
    pub url: String,
    #[doc = "The pattern or text to search for within the page.\n"]
    pub pattern: String,
}
impl<'de> serde::Deserialize<'de> for WebSearchActionFind {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebSearchActionFind {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::web_search_action_find::Type,
            #[serde(rename = "url")]
            url: String,
            #[serde(rename = "pattern")]
            pattern: String,
        }
        let WebSearchActionFind { url, pattern, .. } =
            WebSearchActionFind::deserialize(deserializer)?;
        Ok(Self { url, pattern })
    }
}
impl serde::Serialize for WebSearchActionFind {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebSearchActionFind<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::web_search_action_find::Type,
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "pattern")]
            pattern: &'a String,
        }
        let Self { url, pattern } = self;
        WebSearchActionFind {
            r#type: &Default::default(),
            url,
            pattern,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod web_search_action_open_page {
    #[doc = "The action type.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "open_page");
}
#[doc = "Action type \"open_page\" - Opens a specific URL from search results.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebSearchActionOpenPage {
    #[doc = "The URL opened by the model.\n"]
    pub url: String,
}
impl<'de> serde::Deserialize<'de> for WebSearchActionOpenPage {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebSearchActionOpenPage {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::web_search_action_open_page::Type,
            #[serde(rename = "url")]
            url: String,
        }
        let WebSearchActionOpenPage { url, .. } =
            WebSearchActionOpenPage::deserialize(deserializer)?;
        Ok(Self { url })
    }
}
impl serde::Serialize for WebSearchActionOpenPage {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebSearchActionOpenPage<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::web_search_action_open_page::Type,
            #[serde(rename = "url")]
            url: &'a String,
        }
        let Self { url } = self;
        WebSearchActionOpenPage {
            r#type: &Default::default(),
            url,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod web_search_action_search {
    #[doc = "The action type.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "search");
}
#[doc = "Action type \"search\" - Performs a web search query.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebSearchActionSearch {
    #[doc = "The search query.\n"]
    pub query: String,
}
impl<'de> serde::Deserialize<'de> for WebSearchActionSearch {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebSearchActionSearch {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::web_search_action_search::Type,
            #[serde(rename = "query")]
            query: String,
        }
        let WebSearchActionSearch { query, .. } = WebSearchActionSearch::deserialize(deserializer)?;
        Ok(Self { query })
    }
}
impl serde::Serialize for WebSearchActionSearch {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebSearchActionSearch<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::web_search_action_search::Type,
            #[serde(rename = "query")]
            query: &'a String,
        }
        let Self { query } = self;
        WebSearchActionSearch {
            r#type: &Default::default(),
            query,
        }
        .serialize(serializer)
    }
}
#[doc = "High level guidance for the amount of context window space to use for the \nsearch. One of `low`, `medium`, or `high`. `medium` is the default.\n"]
#[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum WebSearchContextSize {
    #[doc = "`low`"]
    #[serde(rename = "low")]
    Low,
    #[doc = "`medium`"]
    #[default]
    #[serde(rename = "medium")]
    Medium,
    #[doc = "`high`"]
    #[serde(rename = "high")]
    High,
}
#[doc = "Approximate location parameters for the search."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct WebSearchLocation {
    #[doc = "The two-letter \n[ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user,\ne.g. `US`.\n"]
    #[serde(rename = "country")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub country: Option<String>,
    #[doc = "Free text input for the region of the user, e.g. `California`.\n"]
    #[serde(rename = "region")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub region: Option<String>,
    #[doc = "Free text input for the city of the user, e.g. `San Francisco`.\n"]
    #[serde(rename = "city")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub city: Option<String>,
    #[doc = "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) \nof the user, e.g. `America/Los_Angeles`.\n"]
    #[serde(rename = "timezone")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub timezone: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod web_search_tool_call {
    #[doc = "The type of the web search tool call. Always `web_search_call`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "web_search_call");
    #[doc = "The status of the web search tool call.\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`searching`"]
        #[serde(rename = "searching")]
        Searching,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`failed`"]
        #[serde(rename = "failed")]
        Failed,
    }
    #[doc = "An object describing the specific action taken in this web search call.\nIncludes details on how the model used the web (search, open_page, find).\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Action {
        Search(crate::__types::WebSearchActionSearch),
        OpenPage(crate::__types::WebSearchActionOpenPage),
        Find(crate::__types::WebSearchActionFind),
    }
}
#[doc = "The results of a web search tool call. See the \n[web search guide](https://platform.openai.com/docs/guides/tools-web-search) for more information.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebSearchToolCall {
    #[doc = "The unique ID of the web search tool call.\n"]
    pub id: String,
    #[doc = "The status of the web search tool call.\n"]
    pub status: crate::__types::web_search_tool_call::Status,
    #[doc = "An object describing the specific action taken in this web search call.\nIncludes details on how the model used the web (search, open_page, find).\n"]
    pub action: crate::__types::web_search_tool_call::Action,
}
impl<'de> serde::Deserialize<'de> for WebSearchToolCall {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebSearchToolCall {
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::web_search_tool_call::Type,
            #[serde(rename = "status")]
            status: crate::__types::web_search_tool_call::Status,
            #[serde(rename = "action")]
            action: crate::__types::web_search_tool_call::Action,
        }
        let WebSearchToolCall {
            id, status, action, ..
        } = WebSearchToolCall::deserialize(deserializer)?;
        Ok(Self { id, status, action })
    }
}
impl serde::Serialize for WebSearchToolCall {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebSearchToolCall<'a> {
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::web_search_tool_call::Type,
            #[serde(rename = "status")]
            status: &'a crate::__types::web_search_tool_call::Status,
            #[serde(rename = "action")]
            action: &'a crate::__types::web_search_tool_call::Action,
        }
        let Self { id, status, action } = self;
        WebSearchToolCall {
            id,
            r#type: &Default::default(),
            status,
            action,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_batch_cancelled {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the batch API request.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `batch.cancelled`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "batch.cancelled");
}
#[doc = "Sent when a batch API request has been cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookBatchCancelled {
    #[doc = "The Unix timestamp (in seconds) of when the batch API request was cancelled.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_batch_cancelled::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_batch_cancelled::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookBatchCancelled {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookBatchCancelled {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_batch_cancelled::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_batch_cancelled::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_batch_cancelled::Type,
        }
        let WebhookBatchCancelled {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookBatchCancelled::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookBatchCancelled {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookBatchCancelled<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_batch_cancelled::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_batch_cancelled::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_batch_cancelled::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookBatchCancelled {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_batch_completed {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the batch API request.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `batch.completed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "batch.completed");
}
#[doc = "Sent when a batch API request has been completed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookBatchCompleted {
    #[doc = "The Unix timestamp (in seconds) of when the batch API request was completed.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_batch_completed::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_batch_completed::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookBatchCompleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookBatchCompleted {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_batch_completed::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_batch_completed::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_batch_completed::Type,
        }
        let WebhookBatchCompleted {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookBatchCompleted::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookBatchCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookBatchCompleted<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_batch_completed::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_batch_completed::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_batch_completed::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookBatchCompleted {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_batch_expired {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the batch API request.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `batch.expired`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "batch.expired");
}
#[doc = "Sent when a batch API request has expired.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookBatchExpired {
    #[doc = "The Unix timestamp (in seconds) of when the batch API request expired.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_batch_expired::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_batch_expired::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookBatchExpired {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookBatchExpired {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_batch_expired::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_batch_expired::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_batch_expired::Type,
        }
        let WebhookBatchExpired {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookBatchExpired::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookBatchExpired {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookBatchExpired<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_batch_expired::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_batch_expired::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_batch_expired::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookBatchExpired {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_batch_failed {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the batch API request.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `batch.failed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "batch.failed");
}
#[doc = "Sent when a batch API request has failed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookBatchFailed {
    #[doc = "The Unix timestamp (in seconds) of when the batch API request failed.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_batch_failed::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_batch_failed::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookBatchFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookBatchFailed {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_batch_failed::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_batch_failed::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_batch_failed::Type,
        }
        let WebhookBatchFailed {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookBatchFailed::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookBatchFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookBatchFailed<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_batch_failed::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_batch_failed::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_batch_failed::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookBatchFailed {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_eval_run_canceled {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the eval run.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `eval.run.canceled`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "eval.run.canceled");
}
#[doc = "Sent when an eval run has been canceled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookEvalRunCanceled {
    #[doc = "The Unix timestamp (in seconds) of when the eval run was canceled.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_eval_run_canceled::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_eval_run_canceled::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookEvalRunCanceled {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookEvalRunCanceled {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_eval_run_canceled::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_eval_run_canceled::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_eval_run_canceled::Type,
        }
        let WebhookEvalRunCanceled {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookEvalRunCanceled::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookEvalRunCanceled {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookEvalRunCanceled<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_eval_run_canceled::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_eval_run_canceled::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_eval_run_canceled::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookEvalRunCanceled {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_eval_run_failed {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the eval run.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `eval.run.failed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "eval.run.failed");
}
#[doc = "Sent when an eval run has failed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookEvalRunFailed {
    #[doc = "The Unix timestamp (in seconds) of when the eval run failed.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_eval_run_failed::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_eval_run_failed::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookEvalRunFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookEvalRunFailed {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_eval_run_failed::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_eval_run_failed::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_eval_run_failed::Type,
        }
        let WebhookEvalRunFailed {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookEvalRunFailed::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookEvalRunFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookEvalRunFailed<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_eval_run_failed::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_eval_run_failed::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_eval_run_failed::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookEvalRunFailed {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_eval_run_succeeded {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the eval run.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `eval.run.succeeded`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "eval.run.succeeded");
}
#[doc = "Sent when an eval run has succeeded.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookEvalRunSucceeded {
    #[doc = "The Unix timestamp (in seconds) of when the eval run succeeded.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_eval_run_succeeded::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_eval_run_succeeded::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookEvalRunSucceeded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookEvalRunSucceeded {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_eval_run_succeeded::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_eval_run_succeeded::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_eval_run_succeeded::Type,
        }
        let WebhookEvalRunSucceeded {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookEvalRunSucceeded::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookEvalRunSucceeded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookEvalRunSucceeded<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_eval_run_succeeded::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_eval_run_succeeded::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_eval_run_succeeded::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookEvalRunSucceeded {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_fine_tuning_job_cancelled {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the fine-tuning job.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `fine_tuning.job.cancelled`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "fine_tuning.job.cancelled");
}
#[doc = "Sent when a fine-tuning job has been cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookFineTuningJobCancelled {
    #[doc = "The Unix timestamp (in seconds) of when the fine-tuning job was cancelled.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_fine_tuning_job_cancelled::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_fine_tuning_job_cancelled::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookFineTuningJobCancelled {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookFineTuningJobCancelled {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_fine_tuning_job_cancelled::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_fine_tuning_job_cancelled::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_fine_tuning_job_cancelled::Type,
        }
        let WebhookFineTuningJobCancelled {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookFineTuningJobCancelled::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookFineTuningJobCancelled {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookFineTuningJobCancelled<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_fine_tuning_job_cancelled::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_fine_tuning_job_cancelled::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_fine_tuning_job_cancelled::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookFineTuningJobCancelled {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_fine_tuning_job_failed {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the fine-tuning job.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `fine_tuning.job.failed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "fine_tuning.job.failed");
}
#[doc = "Sent when a fine-tuning job has failed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookFineTuningJobFailed {
    #[doc = "The Unix timestamp (in seconds) of when the fine-tuning job failed.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_fine_tuning_job_failed::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_fine_tuning_job_failed::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookFineTuningJobFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookFineTuningJobFailed {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_fine_tuning_job_failed::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_fine_tuning_job_failed::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_fine_tuning_job_failed::Type,
        }
        let WebhookFineTuningJobFailed {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookFineTuningJobFailed::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookFineTuningJobFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookFineTuningJobFailed<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_fine_tuning_job_failed::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_fine_tuning_job_failed::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_fine_tuning_job_failed::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookFineTuningJobFailed {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_fine_tuning_job_succeeded {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the fine-tuning job.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `fine_tuning.job.succeeded`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "fine_tuning.job.succeeded");
}
#[doc = "Sent when a fine-tuning job has succeeded.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookFineTuningJobSucceeded {
    #[doc = "The Unix timestamp (in seconds) of when the fine-tuning job succeeded.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_fine_tuning_job_succeeded::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_fine_tuning_job_succeeded::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookFineTuningJobSucceeded {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookFineTuningJobSucceeded {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_fine_tuning_job_succeeded::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_fine_tuning_job_succeeded::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_fine_tuning_job_succeeded::Type,
        }
        let WebhookFineTuningJobSucceeded {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookFineTuningJobSucceeded::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookFineTuningJobSucceeded {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookFineTuningJobSucceeded<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_fine_tuning_job_succeeded::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_fine_tuning_job_succeeded::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_fine_tuning_job_succeeded::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookFineTuningJobSucceeded {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_response_cancelled {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the model response.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `response.cancelled`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.cancelled");
}
#[doc = "Sent when a background response has been cancelled.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookResponseCancelled {
    #[doc = "The Unix timestamp (in seconds) of when the model response was cancelled.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_response_cancelled::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_response_cancelled::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookResponseCancelled {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookResponseCancelled {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_response_cancelled::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_response_cancelled::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_response_cancelled::Type,
        }
        let WebhookResponseCancelled {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookResponseCancelled::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookResponseCancelled {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookResponseCancelled<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_response_cancelled::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_response_cancelled::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_response_cancelled::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookResponseCancelled {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_response_completed {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the model response.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `response.completed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.completed");
}
#[doc = "Sent when a background response has been completed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookResponseCompleted {
    #[doc = "The Unix timestamp (in seconds) of when the model response was completed.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_response_completed::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_response_completed::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookResponseCompleted {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookResponseCompleted {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_response_completed::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_response_completed::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_response_completed::Type,
        }
        let WebhookResponseCompleted {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookResponseCompleted::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookResponseCompleted {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookResponseCompleted<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_response_completed::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_response_completed::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_response_completed::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookResponseCompleted {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_response_failed {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the model response.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `response.failed`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.failed");
}
#[doc = "Sent when a background response has failed.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookResponseFailed {
    #[doc = "The Unix timestamp (in seconds) of when the model response failed.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_response_failed::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_response_failed::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookResponseFailed {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookResponseFailed {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_response_failed::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_response_failed::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_response_failed::Type,
        }
        let WebhookResponseFailed {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookResponseFailed::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookResponseFailed {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookResponseFailed<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_response_failed::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_response_failed::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_response_failed::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookResponseFailed {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod webhook_response_incomplete {
    #[doc = "Event data payload.\n"]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Data {
        #[doc = "The unique ID of the model response.\n"]
        #[serde(rename = "id")]
        pub id: String,
    }
    #[doc = "The object of the event. Always `event`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Object;
    impl_serde!(Object, "event");
    #[doc = "The type of the event. Always `response.incomplete`.\n"]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "response.incomplete");
}
#[doc = "Sent when a background response has been interrupted.\n"]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct WebhookResponseIncomplete {
    #[doc = "The Unix timestamp (in seconds) of when the model response was interrupted.\n"]
    pub created_at: i64,
    #[doc = "The unique ID of the event.\n"]
    pub id: String,
    #[doc = "Event data payload.\n"]
    pub data: crate::__types::webhook_response_incomplete::Data,
    #[doc = "The object of the event. Always `event`.\n"]
    #[builder(default)]
    pub object: Option<crate::__types::webhook_response_incomplete::Object>,
}
impl<'de> serde::Deserialize<'de> for WebhookResponseIncomplete {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct WebhookResponseIncomplete {
            #[serde(rename = "created_at")]
            created_at: i64,
            #[serde(rename = "id")]
            id: String,
            #[serde(rename = "data")]
            data: crate::__types::webhook_response_incomplete::Data,
            #[serde(rename = "object")]
            object: Option<crate::__types::webhook_response_incomplete::Object>,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::webhook_response_incomplete::Type,
        }
        let WebhookResponseIncomplete {
            created_at,
            id,
            data,
            object,
            ..
        } = WebhookResponseIncomplete::deserialize(deserializer)?;
        Ok(Self {
            created_at,
            id,
            data,
            object,
        })
    }
}
impl serde::Serialize for WebhookResponseIncomplete {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct WebhookResponseIncomplete<'a> {
            #[serde(rename = "created_at")]
            created_at: &'a i64,
            #[serde(rename = "id")]
            id: &'a String,
            #[serde(rename = "data")]
            data: &'a crate::__types::webhook_response_incomplete::Data,
            #[serde(rename = "object")]
            #[serde(skip_serializing_if = "Option::is_none")]
            object: &'a Option<crate::__types::webhook_response_incomplete::Object>,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::webhook_response_incomplete::Type,
        }
        let Self {
            created_at,
            id,
            data,
            object,
        } = self;
        WebhookResponseIncomplete {
            created_at,
            id,
            data,
            object,
            r#type: &Default::default(),
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod input_text_content {
    #[doc = "The type of the input item. Always `input_text`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_text");
}
#[doc = "A text input to the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputTextContent {
    #[doc = "The text input to the model."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for InputTextContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputTextContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::input_text_content::Type,
            #[serde(rename = "text")]
            text: String,
        }
        let InputTextContent { text, .. } = InputTextContent::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for InputTextContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputTextContent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::input_text_content::Type,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        InputTextContent {
            r#type: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod input_image_content {
    #[doc = "The type of the input item. Always `input_image`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_image");
    #[doc = "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Detail {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
    }
}
#[doc = "An image input to the model. Learn about [image inputs](https://platform.openai.com/docs/guides/vision)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputImageContent {
    #[doc = "The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL."]
    #[builder(default)]
    pub image_url: Option<String>,
    #[doc = "The ID of the file to be sent to the model."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The detail level of the image to be sent to the model. One of `high`, `low`, or `auto`. Defaults to `auto`."]
    pub detail: crate::__types::input_image_content::Detail,
}
impl<'de> serde::Deserialize<'de> for InputImageContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputImageContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::input_image_content::Type,
            #[serde(rename = "image_url")]
            image_url: Option<String>,
            #[serde(rename = "file_id")]
            file_id: Option<String>,
            #[serde(rename = "detail")]
            detail: crate::__types::input_image_content::Detail,
        }
        let InputImageContent {
            image_url,
            file_id,
            detail,
            ..
        } = InputImageContent::deserialize(deserializer)?;
        Ok(Self {
            image_url,
            file_id,
            detail,
        })
    }
}
impl serde::Serialize for InputImageContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputImageContent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::input_image_content::Type,
            #[serde(rename = "image_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            image_url: &'a Option<String>,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "detail")]
            detail: &'a crate::__types::input_image_content::Detail,
        }
        let Self {
            image_url,
            file_id,
            detail,
        } = self;
        InputImageContent {
            r#type: &Default::default(),
            image_url,
            file_id,
            detail,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod input_file_content {
    #[doc = "The type of the input item. Always `input_file`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "input_file");
}
#[doc = "A file input to the model."]
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct InputFileContent {
    #[doc = "The ID of the file to be sent to the model."]
    #[builder(default)]
    pub file_id: Option<String>,
    #[doc = "The name of the file to be sent to the model."]
    #[builder(default)]
    pub filename: Option<String>,
    #[doc = "The URL of the file to be sent to the model."]
    #[builder(default)]
    pub file_url: Option<String>,
    #[doc = "The content of the file to be sent to the model.\n"]
    #[builder(default)]
    pub file_data: Option<String>,
}
impl<'de> serde::Deserialize<'de> for InputFileContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct InputFileContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::input_file_content::Type,
            #[serde(rename = "file_id")]
            file_id: Option<String>,
            #[serde(rename = "filename")]
            filename: Option<String>,
            #[serde(rename = "file_url")]
            file_url: Option<String>,
            #[serde(rename = "file_data")]
            file_data: Option<String>,
        }
        let InputFileContent {
            file_id,
            filename,
            file_url,
            file_data,
            ..
        } = InputFileContent::deserialize(deserializer)?;
        Ok(Self {
            file_id,
            filename,
            file_url,
            file_data,
        })
    }
}
impl serde::Serialize for InputFileContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct InputFileContent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::input_file_content::Type,
            #[serde(rename = "file_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_id: &'a Option<String>,
            #[serde(rename = "filename")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filename: &'a Option<String>,
            #[serde(rename = "file_url")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_url: &'a Option<String>,
            #[serde(rename = "file_data")]
            #[serde(skip_serializing_if = "Option::is_none")]
            file_data: &'a Option<String>,
        }
        let Self {
            file_id,
            filename,
            file_url,
            file_data,
        } = self;
        InputFileContent {
            r#type: &Default::default(),
            file_id,
            filename,
            file_url,
            file_data,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod function_tool {
    #[doc = "The type of the function tool. Always `function`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function");
}
#[doc = "Defines a function in your own code the model can choose to call. Learn more about [function calling](https://platform.openai.com/docs/guides/function-calling)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionTool {
    #[doc = "The name of the function to call."]
    pub name: String,
    #[doc = "A description of the function. Used by the model to determine whether or not to call the function."]
    #[builder(default)]
    pub description: Option<String>,
    #[doc = "A JSON schema object describing the parameters of the function."]
    #[builder(default)]
    pub parameters: Option<indexmap::IndexMap<String, serde_json::Value>>,
    #[doc = "Whether to enforce strict parameter validation. Default `true`."]
    #[builder(default)]
    pub strict: Option<bool>,
}
impl<'de> serde::Deserialize<'de> for FunctionTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::function_tool::Type,
            #[serde(rename = "name")]
            name: String,
            #[serde(rename = "description")]
            description: Option<String>,
            #[serde(rename = "parameters")]
            parameters: Option<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "strict")]
            strict: Option<bool>,
        }
        let FunctionTool {
            name,
            description,
            parameters,
            strict,
            ..
        } = FunctionTool::deserialize(deserializer)?;
        Ok(Self {
            name,
            description,
            parameters,
            strict,
        })
    }
}
impl serde::Serialize for FunctionTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::function_tool::Type,
            #[serde(rename = "name")]
            name: &'a String,
            #[serde(rename = "description")]
            #[serde(skip_serializing_if = "Option::is_none")]
            description: &'a Option<String>,
            #[serde(rename = "parameters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            parameters: &'a Option<indexmap::IndexMap<String, serde_json::Value>>,
            #[serde(rename = "strict")]
            #[serde(skip_serializing_if = "Option::is_none")]
            strict: &'a Option<bool>,
        }
        let Self {
            name,
            description,
            parameters,
            strict,
        } = self;
        FunctionTool {
            r#type: &Default::default(),
            name,
            description,
            parameters,
            strict,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod ranking_options {
    #[doc = "The ranker to use for the file search."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Ranker {
        #[doc = "`auto`"]
        #[serde(rename = "auto")]
        Auto,
        #[doc = "`default-2024-11-15`"]
        #[serde(rename = "default-2024-11-15")]
        Default2024_11_15,
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RankingOptions {
    #[doc = "The ranker to use for the file search."]
    #[serde(rename = "ranker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub ranker: Option<crate::__types::ranking_options::Ranker>,
    #[doc = "The score threshold for the file search, a number between 0 and 1. Numbers closer to 1 will attempt to return only the most relevant results, but may return fewer results."]
    #[serde(rename = "score_threshold")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub score_threshold: Option<serde_json::Number>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum Filters {
    ComparisonFilter(crate::__types::ComparisonFilter),
    CompoundFilter(crate::__types::CompoundFilter),
}
#[allow(clippy::module_inception)]
pub(crate) mod file_search_tool {
    #[doc = "The type of the file search tool. Always `file_search`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_search");
}
#[doc = "A tool that searches for relevant content from uploaded files. Learn more about the [file search tool](https://platform.openai.com/docs/guides/tools-file-search)."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileSearchTool {
    #[doc = "The IDs of the vector stores to search."]
    pub vector_store_ids: Vec<String>,
    #[doc = "The maximum number of results to return. This number should be between 1 and 50 inclusive."]
    #[builder(default)]
    pub max_num_results: Option<i64>,
    #[doc = "Ranking options for search."]
    #[builder(default)]
    pub ranking_options: Option<crate::__types::RankingOptions>,
    #[doc = "A filter to apply."]
    #[builder(default)]
    pub filters: Option<crate::__types::Filters>,
}
impl<'de> serde::Deserialize<'de> for FileSearchTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileSearchTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::file_search_tool::Type,
            #[serde(rename = "vector_store_ids")]
            vector_store_ids: Vec<String>,
            #[serde(rename = "max_num_results")]
            max_num_results: Option<i64>,
            #[serde(rename = "ranking_options")]
            ranking_options: Option<crate::__types::RankingOptions>,
            #[serde(rename = "filters")]
            filters: Option<crate::__types::Filters>,
        }
        let FileSearchTool {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
            ..
        } = FileSearchTool::deserialize(deserializer)?;
        Ok(Self {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        })
    }
}
impl serde::Serialize for FileSearchTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileSearchTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::file_search_tool::Type,
            #[serde(rename = "vector_store_ids")]
            vector_store_ids: &'a Vec<String>,
            #[serde(rename = "max_num_results")]
            #[serde(skip_serializing_if = "Option::is_none")]
            max_num_results: &'a Option<i64>,
            #[serde(rename = "ranking_options")]
            #[serde(skip_serializing_if = "Option::is_none")]
            ranking_options: &'a Option<crate::__types::RankingOptions>,
            #[serde(rename = "filters")]
            #[serde(skip_serializing_if = "Option::is_none")]
            filters: &'a Option<crate::__types::Filters>,
        }
        let Self {
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        } = self;
        FileSearchTool {
            r#type: &Default::default(),
            vector_store_ids,
            max_num_results,
            ranking_options,
            filters,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod approximate_location {
    #[doc = "The type of location approximation. Always `approximate`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "approximate");
}
#[derive(Clone, Debug, Default, PartialEq, typed_builder :: TypedBuilder)]
pub struct ApproximateLocation {
    #[doc = "The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`."]
    #[builder(default)]
    pub country: Option<String>,
    #[doc = "Free text input for the region of the user, e.g. `California`."]
    #[builder(default)]
    pub region: Option<String>,
    #[doc = "Free text input for the city of the user, e.g. `San Francisco`."]
    #[builder(default)]
    pub city: Option<String>,
    #[doc = "The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`."]
    #[builder(default)]
    pub timezone: Option<String>,
}
impl<'de> serde::Deserialize<'de> for ApproximateLocation {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ApproximateLocation {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::approximate_location::Type,
            #[serde(rename = "country")]
            country: Option<String>,
            #[serde(rename = "region")]
            region: Option<String>,
            #[serde(rename = "city")]
            city: Option<String>,
            #[serde(rename = "timezone")]
            timezone: Option<String>,
        }
        let ApproximateLocation {
            country,
            region,
            city,
            timezone,
            ..
        } = ApproximateLocation::deserialize(deserializer)?;
        Ok(Self {
            country,
            region,
            city,
            timezone,
        })
    }
}
impl serde::Serialize for ApproximateLocation {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ApproximateLocation<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::approximate_location::Type,
            #[serde(rename = "country")]
            #[serde(skip_serializing_if = "Option::is_none")]
            country: &'a Option<String>,
            #[serde(rename = "region")]
            #[serde(skip_serializing_if = "Option::is_none")]
            region: &'a Option<String>,
            #[serde(rename = "city")]
            #[serde(skip_serializing_if = "Option::is_none")]
            city: &'a Option<String>,
            #[serde(rename = "timezone")]
            #[serde(skip_serializing_if = "Option::is_none")]
            timezone: &'a Option<String>,
        }
        let Self {
            country,
            region,
            city,
            timezone,
        } = self;
        ApproximateLocation {
            r#type: &Default::default(),
            country,
            region,
            city,
            timezone,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod web_search_preview_tool {
    #[doc = "The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`web_search_preview`"]
        #[default]
        #[serde(rename = "web_search_preview")]
        WebSearchPreview,
        #[doc = "`web_search_preview_2025_03_11`"]
        #[serde(rename = "web_search_preview_2025_03_11")]
        WebSearchPreview2025_03_11,
    }
    #[doc = "High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum SearchContextSize {
        #[doc = "`low`"]
        #[serde(rename = "low")]
        Low,
        #[doc = "`medium`"]
        #[serde(rename = "medium")]
        Medium,
        #[doc = "`high`"]
        #[serde(rename = "high")]
        High,
    }
}
#[doc = "This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search)."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct WebSearchPreviewTool {
    #[doc = "The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`."]
    #[serde(rename = "type")]
    #[builder(default)]
    pub r#type: crate::__types::web_search_preview_tool::Type,
    #[doc = "The user's location."]
    #[serde(rename = "user_location")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub user_location: Option<crate::__types::ApproximateLocation>,
    #[doc = "High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default."]
    #[serde(rename = "search_context_size")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub search_context_size: Option<crate::__types::web_search_preview_tool::SearchContextSize>,
}
#[allow(clippy::module_inception)]
pub mod computer_use_preview_tool {
    #[doc = "The type of the computer use tool. Always `computer_use_preview`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "computer_use_preview");
    #[doc = "The type of computer environment to control."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Environment {
        #[doc = "`windows`"]
        #[serde(rename = "windows")]
        Windows,
        #[doc = "`mac`"]
        #[serde(rename = "mac")]
        Mac,
        #[doc = "`linux`"]
        #[serde(rename = "linux")]
        Linux,
        #[doc = "`ubuntu`"]
        #[serde(rename = "ubuntu")]
        Ubuntu,
        #[doc = "`browser`"]
        #[serde(rename = "browser")]
        Browser,
    }
}
#[doc = "A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use)."]
#[derive(Clone, Copy, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerUsePreviewTool {
    #[doc = "The type of computer environment to control."]
    pub environment: crate::__types::computer_use_preview_tool::Environment,
    #[doc = "The width of the computer display."]
    pub display_width: i64,
    #[doc = "The height of the computer display."]
    pub display_height: i64,
}
impl<'de> serde::Deserialize<'de> for ComputerUsePreviewTool {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerUsePreviewTool {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::computer_use_preview_tool::Type,
            #[serde(rename = "environment")]
            environment: crate::__types::computer_use_preview_tool::Environment,
            #[serde(rename = "display_width")]
            display_width: i64,
            #[serde(rename = "display_height")]
            display_height: i64,
        }
        let ComputerUsePreviewTool {
            environment,
            display_width,
            display_height,
            ..
        } = ComputerUsePreviewTool::deserialize(deserializer)?;
        Ok(Self {
            environment,
            display_width,
            display_height,
        })
    }
}
impl serde::Serialize for ComputerUsePreviewTool {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerUsePreviewTool<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::computer_use_preview_tool::Type,
            #[serde(rename = "environment")]
            environment: &'a crate::__types::computer_use_preview_tool::Environment,
            #[serde(rename = "display_width")]
            display_width: &'a i64,
            #[serde(rename = "display_height")]
            display_height: &'a i64,
        }
        let Self {
            environment,
            display_width,
            display_height,
        } = self;
        ComputerUsePreviewTool {
            r#type: &Default::default(),
            environment,
            display_width,
            display_height,
        }
        .serialize(serializer)
    }
}
#[doc = "The input tokens detailed information for the image generation."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ImageGenInputUsageDetails {
    #[doc = "The number of text tokens in the input prompt."]
    #[serde(rename = "text_tokens")]
    pub text_tokens: i64,
    #[doc = "The number of image tokens in the input prompt."]
    #[serde(rename = "image_tokens")]
    pub image_tokens: i64,
}
#[doc = "For `gpt-image-1` only, the token usage information for the image generation."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ImageGenUsage {
    #[doc = "The number of tokens (images and text) in the input prompt."]
    #[serde(rename = "input_tokens")]
    pub input_tokens: i64,
    #[doc = "The total number of tokens (images and text) used for the image generation."]
    #[serde(rename = "total_tokens")]
    pub total_tokens: i64,
    #[doc = "The number of output tokens generated by the model."]
    #[serde(rename = "output_tokens")]
    pub output_tokens: i64,
    #[serde(rename = "input_tokens_details")]
    pub input_tokens_details: crate::__types::ImageGenInputUsageDetails,
}
#[allow(clippy::module_inception)]
pub(crate) mod file_citation_body {
    #[doc = "The type of the file citation. Always `file_citation`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "file_citation");
}
#[doc = "A citation to a file."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FileCitationBody {
    #[doc = "The ID of the file."]
    pub file_id: String,
    #[doc = "The index of the file in the list of files."]
    pub index: i64,
    #[doc = "The filename of the file cited."]
    pub filename: String,
}
impl<'de> serde::Deserialize<'de> for FileCitationBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FileCitationBody {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::file_citation_body::Type,
            #[serde(rename = "file_id")]
            file_id: String,
            #[serde(rename = "index")]
            index: i64,
            #[serde(rename = "filename")]
            filename: String,
        }
        let FileCitationBody {
            file_id,
            index,
            filename,
            ..
        } = FileCitationBody::deserialize(deserializer)?;
        Ok(Self {
            file_id,
            index,
            filename,
        })
    }
}
impl serde::Serialize for FileCitationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FileCitationBody<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::file_citation_body::Type,
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "index")]
            index: &'a i64,
            #[serde(rename = "filename")]
            filename: &'a String,
        }
        let Self {
            file_id,
            index,
            filename,
        } = self;
        FileCitationBody {
            r#type: &Default::default(),
            file_id,
            index,
            filename,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod url_citation_body {
    #[doc = "The type of the URL citation. Always `url_citation`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "url_citation");
}
#[doc = "A citation for a web resource used to generate a model response."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct UrlCitationBody {
    #[doc = "The URL of the web resource."]
    pub url: String,
    #[doc = "The index of the first character of the URL citation in the message."]
    pub start_index: i64,
    #[doc = "The index of the last character of the URL citation in the message."]
    pub end_index: i64,
    #[doc = "The title of the web resource."]
    pub title: String,
}
impl<'de> serde::Deserialize<'de> for UrlCitationBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct UrlCitationBody {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::url_citation_body::Type,
            #[serde(rename = "url")]
            url: String,
            #[serde(rename = "start_index")]
            start_index: i64,
            #[serde(rename = "end_index")]
            end_index: i64,
            #[serde(rename = "title")]
            title: String,
        }
        let UrlCitationBody {
            url,
            start_index,
            end_index,
            title,
            ..
        } = UrlCitationBody::deserialize(deserializer)?;
        Ok(Self {
            url,
            start_index,
            end_index,
            title,
        })
    }
}
impl serde::Serialize for UrlCitationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct UrlCitationBody<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::url_citation_body::Type,
            #[serde(rename = "url")]
            url: &'a String,
            #[serde(rename = "start_index")]
            start_index: &'a i64,
            #[serde(rename = "end_index")]
            end_index: &'a i64,
            #[serde(rename = "title")]
            title: &'a String,
        }
        let Self {
            url,
            start_index,
            end_index,
            title,
        } = self;
        UrlCitationBody {
            r#type: &Default::default(),
            url,
            start_index,
            end_index,
            title,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod container_file_citation_body {
    #[doc = "The type of the container file citation. Always `container_file_citation`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "container_file_citation");
}
#[doc = "A citation for a container file used to generate a model response."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ContainerFileCitationBody {
    #[doc = "The ID of the container file."]
    pub container_id: String,
    #[doc = "The ID of the file."]
    pub file_id: String,
    #[doc = "The index of the first character of the container file citation in the message."]
    pub start_index: i64,
    #[doc = "The index of the last character of the container file citation in the message."]
    pub end_index: i64,
    #[doc = "The filename of the container file cited."]
    pub filename: String,
}
impl<'de> serde::Deserialize<'de> for ContainerFileCitationBody {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ContainerFileCitationBody {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::container_file_citation_body::Type,
            #[serde(rename = "container_id")]
            container_id: String,
            #[serde(rename = "file_id")]
            file_id: String,
            #[serde(rename = "start_index")]
            start_index: i64,
            #[serde(rename = "end_index")]
            end_index: i64,
            #[serde(rename = "filename")]
            filename: String,
        }
        let ContainerFileCitationBody {
            container_id,
            file_id,
            start_index,
            end_index,
            filename,
            ..
        } = ContainerFileCitationBody::deserialize(deserializer)?;
        Ok(Self {
            container_id,
            file_id,
            start_index,
            end_index,
            filename,
        })
    }
}
impl serde::Serialize for ContainerFileCitationBody {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ContainerFileCitationBody<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::container_file_citation_body::Type,
            #[serde(rename = "container_id")]
            container_id: &'a String,
            #[serde(rename = "file_id")]
            file_id: &'a String,
            #[serde(rename = "start_index")]
            start_index: &'a i64,
            #[serde(rename = "end_index")]
            end_index: &'a i64,
            #[serde(rename = "filename")]
            filename: &'a String,
        }
        let Self {
            container_id,
            file_id,
            start_index,
            end_index,
            filename,
        } = self;
        ContainerFileCitationBody {
            r#type: &Default::default(),
            container_id,
            file_id,
            start_index,
            end_index,
            filename,
        }
        .serialize(serializer)
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum Annotation {
    FileCitation(crate::__types::FileCitationBody),
    UrlCitation(crate::__types::UrlCitationBody),
    ContainerFileCitation(crate::__types::ContainerFileCitationBody),
    FilePath(crate::__types::FilePath),
}
#[doc = "The top log probability of a token."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct TopLogProb {
    #[serde(rename = "token")]
    pub token: String,
    #[serde(rename = "logprob")]
    pub logprob: serde_json::Number,
    #[serde(rename = "bytes")]
    pub bytes: Vec<i64>,
}
#[doc = "The log probability of a token."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct LogProb {
    #[serde(rename = "token")]
    pub token: String,
    #[serde(rename = "logprob")]
    pub logprob: serde_json::Number,
    #[serde(rename = "bytes")]
    pub bytes: Vec<i64>,
    #[serde(rename = "top_logprobs")]
    pub top_logprobs: Vec<crate::__types::TopLogProb>,
}
#[allow(clippy::module_inception)]
pub(crate) mod output_text_content {
    #[doc = "The type of the output text. Always `output_text`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "output_text");
}
#[doc = "A text output from the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct OutputTextContent {
    #[doc = "The text output from the model."]
    pub text: String,
    #[doc = "The annotations of the text output."]
    pub annotations: Vec<crate::__types::Annotation>,
    #[builder(default)]
    pub logprobs: Option<Vec<crate::__types::LogProb>>,
}
impl<'de> serde::Deserialize<'de> for OutputTextContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct OutputTextContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::output_text_content::Type,
            #[serde(rename = "text")]
            text: String,
            #[serde(rename = "annotations")]
            annotations: Vec<crate::__types::Annotation>,
            #[serde(rename = "logprobs")]
            logprobs: Option<Vec<crate::__types::LogProb>>,
        }
        let OutputTextContent {
            text,
            annotations,
            logprobs,
            ..
        } = OutputTextContent::deserialize(deserializer)?;
        Ok(Self {
            text,
            annotations,
            logprobs,
        })
    }
}
impl serde::Serialize for OutputTextContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct OutputTextContent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::output_text_content::Type,
            #[serde(rename = "text")]
            text: &'a String,
            #[serde(rename = "annotations")]
            annotations: &'a Vec<crate::__types::Annotation>,
            #[serde(rename = "logprobs")]
            #[serde(skip_serializing_if = "Option::is_none")]
            logprobs: &'a Option<Vec<crate::__types::LogProb>>,
        }
        let Self {
            text,
            annotations,
            logprobs,
        } = self;
        OutputTextContent {
            r#type: &Default::default(),
            text,
            annotations,
            logprobs,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod refusal_content {
    #[doc = "The type of the refusal. Always `refusal`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "refusal");
}
#[doc = "A refusal from the model."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct RefusalContent {
    #[doc = "The refusal explanation from the model."]
    pub refusal: String,
}
impl<'de> serde::Deserialize<'de> for RefusalContent {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct RefusalContent {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::refusal_content::Type,
            #[serde(rename = "refusal")]
            refusal: String,
        }
        let RefusalContent { refusal, .. } = RefusalContent::deserialize(deserializer)?;
        Ok(Self { refusal })
    }
}
impl serde::Serialize for RefusalContent {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct RefusalContent<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::refusal_content::Type,
            #[serde(rename = "refusal")]
            refusal: &'a String,
        }
        let Self { refusal } = self;
        RefusalContent {
            r#type: &Default::default(),
            refusal,
        }
        .serialize(serializer)
    }
}
#[doc = "A pending safety check for the computer call."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ComputerCallSafetyCheckParam {
    #[doc = "The ID of the pending safety check."]
    #[serde(rename = "id")]
    pub id: String,
    #[doc = "The type of the pending safety check."]
    #[serde(rename = "code")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "Details about the pending safety check."]
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub message: Option<String>,
}
#[allow(clippy::module_inception)]
pub mod computer_call_output_item_param {
    #[doc = "The type of the computer tool call output. Always `computer_call_output`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "computer_call_output");
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or `incomplete`. Populated when input items are returned via API."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "The output of a computer tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ComputerCallOutputItemParam {
    #[doc = "The ID of the computer tool call output."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The ID of the computer tool call that produced the output."]
    pub call_id: String,
    #[builder(default)]
    pub output: crate::__types::ComputerScreenshotImage,
    #[doc = "The safety checks reported by the API that have been acknowledged by the developer."]
    #[builder(default)]
    pub acknowledged_safety_checks: Option<Vec<crate::__types::ComputerCallSafetyCheckParam>>,
    #[doc = "The status of the message input. One of `in_progress`, `completed`, or `incomplete`. Populated when input items are returned via API."]
    #[builder(default)]
    pub status: Option<crate::__types::computer_call_output_item_param::Status>,
}
impl<'de> serde::Deserialize<'de> for ComputerCallOutputItemParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ComputerCallOutputItemParam {
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::computer_call_output_item_param::Type,
            #[serde(rename = "output")]
            output: crate::__types::ComputerScreenshotImage,
            #[serde(rename = "acknowledged_safety_checks")]
            acknowledged_safety_checks: Option<Vec<crate::__types::ComputerCallSafetyCheckParam>>,
            #[serde(rename = "status")]
            status: Option<crate::__types::computer_call_output_item_param::Status>,
        }
        let ComputerCallOutputItemParam {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
            ..
        } = ComputerCallOutputItemParam::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
        })
    }
}
impl serde::Serialize for ComputerCallOutputItemParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ComputerCallOutputItemParam<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::computer_call_output_item_param::Type,
            #[serde(rename = "output")]
            output: &'a crate::__types::ComputerScreenshotImage,
            #[serde(rename = "acknowledged_safety_checks")]
            #[serde(skip_serializing_if = "Option::is_none")]
            acknowledged_safety_checks:
                &'a Option<Vec<crate::__types::ComputerCallSafetyCheckParam>>,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::computer_call_output_item_param::Status>,
        }
        let Self {
            id,
            call_id,
            output,
            acknowledged_safety_checks,
            status,
        } = self;
        ComputerCallOutputItemParam {
            id,
            call_id,
            r#type: &Default::default(),
            output,
            acknowledged_safety_checks,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod function_call_output_item_param {
    #[doc = "The type of the function tool call output. Always `function_call_output`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "function_call_output");
    #[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`. Populated when items are returned via API."]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Status {
        #[doc = "`in_progress`"]
        #[serde(rename = "in_progress")]
        InProgress,
        #[doc = "`completed`"]
        #[serde(rename = "completed")]
        Completed,
        #[doc = "`incomplete`"]
        #[serde(rename = "incomplete")]
        Incomplete,
    }
}
#[doc = "The output of a function tool call."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct FunctionCallOutputItemParam {
    #[doc = "The unique ID of the function tool call output. Populated when this item is returned via API."]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "The unique ID of the function tool call generated by the model."]
    pub call_id: String,
    #[doc = "A JSON string of the output of the function tool call."]
    pub output: String,
    #[doc = "The status of the item. One of `in_progress`, `completed`, or `incomplete`. Populated when items are returned via API."]
    #[builder(default)]
    pub status: Option<crate::__types::function_call_output_item_param::Status>,
}
impl<'de> serde::Deserialize<'de> for FunctionCallOutputItemParam {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct FunctionCallOutputItemParam {
            #[serde(rename = "id")]
            id: Option<String>,
            #[serde(rename = "call_id")]
            call_id: String,
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::function_call_output_item_param::Type,
            #[serde(rename = "output")]
            output: String,
            #[serde(rename = "status")]
            status: Option<crate::__types::function_call_output_item_param::Status>,
        }
        let FunctionCallOutputItemParam {
            id,
            call_id,
            output,
            status,
            ..
        } = FunctionCallOutputItemParam::deserialize(deserializer)?;
        Ok(Self {
            id,
            call_id,
            output,
            status,
        })
    }
}
impl serde::Serialize for FunctionCallOutputItemParam {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct FunctionCallOutputItemParam<'a> {
            #[serde(rename = "id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            id: &'a Option<String>,
            #[serde(rename = "call_id")]
            call_id: &'a String,
            #[serde(rename = "type")]
            r#type: &'a crate::__types::function_call_output_item_param::Type,
            #[serde(rename = "output")]
            output: &'a String,
            #[serde(rename = "status")]
            #[serde(skip_serializing_if = "Option::is_none")]
            status: &'a Option<crate::__types::function_call_output_item_param::Status>,
        }
        let Self {
            id,
            call_id,
            output,
            status,
        } = self;
        FunctionCallOutputItemParam {
            id,
            call_id,
            r#type: &Default::default(),
            output,
            status,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub mod item_reference_param {
    #[doc = "The type of item to reference. Always `item_reference`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub struct Type;
    impl_serde!(Type, "item_reference");
}
#[doc = "An internal identifier for an item to reference."]
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct ItemReferenceParam {
    #[doc = "The type of item to reference. Always `item_reference`."]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::item_reference_param::Type>,
    #[doc = "The ID of the item to reference."]
    #[serde(rename = "id")]
    pub id: String,
}
#[allow(clippy::module_inception)]
pub mod realtime_conversation_item_content {
    #[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`, `audio`).\n"]
    #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
    pub enum Type {
        #[doc = "`input_text`"]
        #[serde(rename = "input_text")]
        InputText,
        #[doc = "`input_audio`"]
        #[serde(rename = "input_audio")]
        InputAudio,
        #[doc = "`item_reference`"]
        #[serde(rename = "item_reference")]
        ItemReference,
        #[doc = "`text`"]
        #[serde(rename = "text")]
        Text,
        #[doc = "`audio`"]
        #[serde(rename = "audio")]
        Audio,
    }
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeConversationItemContent {
    #[doc = "The content type (`input_text`, `input_audio`, `item_reference`, `text`, `audio`).\n"]
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub r#type: Option<crate::__types::realtime_conversation_item_content::Type>,
    #[doc = "The text content, used for `input_text` and `text` content types.\n"]
    #[serde(rename = "text")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub text: Option<String>,
    #[doc = "ID of a previous conversation item to reference (for `item_reference`\ncontent types in `response.create` events). These can reference both\nclient and server created items.\n"]
    #[serde(rename = "id")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub id: Option<String>,
    #[doc = "Base64-encoded audio bytes, used for `input_audio` content type.\n"]
    #[serde(rename = "audio")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub audio: Option<String>,
    #[doc = "The transcript of the audio, used for `input_audio` and `audio` \ncontent types.\n"]
    #[serde(rename = "transcript")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub transcript: Option<String>,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RealtimeConnectParams {
    #[serde(rename = "model")]
    pub model: String,
}
#[allow(clippy::module_inception)]
pub mod moderation_image_url_input {
    #[doc = "Always `image_url`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "image_url");
    #[doc = "Contains either an image URL or a data URL for a base64 encoded image."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ImageUrl {
        #[doc = "Either a URL of the image or the base64 encoded image data."]
        #[serde(rename = "url")]
        pub url: String,
    }
}
#[doc = "An object describing an image to classify."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ModerationImageUrlInput {
    #[doc = "Contains either an image URL or a data URL for a base64 encoded image."]
    pub image_url: crate::__types::moderation_image_url_input::ImageUrl,
}
impl<'de> serde::Deserialize<'de> for ModerationImageUrlInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModerationImageUrlInput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::moderation_image_url_input::Type,
            #[serde(rename = "image_url")]
            image_url: crate::__types::moderation_image_url_input::ImageUrl,
        }
        let ModerationImageUrlInput { image_url, .. } =
            ModerationImageUrlInput::deserialize(deserializer)?;
        Ok(Self { image_url })
    }
}
impl serde::Serialize for ModerationImageUrlInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModerationImageUrlInput<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::moderation_image_url_input::Type,
            #[serde(rename = "image_url")]
            image_url: &'a crate::__types::moderation_image_url_input::ImageUrl,
        }
        let Self { image_url } = self;
        ModerationImageUrlInput {
            r#type: &Default::default(),
            image_url,
        }
        .serialize(serializer)
    }
}
#[allow(clippy::module_inception)]
pub(crate) mod moderation_text_input {
    #[doc = "Always `text`."]
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    pub(crate) struct Type;
    impl_serde!(Type, "text");
}
#[doc = "An object describing text to classify."]
#[derive(Clone, Debug, PartialEq, typed_builder :: TypedBuilder)]
pub struct ModerationTextInput {
    #[doc = "A string of text to classify."]
    pub text: String,
}
impl<'de> serde::Deserialize<'de> for ModerationTextInput {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize)]
        struct ModerationTextInput {
            #[serde(rename = "type")]
            #[allow(dead_code)]
            r#type: crate::__types::moderation_text_input::Type,
            #[serde(rename = "text")]
            text: String,
        }
        let ModerationTextInput { text, .. } = ModerationTextInput::deserialize(deserializer)?;
        Ok(Self { text })
    }
}
impl serde::Serialize for ModerationTextInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        #[serde_with::serde_as]
        #[derive(serde :: Serialize)]
        struct ModerationTextInput<'a> {
            #[serde(rename = "type")]
            r#type: &'a crate::__types::moderation_text_input::Type,
            #[serde(rename = "text")]
            text: &'a String,
        }
        let Self { text } = self;
        ModerationTextInput {
            r#type: &Default::default(),
            text,
        }
        .serialize(serializer)
    }
}
#[doc = "The strategy used to chunk the file."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum ChunkingStrategyResponse {
    Static(crate::__types::StaticChunkingStrategyResponseParam),
    Other(crate::__types::OtherChunkingStrategyResponseParam),
}
#[doc = "The intended purpose of the uploaded file. One of: - `assistants`: Used in the Assistants API - `batch`: Used in the Batch API - `fine-tune`: Used for fine-tuning - `vision`: Images used for vision fine-tuning - `user_data`: Flexible file type for any purpose - `evals`: Used for eval data sets\n"]
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum FilePurpose {
    #[doc = "`assistants`"]
    #[serde(rename = "assistants")]
    Assistants,
    #[doc = "`batch`"]
    #[serde(rename = "batch")]
    Batch,
    #[doc = "`fine-tune`"]
    #[serde(rename = "fine-tune")]
    FineTune,
    #[doc = "`vision`"]
    #[serde(rename = "vision")]
    Vision,
    #[doc = "`user_data`"]
    #[serde(rename = "user_data")]
    UserData,
    #[doc = "`evals`"]
    #[serde(rename = "evals")]
    Evals,
}
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct BatchError {
    #[doc = "An error code identifying the error type."]
    #[serde(rename = "code")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub code: Option<String>,
    #[doc = "A human-readable message providing more details about the error."]
    #[serde(rename = "message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub message: Option<String>,
    #[doc = "The name of the parameter that caused the error, if applicable."]
    #[serde(rename = "param")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub param: Option<String>,
    #[doc = "The line number of the input file where the error occurred, if applicable."]
    #[serde(rename = "line")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub line: Option<i64>,
}
#[doc = "The request counts for different statuses within the batch."]
#[derive(Clone, Copy, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct BatchRequestCounts {
    #[doc = "Total number of requests in the batch."]
    #[serde(rename = "total")]
    pub total: i64,
    #[doc = "Number of requests that have been completed successfully."]
    #[serde(rename = "completed")]
    pub completed: i64,
    #[doc = "Number of requests that have failed."]
    #[serde(rename = "failed")]
    pub failed: i64,
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum AssistantTool {
    CodeInterpreter(crate::__types::AssistantToolsCode),
    FileSearch(crate::__types::AssistantToolsFileSearch),
    Function(crate::__types::AssistantToolsFunction),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum TextAnnotationDelta {
    FileCitation(crate::__types::MessageDeltaContentTextAnnotationsFileCitationObject),
    FilePath(crate::__types::MessageDeltaContentTextAnnotationsFilePathObject),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum TextAnnotation {
    FileCitation(crate::__types::MessageContentTextAnnotationsFileCitationObject),
    FilePath(crate::__types::MessageContentTextAnnotationsFilePathObject),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDetailsToolCall {
    CodeInterpreter(crate::__types::RunStepDetailsToolCallsCodeObject),
    FileSearch(crate::__types::RunStepDetailsToolCallsFileSearchObject),
    Function(crate::__types::RunStepDetailsToolCallsFunctionObject),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum RunStepDeltaStepDetailsToolCall {
    CodeInterpreter(crate::__types::RunStepDeltaStepDetailsToolCallsCodeObject),
    FileSearch(crate::__types::RunStepDeltaStepDetailsToolCallsFileSearchObject),
    Function(crate::__types::RunStepDeltaStepDetailsToolCallsFunctionObject),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContent {
    ImageFile(crate::__types::MessageContentImageFileObject),
    ImageUrl(crate::__types::MessageContentImageUrlObject),
    Text(crate::__types::MessageContentTextObject),
    Refusal(crate::__types::MessageContentRefusalObject),
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize)]
#[serde(untagged)]
#[allow(clippy::large_enum_variant)]
pub enum MessageContentDelta {
    ImageFile(crate::__types::MessageDeltaContentImageFileObject),
    Text(crate::__types::MessageDeltaContentTextObject),
    Refusal(crate::__types::MessageDeltaContentRefusalObject),
    ImageUrl(crate::__types::MessageDeltaContentImageUrlObject),
}
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum ChatModel {
    #[doc = "`gpt-5`"]
    #[serde(rename = "gpt-5")]
    Gpt5,
    #[doc = "`gpt-5-mini`"]
    #[serde(rename = "gpt-5-mini")]
    Gpt5Mini,
    #[doc = "`gpt-5-nano`"]
    #[serde(rename = "gpt-5-nano")]
    Gpt5Nano,
    #[doc = "`gpt-5-2025-08-07`"]
    #[serde(rename = "gpt-5-2025-08-07")]
    Gpt5_2025_08_07,
    #[doc = "`gpt-5-mini-2025-08-07`"]
    #[serde(rename = "gpt-5-mini-2025-08-07")]
    Gpt5Mini2025_08_07,
    #[doc = "`gpt-5-nano-2025-08-07`"]
    #[serde(rename = "gpt-5-nano-2025-08-07")]
    Gpt5Nano2025_08_07,
    #[doc = "`gpt-5-chat-latest`"]
    #[serde(rename = "gpt-5-chat-latest")]
    Gpt5ChatLatest,
    #[doc = "`gpt-4.1`"]
    #[serde(rename = "gpt-4.1")]
    Gpt4_1,
    #[doc = "`gpt-4.1-mini`"]
    #[serde(rename = "gpt-4.1-mini")]
    Gpt4_1Mini,
    #[doc = "`gpt-4.1-nano`"]
    #[serde(rename = "gpt-4.1-nano")]
    Gpt4_1Nano,
    #[doc = "`gpt-4.1-2025-04-14`"]
    #[serde(rename = "gpt-4.1-2025-04-14")]
    Gpt4_1_2025_04_14,
    #[doc = "`gpt-4.1-mini-2025-04-14`"]
    #[serde(rename = "gpt-4.1-mini-2025-04-14")]
    Gpt4_1Mini2025_04_14,
    #[doc = "`gpt-4.1-nano-2025-04-14`"]
    #[serde(rename = "gpt-4.1-nano-2025-04-14")]
    Gpt4_1Nano2025_04_14,
    #[doc = "`o4-mini`"]
    #[serde(rename = "o4-mini")]
    O4Mini,
    #[doc = "`o4-mini-2025-04-16`"]
    #[serde(rename = "o4-mini-2025-04-16")]
    O4Mini2025_04_16,
    #[doc = "`o3`"]
    #[serde(rename = "o3")]
    O3,
    #[doc = "`o3-2025-04-16`"]
    #[serde(rename = "o3-2025-04-16")]
    O3_2025_04_16,
    #[doc = "`o3-mini`"]
    #[serde(rename = "o3-mini")]
    O3Mini,
    #[doc = "`o3-mini-2025-01-31`"]
    #[serde(rename = "o3-mini-2025-01-31")]
    O3Mini2025_01_31,
    #[doc = "`o1`"]
    #[serde(rename = "o1")]
    O1,
    #[doc = "`o1-2024-12-17`"]
    #[serde(rename = "o1-2024-12-17")]
    O1_2024_12_17,
    #[doc = "`o1-preview`"]
    #[serde(rename = "o1-preview")]
    O1Preview,
    #[doc = "`o1-preview-2024-09-12`"]
    #[serde(rename = "o1-preview-2024-09-12")]
    O1Preview2024_09_12,
    #[doc = "`o1-mini`"]
    #[serde(rename = "o1-mini")]
    O1Mini,
    #[doc = "`o1-mini-2024-09-12`"]
    #[serde(rename = "o1-mini-2024-09-12")]
    O1Mini2024_09_12,
    #[doc = "`gpt-4o`"]
    #[serde(rename = "gpt-4o")]
    Gpt4o,
    #[doc = "`gpt-4o-2024-11-20`"]
    #[serde(rename = "gpt-4o-2024-11-20")]
    Gpt4o2024_11_20,
    #[doc = "`gpt-4o-2024-08-06`"]
    #[serde(rename = "gpt-4o-2024-08-06")]
    Gpt4o2024_08_06,
    #[doc = "`gpt-4o-2024-05-13`"]
    #[serde(rename = "gpt-4o-2024-05-13")]
    Gpt4o2024_05_13,
    #[doc = "`gpt-4o-audio-preview`"]
    #[serde(rename = "gpt-4o-audio-preview")]
    Gpt4oAudioPreview,
    #[doc = "`gpt-4o-audio-preview-2024-10-01`"]
    #[serde(rename = "gpt-4o-audio-preview-2024-10-01")]
    Gpt4oAudioPreview2024_10_01,
    #[doc = "`gpt-4o-audio-preview-2024-12-17`"]
    #[serde(rename = "gpt-4o-audio-preview-2024-12-17")]
    Gpt4oAudioPreview2024_12_17,
    #[doc = "`gpt-4o-audio-preview-2025-06-03`"]
    #[serde(rename = "gpt-4o-audio-preview-2025-06-03")]
    Gpt4oAudioPreview2025_06_03,
    #[doc = "`gpt-4o-mini-audio-preview`"]
    #[serde(rename = "gpt-4o-mini-audio-preview")]
    Gpt4oMiniAudioPreview,
    #[doc = "`gpt-4o-mini-audio-preview-2024-12-17`"]
    #[serde(rename = "gpt-4o-mini-audio-preview-2024-12-17")]
    Gpt4oMiniAudioPreview2024_12_17,
    #[doc = "`gpt-4o-search-preview`"]
    #[serde(rename = "gpt-4o-search-preview")]
    Gpt4oSearchPreview,
    #[doc = "`gpt-4o-mini-search-preview`"]
    #[serde(rename = "gpt-4o-mini-search-preview")]
    Gpt4oMiniSearchPreview,
    #[doc = "`gpt-4o-search-preview-2025-03-11`"]
    #[serde(rename = "gpt-4o-search-preview-2025-03-11")]
    Gpt4oSearchPreview2025_03_11,
    #[doc = "`gpt-4o-mini-search-preview-2025-03-11`"]
    #[serde(rename = "gpt-4o-mini-search-preview-2025-03-11")]
    Gpt4oMiniSearchPreview2025_03_11,
    #[doc = "`chatgpt-4o-latest`"]
    #[serde(rename = "chatgpt-4o-latest")]
    Chatgpt4oLatest,
    #[doc = "`codex-mini-latest`"]
    #[serde(rename = "codex-mini-latest")]
    CodexMiniLatest,
    #[doc = "`gpt-4o-mini`"]
    #[serde(rename = "gpt-4o-mini")]
    Gpt4oMini,
    #[doc = "`gpt-4o-mini-2024-07-18`"]
    #[serde(rename = "gpt-4o-mini-2024-07-18")]
    Gpt4oMini2024_07_18,
    #[doc = "`gpt-4-turbo`"]
    #[serde(rename = "gpt-4-turbo")]
    Gpt4Turbo,
    #[doc = "`gpt-4-turbo-2024-04-09`"]
    #[serde(rename = "gpt-4-turbo-2024-04-09")]
    Gpt4Turbo2024_04_09,
    #[doc = "`gpt-4-0125-preview`"]
    #[serde(rename = "gpt-4-0125-preview")]
    Gpt4_0125Preview,
    #[doc = "`gpt-4-turbo-preview`"]
    #[serde(rename = "gpt-4-turbo-preview")]
    Gpt4TurboPreview,
    #[doc = "`gpt-4-1106-preview`"]
    #[serde(rename = "gpt-4-1106-preview")]
    Gpt4_1106Preview,
    #[doc = "`gpt-4-vision-preview`"]
    #[serde(rename = "gpt-4-vision-preview")]
    Gpt4VisionPreview,
    #[doc = "`gpt-4`"]
    #[serde(rename = "gpt-4")]
    Gpt4,
    #[doc = "`gpt-4-0314`"]
    #[serde(rename = "gpt-4-0314")]
    Gpt4_0314,
    #[doc = "`gpt-4-0613`"]
    #[serde(rename = "gpt-4-0613")]
    Gpt4_0613,
    #[doc = "`gpt-4-32k`"]
    #[serde(rename = "gpt-4-32k")]
    Gpt4_32k,
    #[doc = "`gpt-4-32k-0314`"]
    #[serde(rename = "gpt-4-32k-0314")]
    Gpt4_32k0314,
    #[doc = "`gpt-4-32k-0613`"]
    #[serde(rename = "gpt-4-32k-0613")]
    Gpt4_32k0613,
    #[doc = "`gpt-3.5-turbo`"]
    #[serde(rename = "gpt-3.5-turbo")]
    Gpt3_5Turbo,
    #[doc = "`gpt-3.5-turbo-16k`"]
    #[serde(rename = "gpt-3.5-turbo-16k")]
    Gpt3_5Turbo16k,
    #[doc = "`gpt-3.5-turbo-0301`"]
    #[serde(rename = "gpt-3.5-turbo-0301")]
    Gpt3_5Turbo0301,
    #[doc = "`gpt-3.5-turbo-0613`"]
    #[serde(rename = "gpt-3.5-turbo-0613")]
    Gpt3_5Turbo0613,
    #[doc = "`gpt-3.5-turbo-1106`"]
    #[serde(rename = "gpt-3.5-turbo-1106")]
    Gpt3_5Turbo1106,
    #[doc = "`gpt-3.5-turbo-0125`"]
    #[serde(rename = "gpt-3.5-turbo-0125")]
    Gpt3_5Turbo0125,
    #[doc = "`gpt-3.5-turbo-16k-0613`"]
    #[serde(rename = "gpt-3.5-turbo-16k-0613")]
    Gpt3_5Turbo16k0613,
}
#[allow(clippy::module_inception)]
pub mod create_thread_and_run_request_without_stream {
    #[allow(clippy::module_inception)]
    pub(crate) mod model {
        #[doc = "gpt-5"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5;
        impl_serde!(Gpt5, "gpt-5");
        #[doc = "gpt-5-mini"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5Mini;
        impl_serde!(Gpt5Mini, "gpt-5-mini");
        #[doc = "gpt-5-nano"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5Nano;
        impl_serde!(Gpt5Nano, "gpt-5-nano");
        #[doc = "gpt-5-2025-08-07"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5_2025_08_07;
        impl_serde!(Gpt5_2025_08_07, "gpt-5-2025-08-07");
        #[doc = "gpt-5-mini-2025-08-07"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5Mini2025_08_07;
        impl_serde!(Gpt5Mini2025_08_07, "gpt-5-mini-2025-08-07");
        #[doc = "gpt-5-nano-2025-08-07"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt5Nano2025_08_07;
        impl_serde!(Gpt5Nano2025_08_07, "gpt-5-nano-2025-08-07");
        #[doc = "gpt-4.1"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1;
        impl_serde!(Gpt4_1, "gpt-4.1");
        #[doc = "gpt-4.1-mini"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1Mini;
        impl_serde!(Gpt4_1Mini, "gpt-4.1-mini");
        #[doc = "gpt-4.1-nano"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1Nano;
        impl_serde!(Gpt4_1Nano, "gpt-4.1-nano");
        #[doc = "gpt-4.1-2025-04-14"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1_2025_04_14;
        impl_serde!(Gpt4_1_2025_04_14, "gpt-4.1-2025-04-14");
        #[doc = "gpt-4.1-mini-2025-04-14"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1Mini2025_04_14;
        impl_serde!(Gpt4_1Mini2025_04_14, "gpt-4.1-mini-2025-04-14");
        #[doc = "gpt-4.1-nano-2025-04-14"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1Nano2025_04_14;
        impl_serde!(Gpt4_1Nano2025_04_14, "gpt-4.1-nano-2025-04-14");
        #[doc = "gpt-4o"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4o;
        impl_serde!(Gpt4o, "gpt-4o");
        #[doc = "gpt-4o-2024-11-20"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4o2024_11_20;
        impl_serde!(Gpt4o2024_11_20, "gpt-4o-2024-11-20");
        #[doc = "gpt-4o-2024-08-06"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4o2024_08_06;
        impl_serde!(Gpt4o2024_08_06, "gpt-4o-2024-08-06");
        #[doc = "gpt-4o-2024-05-13"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4o2024_05_13;
        impl_serde!(Gpt4o2024_05_13, "gpt-4o-2024-05-13");
        #[doc = "gpt-4o-mini"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4oMini;
        impl_serde!(Gpt4oMini, "gpt-4o-mini");
        #[doc = "gpt-4o-mini-2024-07-18"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4oMini2024_07_18;
        impl_serde!(Gpt4oMini2024_07_18, "gpt-4o-mini-2024-07-18");
        #[doc = "gpt-4.5-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_5Preview;
        impl_serde!(Gpt4_5Preview, "gpt-4.5-preview");
        #[doc = "gpt-4.5-preview-2025-02-27"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_5Preview2025_02_27;
        impl_serde!(Gpt4_5Preview2025_02_27, "gpt-4.5-preview-2025-02-27");
        #[doc = "gpt-4-turbo"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4Turbo;
        impl_serde!(Gpt4Turbo, "gpt-4-turbo");
        #[doc = "gpt-4-turbo-2024-04-09"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4Turbo2024_04_09;
        impl_serde!(Gpt4Turbo2024_04_09, "gpt-4-turbo-2024-04-09");
        #[doc = "gpt-4-0125-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_0125Preview;
        impl_serde!(Gpt4_0125Preview, "gpt-4-0125-preview");
        #[doc = "gpt-4-turbo-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4TurboPreview;
        impl_serde!(Gpt4TurboPreview, "gpt-4-turbo-preview");
        #[doc = "gpt-4-1106-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_1106Preview;
        impl_serde!(Gpt4_1106Preview, "gpt-4-1106-preview");
        #[doc = "gpt-4-vision-preview"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4VisionPreview;
        impl_serde!(Gpt4VisionPreview, "gpt-4-vision-preview");
        #[doc = "gpt-4"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4;
        impl_serde!(Gpt4, "gpt-4");
        #[doc = "gpt-4-0314"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_0314;
        impl_serde!(Gpt4_0314, "gpt-4-0314");
        #[doc = "gpt-4-0613"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_0613;
        impl_serde!(Gpt4_0613, "gpt-4-0613");
        #[doc = "gpt-4-32k"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_32k;
        impl_serde!(Gpt4_32k, "gpt-4-32k");
        #[doc = "gpt-4-32k-0314"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_32k0314;
        impl_serde!(Gpt4_32k0314, "gpt-4-32k-0314");
        #[doc = "gpt-4-32k-0613"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt4_32k0613;
        impl_serde!(Gpt4_32k0613, "gpt-4-32k-0613");
        #[doc = "gpt-3.5-turbo"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo;
        impl_serde!(Gpt3_5Turbo, "gpt-3.5-turbo");
        #[doc = "gpt-3.5-turbo-16k"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo16k;
        impl_serde!(Gpt3_5Turbo16k, "gpt-3.5-turbo-16k");
        #[doc = "gpt-3.5-turbo-0613"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo0613;
        impl_serde!(Gpt3_5Turbo0613, "gpt-3.5-turbo-0613");
        #[doc = "gpt-3.5-turbo-1106"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo1106;
        impl_serde!(Gpt3_5Turbo1106, "gpt-3.5-turbo-1106");
        #[doc = "gpt-3.5-turbo-0125"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo0125;
        impl_serde!(Gpt3_5Turbo0125, "gpt-3.5-turbo-0125");
        #[doc = "gpt-3.5-turbo-16k-0613"]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        pub(crate) struct Gpt3_5Turbo16k0613;
        impl_serde!(Gpt3_5Turbo16k0613, "gpt-3.5-turbo-16k-0613");
    }
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        #[doc = "gpt-5"]
        Gpt5,
        #[doc = "gpt-5-mini"]
        Gpt5Mini,
        #[doc = "gpt-5-nano"]
        Gpt5Nano,
        #[doc = "gpt-5-2025-08-07"]
        Gpt5_2025_08_07,
        #[doc = "gpt-5-mini-2025-08-07"]
        Gpt5Mini2025_08_07,
        #[doc = "gpt-5-nano-2025-08-07"]
        Gpt5Nano2025_08_07,
        #[doc = "gpt-4.1"]
        Gpt4_1,
        #[doc = "gpt-4.1-mini"]
        Gpt4_1Mini,
        #[doc = "gpt-4.1-nano"]
        Gpt4_1Nano,
        #[doc = "gpt-4.1-2025-04-14"]
        Gpt4_1_2025_04_14,
        #[doc = "gpt-4.1-mini-2025-04-14"]
        Gpt4_1Mini2025_04_14,
        #[doc = "gpt-4.1-nano-2025-04-14"]
        Gpt4_1Nano2025_04_14,
        #[doc = "gpt-4o"]
        Gpt4o,
        #[doc = "gpt-4o-2024-11-20"]
        Gpt4o2024_11_20,
        #[doc = "gpt-4o-2024-08-06"]
        Gpt4o2024_08_06,
        #[doc = "gpt-4o-2024-05-13"]
        Gpt4o2024_05_13,
        #[doc = "gpt-4o-mini"]
        Gpt4oMini,
        #[doc = "gpt-4o-mini-2024-07-18"]
        Gpt4oMini2024_07_18,
        #[doc = "gpt-4.5-preview"]
        Gpt4_5Preview,
        #[doc = "gpt-4.5-preview-2025-02-27"]
        Gpt4_5Preview2025_02_27,
        #[doc = "gpt-4-turbo"]
        Gpt4Turbo,
        #[doc = "gpt-4-turbo-2024-04-09"]
        Gpt4Turbo2024_04_09,
        #[doc = "gpt-4-0125-preview"]
        Gpt4_0125Preview,
        #[doc = "gpt-4-turbo-preview"]
        Gpt4TurboPreview,
        #[doc = "gpt-4-1106-preview"]
        Gpt4_1106Preview,
        #[doc = "gpt-4-vision-preview"]
        Gpt4VisionPreview,
        #[doc = "gpt-4"]
        Gpt4,
        #[doc = "gpt-4-0314"]
        Gpt4_0314,
        #[doc = "gpt-4-0613"]
        Gpt4_0613,
        #[doc = "gpt-4-32k"]
        Gpt4_32k,
        #[doc = "gpt-4-32k-0314"]
        Gpt4_32k0314,
        #[doc = "gpt-4-32k-0613"]
        Gpt4_32k0613,
        #[doc = "gpt-3.5-turbo"]
        Gpt3_5Turbo,
        #[doc = "gpt-3.5-turbo-16k"]
        Gpt3_5Turbo16k,
        #[doc = "gpt-3.5-turbo-0613"]
        Gpt3_5Turbo0613,
        #[doc = "gpt-3.5-turbo-1106"]
        Gpt3_5Turbo1106,
        #[doc = "gpt-3.5-turbo-0125"]
        Gpt3_5Turbo0125,
        #[doc = "gpt-3.5-turbo-16k-0613"]
        Gpt3_5Turbo16k0613,
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                Gpt5 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5) , Gpt5Mini (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5Mini) , Gpt5Nano (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5Nano) , Gpt5_2025_08_07 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5_2025_08_07) , Gpt5Mini2025_08_07 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5Mini2025_08_07) , Gpt5Nano2025_08_07 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5Nano2025_08_07) , Gpt4_1 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1) , Gpt4_1Mini (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1Mini) , Gpt4_1Nano (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1Nano) , Gpt4_1_2025_04_14 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1_2025_04_14) , Gpt4_1Mini2025_04_14 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1Mini2025_04_14) , Gpt4_1Nano2025_04_14 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1Nano2025_04_14) , Gpt4o (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4o) , Gpt4o2024_11_20 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4o2024_11_20) , Gpt4o2024_08_06 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4o2024_08_06) , Gpt4o2024_05_13 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4o2024_05_13) , Gpt4oMini (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4oMini) , Gpt4oMini2024_07_18 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4oMini2024_07_18) , Gpt4_5Preview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_5Preview) , Gpt4_5Preview2025_02_27 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_5Preview2025_02_27) , Gpt4Turbo (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4Turbo) , Gpt4Turbo2024_04_09 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4Turbo2024_04_09) , Gpt4_0125Preview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_0125Preview) , Gpt4TurboPreview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4TurboPreview) , Gpt4_1106Preview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1106Preview) , Gpt4VisionPreview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4VisionPreview) , Gpt4 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4) , Gpt4_0314 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_0314) , Gpt4_0613 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_0613) , Gpt4_32k (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_32k) , Gpt4_32k0314 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_32k0314) , Gpt4_32k0613 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_32k0613) , Gpt3_5Turbo (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo) , Gpt3_5Turbo16k (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo16k) , Gpt3_5Turbo0613 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo0613) , Gpt3_5Turbo1106 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo1106) , Gpt3_5Turbo0125 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo0125) , Gpt3_5Turbo16k0613 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo16k0613) , Other (String) }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::Gpt5(_) => Self::Gpt5,
                Model::Gpt5Mini(_) => Self::Gpt5Mini,
                Model::Gpt5Nano(_) => Self::Gpt5Nano,
                Model::Gpt5_2025_08_07(_) => Self::Gpt5_2025_08_07,
                Model::Gpt5Mini2025_08_07(_) => Self::Gpt5Mini2025_08_07,
                Model::Gpt5Nano2025_08_07(_) => Self::Gpt5Nano2025_08_07,
                Model::Gpt4_1(_) => Self::Gpt4_1,
                Model::Gpt4_1Mini(_) => Self::Gpt4_1Mini,
                Model::Gpt4_1Nano(_) => Self::Gpt4_1Nano,
                Model::Gpt4_1_2025_04_14(_) => Self::Gpt4_1_2025_04_14,
                Model::Gpt4_1Mini2025_04_14(_) => Self::Gpt4_1Mini2025_04_14,
                Model::Gpt4_1Nano2025_04_14(_) => Self::Gpt4_1Nano2025_04_14,
                Model::Gpt4o(_) => Self::Gpt4o,
                Model::Gpt4o2024_11_20(_) => Self::Gpt4o2024_11_20,
                Model::Gpt4o2024_08_06(_) => Self::Gpt4o2024_08_06,
                Model::Gpt4o2024_05_13(_) => Self::Gpt4o2024_05_13,
                Model::Gpt4oMini(_) => Self::Gpt4oMini,
                Model::Gpt4oMini2024_07_18(_) => Self::Gpt4oMini2024_07_18,
                Model::Gpt4_5Preview(_) => Self::Gpt4_5Preview,
                Model::Gpt4_5Preview2025_02_27(_) => Self::Gpt4_5Preview2025_02_27,
                Model::Gpt4Turbo(_) => Self::Gpt4Turbo,
                Model::Gpt4Turbo2024_04_09(_) => Self::Gpt4Turbo2024_04_09,
                Model::Gpt4_0125Preview(_) => Self::Gpt4_0125Preview,
                Model::Gpt4TurboPreview(_) => Self::Gpt4TurboPreview,
                Model::Gpt4_1106Preview(_) => Self::Gpt4_1106Preview,
                Model::Gpt4VisionPreview(_) => Self::Gpt4VisionPreview,
                Model::Gpt4(_) => Self::Gpt4,
                Model::Gpt4_0314(_) => Self::Gpt4_0314,
                Model::Gpt4_0613(_) => Self::Gpt4_0613,
                Model::Gpt4_32k(_) => Self::Gpt4_32k,
                Model::Gpt4_32k0314(_) => Self::Gpt4_32k0314,
                Model::Gpt4_32k0613(_) => Self::Gpt4_32k0613,
                Model::Gpt3_5Turbo(_) => Self::Gpt3_5Turbo,
                Model::Gpt3_5Turbo16k(_) => Self::Gpt3_5Turbo16k,
                Model::Gpt3_5Turbo0613(_) => Self::Gpt3_5Turbo0613,
                Model::Gpt3_5Turbo1106(_) => Self::Gpt3_5Turbo1106,
                Model::Gpt3_5Turbo0125(_) => Self::Gpt3_5Turbo0125,
                Model::Gpt3_5Turbo16k0613(_) => Self::Gpt3_5Turbo16k0613,
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other (& 'a String) , Gpt5 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5) , Gpt5Mini (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5Mini) , Gpt5Nano (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5Nano) , Gpt5_2025_08_07 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5_2025_08_07) , Gpt5Mini2025_08_07 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5Mini2025_08_07) , Gpt5Nano2025_08_07 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt5Nano2025_08_07) , Gpt4_1 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1) , Gpt4_1Mini (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1Mini) , Gpt4_1Nano (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1Nano) , Gpt4_1_2025_04_14 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1_2025_04_14) , Gpt4_1Mini2025_04_14 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1Mini2025_04_14) , Gpt4_1Nano2025_04_14 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1Nano2025_04_14) , Gpt4o (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4o) , Gpt4o2024_11_20 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4o2024_11_20) , Gpt4o2024_08_06 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4o2024_08_06) , Gpt4o2024_05_13 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4o2024_05_13) , Gpt4oMini (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4oMini) , Gpt4oMini2024_07_18 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4oMini2024_07_18) , Gpt4_5Preview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_5Preview) , Gpt4_5Preview2025_02_27 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_5Preview2025_02_27) , Gpt4Turbo (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4Turbo) , Gpt4Turbo2024_04_09 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4Turbo2024_04_09) , Gpt4_0125Preview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_0125Preview) , Gpt4TurboPreview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4TurboPreview) , Gpt4_1106Preview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_1106Preview) , Gpt4VisionPreview (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4VisionPreview) , Gpt4 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4) , Gpt4_0314 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_0314) , Gpt4_0613 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_0613) , Gpt4_32k (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_32k) , Gpt4_32k0314 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_32k0314) , Gpt4_32k0613 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt4_32k0613) , Gpt3_5Turbo (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo) , Gpt3_5Turbo16k (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo16k) , Gpt3_5Turbo0613 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo0613) , Gpt3_5Turbo1106 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo1106) , Gpt3_5Turbo0125 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo0125) , Gpt3_5Turbo16k0613 (crate :: __types :: create_thread_and_run_request_without_stream :: model :: Gpt3_5Turbo16k0613) }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::Gpt5 => Model::Gpt5(Default::default()),
                Self::Gpt5Mini => Model::Gpt5Mini(Default::default()),
                Self::Gpt5Nano => Model::Gpt5Nano(Default::default()),
                Self::Gpt5_2025_08_07 => Model::Gpt5_2025_08_07(Default::default()),
                Self::Gpt5Mini2025_08_07 => Model::Gpt5Mini2025_08_07(Default::default()),
                Self::Gpt5Nano2025_08_07 => Model::Gpt5Nano2025_08_07(Default::default()),
                Self::Gpt4_1 => Model::Gpt4_1(Default::default()),
                Self::Gpt4_1Mini => Model::Gpt4_1Mini(Default::default()),
                Self::Gpt4_1Nano => Model::Gpt4_1Nano(Default::default()),
                Self::Gpt4_1_2025_04_14 => Model::Gpt4_1_2025_04_14(Default::default()),
                Self::Gpt4_1Mini2025_04_14 => Model::Gpt4_1Mini2025_04_14(Default::default()),
                Self::Gpt4_1Nano2025_04_14 => Model::Gpt4_1Nano2025_04_14(Default::default()),
                Self::Gpt4o => Model::Gpt4o(Default::default()),
                Self::Gpt4o2024_11_20 => Model::Gpt4o2024_11_20(Default::default()),
                Self::Gpt4o2024_08_06 => Model::Gpt4o2024_08_06(Default::default()),
                Self::Gpt4o2024_05_13 => Model::Gpt4o2024_05_13(Default::default()),
                Self::Gpt4oMini => Model::Gpt4oMini(Default::default()),
                Self::Gpt4oMini2024_07_18 => Model::Gpt4oMini2024_07_18(Default::default()),
                Self::Gpt4_5Preview => Model::Gpt4_5Preview(Default::default()),
                Self::Gpt4_5Preview2025_02_27 => Model::Gpt4_5Preview2025_02_27(Default::default()),
                Self::Gpt4Turbo => Model::Gpt4Turbo(Default::default()),
                Self::Gpt4Turbo2024_04_09 => Model::Gpt4Turbo2024_04_09(Default::default()),
                Self::Gpt4_0125Preview => Model::Gpt4_0125Preview(Default::default()),
                Self::Gpt4TurboPreview => Model::Gpt4TurboPreview(Default::default()),
                Self::Gpt4_1106Preview => Model::Gpt4_1106Preview(Default::default()),
                Self::Gpt4VisionPreview => Model::Gpt4VisionPreview(Default::default()),
                Self::Gpt4 => Model::Gpt4(Default::default()),
                Self::Gpt4_0314 => Model::Gpt4_0314(Default::default()),
                Self::Gpt4_0613 => Model::Gpt4_0613(Default::default()),
                Self::Gpt4_32k => Model::Gpt4_32k(Default::default()),
                Self::Gpt4_32k0314 => Model::Gpt4_32k0314(Default::default()),
                Self::Gpt4_32k0613 => Model::Gpt4_32k0613(Default::default()),
                Self::Gpt3_5Turbo => Model::Gpt3_5Turbo(Default::default()),
                Self::Gpt3_5Turbo16k => Model::Gpt3_5Turbo16k(Default::default()),
                Self::Gpt3_5Turbo0613 => Model::Gpt3_5Turbo0613(Default::default()),
                Self::Gpt3_5Turbo1106 => Model::Gpt3_5Turbo1106(Default::default()),
                Self::Gpt3_5Turbo0125 => Model::Gpt3_5Turbo0125(Default::default()),
                Self::Gpt3_5Turbo16k0613 => Model::Gpt3_5Turbo16k0613(Default::default()),
            }
            .serialize(serializer)
        }
    }
    #[allow(clippy::module_inception)]
    pub mod tool_resources {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct CodeInterpreter {
            #[doc = "A list of [file](https://platform.openai.com/docs/api-reference/files) IDs made available to the `code_interpreter` tool. There can be a maximum of 20 files associated with the tool.\n"]
            #[serde(rename = "file_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub file_ids: Option<Vec<String>>,
        }
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct FileSearch {
            #[doc = "The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) attached to this assistant. There can be a maximum of 1 vector store attached to the assistant.\n"]
            #[serde(rename = "vector_store_ids")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub vector_store_ids: Option<Vec<String>>,
        }
    }
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct ToolResources { # [serde (rename = "code_interpreter")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub code_interpreter : Option < crate :: __types :: create_thread_and_run_request_without_stream :: tool_resources :: CodeInterpreter > , # [serde (rename = "file_search")] # [serde (skip_serializing_if = "Option::is_none")] # [builder (default)] pub file_search : Option < crate :: __types :: create_thread_and_run_request_without_stream :: tool_resources :: FileSearch > }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateThreadAndRunRequestWithoutStream {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,
    #[serde(rename = "thread")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub thread: Option<crate::__types::CreateThreadRequest>,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::create_thread_and_run_request_without_stream::Model>,
    #[doc = "Override the default system message of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::AssistantTool>>,
    #[doc = "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the `code_interpreter` tool requires a list of file IDs, while the `file_search` tool requires a list of vector store IDs.\n"]
    #[serde(rename = "tool_resources")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_resources:
        Option<crate::__types::create_thread_and_run_request_without_stream::ToolResources>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[serde(rename = "max_prompt_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_prompt_tokens: Option<i64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[serde(rename = "max_completion_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_completion_tokens: Option<i64>,
    #[serde(rename = "truncation_strategy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub truncation_strategy: Option<crate::__types::TruncationObject>,
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<crate::__types::AssistantsApiToolChoiceOption>,
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parallel_tool_calls: Option<crate::__types::ParallelToolCalls>,
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
}
#[allow(clippy::module_inception)]
pub mod create_run_request_without_stream {
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[derive(Clone, Debug, PartialEq)]
    #[allow(clippy::large_enum_variant)]
    pub enum Model {
        Other(String),
        AssistantSupportedModels(crate::__types::AssistantSupportedModels),
    }
    impl<'de> serde::Deserialize<'de> for Model {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Deserialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names, clippy::large_enum_variant)]
            enum Model {
                AssistantSupportedModels(crate::__types::AssistantSupportedModels),
                Other(String),
            }
            Ok(match Model::deserialize(deserializer)? {
                Model::Other(v) => Self::Other(v),
                Model::AssistantSupportedModels(v) => Self::AssistantSupportedModels(v),
            })
        }
    }
    impl serde::Serialize for Model {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            #[serde_with::serde_as]
            #[derive(serde :: Serialize)]
            #[serde(untagged)]
            #[allow(clippy::enum_variant_names)]
            enum Model<'a> {
                Other(&'a String),
                AssistantSupportedModels(&'a crate::__types::AssistantSupportedModels),
            }
            match self {
                Self::Other(v) => Model::Other(v),
                Self::AssistantSupportedModels(v) => Model::AssistantSupportedModels(v),
            }
            .serialize(serializer)
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct CreateRunRequestWithoutStream {
    #[doc = "The ID of the [assistant](https://platform.openai.com/docs/api-reference/assistants) to use to execute this run."]
    #[serde(rename = "assistant_id")]
    pub assistant_id: String,
    #[doc = "The ID of the [Model](https://platform.openai.com/docs/api-reference/models) to be used to execute this run. If a value is provided here, it will override the model associated with the assistant. If not, the model associated with the assistant will be used."]
    #[serde(rename = "model")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub model: Option<crate::__types::create_run_request_without_stream::Model>,
    #[serde(rename = "reasoning_effort")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub reasoning_effort: Option<crate::__types::ReasoningEffort>,
    #[doc = "Overrides the [instructions](https://platform.openai.com/docs/api-reference/assistants/createAssistant) of the assistant. This is useful for modifying the behavior on a per-run basis."]
    #[serde(rename = "instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub instructions: Option<String>,
    #[doc = "Appends additional instructions at the end of the instructions for the run. This is useful for modifying the behavior on a per-run basis without overriding other instructions."]
    #[serde(rename = "additional_instructions")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub additional_instructions: Option<String>,
    #[doc = "Adds additional messages to the thread before creating the run."]
    #[serde(rename = "additional_messages")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub additional_messages: Option<Vec<crate::__types::CreateMessageRequest>>,
    #[doc = "Override the tools the assistant can use for this run. This is useful for modifying the behavior on a per-run basis."]
    #[serde(rename = "tools")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tools: Option<Vec<crate::__types::AssistantTool>>,
    #[serde(rename = "metadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub metadata: Option<crate::__types::Metadata>,
    #[doc = "What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.\n"]
    #[serde(rename = "temperature")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub temperature: Option<serde_json::Number>,
    #[doc = "An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.\n\nWe generally recommend altering this or temperature but not both.\n"]
    #[serde(rename = "top_p")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub top_p: Option<serde_json::Number>,
    #[doc = "The maximum number of prompt tokens that may be used over the course of the run. The run will make a best effort to use only the number of prompt tokens specified, across multiple turns of the run. If the run exceeds the number of prompt tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[serde(rename = "max_prompt_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_prompt_tokens: Option<i64>,
    #[doc = "The maximum number of completion tokens that may be used over the course of the run. The run will make a best effort to use only the number of completion tokens specified, across multiple turns of the run. If the run exceeds the number of completion tokens specified, the run will end with status `incomplete`. See `incomplete_details` for more info.\n"]
    #[serde(rename = "max_completion_tokens")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub max_completion_tokens: Option<i64>,
    #[serde(rename = "truncation_strategy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub truncation_strategy: Option<crate::__types::TruncationObject>,
    #[serde(rename = "tool_choice")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub tool_choice: Option<crate::__types::AssistantsApiToolChoiceOption>,
    #[serde(rename = "parallel_tool_calls")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub parallel_tool_calls: Option<crate::__types::ParallelToolCalls>,
    #[serde(rename = "response_format")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub response_format: Option<crate::__types::AssistantsApiResponseFormatOption>,
}
#[allow(clippy::module_inception)]
pub mod submit_tool_outputs_run_request_without_stream {
    #[allow(clippy::module_inception)]
    pub mod tool_outputs {
        #[derive(Clone, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct Item {
            #[doc = "The ID of the tool call in the `required_action` object within the run object the output is being submitted for."]
            #[serde(rename = "tool_call_id")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub tool_call_id: Option<String>,
            #[doc = "The output of the tool call to be submitted to continue the run."]
            #[serde(rename = "output")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub output: Option<String>,
        }
    }
}
#[derive(Clone, Debug, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct SubmitToolOutputsRunRequestWithoutStream {
    #[doc = "A list of tools for which the outputs are being submitted."]
    #[serde(rename = "tool_outputs")]
    pub tool_outputs:
        Vec<crate::__types::submit_tool_outputs_run_request_without_stream::tool_outputs::Item>,
}
#[doc = "The status of the run, which can be either `queued`, `in_progress`, `requires_action`, `cancelling`, `cancelled`, `failed`, `completed`, `incomplete`, or `expired`."]
#[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
pub enum RunStatus {
    #[doc = "`queued`"]
    #[serde(rename = "queued")]
    Queued,
    #[doc = "`in_progress`"]
    #[serde(rename = "in_progress")]
    InProgress,
    #[doc = "`requires_action`"]
    #[serde(rename = "requires_action")]
    RequiresAction,
    #[doc = "`cancelling`"]
    #[serde(rename = "cancelling")]
    Cancelling,
    #[doc = "`cancelled`"]
    #[serde(rename = "cancelled")]
    Cancelled,
    #[doc = "`failed`"]
    #[serde(rename = "failed")]
    Failed,
    #[doc = "`completed`"]
    #[serde(rename = "completed")]
    Completed,
    #[doc = "`incomplete`"]
    #[serde(rename = "incomplete")]
    Incomplete,
    #[doc = "`expired`"]
    #[serde(rename = "expired")]
    Expired,
}
#[allow(clippy::module_inception)]
pub mod run_step_delta_object_delta {
    #[doc = "The details of the run step."]
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum StepDetails {
        MessageCreation(crate::__types::RunStepDeltaStepDetailsMessageCreationObject),
        ToolCalls(crate::__types::RunStepDeltaStepDetailsToolCallsObject),
    }
}
#[doc = "The delta containing the fields that have changed on the run step."]
#[derive(Clone, Debug, Default, PartialEq)]
#[serde_with::serde_as]
#[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
pub struct RunStepDeltaObjectDelta {
    #[doc = "The details of the run step."]
    #[serde(rename = "step_details")]
    #[serde(skip_serializing_if = "Option::is_none")]
    #[builder(default)]
    pub step_details: Option<crate::__types::run_step_delta_object_delta::StepDetails>,
}
#[allow(clippy::module_inception)]
pub mod list_assistants {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_assistants::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_assistant {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the assistant to retrieve."]
        #[serde(rename = "assistant_id")]
        pub assistant_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod modify_assistant {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the assistant to modify."]
        #[serde(rename = "assistant_id")]
        pub assistant_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_assistant {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the assistant to delete."]
        #[serde(rename = "assistant_id")]
        pub assistant_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod create_transcription {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Response {
        CreateTranscriptionResponseJson(crate::__types::CreateTranscriptionResponseJson),
        CreateTranscriptionResponseVerboseJson(
            crate::__types::CreateTranscriptionResponseVerboseJson,
        ),
    }
}
#[allow(clippy::module_inception)]
pub mod create_translation {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize)]
    #[serde(untagged)]
    #[allow(clippy::large_enum_variant)]
    pub enum Response {
        CreateTranslationResponseJson(crate::__types::CreateTranslationResponseJson),
        CreateTranslationResponseVerboseJson(crate::__types::CreateTranslationResponseVerboseJson),
    }
}
#[allow(clippy::module_inception)]
pub mod create_batch {
    #[allow(clippy::module_inception)]
    pub mod request {
        #[doc = "The endpoint to be used for all requests in the batch. Currently `/v1/responses`, `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Endpoint {
            #[doc = "`/v1/responses`"]
            #[serde(rename = "/v1/responses")]
            V1Responses,
            #[doc = "`/v1/chat/completions`"]
            #[serde(rename = "/v1/chat/completions")]
            V1ChatCompletions,
            #[doc = "`/v1/embeddings`"]
            #[serde(rename = "/v1/embeddings")]
            V1Embeddings,
            #[doc = "`/v1/completions`"]
            #[serde(rename = "/v1/completions")]
            V1Completions,
        }
        #[doc = "The time frame within which the batch should be processed. Currently only `24h` is supported."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum CompletionWindow {
            #[doc = "`24h`"]
            #[serde(rename = "24h")]
            _24h,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Request {
        #[doc = "The ID of an uploaded file that contains requests for the new batch.\n\nSee [upload file](https://platform.openai.com/docs/api-reference/files/create) for how to upload a file.\n\nYour input file must be formatted as a [JSONL file](https://platform.openai.com/docs/api-reference/batch/request-input), and must be uploaded with the purpose `batch`. The file can contain up to 50,000 requests, and can be up to 200 MB in size.\n"]
        #[serde(rename = "input_file_id")]
        pub input_file_id: String,
        #[doc = "The endpoint to be used for all requests in the batch. Currently `/v1/responses`, `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch."]
        #[serde(rename = "endpoint")]
        pub endpoint: crate::__types::create_batch::request::Endpoint,
        #[doc = "The time frame within which the batch should be processed. Currently only `24h` is supported."]
        #[serde(rename = "completion_window")]
        pub completion_window: crate::__types::create_batch::request::CompletionWindow,
        #[serde(rename = "metadata")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub metadata: Option<crate::__types::Metadata>,
        #[serde(rename = "output_expires_after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub output_expires_after: Option<crate::__types::BatchFileExpirationAfter>,
    }
}
#[allow(clippy::module_inception)]
pub mod list_batches {
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_batch {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the batch to retrieve."]
        #[serde(rename = "batch_id")]
        pub batch_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod cancel_batch {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the batch to cancel."]
        #[serde(rename = "batch_id")]
        pub batch_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_chat_completions {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order for Chat Completions by timestamp. Use `asc` for ascending order or `desc` for descending order. Defaults to `asc`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[default]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The model used to generate the Chat Completions."]
        #[serde(rename = "model")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub model: Option<String>,
        #[doc = "A list of metadata keys to filter the Chat Completions by. Example:\n\n`metadata[key1]=value1&metadata[key2]=value2`\n"]
        #[serde(rename = "metadata")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub metadata: Option<crate::__types::Metadata>,
        #[doc = "Identifier for the last chat completion from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of Chat Completions to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order for Chat Completions by timestamp. Use `asc` for ascending order or `desc` for descending order. Defaults to `asc`."]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_chat_completions::params::Order>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_chat_completion {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the chat completion to retrieve."]
        #[serde(rename = "completion_id")]
        pub completion_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod update_chat_completion {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the chat completion to update."]
        #[serde(rename = "completion_id")]
        pub completion_id: String,
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Request {
        #[serde(rename = "metadata")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub metadata: Option<crate::__types::Metadata>,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_chat_completion {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the chat completion to delete."]
        #[serde(rename = "completion_id")]
        pub completion_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod get_chat_completion_messages {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order for messages by timestamp. Use `asc` for ascending order or `desc` for descending order. Defaults to `asc`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[default]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the chat completion to retrieve messages from."]
        #[serde(rename = "completion_id")]
        pub completion_id: String,
        #[doc = "Identifier for the last message from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of messages to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order for messages by timestamp. Use `asc` for ascending order or `desc` for descending order. Defaults to `asc`."]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::get_chat_completion_messages::params::Order>,
    }
}
#[allow(clippy::module_inception)]
pub mod list_containers {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_containers::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod create_container {
    #[derive(Clone, Copy, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {}
}
#[allow(clippy::module_inception)]
pub mod retrieve_container {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "container_id")]
        pub container_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_container {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the container to delete."]
        #[serde(rename = "container_id")]
        pub container_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod create_container_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "container_id")]
        pub container_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_container_files {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "container_id")]
        pub container_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_container_files::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_container_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "container_id")]
        pub container_id: String,
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_container_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "container_id")]
        pub container_id: String,
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_container_file_content {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "container_id")]
        pub container_id: String,
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_evals {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order for evals by timestamp. Use `asc` for ascending order or `desc` for descending order."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[default]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[serde(rename = "desc")]
            Desc,
        }
        #[doc = "Evals can be ordered by creation time or last updated time. Use\n`created_at` for creation time or `updated_at` for last updated time.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum OrderBy {
            #[doc = "`created_at`"]
            #[default]
            #[serde(rename = "created_at")]
            CreatedAt,
            #[doc = "`updated_at`"]
            #[serde(rename = "updated_at")]
            UpdatedAt,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Identifier for the last eval from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of evals to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order for evals by timestamp. Use `asc` for ascending order or `desc` for descending order."]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_evals::params::Order>,
        #[doc = "Evals can be ordered by creation time or last updated time. Use\n`created_at` for creation time or `updated_at` for last updated time.\n"]
        #[serde(rename = "order_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order_by: Option<crate::__types::list_evals::params::OrderBy>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_eval {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to retrieve."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod update_eval {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to update."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Request {
        #[doc = "Rename the evaluation."]
        #[serde(rename = "name")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub name: Option<String>,
        #[serde(rename = "metadata")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub metadata: Option<crate::__types::Metadata>,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_eval {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to delete."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Response {
        #[serde(rename = "object")]
        pub object: String,
        #[serde(rename = "deleted")]
        pub deleted: bool,
        #[serde(rename = "eval_id")]
        pub eval_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod get_eval_runs {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order for runs by timestamp. Use `asc` for ascending order or `desc` for descending order. Defaults to `asc`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[default]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[serde(rename = "desc")]
            Desc,
        }
        #[doc = "Filter runs by status. One of `queued` | `in_progress` | `failed` | `completed` | `canceled`."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Status {
            #[doc = "`queued`"]
            #[serde(rename = "queued")]
            Queued,
            #[doc = "`in_progress`"]
            #[serde(rename = "in_progress")]
            InProgress,
            #[doc = "`completed`"]
            #[serde(rename = "completed")]
            Completed,
            #[doc = "`canceled`"]
            #[serde(rename = "canceled")]
            Canceled,
            #[doc = "`failed`"]
            #[serde(rename = "failed")]
            Failed,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to retrieve runs for."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
        #[doc = "Identifier for the last run from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of runs to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order for runs by timestamp. Use `asc` for ascending order or `desc` for descending order. Defaults to `asc`."]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::get_eval_runs::params::Order>,
        #[doc = "Filter runs by status. One of `queued` | `in_progress` | `failed` | `completed` | `canceled`."]
        #[serde(rename = "status")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub status: Option<crate::__types::get_eval_runs::params::Status>,
    }
}
#[allow(clippy::module_inception)]
pub mod create_eval_run {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to create a run for."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod get_eval_run {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to retrieve runs for."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
        #[doc = "The ID of the run to retrieve."]
        #[serde(rename = "run_id")]
        pub run_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod cancel_eval_run {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation whose run you want to cancel."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
        #[doc = "The ID of the run to cancel."]
        #[serde(rename = "run_id")]
        pub run_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_eval_run {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to delete the run from."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
        #[doc = "The ID of the run to delete."]
        #[serde(rename = "run_id")]
        pub run_id: String,
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Response {
        #[serde(rename = "object")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub object: Option<String>,
        #[serde(rename = "deleted")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub deleted: Option<bool>,
        #[serde(rename = "run_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub run_id: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_eval_run_output_items {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Filter output items by status. Use `failed` to filter by failed output\nitems or `pass` to filter by passed output items.\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Status {
            #[doc = "`fail`"]
            #[serde(rename = "fail")]
            Fail,
            #[doc = "`pass`"]
            #[serde(rename = "pass")]
            Pass,
        }
        #[doc = "Sort order for output items by timestamp. Use `asc` for ascending order or `desc` for descending order. Defaults to `asc`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[default]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to retrieve runs for."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
        #[doc = "The ID of the run to retrieve output items for."]
        #[serde(rename = "run_id")]
        pub run_id: String,
        #[doc = "Identifier for the last output item from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of output items to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Filter output items by status. Use `failed` to filter by failed output\nitems or `pass` to filter by passed output items.\n"]
        #[serde(rename = "status")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub status: Option<crate::__types::get_eval_run_output_items::params::Status>,
        #[doc = "Sort order for output items by timestamp. Use `asc` for ascending order or `desc` for descending order. Defaults to `asc`."]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::get_eval_run_output_items::params::Order>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_eval_run_output_item {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the evaluation to retrieve runs for."]
        #[serde(rename = "eval_id")]
        pub eval_id: String,
        #[doc = "The ID of the run to retrieve."]
        #[serde(rename = "run_id")]
        pub run_id: String,
        #[doc = "The ID of the output item to retrieve."]
        #[serde(rename = "output_item_id")]
        pub output_item_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_files {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Only return files with the given purpose."]
        #[serde(rename = "purpose")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub purpose: Option<String>,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 10,000, and the default is 10,000.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_files::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the file to use for this request."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the file to use for this request."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod download_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the file to use for this request."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_fine_tuning_checkpoint_permissions {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "The order in which to retrieve permissions."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`ascending`"]
            #[serde(rename = "ascending")]
            Ascending,
            #[doc = "`descending`"]
            #[default]
            #[serde(rename = "descending")]
            Descending,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuned model checkpoint to get permissions for.\n"]
        #[serde(rename = "fine_tuned_model_checkpoint")]
        pub fine_tuned_model_checkpoint: String,
        #[doc = "The ID of the project to get permissions for."]
        #[serde(rename = "project_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_id: Option<String>,
        #[doc = "Identifier for the last permission ID from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of permissions to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "The order in which to retrieve permissions."]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_fine_tuning_checkpoint_permissions::params::Order>,
    }
}
#[allow(clippy::module_inception)]
pub mod create_fine_tuning_checkpoint_permission {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuned model checkpoint to create a permission for.\n"]
        #[serde(rename = "fine_tuned_model_checkpoint")]
        pub fine_tuned_model_checkpoint: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_fine_tuning_checkpoint_permission {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuned model checkpoint to delete a permission for.\n"]
        #[serde(rename = "fine_tuned_model_checkpoint")]
        pub fine_tuned_model_checkpoint: String,
        #[doc = "The ID of the fine-tuned model checkpoint permission to delete.\n"]
        #[serde(rename = "permission_id")]
        pub permission_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_paginated_fine_tuning_jobs {
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Identifier for the last job from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of fine-tuning jobs to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Optional metadata filter. To filter, use the syntax `metadata[k]=v`. Alternatively, set `metadata=null` to indicate no metadata.\n"]
        #[serde(rename = "metadata")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub metadata: Option<indexmap::IndexMap<String, String>>,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_fine_tuning_job {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuning job.\n"]
        #[serde(rename = "fine_tuning_job_id")]
        pub fine_tuning_job_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod cancel_fine_tuning_job {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuning job to cancel.\n"]
        #[serde(rename = "fine_tuning_job_id")]
        pub fine_tuning_job_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_fine_tuning_job_checkpoints {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuning job to get checkpoints for.\n"]
        #[serde(rename = "fine_tuning_job_id")]
        pub fine_tuning_job_id: String,
        #[doc = "Identifier for the last checkpoint ID from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of checkpoints to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
    }
}
#[allow(clippy::module_inception)]
pub mod list_fine_tuning_events {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuning job to get events for.\n"]
        #[serde(rename = "fine_tuning_job_id")]
        pub fine_tuning_job_id: String,
        #[doc = "Identifier for the last event from the previous pagination request."]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Number of events to retrieve."]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
    }
}
#[allow(clippy::module_inception)]
pub mod pause_fine_tuning_job {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuning job to pause.\n"]
        #[serde(rename = "fine_tuning_job_id")]
        pub fine_tuning_job_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod resume_fine_tuning_job {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the fine-tuning job to resume.\n"]
        #[serde(rename = "fine_tuning_job_id")]
        pub fine_tuning_job_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_model {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the model to use for this request"]
        #[serde(rename = "model")]
        pub model: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_model {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The model to delete"]
        #[serde(rename = "model")]
        pub model: String,
    }
}
#[allow(clippy::module_inception)]
pub mod admin_api_keys_list {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[default]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::admin_api_keys_list::params::Order>,
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
    }
}
#[allow(clippy::module_inception)]
pub mod admin_api_keys_create {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Request {
        #[serde(rename = "name")]
        pub name: String,
    }
}
#[allow(clippy::module_inception)]
pub mod admin_api_keys_get {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "key_id")]
        pub key_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod admin_api_keys_delete {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[serde(rename = "key_id")]
        pub key_id: String,
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Response {
        #[serde(rename = "id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub id: Option<String>,
        #[serde(rename = "object")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub object: Option<String>,
        #[serde(rename = "deleted")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub deleted: Option<bool>,
    }
}
#[allow(clippy::module_inception)]
pub mod list_audit_logs {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Return only events whose `effective_at` (Unix seconds) is in this range."]
        #[derive(Clone, Copy, Debug, Default, PartialEq)]
        #[serde_with::serde_as]
        #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
        pub struct EffectiveAt {
            #[doc = "Return only events whose `effective_at` (Unix seconds) is greater than this value."]
            #[serde(rename = "gt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub gt: Option<i64>,
            #[doc = "Return only events whose `effective_at` (Unix seconds) is greater than or equal to this value."]
            #[serde(rename = "gte")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub gte: Option<i64>,
            #[doc = "Return only events whose `effective_at` (Unix seconds) is less than this value."]
            #[serde(rename = "lt")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub lt: Option<i64>,
            #[doc = "Return only events whose `effective_at` (Unix seconds) is less than or equal to this value."]
            #[serde(rename = "lte")]
            #[serde(skip_serializing_if = "Option::is_none")]
            #[builder(default)]
            pub lte: Option<i64>,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Return only events whose `effective_at` (Unix seconds) is in this range."]
        #[serde(rename = "effective_at")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub effective_at: Option<crate::__types::list_audit_logs::params::EffectiveAt>,
        #[doc = "Return only events for these projects."]
        #[serde(rename = "project_ids[]")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Return only events with a `type` in one of these values. For example, `project.created`. For all options, see the documentation for the [audit log object](https://platform.openai.com/docs/api-reference/audit-logs/object)."]
        #[serde(rename = "event_types[]")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub event_types: Option<Vec<crate::__types::AuditLogEventType>>,
        #[doc = "Return only events performed by these actors. Can be a user ID, a service account ID, or an api key tracking ID."]
        #[serde(rename = "actor_ids[]")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub actor_ids: Option<Vec<String>>,
        #[doc = "Return only events performed by users with these emails."]
        #[serde(rename = "actor_emails[]")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub actor_emails: Option<Vec<String>>,
        #[doc = "Return only events performed on these targets. For example, a project ID updated."]
        #[serde(rename = "resource_ids[]")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub resource_ids: Option<Vec<String>>,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod list_organization_certificates {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_organization_certificates::params::Order>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_certificate {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[allow(clippy::module_inception)]
        pub mod include {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`content`"]
                #[serde(rename = "content")]
                Content,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Unique ID of the certificate to retrieve."]
        #[serde(rename = "certificate_id")]
        pub certificate_id: String,
        #[doc = "A list of additional fields to include in the response. Currently the only supported value is `content` to fetch the PEM content of the certificate."]
        #[serde(rename = "include")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub include: Option<Vec<crate::__types::get_certificate::params::include::Item>>,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_costs {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently only `1d` is supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
                #[doc = "`line_item`"]
                #[serde(rename = "line_item")]
                LineItem,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently only `1d` is supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width: Option<crate::__types::usage_costs::params::BucketWidth>,
        #[doc = "Return only costs for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Group the costs by the specified fields. Support fields include `project_id`, `line_item` and any combination of them."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by: Option<Vec<crate::__types::usage_costs::params::group_by::Item>>,
        #[doc = "A limit on the number of buckets to be returned. Limit can range between 1 and 180, and the default is 7.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod list_invites {
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_invite {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the invite to retrieve."]
        #[serde(rename = "invite_id")]
        pub invite_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_invite {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the invite to delete."]
        #[serde(rename = "invite_id")]
        pub invite_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_projects {
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "If `true` returns all projects including those that have been `archived`. Archived projects are not included by default."]
        #[serde(rename = "include_archived")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub include_archived: Option<bool>,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_project {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod modify_project {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_project_api_keys {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_project_api_key {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "The ID of the API key."]
        #[serde(rename = "key_id")]
        pub key_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_project_api_key {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "The ID of the API key."]
        #[serde(rename = "key_id")]
        pub key_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod archive_project {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_project_certificates {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_project_certificates::params::Order>,
    }
}
#[allow(clippy::module_inception)]
pub mod activate_project_certificates {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod deactivate_project_certificates {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_project_rate_limits {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "A limit on the number of objects to be returned. The default is 100.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, beginning with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod update_project_rate_limits {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "The ID of the rate limit."]
        #[serde(rename = "rate_limit_id")]
        pub rate_limit_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_project_service_accounts {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod create_project_service_account {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_project_service_account {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "The ID of the service account."]
        #[serde(rename = "service_account_id")]
        pub service_account_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_project_service_account {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "The ID of the service account."]
        #[serde(rename = "service_account_id")]
        pub service_account_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_project_users {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod create_project_user {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_project_user {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "The ID of the user."]
        #[serde(rename = "user_id")]
        pub user_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod modify_project_user {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "The ID of the user."]
        #[serde(rename = "user_id")]
        pub user_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_project_user {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the project."]
        #[serde(rename = "project_id")]
        pub project_id: String,
        #[doc = "The ID of the user."]
        #[serde(rename = "user_id")]
        pub user_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_audio_speeches {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1m`"]
            #[serde(rename = "1m")]
            _1m,
            #[doc = "`1h`"]
            #[serde(rename = "1h")]
            _1h,
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
                #[doc = "`user_id`"]
                #[serde(rename = "user_id")]
                UserId,
                #[doc = "`api_key_id`"]
                #[serde(rename = "api_key_id")]
                ApiKeyId,
                #[doc = "`model`"]
                #[serde(rename = "model")]
                Model,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width: Option<crate::__types::usage_audio_speeches::params::BucketWidth>,
        #[doc = "Return only usage for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these users."]
        #[serde(rename = "user_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub user_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these API keys."]
        #[serde(rename = "api_key_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub api_key_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these models."]
        #[serde(rename = "models")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub models: Option<Vec<String>>,
        #[doc = "Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by: Option<Vec<crate::__types::usage_audio_speeches::params::group_by::Item>>,
        #[doc = "Specifies the number of buckets to return.\n- `bucket_width=1d`: default: 7, max: 31\n- `bucket_width=1h`: default: 24, max: 168\n- `bucket_width=1m`: default: 60, max: 1440\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_audio_transcriptions {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1m`"]
            #[serde(rename = "1m")]
            _1m,
            #[doc = "`1h`"]
            #[serde(rename = "1h")]
            _1h,
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
                #[doc = "`user_id`"]
                #[serde(rename = "user_id")]
                UserId,
                #[doc = "`api_key_id`"]
                #[serde(rename = "api_key_id")]
                ApiKeyId,
                #[doc = "`model`"]
                #[serde(rename = "model")]
                Model,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width: Option<crate::__types::usage_audio_transcriptions::params::BucketWidth>,
        #[doc = "Return only usage for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these users."]
        #[serde(rename = "user_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub user_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these API keys."]
        #[serde(rename = "api_key_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub api_key_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these models."]
        #[serde(rename = "models")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub models: Option<Vec<String>>,
        #[doc = "Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by:
            Option<Vec<crate::__types::usage_audio_transcriptions::params::group_by::Item>>,
        #[doc = "Specifies the number of buckets to return.\n- `bucket_width=1d`: default: 7, max: 31\n- `bucket_width=1h`: default: 24, max: 168\n- `bucket_width=1m`: default: 60, max: 1440\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_code_interpreter_sessions {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1m`"]
            #[serde(rename = "1m")]
            _1m,
            #[doc = "`1h`"]
            #[serde(rename = "1h")]
            _1h,
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width:
            Option<crate::__types::usage_code_interpreter_sessions::params::BucketWidth>,
        #[doc = "Return only usage for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Group the usage data by the specified fields. Support fields include `project_id`."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by:
            Option<Vec<crate::__types::usage_code_interpreter_sessions::params::group_by::Item>>,
        #[doc = "Specifies the number of buckets to return.\n- `bucket_width=1d`: default: 7, max: 31\n- `bucket_width=1h`: default: 24, max: 168\n- `bucket_width=1m`: default: 60, max: 1440\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_completions {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1m`"]
            #[serde(rename = "1m")]
            _1m,
            #[doc = "`1h`"]
            #[serde(rename = "1h")]
            _1h,
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
                #[doc = "`user_id`"]
                #[serde(rename = "user_id")]
                UserId,
                #[doc = "`api_key_id`"]
                #[serde(rename = "api_key_id")]
                ApiKeyId,
                #[doc = "`model`"]
                #[serde(rename = "model")]
                Model,
                #[doc = "`batch`"]
                #[serde(rename = "batch")]
                Batch,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width: Option<crate::__types::usage_completions::params::BucketWidth>,
        #[doc = "Return only usage for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these users."]
        #[serde(rename = "user_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub user_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these API keys."]
        #[serde(rename = "api_key_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub api_key_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these models."]
        #[serde(rename = "models")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub models: Option<Vec<String>>,
        #[doc = "If `true`, return batch jobs only. If `false`, return non-batch jobs only. By default, return both.\n"]
        #[serde(rename = "batch")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub batch: Option<bool>,
        #[doc = "Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `batch` or any combination of them."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by: Option<Vec<crate::__types::usage_completions::params::group_by::Item>>,
        #[doc = "Specifies the number of buckets to return.\n- `bucket_width=1d`: default: 7, max: 31\n- `bucket_width=1h`: default: 24, max: 168\n- `bucket_width=1m`: default: 60, max: 1440\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_embeddings {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1m`"]
            #[serde(rename = "1m")]
            _1m,
            #[doc = "`1h`"]
            #[serde(rename = "1h")]
            _1h,
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
                #[doc = "`user_id`"]
                #[serde(rename = "user_id")]
                UserId,
                #[doc = "`api_key_id`"]
                #[serde(rename = "api_key_id")]
                ApiKeyId,
                #[doc = "`model`"]
                #[serde(rename = "model")]
                Model,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width: Option<crate::__types::usage_embeddings::params::BucketWidth>,
        #[doc = "Return only usage for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these users."]
        #[serde(rename = "user_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub user_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these API keys."]
        #[serde(rename = "api_key_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub api_key_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these models."]
        #[serde(rename = "models")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub models: Option<Vec<String>>,
        #[doc = "Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by: Option<Vec<crate::__types::usage_embeddings::params::group_by::Item>>,
        #[doc = "Specifies the number of buckets to return.\n- `bucket_width=1d`: default: 7, max: 31\n- `bucket_width=1h`: default: 24, max: 168\n- `bucket_width=1m`: default: 60, max: 1440\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_images {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1m`"]
            #[serde(rename = "1m")]
            _1m,
            #[doc = "`1h`"]
            #[serde(rename = "1h")]
            _1h,
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod sources {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`image.generation`"]
                #[serde(rename = "image.generation")]
                ImageGeneration,
                #[doc = "`image.edit`"]
                #[serde(rename = "image.edit")]
                ImageEdit,
                #[doc = "`image.variation`"]
                #[serde(rename = "image.variation")]
                ImageVariation,
            }
        }
        #[allow(clippy::module_inception)]
        pub mod sizes {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`256x256`"]
                #[serde(rename = "256x256")]
                _256x256,
                #[doc = "`512x512`"]
                #[serde(rename = "512x512")]
                _512x512,
                #[doc = "`1024x1024`"]
                #[serde(rename = "1024x1024")]
                _1024x1024,
                #[doc = "`1792x1792`"]
                #[serde(rename = "1792x1792")]
                _1792x1792,
                #[doc = "`1024x1792`"]
                #[serde(rename = "1024x1792")]
                _1024x1792,
            }
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
                #[doc = "`user_id`"]
                #[serde(rename = "user_id")]
                UserId,
                #[doc = "`api_key_id`"]
                #[serde(rename = "api_key_id")]
                ApiKeyId,
                #[doc = "`model`"]
                #[serde(rename = "model")]
                Model,
                #[doc = "`size`"]
                #[serde(rename = "size")]
                Size,
                #[doc = "`source`"]
                #[serde(rename = "source")]
                Source,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width: Option<crate::__types::usage_images::params::BucketWidth>,
        #[doc = "Return only usages for these sources. Possible values are `image.generation`, `image.edit`, `image.variation` or any combination of them."]
        #[serde(rename = "sources")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub sources: Option<Vec<crate::__types::usage_images::params::sources::Item>>,
        #[doc = "Return only usages for these image sizes. Possible values are `256x256`, `512x512`, `1024x1024`, `1792x1792`, `1024x1792` or any combination of them."]
        #[serde(rename = "sizes")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub sizes: Option<Vec<crate::__types::usage_images::params::sizes::Item>>,
        #[doc = "Return only usage for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these users."]
        #[serde(rename = "user_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub user_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these API keys."]
        #[serde(rename = "api_key_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub api_key_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these models."]
        #[serde(rename = "models")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub models: Option<Vec<String>>,
        #[doc = "Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model`, `size`, `source` or any combination of them."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by: Option<Vec<crate::__types::usage_images::params::group_by::Item>>,
        #[doc = "Specifies the number of buckets to return.\n- `bucket_width=1d`: default: 7, max: 31\n- `bucket_width=1h`: default: 24, max: 168\n- `bucket_width=1m`: default: 60, max: 1440\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_moderations {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1m`"]
            #[serde(rename = "1m")]
            _1m,
            #[doc = "`1h`"]
            #[serde(rename = "1h")]
            _1h,
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
                #[doc = "`user_id`"]
                #[serde(rename = "user_id")]
                UserId,
                #[doc = "`api_key_id`"]
                #[serde(rename = "api_key_id")]
                ApiKeyId,
                #[doc = "`model`"]
                #[serde(rename = "model")]
                Model,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width: Option<crate::__types::usage_moderations::params::BucketWidth>,
        #[doc = "Return only usage for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these users."]
        #[serde(rename = "user_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub user_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these API keys."]
        #[serde(rename = "api_key_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub api_key_ids: Option<Vec<String>>,
        #[doc = "Return only usage for these models."]
        #[serde(rename = "models")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub models: Option<Vec<String>>,
        #[doc = "Group the usage data by the specified fields. Support fields include `project_id`, `user_id`, `api_key_id`, `model` or any combination of them."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by: Option<Vec<crate::__types::usage_moderations::params::group_by::Item>>,
        #[doc = "Specifies the number of buckets to return.\n- `bucket_width=1d`: default: 7, max: 31\n- `bucket_width=1h`: default: 24, max: 168\n- `bucket_width=1m`: default: 60, max: 1440\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod usage_vector_stores {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum BucketWidth {
            #[doc = "`1m`"]
            #[serde(rename = "1m")]
            _1m,
            #[doc = "`1h`"]
            #[serde(rename = "1h")]
            _1h,
            #[doc = "`1d`"]
            #[default]
            #[serde(rename = "1d")]
            _1d,
        }
        #[allow(clippy::module_inception)]
        pub mod group_by {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`project_id`"]
                #[serde(rename = "project_id")]
                ProjectId,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "Start time (Unix seconds) of the query time range, inclusive."]
        #[serde(rename = "start_time")]
        pub start_time: i64,
        #[doc = "End time (Unix seconds) of the query time range, exclusive."]
        #[serde(rename = "end_time")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub end_time: Option<i64>,
        #[doc = "Width of each time bucket in response. Currently `1m`, `1h` and `1d` are supported, default to `1d`."]
        #[serde(rename = "bucket_width")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub bucket_width: Option<crate::__types::usage_vector_stores::params::BucketWidth>,
        #[doc = "Return only usage for these projects."]
        #[serde(rename = "project_ids")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub project_ids: Option<Vec<String>>,
        #[doc = "Group the usage data by the specified fields. Support fields include `project_id`."]
        #[serde(rename = "group_by")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub group_by: Option<Vec<crate::__types::usage_vector_stores::params::group_by::Item>>,
        #[doc = "Specifies the number of buckets to return.\n- `bucket_width=1d`: default: 7, max: 31\n- `bucket_width=1h`: default: 24, max: 168\n- `bucket_width=1m`: default: 60, max: 1440\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. Corresponding to the `next_page` field from the previous response."]
        #[serde(rename = "page")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub page: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod list_users {
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "Filter by the email address of users."]
        #[serde(rename = "emails")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub emails: Option<Vec<String>>,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_user {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the user."]
        #[serde(rename = "user_id")]
        pub user_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod modify_user {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the user."]
        #[serde(rename = "user_id")]
        pub user_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_user {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the user."]
        #[serde(rename = "user_id")]
        pub user_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod get_response {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the response to retrieve."]
        #[serde(rename = "response_id")]
        pub response_id: String,
        #[doc = "Additional fields to include in the response. See the `include`\nparameter for Response creation above for more information.\n"]
        #[serde(rename = "include")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub include: Option<Vec<crate::__types::Includable>>,
        #[doc = "If set to true, the model response data will be streamed to the client\nas it is generated using [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format).\nSee the [Streaming section below](https://platform.openai.com/docs/api-reference/responses-streaming)\nfor more information.\n"]
        #[serde(rename = "stream")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub stream: Option<bool>,
        #[doc = "The sequence number of the event after which to start streaming.\n"]
        #[serde(rename = "starting_after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub starting_after: Option<i64>,
        #[doc = "When true, stream obfuscation will be enabled. Stream obfuscation adds\nrandom characters to an `obfuscation` field on streaming delta events\nto normalize payload sizes as a mitigation to certain side-channel\nattacks. These obfuscation fields are included by default, but add a\nsmall amount of overhead to the data stream. You can set\n`include_obfuscation` to false to optimize for bandwidth if you trust\nthe network links between your application and the OpenAI API.\n"]
        #[serde(rename = "include_obfuscation")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub include_obfuscation: Option<bool>,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_response {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the response to delete."]
        #[serde(rename = "response_id")]
        pub response_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod cancel_response {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the response to cancel."]
        #[serde(rename = "response_id")]
        pub response_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_input_items {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "The order to return the input items in. Default is `desc`.\n- `asc`: Return the input items in ascending order.\n- `desc`: Return the input items in descending order.\n"]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the response to retrieve input items for."]
        #[serde(rename = "response_id")]
        pub response_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between\n1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "The order to return the input items in. Default is `desc`.\n- `asc`: Return the input items in ascending order.\n- `desc`: Return the input items in descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_input_items::params::Order>,
        #[doc = "An item ID to list items after, used in pagination.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "An item ID to list items before, used in pagination.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
        #[doc = "Additional fields to include in the response. See the `include`\nparameter for Response creation above for more information.\n"]
        #[serde(rename = "include")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub include: Option<Vec<crate::__types::Includable>>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_thread {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread to retrieve."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod modify_thread {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread to modify. Only the `metadata` can be modified."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_thread {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread to delete."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_messages {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) the messages belong to."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_messages::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
        #[doc = "Filter messages by the run ID that generated them.\n"]
        #[serde(rename = "run_id")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub run_id: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod create_message {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) to create a message for."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod get_message {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) to which this message belongs."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the message to retrieve."]
        #[serde(rename = "message_id")]
        pub message_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod modify_message {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread to which this message belongs."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the message to modify."]
        #[serde(rename = "message_id")]
        pub message_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_message {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread to which this message belongs."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the message to delete."]
        #[serde(rename = "message_id")]
        pub message_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_runs {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread the run belongs to."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_runs::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod create_run {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[allow(clippy::module_inception)]
        pub mod include {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`step_details.tool_calls[*].file_search.results[*].content`"]
                #[serde(rename = "step_details.tool_calls[*].file_search.results[*].content")]
                StepDetailsToolCallsFileSearchResultsContent,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread to run."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.\n\nSee the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
        #[serde(rename = "include[]")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub include: Option<Vec<crate::__types::create_run::params::include::Item>>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_run {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the run to retrieve."]
        #[serde(rename = "run_id")]
        pub run_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod modify_run {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) that was run."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the run to modify."]
        #[serde(rename = "run_id")]
        pub run_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod cancel_run {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread to which this run belongs."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the run to cancel."]
        #[serde(rename = "run_id")]
        pub run_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_run_steps {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
        #[allow(clippy::module_inception)]
        pub mod include {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`step_details.tool_calls[*].file_search.results[*].content`"]
                #[serde(rename = "step_details.tool_calls[*].file_search.results[*].content")]
                StepDetailsToolCallsFileSearchResultsContent,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread the run and run steps belong to."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the run the run steps belong to."]
        #[serde(rename = "run_id")]
        pub run_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_run_steps::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
        #[doc = "A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.\n\nSee the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
        #[serde(rename = "include[]")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub include: Option<Vec<crate::__types::list_run_steps::params::include::Item>>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_run_step {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[allow(clippy::module_inception)]
        pub mod include {
            #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
            pub enum Item {
                #[doc = "`step_details.tool_calls[*].file_search.results[*].content`"]
                #[serde(rename = "step_details.tool_calls[*].file_search.results[*].content")]
                StepDetailsToolCallsFileSearchResultsContent,
            }
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the thread to which the run and run step belongs."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the run to which the run step belongs."]
        #[serde(rename = "run_id")]
        pub run_id: String,
        #[doc = "The ID of the run step to retrieve."]
        #[serde(rename = "step_id")]
        pub step_id: String,
        #[doc = "A list of additional fields to include in the response. Currently the only supported value is `step_details.tool_calls[*].file_search.results[*].content` to fetch the file search result content.\n\nSee the [file search tool documentation](https://platform.openai.com/docs/assistants/tools/file-search#customizing-file-search-settings) for more information.\n"]
        #[serde(rename = "include[]")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub include: Option<Vec<crate::__types::get_run_step::params::include::Item>>,
    }
}
#[allow(clippy::module_inception)]
pub mod submit_tool_ouputs_to_run {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the [thread](https://platform.openai.com/docs/api-reference/threads) to which this run belongs."]
        #[serde(rename = "thread_id")]
        pub thread_id: String,
        #[doc = "The ID of the run that requires the tool output submission."]
        #[serde(rename = "run_id")]
        pub run_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod cancel_upload {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the Upload.\n"]
        #[serde(rename = "upload_id")]
        pub upload_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod complete_upload {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the Upload.\n"]
        #[serde(rename = "upload_id")]
        pub upload_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod add_upload_part {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the Upload.\n"]
        #[serde(rename = "upload_id")]
        pub upload_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_vector_stores {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
    }
    #[derive(Clone, Debug, Default, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_vector_stores::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
    }
}
#[allow(clippy::module_inception)]
pub mod get_vector_store {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store to retrieve."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod modify_vector_store {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store to modify."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_vector_store {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store to delete."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod create_vector_store_file_batch {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store for which to create a File Batch.\n"]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod get_vector_store_file_batch {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store that the file batch belongs to."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
        #[doc = "The ID of the file batch being retrieved."]
        #[serde(rename = "batch_id")]
        pub batch_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod cancel_vector_store_file_batch {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store that the file batch belongs to."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
        #[doc = "The ID of the file batch to cancel."]
        #[serde(rename = "batch_id")]
        pub batch_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod list_files_in_vector_store_batch {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
        #[doc = "Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Filter {
            #[doc = "`in_progress`"]
            #[serde(rename = "in_progress")]
            InProgress,
            #[doc = "`completed`"]
            #[serde(rename = "completed")]
            Completed,
            #[doc = "`failed`"]
            #[serde(rename = "failed")]
            Failed,
            #[doc = "`cancelled`"]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store that the files belong to."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
        #[doc = "The ID of the file batch that the files belong to."]
        #[serde(rename = "batch_id")]
        pub batch_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_files_in_vector_store_batch::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
        #[doc = "Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`."]
        #[serde(rename = "filter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub filter: Option<crate::__types::list_files_in_vector_store_batch::params::Filter>,
    }
}
#[allow(clippy::module_inception)]
pub mod list_vector_store_files {
    #[allow(clippy::module_inception)]
    pub mod params {
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[derive(
            Clone, Copy, Debug, Default, PartialEq, serde :: Deserialize, serde :: Serialize,
        )]
        pub enum Order {
            #[doc = "`asc`"]
            #[serde(rename = "asc")]
            Asc,
            #[doc = "`desc`"]
            #[default]
            #[serde(rename = "desc")]
            Desc,
        }
        #[doc = "Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`."]
        #[derive(Clone, Copy, Debug, PartialEq, serde :: Deserialize, serde :: Serialize)]
        pub enum Filter {
            #[doc = "`in_progress`"]
            #[serde(rename = "in_progress")]
            InProgress,
            #[doc = "`completed`"]
            #[serde(rename = "completed")]
            Completed,
            #[doc = "`failed`"]
            #[serde(rename = "failed")]
            Failed,
            #[doc = "`cancelled`"]
            #[serde(rename = "cancelled")]
            Cancelled,
        }
    }
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store that the files belong to."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
        #[doc = "A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n"]
        #[serde(rename = "limit")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub limit: Option<i64>,
        #[doc = "Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n"]
        #[serde(rename = "order")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub order: Option<crate::__types::list_vector_store_files::params::Order>,
        #[doc = "A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n"]
        #[serde(rename = "after")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub after: Option<String>,
        #[doc = "A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n"]
        #[serde(rename = "before")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub before: Option<String>,
        #[doc = "Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`."]
        #[serde(rename = "filter")]
        #[serde(skip_serializing_if = "Option::is_none")]
        #[builder(default)]
        pub filter: Option<crate::__types::list_vector_store_files::params::Filter>,
    }
}
#[allow(clippy::module_inception)]
pub mod create_vector_store_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store for which to create a File.\n"]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod get_vector_store_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store that the file belongs to."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
        #[doc = "The ID of the file being retrieved."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod delete_vector_store_file {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store that the file belongs to."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
        #[doc = "The ID of the file to delete."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod update_vector_store_file_attributes {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store the file belongs to."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
        #[doc = "The ID of the file to update attributes."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod retrieve_vector_store_file_content {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
        #[doc = "The ID of the file within the vector store."]
        #[serde(rename = "file_id")]
        pub file_id: String,
    }
}
#[allow(clippy::module_inception)]
pub mod search_vector_store {
    #[derive(Clone, Debug, PartialEq)]
    #[serde_with::serde_as]
    #[derive(serde :: Deserialize, serde :: Serialize, typed_builder :: TypedBuilder)]
    pub struct Params {
        #[doc = "The ID of the vector store to search."]
        #[serde(rename = "vector_store_id")]
        pub vector_store_id: String,
    }
}
